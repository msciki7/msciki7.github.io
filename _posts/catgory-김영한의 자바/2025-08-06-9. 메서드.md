---
title: "9주차 메서드"
excerpt: ""

wirter: sohee Kim
categories:
  - 김영한의 자바
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-08-06
last_modified_at: 2025-08-06
---

메서드 시작
======

```java
public class Method1 {
    public static void main(String[] args) {
        //계산1
        int a = 1;
        int b = 2;
        System.out.println(a + "+" + b + " 연산 수행");
        int sum1 = a + b;
        System.out.println("결과1 출력:" + sum1);

        //계산2
        int x = 10;
        int y = 20;
        System.out.println(x + "+" + y + " 연산 수행");
        int sum2 = x + y;
        System.out.println("결과2 출력:" + sum2);
    }
}
```

* 같은 연산을 두 번 수행한다.
* 코드를 보면 계산 1 부분과 계산 2 부분이 거의 같다.

&ensp;계산 1<br/>

```java
int a = 1;
int b = 2;
System.out.println(a + "+" + b + " 연산 수행");
int sum1 = a + b;
```

&ensp;계산 2<br/>

```java
int x = 10;
int y = 20;
System.out.println(x + "+" + y + " 연산 수행");
int sum2 = x + y;
```

&ensp;계산1, 계산2 둘 다 변수를 두 개 선언하고, 어떤 연산을 수행하는지 출력하고, 두 변수를 더해서 결과를 구한다. 만약 프로그램의 여러 곳에서 이와 같은 계산을 반복해야 한다면 같은 코드를 여러번 반복해서 작성해야 할 것이다. 더 나아가서 어떤 연산을 수행하는지 출력하는 부분을 변경하거나 또는 제거하고 싶다면 해당 코드를 다 찾아다니면서 
모두 수정해야 할 것이다.<br/>

&ensp;<b>함수(function)</b><br/>
<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-1.png" width="600"></p>

&ensp;함수의 정의<br/>
&ensp;add(a, b) = a + b<br/>
* 이름이 add이고 a, b라는 두 값을 받는 함수이다. 그리고 이 함수는 a + b 연산을 수행한다.

&ensp;함수 사용<br/>

```java
add(1,2) -> 결과:3
add(5,6) -> 결과:11
add(3,5) -> 결과:8
```

* 함수에 값을 입력하면 함수가 가진 연산을 처리한 다음 결과를 출력한다. 여기서 단순히 a + b 라는 연산을 수행한다.
* 여러번 같은 계산을 해야 한다면 지금처럼 함수를 만들어두고(정의) 필요한 입력 값을 넣어서 해당 함수를 호출하면 된다. 그러면 계산 결과가 나온다.
* 함수는 마치 블랙박스와 같다. 함수를 호출할 때는 외부에서는 필요한 값만 입력하면 된다. 그러면 계산된 결과가 출력된다.
* 같은 함수를 다른 입력 값으로 여러번 호출할 수 있다.
* 여기서 핵심은 함수를 한 번 정의해두면 계속해서 재사용할 수 있다는 점이다.

&ensp;평균 함수<br/>
<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-2.png" width="600"></p>

&ensp;만약 두 수의 평균을 구해야 한다면 매번 (a + b) / 2라는 공식을 사용해야 할 것 이다. 이것을 함수로 만들어두면 다음과 같이 사용하면 된다.<br/> 

&ensp;함수 사용<br/>

```java
avg(4,6) -> 결과:5
avg(10,20) -> 결과:15
avg(100,200) -> 결과:150
```

&ensp;프로그램 언어들은 오래 전부터 이런 문제를 해결하기 위해 수학의 함수라는 개념을 차용해서 사용한다.<br/>

메서드 사용
======

&ensp;자바에서는 함수를 메서드(Method)라 한다.<br/> 
&ensp;메서드도 함수의 한 종류라고 생각하면 된다. 메서드를 사용하면 앞서 고민한 문제를 한 번에 해결할 수 있다.<br/>

```java
public class Method1Ref {
    public static void main(String[] args) {
        int sum1 = add(5, 10);
        System.out.println("결과1 출력:" + sum1);

        int sum2 = add(15, 20);
        System.out.println("결과2 출력:" + sum2);
    }

    //add 메서드
    public static int add(int a, int b) {
        System.out.println(a + "+" + b + " 연산 수행");
        int sum = a + b;
        return sum;
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-3.png" width="600"></p>

&ensp;<b>메서드 정의</b><br/>

```java
public static int add(int a, int b) {
    System.out.println(a + "+" + b + " 연산 수행");
    int sum = a + b;
    return sum;
}
```

&ensp;이 부분이 바로 매서드이다. 이것을 함수를 정의하는 것과 같이 메서드를 정의한다고 표현한다. 메서드는 수학의 함수와 유사하게 생겼다. 함수에 값을 입력하면 어떤 연산을 처리한 다음에 결과를 반환한다.<br/>

&ensp;<b>메서드 선언(Method Declaration)</b><br/>
&ensp;public static int add(int a, int b)<br/>
&ensp;메서드의 선언 부분으로 메서드 이름, 반환 타입, 매개변수(파라미터) 목록을 포함한다.<br/>
&ensp;이름 그대로 이런 메서드가 있다고 선언하는 것이다. 메서드 선언 정보를 통해 다른 곳에서 해당 메서드를 호출할 수 있다.<br/>

* public static
    - public : 다른 클래스에서 호출할 수 있는 메서드라는 뜻이다.
    - static : 객체를 생성하지 않고 호출할 수 있는 정적 메서드라는 뜻이다.
    - 두 키워드의 자세한 내용은 뒤에서 다룬다. 지금은 단순하게 메서드를 만들 때 둘을 사용해야 한다고 생각하자.
* int add(int a, int b)
    - int : 반환 타입을 정의한다. 메서드의 실행 결과를 반환할 때 사용할 반환 타입을 지정한다.
    - add : 메서드에 이름을 부여한다. 이 이름으로 메서드를 호출할 수 있다. 
    - (int a, int b) : 메서드를 호출할 때 전달하는 입력 값을 정의한다. 이 변수들은 해당 메서드 안에서만 사용한다. 이렇게 메서드 선언에 사용되는 변수를 영어로 파라미터(parameter), 한글로 매개변수라 한다.

&ensp;<b>메서드 본문</b><br/>

```java
{

     System.out.println(a + "+" + b + " 연산 수행");
    int sum = a + b;
     return sum;
}
```

* 메서드가 수행해야 하는 코드 블럭이다.
* 메소드를 호출하면 멧드 본문이 순서대로 실행된다.
* 메서드 본문은 블랙박스이다. 메서드 호출하는 곳에서는 메서드 선언은 알지만 메서드 본문은 모른다.
* 메서드의 실행 결과를 반환하려면 return 문을 사용해야 한다. return 문 다음에 반환할 결과를 적어주면 된다.
    - return sum: sum 변수에 들어있는 값을 반환한다.

&ensp;<b>메서드 호출</b><br/>
&ensp;잎서 정읳나 메서드를 호출해서 실행하려면 이름에 입력 값을 전달하면 된다.보통 메서드를 호출한다고 표현한다.<br/>

```java
int sum1 = add(5, 10);
int sum2 = add(15, 20);
```

&ensp;메서드를 호출하면 어떻게 실행되는지 순서대로 확인해보자<br/>

```java
int sum1 = add(5, 10); //add라는 메서드를 숫자 5,10을 전달하면서 호출한다.
int sum1 = 15; //add(5, 10)이 실행된다. 실행 결과는 반환 값은 15이다.
//sum1에 15 값이 저장된다.
```

&ensp;메서드를 호출하면 메서드는 계산을 끝내고 결과를 반환한다. 쉽게 이야기하자면 메서드 호출이 끝나면 해당 메서드가 반환한 결과 값으로 치환된다.<br/>

```java
 //1: 메서드 호출
int sum1 = add(5, 10);

//2: 파라미터 변수 a=5, b=10이 전달되면서 메서드가 수행된다.
public static int add(int a=5, int b=10) {
    int sum = a + b;
    return sum;
}

//3: 메서드가 수행된다.
public static int add(int a=5, int b=10) {
    int sum = a(5) + b(10);
    return sum;
}

//4: return을 사용해서 메서드 실행의 결과인 sum을 반환한다. sum에는 값 15가 들어있으므로 값 15가 반환된다.
public static int add(int a=5, int b=10) {
    int sum = 15;
    return sum(15);
}

//5: 메서드 호출 결과로 메서드에서 반환한 값 15가 나온다. 이 값을 sum1에 대입했다.
int sum1 = 15;
```

&ensp;메서드 호출이 끝나면 더 이상 해당 메서드가 사용한 메모리를 낭비할 이유가 없다. 메서드 호출이 끝나면 메서드 정의에 사용한 피라미터 변수인 int a, int b는 물론이고 그 안에서 정의한 int sum 도 모두 제거된다.<br/>

메서드 호출과 용어 정리
======

&ensp;메서드를 호출할 때는 다음과 같이 메서드에 넘기는 값과 매기벼수(피라미터)의 타입이 맞아야 한다. 물론 넘기는 값과 매개변수(피라미터)의 순서와 갯수도 맞아야 한다.<br/>

```java
호출: call("hello", 20)
메서드 정의: int call(String str, int age)
```

인수(Argument)
------

&ensp;여기서 "hello", 20처럼 넘기는 값을 영어로 Argument(아규먼트), 한글로 인수 또는 인자라 한다. 실무에서는 아규먼트, 인수, 인자라는 용어를 모두 사용한다.<br/>

매개변수(Parameter)
------

&ensp;메서드를 정의할 때 선언한 변수인 String str, int age를 매개변수, 파라미터라 한다. 메서드를 호출할 때 인수를 넘기면 그 인수가 매개변수에 대입된다. 실무에서는 매개변수, 파라미터 용어 모두 사용한다.<br/>

용어 정리
------

* 인수라는 용어는 인과 수의 합성어로 들어가는 수라는 의미를 가진다. 즉 메서드 내부로 들어가는 값을 의미한다. 인자도 같은 의미이다.
* 매개변수, parameter는 매개와 변수의 합성어로 중간에서 전달하는 변수라는 의미를 가진다. 즉 메서드 호출부와 메서드 내부 사이에서 값을 전달하는 역할을 하는 변수라는 뜻이다.

메서드 정의
------

```java
 public static int add(int a, int b) {
    //메서드 본문, 실행 코드
}

제어자 반환타입 메서드이름(매개변수 목록) {
    메서드 본문
}
```

* 제어자(Modifier): public, static 과 같은 부분이다. 제어자는 뒤에서 설명한다. 
* 반환 타입(Return Type): 메서드가 실행된 후 반환하는 데이터의 타입을 지정한다. 메서드가 값을 반환하지 않는 경우 없다는 뜻의 void를 사용해야 한다. 예) void print(String str)
* 메서드 이름(Method Name): 메서드의 이름이다. 이 이름은 메서드를 호출하는 데 사용된다.
* 매개변수(Parameter): 입력 값으로 메서드 내부에서 사용할 수 있는 변수이다. 매개변수는 옵션이다. 입력값이 필요 없는 메서드는 매개변수를 지정하지 않아도 된다. 예) add()
* 메서드 본문(Method Body): 실제 메서드의 코드가 위치한다. 중괄호 {} 사이에 코드를 작성한다.

매개변수가 없거나 반환 타입이 없는 경우
======

&ensp;매개변수가 없고 반환 타입도 없는 메서드를 확인해보자<br/>

```java
public class Method2 {
    public static void main(String[] args) {
        printHeader();
        System.out.println("프로그램이 동작합니다.");
        printFooter();
    }

    public static void printHeader(){
        System.out.println("= 프로그램을 시작합니다 =");
        return; //void의 경우 생략 가능
    }

    public static void printFooter(){
        System.out.println("= 프로그램을 종료합니다 = ");
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-4.png" width="600"></p>

&ensp;printHeader(), printFooter() 메서드는 매개변수가 없고 반환 타입도 없다.<br/>

* 매개변수가 없는 경우
    - 선언: public static void printHeader() 와 같이 매개변수를 비워두고 정의하면 된다.
* 반환 타입이 없는 경우
    - 선언: public static void printHeader() 와 같이 반환 타입이 void로 정의하면 된다.
    - 호출: printHeader(); 와 같이 반환 타입이 없으므로 메서드만 호출하고 반환 값ㅇ르 받지 않으면 된다. 
        + String str = printHeader(): 반환 타입이 void이기 때문에 이렇게 반환 값을 받으면 컴파일 오류가 발생한다.

&ensp;void와 return생략<br/>
&ensp;모든 메서드는 항상 return을 호출해야 한다. 그런데 반환 타입 void의 경우에는 예외로 printFooter() 와 같이 생략해도 된다. 자바가 반환 타입이 없는 경우에는 return을 마지막줄에 넣어준다. 참고로 return을 만나면 해당 메서드는 종료된다.<br/>

반환 타입
======

&ensp;<b>반환 타입이 있으면 반드시 값을 반환해야 한다.</b><br/>
&ensp;반환 타입이 있는 메서드는 반드시 return을 사용해서 값을 반환해야 한다.<br/>

```java
public class MethodReturn1 {
    public static void main(String[] args) {
        boolean result = odd(2);
        System.out.println(result);
    }

    public static boolean odd(int i) {
        if (i % 2 == 1) {
        return true;
        }
    }
 }
```

&ensp;이 코드에서 if 조건이 만족할 때는 true가 반환되지만 조건을 만족하지 않으면 어떻게 될까? 조건을 만족하지 않는 경우에는 return문이 실행되지 안흔ㄴ다. 따라서 이 코드를 실행하면 return 문을 누락했다는 다음과 같은 컴파일 오류가 발생한다.<br/>

&ensp;컴파일 오류<br/>
&ensp;java: missing return statement<br/>

```java
public class MethodReturn1 {
    public static void main(String[] args) {
        boolean result = odd(2);
        System.out.println(result);
    }

    public static boolean odd(int i) {
        if(i % 2 == 1){
            return true;
        }else{
            return false;
        }
    }
}
```

&ensp;이렇게 수정하면 if조건을 만족하지 않아도 else를 통해 return문이 실행된다.<br/>

&ensp;<b>return문을 만나면 그 즉시 메서드를 빠져나간다.</b><br/>

* 18살 미만의 경우: 미성년자는 출입이 불가합니다.
* 18세 이상의 경우: 입장하세요

```java
public class MethodReturn2 {
    public static void main(String[] args) {
        checkAge(10);
        checkAge(20);
    }

    public static void checkAge(int age) {
        if (age < 18) {
        System.out.println(age + "살, 미성년자는 출입이 불가능합니다.");
        return;
        }

         System.out.println(age + "살, 입장하세요.");
    }
}
```

* 18세 미만의 경우 "미성년자는 출입이 불가능합니다"를 출력하고 바로 return문이 수행된다. 따라서 다음 로직을 수행하지 않고 해당 메서드를 빠져나온다.
* 18세 이상의 경우 "입장하세요"를 출력하고, 메서드가 종료된다. 참고로 반환 타입이 없는 void형이기 때문에 마지막 줄의 return은 생략할 수 있다.

반환 값 무시
------

&ensp;반환 타입이 있는 메서드를 호출했는데 만약 반환 값이 필요없다면 사용하지 않아도 된다.<br/>

&ensp;예시1: int sum = add(1, 2)  //반환된 값을 받아서 sum에 저장했다.<br/>
&ensp;add(1, 2)  //반환된 값을 사용하지 않고 버린다. 여기서는 예시1과 같이 호출 결과를 변수에 담지 않았다. 단순히 메서드만 호출했다.<br/>

메서드 호출과 값 전달
======

&ensp;<b>자바는 항상 변수의 값을 복사해서 대입한다.</b><br/>

변수와 값 복사
------

```java
public class MethodValue0 {
    public static void main(String[] args) {
        int num1 = 5;
        int num2 = num1;
        num2 = 10;

        System.out.println("num1=" + num1);
        System.out.println("num2=" + num2);
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-5.png" width="600"></p>

&ensp;실행 과정<br/>

```java
int num2 = num1; //num1의 값은 5이다. num1(5)
int num2 = 5; //num2 변수에 대입하기 전에 num1의 값 5를 읽는다. 결과: num1(5), num2(5)
num2 = 10; // num2에 10을 대입한다. 결과: num1(5), num2(10)
```

&ensp;여기서 값을 복사해서 대입한다는 부분이 바로 이 부분이다.<br/>

```java
int num2 = num1;
```

* 이 부분은 생각해보면 num1에 있는 값 5를 복사해서 num2에 넣는 것이다.
    - 복사한다고 표현한 이유는 num1의 값을 읽어도 num1에 있는 기존 값이 유지되고 새로운 값이 num2에 들어가기 때문이다. 마치 num1의 값이 num2에 복사가 된 것 같다.
    - num1이라는 변수 자체가 num2에 들어가는 것이 아니다. num1에 들어있는 값을 읽고 복사해서 num2에 넣는 것이다.
    - 간단하게 num1에 있는 값을 num2에 대입한다고 표현한다. 하지만 실제로는 그 값을 복사해서 대입하는 것이다. 

메서드 호출과 값 복사
------

```java
public class MethodValue1 {
    public static void main(String[] args) {
        int num1 = 5;
        System.out.println("1. changeNumber 호출 전, num1: " + num1);
        changeNumber(num1);
        System.out.println("4. changeNumber 호출 후, num1: " + num1);
    }

     public static void changeNumber(int num2) {
        System.out.println("2. changeNumber 변경 전, num2: " + num2);
        num2 = num2 * 2;
        System.out.println("3. changeNumber 변경 후, num2: " + num2);
     }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-6.png" width="600"></p>

&ensp;실행 과정 그림<br/>

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-7.png" width="600"></p>


* num1의 값 5를 읽고 복사해서 num2에 전달 -> 이 부분이 핵심

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-8.png" width="600"></p>


* num2의 변경은 num1에 영향을 주지 않는다. 왜냐하면 앞서 값을 복사해서 전달했기 때문이다.

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-9.png" width="600"></p>

&ensp;실행 과정 코드<br/>

```java
changeNumber(num1); //changeNumber를 호출한다. num1(5)
changeNumber(5); //num1의 값을 읽는다.

void changeNumber(int num2=5) //num1의 값 5가 num2에 복사된다. 결과: num1(5), num2(5)
num2 = num2 * 2; //num2에 2를 곱한다. 결과: num1(5), num2(5)
num2 = 5 * 2; //num2의 값을 읽어서 2를 곱한다. 결과: num1(5), num2(5)
num2 = 10; //num2에 계산 결과인 값 10을 대입한다. 결과: num1(5), num2(10)

num2를 출력한다: num2의 값인 10이 출력된다.
num1을 출력한다: num1의 값인 5가 출력된다.
```

&ensp;결과적으로 매개변수 num2의 값만 10으로 변경되고 num1의 값은 변경되지 않고 기존 값인 5로 유지된다. 자바는 항상 값을 복사해서 전달하기 때문에 num2의 값을 바꾸더라고 num2의 값을 바꾸더라도 num1에는 영향을 주지 않는다.<br/>

메서드 호출과 이름이 같은 변수
------

```java
public class MethodValue2 {
    public static void main(String[] args) {
        int number = 5;
        System.out.println("1. changeNumber 호출 전, number: " + number); // 출력: 5
        changeNumber(number);
        System.out.println("4. changeNumber 호출 후, number: " + number); // 출력: 5
    }

    public static void changeNumber(int number) {
        System.out.println("2. changeNumber 변경 전, number: " + number); // 출력: 5

        number = number * 2;
        System.out.println("3. changeNumber 변경 후, number: " + number); // 출력: 10
    }
 }
```

&ensp;이번에는 main() 에 정의한 변수와 메서드의 매개변수(파라미터)의 이름이 둘다 number로 같다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-10.png" width="600"></p>

&ensp;main() 도 사실은 메서드이다. 각각의 메서드 안에서 사용하는 변수는 서로 완전히 분리된 다른 변수이다. 물론 이름이 같아도 완전히 다른 변수다. 따라서 main()의 number와 changeNumber()의 number는 서로 다른 변수이다.<br/>

&ensp;실행과정<br/>

```java
changeNumber(number); //changeNumber를 호출한다. main의number(5)
changeNumber(5); //number의 값을 읽는다.

//main의 number값 5가 changeNumber의 number에 복사된다.
//결과: main의 number(5), changeNumber의 number(5)
void changeNumber(int number=5) 

//changeNumber의 number에 값 10을 대입한다.
//결과: main의 number(5), changeNumber의 number(10)
number = number * 2;
main의 number을 출력한다: main의 number의 값인 5가 출력된다.
```

메서드 호출과 값 반환받기
======

```java
public class MethodValue3 {
    public static void main(String[] args) {
        int num1 = 5;
        System.out.println("changeNumber 호출 전, num1: " + num1); // 출력: 5
        num1 = changeNumber(num1);
        System.out.println("changeNumber 호출 후, num1: " + num1); // 출력: 10
    }

    public static int changeNumber(int num2) {
        num2 = num2 * 2;
        return num2;
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-11.png" width="600"></p>

&ensp;실행결과<br/>

```java
num1 = changeNumber(num1); //num1(5)
num1 = changeNumber(5);

//호출 시작:changeNumber()
//num1의 값 5가 num2에 대입된다. num1의 값을 num2에 복사한다. num1(5), num2(5)
int changeNumber(int num2=5) 
num2 = num2 * 2; //계산 결과: num1(5), num2(10)
return num2; // num2의 값은 10이다.
return 10;
//호출 끝: changeNumber()

num1 = changeNumber(5);//반환 결과가 10이다.
num1 = 10;//결과: num1(10)
```

정리
-----

&ensp;자바는 항상 변수의 값을 복사해서 대입한다.(참조형도 참조형 변수에 있는 값인 참조값을 복사하는 것이다.)<br/>

메서드와 형변환
======

&ensp;메서드를 호출할 때도 형변환이 적용된다.<br/>

명시적 형변환
-------

&ensp;메서드를 호출하는데 인자오아 매개변수의 타입이 맞지 않다면 어떻게 해야할까?<br/>

```java
public class MethodCasting1 {
    public static void main(String[] args) {
        double number = 1.5;
        //printNumber(number); // double을 int형에 대입하므로 컴파일 오류
        printNumber((int) number); // 명시적 형변환을 사용해 double을 int로 변환
    }

    public static void printNumber(int n) {
        System.out.println("숫자: " + n);
    }
 }
```

&ensp;printNumber(number)   //double을 int형에 대입하므로 컴파일 오류<br/>

&ensp;실행결과-컴파일 오류<br/>
&ensp;java: incompatible types: possible lossy conversion from double to int<br/>

&ensp;다음과 같은 이유로 컴파일 오류가 발생한다.<br/>

```java
printNumber(number) //number는 1.5 실수
printNumber(1.5) //메서드를 호출하기 전에 number 변수의 값을 읽음
void printNumber(int n=1.5) //int형 매개변수 n에 double형 실수인 1.5를 대입 시도, 컴파일 오류
```

&ensp;이 경우 메서드 호출이 꼭 필요하다면 다음과 같이 명시적 형변환을 사용해야 한다.<br/>

```java
printNumber((int) number); // 명시적 형변환을 사용해 double을 int로 변환
printNumber(1); // (double) 1.5 -> (int) 1로 변환
void printNumber(int n=1) //int형 파라미터 변수 n에 int형 1을 대입
```

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-12.png" width="600"></p>

자동 형변환
------

&ensp;int < long < double<br/>
&ensp;메서드를 호출할 때 매개변수에 값을 전달히는 것도 결국 변수에 값을 대입하는 것이다.<br/>

```java
public class MethodCasting2 {
    public static void main(String[] args) {
        int number = 100;
        printNumber(number); // int에서 double로 자동 형변환
    }

    public static void printNumber(double n) {
        System.out.println("숫자: " + n);
    }
 }
```

* double 형 매개변수(피라미터)에 int형 인수를 전달하는데 문제없이 잘 동작한다.

&ensp;실행결과<br/>
<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-13.png" width="600"></p>

&ensp;다음과 같이 자동 형변환이 동작한다.<br/>

```java
printNumber(number); // number는 int형 100
printNumber(100); //메서드를 호출하기 전에 number 변수의 값을 읽음

void printNumber(double n=100) //double형 파라미터 변수 n에 int형 값 100을 대입
void printNumber(double n=(double) 100) //double이 더 큰 숫자 범위이므로 자동 형변환 적용
void printNumber(double n=100.0) //자동 형변환 완료
```

&ensp;<b>정리</b><br/>
&ensp;메서드를 호출할 때는 전달하는 인수의 타입과 매개변수의 타입이 맞아야 한다. 단 타입이 달라도 자동 형변환이 가능한 경우에는 호출할 수 있다.<br/>

메서드 오버로딩
======

&ensp;다음과 같은 메서드를 만들고 싶다.<br/>
* 두 수를 더하는 메서드
* 세 수를 더하는 메서드

&ensp;이 경우 둘 다 더하는 메서드이기 때문에 가급적 같은 이름인 add를 사용하고 싶다. 자바는 메서드의 이름 뿐만 아니라 매개변수 정보를 함께 사용해서 매서드를 구분한다. 따라서 다음과 같이 이름이 같고 매개변수가 다른 매서드를 정의할 수 있다.<br/>

&ensp;오버로딩 성공<br/>

```java
add(int a, int b)
add(int a, int b, int c)
add(double a, double b)
```

&ensp;이렇게 이름이 같고 매개변수가 다른 매서드를 여러 개 정의하는 것을 매서드 오버로딩(Overloading)이라 한다. 오버로딩은 번역하면 과적인데 과하게 물건을 담았다는 뜻이다. 따라서 같은 이름의 매서드를 여러개 정의했다고 이해하면 된다.<br/>

&ensp;오버로딩 규칙<br/>
&ensp;메서드의 이름이 같아도 매개변수의 타입 및 순서가 다르면 오버로딩을 할 수 있다. 참고로 반환 타입은 인정되지 않는다.<br/>

&ensp;다음 케이스는 메서드 이름과 매개변수의 타입이 같으므로 컴파일 오루가 발생한다. 반환 타입은 인정하지 않는다.<br/>
&ensp;오버로딩 실패<br/>

```java
 int add(int a, int b)
 double add(int a, int b)
```

&ensp;용어: 매서드 시그니처(method signature)<br/>
&ensp;매서드 시그니처는 자바에서 메서드를 구분할 수 있는 고유한 식별자나 서명을 뜻한다. 메서드 시그니처는 매서드의 이름과ㅏ 매개변수 타입(순서 포함)으로 구성되어 있다. 쉽게 이야기해서 메서드를 구분할 수 있는 기준이다. 자바 입장에서는 각각의 메서드를 고유하게 구분할 수 있어야 한다. 그래야 어떤 메서드를 호출할 지 결정할 수 있다.<br/>
&ensp;따라서 메서드 오버로딩에서 설명한 것처럼 메서드 이름이 같아도 메서드 시그니처가 다르면 다른 메서드로 간주한다. 반환 타입은 시그니처에 포함되지 않는다. 방금 오버로딩이 실패한 두 메서드를 보자. 두 메서드는 add(int a, int b)로 메서드 시그니처가 같다. 따라서 메서드의 구분이 불가능하므로 컴파일 오류가 발생한다.<br/>

* 매개변수의 갯수가 다른 오버로딩 예제

```java
public class Overloading1 {
    public static void main(String[] args) {
        System.out.println("1: " + add(1, 2));
        System.out.println("2: " + add(1, 2, 3));
    }

    // 첫 번째 add 메서드: 두 정수를 받아서 합을 반환한다.
    public static int add(int a, int b) {
        System.out.println("1번 호출");
        return a + b;
    }

    // 두 번째 add 메서드: 세 정수를 받아서 합을 반환한다.
    // 첫 번째 메서드와 이름은 같지만, 매개변수 목록이 다르다.
    public static int add(int a, int b, int c) {
        System.out.println("2번 호출");
        return a + b + c;
    }
}
```

1. 정수 1, 2를 호출했으므로 add(int a, int b)가 호출된다.
2. 정수 1, 2, 3을 호출했으므로 add(int a, int b, int c)가 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-14.png" width="600"></p>

* 매개변수의 타입이 다른 오버로딩 예제

```java
public class Overloading2 {
    public static void main(String[] args) {
        myMethod(1, 1.2);
        myMethod(1.2, 2);
    }

    public static void myMethod(int a, double b) {
        System.out.println("int a, double b");
    }

     public static void myMethod(double a, int b) {
        System.out.println("double a, int b");
    }
}
```

1. 정수 1, 실수 1.2를 호출했으므로 myMethod(int a, double b)가 호출된다.
2. 실수 1.2, 정수 2를 호출했으므로 myMethod(double a, int b)가 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-15.png" width="600"></p>

* 매개변수의 타입이 다른 경우

```java
public class Overloading3 {
    public static void main(String[] args) {
        System.out.println("1: " + add(1, 2));
        System.out.println("2: " + add(1.2, 1.5));
    }

    // 첫 번째 add 메서드: 두 정수를 받아서 합을 반환한다.
    public static int add(int a, int b) {
        System.out.println("1번 호출");
        return a + b;
    }

    // 두 번째 add 메서드: 두 실수를 받아서 합을 반환한다.
    // 첫 번째 메서드와 이름은 같지만, 매개변수의 유형이 다르다.
    public static double add(double a, double b) {
        System.out.println("2번 호출");
        return a + b;
    }
}
```

1. 정수 1, 정수 2를 호출했으므로 add(int a, int b)가 호출된다.
2. 실수 1.2, 실수 1.5를 호출했으므로 add(double a, double b)가 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-16.png" width="600"></p>

&ensp;만약 다음 첫 번째 메서드를 삭제하면 어떻게 될까?<br/>

```java
public static int add(int a, int b) {
    System.out.println("1번 호출");
    return a + b;
}
```

1. int 형 정수 1, int 형 정수 2를 호출했으므로 자동 형변환이 발생해서 add(double a, double b)가 호출된다.
2. 실수 1.2, 실수 1.5를 호출했으므로 add(double a, double b)가 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/9. 메서드/9-17.png" width="600"></p>

&ensp;먼저 본인의 타입에 죄대한 맞는 메서드를 찾아서 실행하고 그래도 없으면 형 변환 가능한 타입의 메서드를 찾아서 실행한다.<br/>

정리
======

변수명 vs 메서드명
------

&ensp;변수 이름은 일반적으로 명사를 사용한다. 한편 메서드는 무언가 동작하는데 사용하기 때문에 일반적으로 동사로 시작한다.<br/>
&ensp;이런 차이점 외에는 변수 이름과 메서드 이름에 대한 규칙은 둘 다 같다.<br/>
* 변수명: 예) customerName, totalSum, employeeCount, isAvailable
* 메서드명: 예) printReport(), calculateSum(), addCustomer(), getEmployeeCount(), serEmployeeName()

&ensp;메서드 사용의 장점<br/>
* 코드 재사용: 메서드는 특정 기능을 캡슐화하므로 필요할 때마다 그 기능을 다시 작성할 필요 없이 해당 메서드를 호출함으로써 코드를 재사용할 수 있다.
* 코드의 가독성: 일므이 부여된 메서드는 코드가 수행하는 작업을 명확하게 나타내므로 코드르 읽는 사람에게 추가적인 문맥을 제공한다.
* 모듈성: 큰 프로그램을 작은, 관리 가능한 부분으로 나눌 수 있다. 이는 코드의 가독성을 향상시키고 디버깅을 쉽게 만든다. 
* 코드 유지 관리: 메서드를 사용하면 코드의 특정 부분에서 문제가 발생하거나 업데이트가 필요한 경우 해당 메서드만 수정하면 된다. 이렇게 하면 전체 코드 베이스에 영향을 주지 않고 변경 사항을 적용할 수 있다. 
* 재사용성과 확장성: 잘 설계된 메서드는 다른 프로그램이나 프로젝트에서도 재사용할 수 있으며, 새로운 기능을 추가하거나 기존 기능을 확장하는 데 유용하다.
* 추상화: 메서드를 사용하는 곳에서는 메서드의 구현을 몰라도 된다. 프로그램의 다른 부분에서는 복잡한 내부 작업에 대해 알 필요 없이 메서드를 사용할 수 있다.
* 테스트와 디버깅 용이성: 개별 매서드는 독립적으로 테스트하고 디버그할 수 있다. 이는 코드의 문제를 신속하게 찾고 수정하는 데 도움이 된다.

