---
title: "6주차 스코프, 형변한"
excerpt: ""

wirter: sohee Kim
categories:
  - 김영한의 자바
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-07-22
last_modified_at: 2025-07-22
---

스코프
======

지역 변수와 스코프
-----

&ensp;변수는 선언한 위치에 따라 지역 변수, 멤버 변수(클래스 변수, 인스턴스 변수)와 같이 분류된다. <br/>
&ensp;지역변수는 이름 그대로 특정 지역에서만 사용할 수 있는 변수라는 뜻이다. 그 특정 지역을 벗어나면 사용할 수 없다. 여기서 말하는 지역이 바로 변수가 선언된 코드 블럭( {} )이다. 지역 변수는 자신이 선언된 코드 블럭( {} ) 안에서만 생존하고 자신이 선언된 코드 블록을 벗어나면 제거된다. <br/>

```java
public class Scope1 {
    public static void main(String[] args) {
        int m = 10; //m 생존 시작
        if (true) {
            int x = 20; //x 생존 시작
            System.out.println("if m = " + m); //블록 내부에서 블록 외부는 접근 가능
            System.out.println("if x = " + x);
        }  // x 생존 종료

        //System.out.println("main x = " + x);  //오류 , 변수 x에 접근 불가
        System.out.println("main m = " + m); 
    } //m 생존 종료
}
```

* int m
    - int m은 main{} 의 코드 블록 안에서 선언되었다. 따라서 변수를 선언한 시점부터 main{}의 코드 블럭이 종료될 때까지 생존한다.
    - if{} 블럭 내부에서도 외부 블록에서 선언된 m에 접근할 수 있다. 쉽게 이야기해서 생존 범위만 맞으면 다 접근할 수 있다.
* int x
    - int x는 if{} 블럭 안에서 선언되었다. 따라서 변수를 선언한 시점부터 if{}의 코드 블럭이 종료될 때까지 생존한다.
    - if{} 내부에서는 자신의 범위에서 선언한 x에 당연히 접근할 수 있다.
    - if{} 코드 블록이 끝나버리면 x는 제거된다. 따라서 더는 x에 접근할 수 없다. 따라서 이후에 접근하면 cannot find symbol이라는 변수 이름을 찾을 수 없다는 컴파일 오류가 발생한다.

&ensp;지역변수는 본인의 코드 블럭 안에서만 생존한다. 그리고 자신의 코드 블록 안에서는 얼마든지 접근할 수 있다. 하지만 자신의 코드 블럭을 벗어나면 제거되기 때문에 접근할 수 없다.<br/>

&ensp;이렇게 변수의 접근 가능한 범위를 스코프(scope)라 한다. 참고로 Scope를 번역하면 범위라는 뜻이다. <br/>
&ensp;int m은 main{} 전체에서 접근할 수 있기 때문에 스코프가 넓고 int x는 if{} 코드 블록 안에서만 접근할 수 있기 때문에 스코프가 좁다.<br/>

```java
public class Scope2 {
    public static void main(String[] args) {
        int m = 10;
        for (int i = 0; i < 2; i++) { //블록 내부, for문 내
        System.out.println("for m = " + m); //블록 내부에서 외부는 접근 가능
        System.out.println("for i = " + i);
        } //i 생존 종료
    
        //System.out.println("main i = " + i); //오류, i에 접근 불가
        System.out.println("main m = " + m);
    }
}
```

스코프 존재 이유
------

```java
public class Scope3_1 {
    public static void main(String[] args) {
        int m = 10;
        int temp = 0;
        if (m > 0) {
            temp = m * 2;
            System.out.println("temp = " + temp);
        }
        System.out.println("m = " + m);
    }
}
```

&ensp;조건이 맞으면 변수 m의 값을 2배 증가해서 출력하는 코드이다. 여기서 2배 증가한 값을 저장해두기 위해 임시 변수 temp를 사용했다. 그런데 이 코드는 좋은 코드라고 보기는 어렵다. 왜냐하면 임시 변수 temp는 if 조건이 만족할 때 임시로 잠깐 사용하는 변수이다. 그런데 임시 변수 temp main() 코드 블럭에 선언되어 있다. 이렇게 되면 다음과 같은 문제가 발생한다.<br/>
* 비효율적인 메모리 사용: temp는 if코드 블록에서만 필요하지만 main() 코드 블럭이 종료될 때까지 메모리에 유지된다. 따라서 불필요한 메모리가 낭비된다. 만약 if 코드 블럭 안에 temp를 선언했다면 자바를 구현하는 곳에서 if코드 블록의 종료 시점에 이 변수를 메모리에서 제거해서 더 효율적으로 메모리를 사용할 수 있다. 
* 코드 복잡성 증가: 좋은 코드는 군더더기 없는 단순한 코드이다. temp는 if코드 블럭에서만 필요하고 여기서만 사용하면 된다. 만약 if코드 블럭 안에 temp를 선언했다면 if가 끝나고 나면 if 코드 블럭이 끝나도 main() 어디서나 temp를 여전히 접근할 수 있다. 누군가 이 코드를 유지보수 할 때 m은 물론이고 temp까지 계속 신경써야 한다. 스코프가 불필요하게 넓은 것이다. 지금은 코드가 매우 단순해서 이해하는데 어려움이 없겠지만 실무에서는 코드가 매우 복잡한 경우가 많다.

&ensp;temp의 스코프를 꼭 필요한 곳으로 한정하면<br/>

```java
 public class Scope3_2 {
    public static void main(String[] args) {
        int m = 10;
        if (m > 0) {
            int temp = m * 2;
            System.out.println("temp = " + temp);
        }
        System.out.println("m = " + m);
    }
 }
```

&ensp;temp를 if코드 블록 안에서 선언했다. 이제 temp는 if 코드 블록 안으로 스코프가 줄어든다. 덕분에 temp 메모리를 빨리 제거해서 메모리를 효율적으로 사용하고 temp 변수를 생각해야 하는 범위를 줄여서 더 유지보수 하기 좋은 코드를 만들었다.<br/> 

while문 vs for문 - 스코프 관점
------

* while

```java
public class While2_3 {
    public static void main(String[] args) {
        int sum = 0;
        int i = 1;
        int endNum = 3;

        while (i <= endNum) {
            sum = sum + i;
            System.out.println("i=" + i + " sum=" + sum);
            i++;
        }
        //아래 코드 더 있다고 가정
    }
}
```

* for

```java
public class For2 {
    public static void main(String[] args) {
        int sum = 0;
        int endNum = 3;

        for (int i = 1; i <= endNum; i++) {
            sum = sum + i;
            System.out.println("i=" + i + " sum=" + sum);
        }
         //아래 코드 더 있다고 가정
    }
}
```

&ensp;변수의 스코프 관점에서 카운터 변수 i를 비교해보면<br/>
* while문의 경우 변수 i의 스코프가 main() 메서드 전체가 된다. 반면에 for문의 경우 변수 i의 스코프가 for문 안으로 한정된다.
* 따라서 변수 i와 같이 for문 안에서만 사용되는 카운터 변수가 있다면 while문보다는 for문을 사용해서 스코프의 범위를 제한하는 것이 메모리 사용과 유지보수 관점에서 더 좋다.

정리 
------

* 변수는 꼭 필요한 범위로 한정해서 사용하는 것이 좋다. 변수의 스코프는 꼭 필요한 곳으로 한정해서 사용하자. 메모리를 효율적으로 사용하고 더 유지보수하기 좋은 코드를 만들 수 있다.
* 좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 적절한 제약이 있는 프로그램이다.

형변횐
======

자동 형변환
------

&ensp;형변환<br/>
* 작은 범위에서 큰 범위로는 당연히 값을 넣을 수 있다
    - 예) int -> long -> double
* 큰 범위에서 작은 범위는 다음과 같은 문제가 발생할 수 있다.
    - 소수점 버림
    - 오버플로우

&ensp;작은 범위에서 큰 범위로 대입은 허용한다.<br/>
&ensp;자바에서 숫자를 표현할 수 있는 범위는 다음과 같다.<br/>
&ensp;int < long < double<br/>
&ensp;int 보다는 long이, long보다는 double 이 더 큰 범위를 표현할 수 있다.<br/>

```java
public class Casting1 {
    public static void main(String[] args) {
        int intValue = 10;
        long longValue;
        double doubleValue;

        longValue = intValue; // int -> long
        System.out.println("longValue = " + longValue); //longValue = 10

        doubleValue = intValue; // int -> double
        System.out.println("doubleValue1 = " + doubleValue); //doubleValue1 = 10.0

        doubleValue = 20L; // long -> double
        System.out.println("doubleValue2 = " + doubleValue); //doubleValue2 = 20.0
    }
 }
```

<p align="center"><img src="/assets/img/김영한의 자바/6. 스코프, 형변환/6-1.png" width="600"></p>

* 자바는 기본적으로 같은 타입에 값을 대입할 수 있다. 그런데 다른 타입에 값을 대입하면 어떻게 될까?
* int -> long을 비교해보면 long이 int보다 더 큰 숫자 범위를 표현한다. 작은 범위 숫자 타입에서 큰 범위 숫자 타입에 대입을 하면 문제가 되지 않는다. 만약 이런 경우까지 오루가 발생하면 개발이 너무 불편할 것이다.
* long -> double 의 경우에도 double은 부동 소수점을 사용하기 때문에 더 큰 숫자 범위를 표현한다. 따라서 대입할 수 있다.
* 정리하면 작은 범위에서 큰 범위로의 대입은 자바 언어에서 허용한다. 쉽게 이야기하면 큰 그릇은 작은 그릇에 담긴 내용물을 담을 수 있다.

&ensp;자동 형변환<br/>
&ensp;하지만 결국 대입하는 형(타입)을 맞추어야 하기 때문에 개념적으로 다음과 같이 동작한다.<br/>

```java
//intValue = 10
doubleValue = intValue
doubleValue = (double) intValue //형 맞추기
doubleValue = (double) 10 //변수 값 읽기
doubleValue = 10.0 //형변환
```

&ensp;이렇게 앞에 (double)과 같이 적어주면 int형이 double형으로 형이 변한다. 이렇게 형이 변경되는 것을 형변환이라 한다. 작은 범위 숫자 타입에서 큰 범위 숫자 타입으로의 대입은 개발자가 이렇게 직접 형변환을 하지 않아도 된다. 이런 과정이 자동으로 일어나기 때문에 자동 형변환 또는 묵시적 형변환이라 한다. <br/>

명시적 형변환
------