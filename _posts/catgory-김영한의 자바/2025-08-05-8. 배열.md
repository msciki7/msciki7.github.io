---
title: "8주차 배열"
excerpt: ""

wirter: sohee Kim
categories:
  - 김영한의 자바
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-08-05
last_modified_at: 2025-08-05
---


배열의 선언과 생성
======

&ensp;배열은 같은 타입의 변수를 사용하기 편하게 하나로 묶어둔 것이다.<br/>


```java
 public class Array1Ref1 {
    public static void main(String[] args) {
        int[] students; //배열 변수 선언
        students = new int[5]; //배열 생성

        //변수 값 대입
        students[0] = 90;
         students[1] = 80;
        students[2] = 70;
        students[3] = 60;
        students[4] = 50;

        //변수 값 사용
        System.out.println("학생1 점수: " + students[0]);
        System.out.println("학생2 점수: " + students[1]);
        System.out.println("학생3 점수: " + students[2]);
        System.out.println("학생4 점수: " + students[3]);
        System.out.println("학생5 점수: " + students[4]);
    }
 }
```

```java
int[] students;  //1. 배열 변수 선언
students = new int[5];   //2. 배열 생성
```

&ensp;<b>1. 배열 변수 선언</b><br/>
<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-1.png" width="600"></p>

* 배열을 사용하려면 int[] students; 와 같이 배열 변수를 선언해야 한다.
* 일반적인 변수와 차이점은 int[] 처럼 타입 다음에 대괄호([]) 가 들어간다는 점이다.
* 배열 변수를 선언한다고해서 아직 사용할 수 있는 배열이 만들어진 것은 아니다.
    - int a에는 정수를 double b에는 실수를 담을 수 있다.
    - int[] students와 같은 배열 변수에는 배열을 담을 수 있다.

&ensp;<b>2. 배열 생성</b><br/>
<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-2.png" width="600"></p>


* 배열을 사용하려면 배열을 생성해야 한다.
* new int[5] 라고 입력하면 오른쪽 그림과 같이 총 5개의 int형 변수가 만들어진다.
* new는 새로 생성한다는 뜻이고 int[5]는 int형 변수 5개라는 뜻이다. 따라서 int형 변수 5개를 다룰 수 있는 배열을 새로 만든다는 뜻이다.
* 앞서 int student1, int student2...int student5 까지 총 5개의 변수르르 직접 선언했다. 배열을 사용하면 이런 과정을 한 번에 깔끔하게 처리할 수 있다.

&ensp;<b>배열과 초기화</b><br/>

* new int[5] 라고 하면 총 5개의 int형 변수가 만들어진다. 자바는 배열을 생성할 때 그 내부값을 자동으로 초기화한다.
* 숫자 0, boolean은 false, String은 null(없다는 뜻이다.)로 초기화된다.

&ensp;<b>3. 배열 참조값 보관</b><br/>
<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-3.png" width="600"></p>

* new int[5]로 배열을 생성하면 배열의 크기만큼 메모리를 확보한다.
    - int 형을 5개 사용하면 4byte * 5 -> 20 byte를 확보한다.
*  배열을 생성하고 나면 자바는 메모리 어딘가에 있는 이 배열에 접근할 수 있는 참조값(주소)(x001)을 반환한다.
    - 여기서 x001이라고 표현한 것이 참조값이다.(실제로 x001 처럼 표현되는 겂은 아니고 이해를 돕기 위한 예시이다.)
* 앞서 선언한 배열 변수인 int[] students 에 생성된 배열의 참조값(x001)을 보관한다.
* int[] students 변수는 new int[5]로 생성한 배열의 참조값을 가지고 있다.
    - 이 변수는 참조값을 가지고 있다. 이 참조값을 통해 배열을 참조할 수 있다. 쉽게 이야기해서 참조값을 통해 메모리에 있는 실제 배열에 접근하고 사용할 수 있다.
    - 참고로 배열을 생성하는 new int[5]  자체에는 아무런 이름이 없다! 그냥 int형 변수 5개 연속으로 만드는 것이다. 따라서 생성한 배열에 접근하는 방법이 필요하다. 따라서 배열을 생성할 때 반환되는 참조값을 어딘가에 보관해두어야 한다. 앞서 int[] students 변수에 참조값(x001)을 보관해두었다. 이 변수를 통해서 이 배열에 접근할 수 있다.

```java
int[] students = new int[5]; //1. 배열 생성
int[] students = x001; //2. new int[5]의 결과로 x001 참조값 반환
students = x001 //3. 최종 결과
```

배열 사용
======

인덱스
------

&ensp;배열은 변수와 사용법이 비슷한데 차이점이 있다면 다음과 같이 [] 사이에 숫자 번호를 넣어주면 된다. 배열의 위치를 나타내는 숫자를 인덱스(index)라 한다.<br/>

```java
//변수 값 대입
students[0] = 90;
students[1] = 80;

//변수 값 사용
System.out.println("학생1 점수: " + students[0]);
System.out.println("학생2 점수: " + students[1]);
```

&ensp;배열 참조 그림<br/>
<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-4.png" width="600"></p>

&ensp;배열은 0부터 시작한다.<br/>
&ensp;new int[5]와 같이 5개의 요소를 가지는 int형 배열을 만들었다면 인덱스는 0, 1, 2, 3, 4가 존재한다.<br/>
&ensp;여기서 주의해야 할 점이 있는데 인덱스는 0부터 시작한다는 것이다. 배열의 요소를 5개로 생성했지만 인덱스는 0부터 시작한다. 따라서 사용 가능한 인덱스의 범위는 0 ~ (n-1)이 된다. 그래서 students[4]가 배열의 마지막 요소이다.<br/>

&ensp;만약 students[5]와 같이 접근 가능한 배열의 인덱스 범위를 넘어가면 다음과 같은 오류가 발생한다.<br/>
&ensp;인덱스 허용 범위를 넘어설 때 발생하는 오류<br/>
<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-5.png" width="600"></p>

배열에 값 대입
------

&ensp;배열에 값을 대입하든 배열의 값을 사용하든 간에 일반적인 변수와 사용법은 같다. 추가로 []를 통해 인덱스만 넣어주면 된다.<br/>

```java
students[0] = 90; //1. 배열에 값을 대입
x001[0] = 90; //2. 변수에 있는 참조값을 통해 실제 배열에 접근. 인덱스를 사용해서 해당 위치의 요소에 접근, 값 대입
```

```java
 students[1] = 80; //1. 배열에 값을 대입
x001[1] = 80; //2. 변수에 있는 참조값을 통해 실제 배열에 접근. 인덱스를 사용해서 해당 위치의 요소에 접근, 값 대입
```

배열 값 읽기
------

```java
//1. 변수 값 읽기
System.out.println("학생1 점수: " + students[0]); 
//2. 변수에 있는 참조값을 통해 실제 배열에 접근. 인덱스를 사용해서 해당 위치의 요소에 접근
System.out.println("학생1 점수: " + x001[0]);
 //3. 배열의 값을 읽어옴
System.out.println("학생1 점수: " + 90);
```

&ensp;배열은 사용하면 이렇게 참조값을 통해서 실제 배열에 접근하고 인덱스를 통해서 원하는 요소를 찾는다.<br/>

기존형 vs 참조형
======

&ensp;자바의 변수 데이터 타입을 가장 크게 보면 기본형과 참조형으로 분류할 수 있다. 사용하는 값을 직접 넣을 수 있는 기본형, 그리고 방금 본 배열 변수와 같이 메모리의 참조값을 넣을 수 있는 참조형으로 분류할 수 있다.<br/>

* 기본형(Primitive Type) : 우리가 지금까지 봤던 int, long, double, boolean처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입을 기본형(Primitive Type)이라 한다.
* 참조형(Reference Type) : int[] students 와 같이 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입을 참조형(Reference Type)이라 한다.

참조
------

&ensp;기본형은 모두 사이즈가 명확하게 정해져 있다.<br/>

```java
int i; //4byte
long l;//8byte
double d; //8byte
```

&ensp;그런데 배열은 다음과 같이 동적으로 사이즈를 변경할 수 있다.<br/>

```java
int size=10000; //사용자가 입력한 값을 넣었다고 가정해보자.
new int[size]; //이 코드가 실행되는 시점에 배열의 크기가 정해진다.
```

* 기본형은 선언과 동시에 크기가 정해진다. 따라서 크기를 동적으로 바꾸거나 할 수는 없다. 반면에 앞서본 배열과 같은 참조형은 크기를 동적으로 할당할 수 있다. 예를 들어서 Scanner를 사용해서 사용자 입력에 따라 size변수의 값이 변하고 생성되는 배열의 크기도 달라질 수 있다. 이런 것을 동적 메모리 할당이라 한다. 기본형은 선언과 동시에 사이지가 정적으로 정해지지만 참조형을 사용하면 이처럼 동적으로 크기가 변해서 유연성을 제공할 수 있다.
* 기본형은 사용할 값을 직접 저장한다. 반면에 참조형은 메모리에 저장된 배열이나 객체의 참조를 저장한다. 이로 인해 참조형은 더 복잡한 데이터 구조를 만들고 관리할 수 있다. 반면 기본형은 더 빠르고 메모리를 효율저긍로 처리한다.

배열 리펙토링
======

변수 값 사용
------

&ensp;리펙토링(refatoring)은 기존의 코드 기능은 유지하면서 내부 구조를 개선하여 가독성을 높이고 유지보수를 용이하게 하는 과정을 뜻한다. 이는 중복을 제거하고 복잡성을 줄이며 이해하기 쉬운 코드로 만들기 위해 수행된다. 리펙토링은 버그를 줄이고 프로그램의 성능을 향상시킬 수도 있으며 코드의 설계를 개선하는 데에도 도움이 된다. 쉽게 이야기해서 작동하는 기능은 똑같은데 코드를 개선하는 것을 리펙토링이라 한다.<br/> 

```java
//변수 값 사용
System.out.println("학생1 점수: " + students[0]);
System.out.println("학생2 점수: " + students[1]);
System.out.println("학생3 점수: " + students[2]);
System.out.println("학생4 점수: " + students[3]);
System.out.println("학생5 점수: " + students[4]);
```

&ensp;for문을 사용해서 문제를 해결<br/>

```java
public class Array1Ref2 {
    public static void main(String[] args) {
        int[] students; //배열 변수 선언
        students = new int[5]; //배열 생성

        //변수 값 대입
        students[0] = 90;
        students[1] = 80;
        students[2] = 70;
        students[3] = 60;
        students[4] = 50;

        //변수 값 사용
        for (int i = 0; i < students.length; i++) {
        System.out.println("학생" + (i + 1) + " 점수: " + students[i]);
        }
    }
}
```

* 반복문을 사용해서 배열을 통해 값을 사용하는 부분을 효과적으로 변경했다.
* 배열의 인덱스는 0부터 시작하기 때문에 반복문에서 i = 0을 초기값으로 사용했다.
* students.length
    - 배열의 길이를 제공하는 특별한 기능이다.
    - 참고로 이 값은 조회만 할 수 있다. 대입은 할 수는 없다.
    - 현재 배열의 크기가 5이기 때문에 여기서는 5가 출력된다. 
* for문의 조건이 i < students.length이기 때문에 i는 0, 1, 2, 3, 4까지만 반복한다. 
    - i가 5가 되면 5 < 5 가 되면서 조건이 거짓이 되고 반복을 종료한다.

초기화
-----

&ensp;배열은 {} 를 사용해서 생성과 동시에 편리하게 초기화 하는 기능을 제공한다.<br/>

```java
int[] students;
students = new int[]{90, 80, 70, 60, 50}; //배열 생성과 초기화
```

```java
 public class Array1Ref3 {
    public static void main(String[] args) {
        int[] students;
        students = new int[]{90, 80, 70, 60, 50}; //배열 생성과 초기화

        for (int i = 0; i < students.length; i++) {
            System.out.println("학생" + (i + 1) + " 점수: " + students[i]);
        }
    }
 }
```

&ensp;이해를 돕기 위해 배열 변수의 선언과 배열의 생성 및 초기화를 두 줄로 나누었지만 다음과 같이 한 줄도 가능하다.<br/>

```java
int[] students = new int[]{90, 80, 70, 60, 50}; //배열 변수 선언, 배열 생성과 초기화
```

간단한 배열 생성
------

&ensp;배열은 {}만 사용해서 생성과 동시에 편리하게 초기화 하는 기능을 제공한다.<br/>

&ensp;배열의 편리한 초기화<br/>

```java
int[] students = {90, 80, 70, 60, 50};
```

&ensp;단 이때는 예제와 같이 배열 변수의 선언을 한 줄에 함께 사용할 때만 가능하다.<br/>
&ensp;물론 이렇게 하더라도 자바가 내부에서 배열 요소의 크기를 보고 new int[5]을 사용해서 배열을 생성한다. 따라서 기존 코드를 조금 더 편리하게 사용할 수 있는 편의 기능이라 생각하면 된다.<br/>

&ensp;오류<br/>

```java
int[] students;
students = {90, 80, 70, 60, 50};
```

```java
public class Array1Ref4 {
    public static void main(String[] args) {
        //배열 생성 간략 버전, 배열 선언과 함께 사용시 new int[] 생략 가능
        int[] students = {90, 80, 70, 60, 50};

        for (int i = 0; i < students.length; i++) {
            System.out.println("학생" + (i + 1) + " 점수: " + students[i]);
        }
    }
 }
```

&ensp;이제 학생의 점수를 추가해도 {90, 80, 70, 60, 50}의 내용만 변경하면 된다. 그러면 나머지 코드는 변경하지 않아도 된다.<br/>

2차 배열
======

&ensp;지금까지 학습한 배열은 단순히 순서대로 나열되어 있었다. 이것을 1차원 배열이라 한다. 이번에 학습할 2차원 배열은 이름 그대로 하나의 차원이 추가된다. 2차원 배열은 행과 열로 구성된다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-6.png" width="600"></p>

&ensp;2차 배열은 int[][]  arr = new int[2][3]와 같이 선언하고 생성한다. 그리고 arr[1][2]와 같이 사용하는데 먼저 행 번호를 찾고 그 다음에 열 번호를 찾으면 된다.<br/>
&ensp;2차 배열의 사용법은 []가 하나 추가되는 것을 제외하고는 앞서본 1차우너 배열과 같다.<br/>

&ensp;arr[행][열], arr[row][column]<br/>

&ensp;그림의 2차원 배열 데이터<br/>
* arr[0][0]: 1
* arr[0][1]: 2
* arr[0][2]: 3
* arr[1][0]: 4
* arr[1][1]: 5
* arr[1][2]: 6

```java
public class ArrayDi0 {
    public static void main(String[] args) {
        // 2x3 2차원 배열을 만든다.
        int[][] arr = new int[2][3]; //행(row), 열(column)

        arr[0][0] = 1; //0행, 0열
        arr[0][1] = 2; //0행, 1열
        arr[0][2] = 3; //0행, 2열
        arr[1][0] = 4; //1행, 0열
        arr[1][1] = 5; //1행, 1열
        arr[1][2] = 6; //1행, 2열

        //0행 출력
        System.out.print(arr[0][0] + " "); //0열 출력
        System.out.print(arr[0][1] + " "); //1열 출력
        System.out.print(arr[0][2] + " "); //2열 출력
        System.out.println(); //한 행이 끝나면 라인을 변경한다.

        //1행 출력
        System.out.print(arr[1][0] + " "); //0열 출력
        System.out.print(arr[1][1] + " "); //1열 출력
        System.out.print(arr[1][2] + " "); //2열 출력
        System.out.println(); //한 행이 끝나면 라인을 변경한다.
    }
 }
```

* 이 코드는 2차원 배열을 만들고 배열에 값을 1부터 6까지 순서대로 직접 입력한다.
* 다음과 같은 결과를 만들기 위해 0행에 있는 0,1,2열을 출력한다. 그리고 다음으로 1행에 있는 0,1,2열을 출력한다.

<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-7.png" width="600"></p>

2차원 배열-리펙토링
======

구조 개선- 행 출력 반복
------

&ensp;구조 변경<br/>
&ensp;코드 구조를 보면 비슷한 부분이 반복된다.<br/>

```java
//0행 출력
System.out.print(arr[0][0] + " "); //0열 출력
System.out.print(arr[0][1] + " "); //1열 출력
System.out.print(arr[0][2] + " "); //2열 출력
System.out.println(); //한 행이 끝나면 라인을 변경한다.

 //1행 출력
System.out.print(arr[1][0] + " "); //0열 출력
System.out.print(arr[1][1] + " "); //1열 출력
System.out.print(arr[1][2] + " "); //2열 출력
System.out.println(); //한 행이 끝나면 라인을 변경한다.
```

&ensp;코드를 보면 행을 출력하는 부분이 거의 같다. 차이가 있는 부분은 행에서 arr[0]으로 시작할지 arr[1]로 시작할지의 차이다.<br/>

&ensp;다음과 같이 행(row)에 들어가는 숫자만 하나씩 증가하면서 반복하면 될 것 같다.<br/>

```java
//row를 0, 1로 변경하면서 다음 코드를 반복
System.out.print(arr[row][0] + " "); //0열 출력
System.out.print(arr[row][1] + " "); //1열 출력
System.out.print(arr[row][2] + " "); //2열 출력
System.out.println(); //한 행이 끝나면 라인을 변경한다.
```

```java
public class ArrayDi1 {
    public static void main(String[] args) {
        // 2x3 2차원 배열을 만듭니다.
        int[][] arr = new int[2][3]; //행(row), 열(column)

        arr[0][0] = 1; //0행, 0열
        arr[0][1] = 2; //0행, 1열
        arr[0][2] = 3; //0행, 2열
        arr[1][0] = 4; //1행, 0열
        arr[1][1] = 5; //1행, 1열
        arr[1][2] = 6; //1행, 2열

        for (int row = 0; row < 2; row++) {
            System.out.print(arr[row][0] + " "); //0열 출력
            System.out.print(arr[row][1] + " "); //1열 출력
            System.out.print(arr[row][2] + " "); //2열 출력
            System.out.println(); //한 행이 끝나면 라인을 변경한다.
        }
    }
 }
```

* for문을 통해서 행(row)을 반복해서 접근한다. 각 행 안에서 열(column)이 3개이므로 arr[row][0], arr[row][1], arr[row][2] 3변 출력한다. 이렇게하면 for문을 한 번 도는 동안 3개의 열을 출력할 수 있다.
    - row = 0 의 for문이 실행되면 arr[0][0], arr[0][1], arr[0][2]로 1 2 3 이 출력된다.
    - row = 1 의 for문이 실행되면 arr[1][0], arr[1][1], arr[1][2]로 4 5 6이 출력된다.

<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-8.png" width="600"></p>

구조 개선 - 열 출력 반복
------

&ensp;다음 부분을 보면 같은 코드가 반복된다.<br/>

```java
System.out.print(arr[row][0] + " "); //0열 출력
System.out.print(arr[row][1] + " "); //1열 출력
System.out.print(arr[row][2] + " "); //2열 출력
```

&ensp;다음과 같이 열(column)에 들어가는 숫자만 하나씩 증가하면서 반복하면 될 것 같다.<br/>

```java
//column를 0, 1, 2로 변경하면서 다음 코드를 반복
System.out.print(arr[row][column] + " "); //column열 출력
```

```java
public class ArrayDi2 {
    public static void main(String[] args) {
        // 2x3 2차원 배열을 만듭니다.
        int[][] arr = new int[2][3]; //행(row), 열(column)

        arr[0][0] = 1; //0행, 0열
        arr[0][1] = 2; //0행, 1열
        arr[0][2] = 3; //0행, 2열
        arr[1][0] = 4; //1행, 0열
        arr[1][1] = 5; //1행, 1열
        arr[1][2] = 6; //1행, 2열

        for (int row = 0; row < 2; row++) {
            for (int column = 0; column < 3; column++) {
                System.out.print(arr[row][column] + " ");
            }
            System.out.println(); //한 행이 끝나면 라인을 변경한다.
        }
    }
 }
```

* for문을 2번 중첩해서 사용하는데, 첫번째 for문은 행을 탐색하고, 내부에 있는 두번째 for문은 열을 탐색한다.
* 내부에 있는 for문은 앞서 작성한 다음 코드와 같다. for문을 사용해서 열을 효과적으로 출력했다.

```java
System.out.print(arr[row][0] + " "); //0열 출력
System.out.print(arr[row][1] + " "); //1열 출력
System.out.print(arr[row][2] + " "); //2열 출력
```

구조 개선-초기화, 배열의 길이
------

&ensp;위 코드에서 2가지 개선할 부분이 있다.<br/>
1. 초기화: 기존 배열처럼 2차원 배열도 편리하게 초기화 할 수 있다.
2. for문에서 배열의 길이 활용: 배열의 길이가 달라지면 for문에서 row < 2, column < 3 같은 부분을 같이 변경해야 한다. 이 부분을 배열의 길이를 사용하도록 변경해보자. 배열이 커지거나 줄어들어도 for문의 코드를 변경하지 않고 그대로 유지할 수 있다.

```java
public class ArrayDi3 {
    public static void main(String[] args) {
        // 2x3 2차원 배열, 초기화
        int[][] arr = {
            {1, 2, 3},
            {4, 5, 6}
        };

        // 2차원 배열의 길이를 활용
        for (int row = 0; row < arr.length; row++) {
            for (int column = 0; column < arr[row].length; column++) {
                System.out.print(arr[row][column] + " ");
            }
            System.out.println();
        }
    }
 }
```

&ensp;배열의 길이<br/>
<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-9.png" width="600"></p>

&ensp;for문에서 2차원 배열의 길이를 활용했다.<br/>
* arr.length는 행의 길이를 뜻한다. 여기서는 2가 출력된다.
    - {{}, {}}를 생각해보면 arr배열은 {}, {} 2개의 배열 요소를 가진다.
* arr[row].length는 열의 길이를 뜻한다. 여기서는 3이 출력된다.
    - arr[0]은 {1, 2, 3} 배열을 뜻한다. 이 배열에는 3개의 요소가 있다.
    - arr[1]은 {4, 5, 6} 배열을 뜻한다. 이 배열에는 3개의 요소가 있다.

구조 개선-값 입력
------

&ensp;이번에는 배열에 직접 1,2,3 숫자를 적어서 값을 할당하는 것이 아니라, 배열의 크기와 상관없이 배열에 순서대로 1씩 증가하는 값을 입력하도록 변경해보자.<br/>

```java
public class ArrayDi4 {
    public static void main(String[] args) {
        // 2x3 2차원 배열, 초기화
        int[][] arr = new int[2][3];

        int i = 1;
        // 순서대로 1씩 증가하는 값을 입력한다.
        for (int row = 0; row < arr.length; row++) {
            for (int column = 0; column < arr[row].length; column++) {
                arr[row][column] = i++;
            }
        }

        // 2차원 배열의 길이를 활용
        for (int row = 0; row < arr.length; row++) {
            for (int column = 0; column < arr[row].length; column++) {
                System.out.print(arr[row][column] + " ");
            }
            System.out.println();
        }
    }
 }
```

* 중첩된 for문을 사용해서 값을 순서대로 입력한다.
* arr[row][column] = i++ 후의 증감 연산자(++)를 사용해서 값을 먼저 대입한 다음에 증가한다.

&ensp;2차원 배열 선언 부분인 new int[2][3]을 new int[4][5] 처럼 다른 숫자로 변경해도 잘 동작하는 것을 확인할 수 있다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/8. 배열/8-10.png" width="600"></p>

향상된 for문
======

&ensp;앞서 반복문에서 설명하지 않은 내용이 하나 있는데, 바로 향상된 for문(Enhanced For Loop)이다. 향상된 for문을 이해하려면 배열을 먼저 알아야 한다. 각각의 요소를 탐색한다는 의미로 for-each문이라고도 많이 부른다. 향상된 for문은 배열을 사용할 때 기존 for문보다 더 편리하게 사용할 수 있다.<br/>

&ensp;향상된 for문 정의<br/>

```java
for (변수 : 배열 또는 컬렉션) {
 // 배열 또는 컬렉션의 요소를 순회하면서 수행할 작업
}
```

```java
public class EnhancedFor1 {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        //일반 for문
        for(int i = 0; i < numbers.length; ++i) {
            int number = numbers[i];
            System.out.println(number);
        }

        //향상된 for문, for-each문
        for (int number : numbers) {
            System.out.println(number);
        }

        //for-each문을 사용할 수 없는 경우, 증가하는 index 값 필요
        for(int i = 0; i < numbers.length; ++i) {
            System.out.println("number" + i + "번의 결과는: " + numbers[i]);
        }
    }
 }
```

&ensp;일반 for문<br/>

```java
 //일반 for문
for(int i = 0; i < numbers.length; ++i) {
    int number = numbers[i];
    System.out.println(number);
}
```

&ensp;먼저 일반 for 문을 살펴보자. 배열에 있는 값을 순선대로 읽어서 number 변수에 넣고 출력한다. 배열은 처음부터 끝까지 순서대로 읽어서 사용하는 경우가 많다. 그런데 배열의 값을 읽으려면 int i 와 같은 인덱스를 탐색할 수 있는 변수를 선언해야 한다. 그리고 i < number.length 와 같이 배열의 끝 조건을 지정해야 한다. 마지막으로 배열의 값을 하나 읽을 때마다 인덱스를 하나씩 증가해야 한다.<br/>

&ensp;향상된 for문<br/>

```java
 //일반 for문
for(int i = 0; i < numbers.length; ++i) {
    int number = numbers[i];
    System.out.println(number);
}
```

* 앞서 일반 for문과 동일하게 작동한다.
* 향상된 for문은 배열의 인덱스를 사용하지 않고, 종료 조건을 주지 않아도 된다. 단순히 해당 배열을 처음부터 끝까지 탐색한다.
* : 의 오른쪽에 numbers와 같이 탐색할 배열을 선택하고 : 의 왼쪽에 int number와 같이 반복할 때마다 찾은 값을 저장할 변수를 선언한다. 그러면 배열의 값을 하나씩 꺼내서 왼쪽에 있는 number 에 담고 for문을 반복 수행한다. numbers 배열의 끝에 도달해서 더 값이 없으면 for문이 완전히 종료된다.
* 향상도니 for문은 배열의 인덱스를 사용하지 않고도 배열의 요소를 순회할 수 있기 때문에 코드가 간결하고 가독성이 좋다.

&ensp;향상된 for문을 사용하지 못하는 경우<br/>
&ensp;향상된 for문을 사용하지 못하는 경우가 있다.<br/>
&ensp;향상된 for문에는 증가하는 인덱스 값이 감추어져 있다. 따라서 int i와 같은 증가하는 인덱스 값을 직접 사용해야 하는 경우에는 향상된 for문을 사용할 수 없다.<br/>

```java
//for-each문을 사용할 수 없는 경우, 증가하는 index 값 필요
for(int i = 0; i < numbers.length; ++i) {
    System.out.println("number" + i + "번의 결과는: " + numbers[i]);
}
```

&ensp;이 예제에서는 증가하는 i값을 출력해야 하므로 향상된 for문 대신에 일반 for문을 사용해야 한다.<br/>
