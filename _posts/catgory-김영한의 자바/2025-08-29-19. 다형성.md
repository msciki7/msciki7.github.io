---
title: "19주차 다형성"
excerpt: ""

wirter: sohee Kim
categories:
  - 김영한의 자바
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-08-29
last_modified_at: 2025-08-30
---

다형성 시작
======

&ensp;객체지향 프로그래밍의 대표적인 특징으로는 캡슐화, 상속, 다형성이 있다. 그 중에서 다형성은 객체지향 프로그래밍의 꽃이라 불린다. 앞서 학습한 캡슐화나 상속은 직관적으로 이해하기 쉽다. 반면에 다형성은 제대로 이해하기도 어렵고, 잘 활용하기는 더 어렵다. 하지만 좋은 개발자가 되기 위해서는 다형성에 대한 이해가 필수다. <br/>
&ensp;다형성(Polymorphism)은 이름 그대로 "다양한 형태", "여러 형태"를 를 뜻한다. 프로그래밍에서 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 뜻한다. 보통 하나의 객체는 하나의 타입으로 고정되어 있다. 그런데 다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있다는 뜻이다.<br/>

* 다형적 참조
* 메서드 오버라이딩

다형적 참조
------

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-1.png" width="600"></p>

&ensp;부모와 자식이 있고, 각각 다른 메서드를 가진다.<br/>

```java
package poly.basic;

public class Parent {

    public void parentMethod() {
        System.out.println("Parent.parentMethod");
    }
}
```

```java
package poly.basic;

public class Child extends Parent {

    public void childMethod() {
        System.out.println("Child.childMethod");
    }
}
```

```java
package poly.basic;

 /**
 * 다형적 참조: 부모는 자식을 품을 수 있다.
 */

public class PolyMain {
    public static void main(String[] args) {
        //부모 변수가 부모 인스턴스 참조
        System.out.println("Parent -> Parent");
        Parent parent = new Parent();
        parent.parentMethod();

        //자식 변수가 자식 인스턴스 참조
        System.out.println("Child -> Child");
        Child child = new Child();
        child.parentMethod();
        child.childMethod();

        //부모 변수가 자식 인스턴스 참조(다형적 참조)
        System.out.println("Parent -> Child");
        Parent poly = new Child();
        poly.parentMethod();

        //Child child1 = new Parent(); 자식은 부모를 담을 수 없다.

        //자식의 기능은 호출할 수 없다. 컴파일 오류 발생
        //poly.childMethod();
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-2.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-3.png" width="600"></p>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-4.png" width="600"></p>

* 부모 타입의 변수가 부모 인스턴스를 참조한다.
* Parent parent = new Parent()
* Parent 인스턴스를 만들었다. 이 경우 부모 타입인 Parent를 생성했기 때문에 메모리 상에 Parent만 생성된다.(자식은 생성되지 않는다.)
* 생성된 참조값을 Parent타입의 변수의 parent에 담아둔다.
* parent.parentMethod()를 호출하면 인스턴스의 Parent 클래스에 있는 parentMethod()가 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-5.png" width="600"></p>

* 자식 타입의 변수가 자식 인스턴스를 참조한다.
* Child child = new Child()
* Child 인스턴스를 만들었다. 이 경우 자식 타입인 Child를 생성했기 때문에 메모리 상에 Child와 Parent가 모두 생성된다.
* 생성된 참조값을 Child 타입의 변수인 child에 담아둔다.
* child.childMethod()를 호출하면 인스턴스의 Child 클래스에 있는 childMethod()가 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-6.png" width="600"></p>

* 부모 타입의 변수가 자식 인스턴스를 참조한다.
* Parent poly = new Child()
* Child 인스턴스를 만들었다. 이 경우 자식 타입인 Child를 생성했기 때문에 메모리 상에 Chiild와 Parent가 모두 생성된다.
* 생성된 참조값을 Parent 타입의 변수인 poly에 담아둔다.

&ensp;부모는 자식을 담을 수 있다.<br/>
* 부모 타입은 자식 타입을 담을 수 있다.
* Parent poly는 부모 타입이다. new Child()를 통해 생성된 결과는 Child 타입이다. 자바에서 부모 타입은 자식 타입을 담을 수 있다.
    - Parent poly = new Child(): 성공
* 반대로 자식 타입은 부모 타입을 담을 수 없다.
    - Child child1 = new Parent(): 컴파일 오류 발생

&ensp;다형적 참조<br/>
&ensp;지금까지 학습한 내용을 떠올려보면 항상 같은 타입에 참조를 대입했다. 그래서 보통 한 가지 형태만 참조할 수 있다.<br/>
* Parent parent = new Parent()
* Child child =  new Child()

&ensp;그런데 Parent 타입의 변수는 다음과 같이 자신인 Parent는 물론이고 자식 타입까지 참조할 수 있다. 만약 손자가 있다면 손자도 그 하위 타입도 참조할 수 있다.<br/>

* Parent poly = new Parent()
* Parent poly = new Child()
* Parent poly = new Grandson(): Child 하위에 손자가 있다면 가능

&ensp;자바에서 부모 타입은 자신은 물론이고, 자신을 기준으로 모든 자식 타입을 참조할 수 있다. 이것이 바로 다양한 형태를 참조할 수 있다고 해서 다형적 참조라 한다.<br/>

다형적 참조와 인스턴스 실행
------

&ensp;poly.parentMethod()를 호출하면 먼저 참조값을 사용해서 인스턴스를 찾는다. 그리고 다음으로 인스턴스 안에서 실행할 타입도 찾아야 한다. poly는 Parent타입이다. 따라서 Parent 클래스부터 시작해서 필요한 기능을 찾는다. 인스턴스의 Parent 클래스에 parentMethod()가 있다. 따라서 해당 메서드가 호출된다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-7.png" width="600"></p>

&ensp;Parent poly = new Child() 이렇게 자식을 참조한 상황에서 poly가 자식 타입인 Child에 있는 childMethod()를 호출하면 어떻게 될까?<br/>
&ensp;poly.childMethod()를 실행하면 먼저 참조값을 통해 인스턴스를 찾는다. 그리고 다음으로 인스턴스 안에서 실행할 타입을 찾아야 한다. 호출자인 poly는 Parent 타입이다. 따라서 Parent 클래스부터 시작해서 필요한 기능 찾는다. 그런데 상속 관계는 부모 방향으로 찾아 올라갈 수는 있지만 자식 방향으로 찾아 내려갈 수는 없다. Parent는 부모 타입이고 상위에 부모가 없다. 따라서 childMethod()를 찾을 수 없으므로 컴파일 오류가 발생한다.<br/>

&ensp;이런 경우 childMethod()를 호출하고 싶으면 어떻게 해야할까? 바로 캐스팅이 필요하다.<br/>

&ensp;다형적 참조의 핵심은 부모는 자식을 품을 수 있다는 것이다.<br/>
&ensp;그런데 이런 다형적 참조가 왜 필요하지? 라는 의문이 들 수 있다. 이 부분은 다형성의 다른 이론들도 함께 알아야 이해할 수 있다.<br/>

다형성과 캐스팅
======

&ensp;Parent poly = new Child()와 같이 부모 타입의 변수를 사용하게 되면 poly.childMethod()와 같이 자식 타입에 있는 기능은 호출할 수 없다.<br/>

```java
package poly.basic;

public class CastingMain1 {
    public static void main(String[] args) {
        //부모 변수가 자식 인스턴스 참조(다형적 참조)
        Parent poly = new Child();
        //단 자식의 기능은 호출할 수 없다. 컴파일 오류 발생
        //poly.childMethod();

        //다운캐스팅(부모 타입 -> 자식 타입)
        Child child = (Child) poly;
        child.childMethod();
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-8.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-9.png" width="600"></p>

* poly.childMethod()를 호출하면 먼저 참조값을 사용해서 인스턴스를 찾는다.
* 인스턴스 안에서 사용할 타입을 찾아야 한다. poly는 Parent타입이다.
* Parent는 최상위 부모이다. 상속 관계는 부모로만 찾아서 올라갈 수 있다. childMethod()는 자식 타입에 있으므로 호출할 수 없다. 따라서 컴파일 오류가 발생한다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-10.png" width="600"></p>

&ensp;이럴때는 어떻게 하면 될까? 호출하는 타입을 자식인 Child 타입으로 변경하면 인스턴스의 Child에 있는 childMethod()를 호출할 수 있다. 하지만 다음과 같은 문제에 봉착한다.<br/>

&ensp;부모는 자식을 담을 수 있지만 자식은 부모를 담을 수 없다.<br/>
* Parent parent = new Child(): 부모는 자식을 담을 수 있다.
* Parent parent = child //Child child 변수: 부모는 자식을 담을 수 있다.

&ensp;반면에 다음과 같이 자식은 부모를 담을 수 없다.<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-11.png" width="600"></p>

&ensp;부모 타입을 사용하는 변수를 자식 타입에 대입하려고 하면 컴파일 오류가 발생한다. 자식은 부모를 담을 수 없다. 이때는 다운캐스팅이라는 기능을 사용해서 부모 타입을 잠깐 자식 타입으로 변경하면 된다.<br/>

&ensp;다음 코드를 분석해보자.<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-12.png" width="600"></p>

&ensp;(타입)처럼 괄호와 그 사이에 타입을 지정하면 참조 대상을 특정 타입으로 변경할 수 있다. 이렇게 특정 타입으로 변경하는 것을 캐스팅이라 한다. 오른쪽에 있는 (Child) poly 코드를 먼저 보자. poly는 Parent 타입이다. 이 타입을 (Child)를 사용해서 일시적으로 자식 타입인 Child타입으로 변경한다. 그리고 나서 왼쪽에 있는 Child child에 대입한다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-13.png" width="600"></p>

&ensp;참고로 캐스팅을 한다고 해서 Parent poly의 타입이 변하는 것은 아니다. 해당 참조값을 꺼내고 꺼낸 참조값이 Child 타입이 되는 것이다. 따라서 poly의 타입은 Parent로 기존과 같이 유지된다.<br/>

&ensp;캐스팅<br/>
* 업캐스팅(upcasting): 부모 타입으로 변경
* 다운캐스팅(downcasting): 자식 타입으로 변경

캐스팅 용어
------

&ensp;"캐스팅"은 영어 단어 "cast"에서 유래되었다. "cast"는 금속이나 다른 물질을 녹여서 특정한 형태나 모양으로 만드는 과정을 의미한다. Child child = (Child) poly 경우 Parent poly라는 부모 타입을 Child라는 자식 타입으로 변경했다. 부모 타입을 자식 타입으로 변경하는 것을 다운캐스팅이라 한다. 반대로 부모 타입으로 변경하는 것은 업캐스팅이라 한다.<br/>

&ensp;다운캐스팅과 실행<br/>
```java
//다운캐스팅(부모 타입 -> 자식 타입)
Child child = (Child) poly;
child.childMethod();
```

&ensp;다운캐스팅 덕분에 child.childMethod()를 호출할 수 있게 되었다. childMethod()를 호출하기 위해 해당 인스턴스를 찾아간 다음 Child 타입을 찾는다. Child 타입에는 childMethod()가 있으므로 해당 기능을 호출할 수 있다. <br/>

캐스팅의 종류
------

&ensp;자식 타입의 기능을 사용하려면 다음과 같이 다운캐스팅 결과를 변수에 담아두고 이후에 기능을 사용하면 된다.<br/>
```java
Child child = (Child) poly
child.childMethod();
```

&ensp;하지만 다운캐스팅 결과를 변수에 담아두는 과정이 번거롭다. 이런 과정 없이 일시적으로 다운캐스팅을 해서 인스턴스에 있는 하위 클래스의 기능을 바로 호출할 수 있다.<br/>

&ensp;일시적 다운 캐스팅<br/>
```java
 package poly.basic;

public class CastingMain2 {

    public static void main(String[] args) {
        //부모 변수가 자식 인스턴스 참조(다형적 참조)
        Parent poly = new Child();
        //단 자식의 기능은 호출할 수 없다. 컴파일 오류 발생
        //poly.childMethod();

        //일시적 다운캐스팅 - 해당 메서드를 호출하는 순간만 다운캐스팅
        ((Child) poly).childMethod();
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-14.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-15.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-16.png" width="600"></p>

&ensp;poly는 Parent타입이다. 그런데 이 코드를 실행하면 Parent 타입을 임시로 Child로 변경한다. 그리고 메서드를 호출할 때 Child 타입에서 찾아서 실행한다.<br/>

&ensp;정확히는 poly가 Child타입으로 바뀌는 것은 아니다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-17.png" width="600"></p>

&ensp;참고로 캐스팅을 한다고 해서 Parent poly의 타입이 변하는 것은 아니다. 해당 참조값을 꺼내고 꺼낸 참조값이 Child 타입이 되는 것이다. 따라서 poly의 타입은 Parent로 그대로 유지된다.<br/>

&ensp;이렇게 일시적 다운캐스팅을 사용하면 별도의 변수 없이 인스턴스의 자식 타입의 기능을 사용할 수 있다.<br/>

업캐스팅
-----

&ensp;다운캐스팅과 반대로 현재 타입을 부모 타입으로 변경하는 것을 업캐스팅이라 한다.<br/>

```java
package poly.basic;

//upcasting vs downcasting
public class CastingMain3 {

    public static void main(String[] args) {
        Child child = new Child();
        Parent parent1 = (Parent) child; //업캐스팅은 생략 가능, 생략 권장
        Parent parent2 = child; //업캐스팅 생략

        parent1.parentMethod();
        parent2.parentMethod();
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-18.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-19.png" width="600"></p>

&ensp;Child타입을 Parent 타입에 대입해야 한다. 따라서 타입을 변환하는 캐스팅이 필요하다.<br/>
&ensp;그런데 부모 타입으로 변환하는 경우에는 다음과 같이 캐스팅 코드인 (타입)를 생략할 수 있다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-20.png" width="600"></p>

&ensp;업캐스팅은 생략할 수 있다. 다운캐스팅은 생략할 수 없다. 참고로 업캐스팅은 매우 자주 사용하기 때문에 생략을 권장한다.<br/>
&ensp;자바에서 부모는 자식을 담을 수 있다. 하지만 그 반대는 안된다. (꼭 필요하다면 다운캐스팅을 해야 한다.)<br/>
&ensp;업캐스팅은 생략해도 되고, 다운캐스팅은 왜 개발자가 직접 명시적으로 캐스팅을 해야할까?<br/>

다운캐스팅과 주의점
------

&ensp;다운캐스팅은 잘못하면 심각한 런타임 오류가 발생할 수 있다.<br/>

```java
package poly.basic;

//다운캐스팅을 자동으로 하지 않는 이유
public class CastingMain4 {
    public static void main(String[] args) {
        Parent parent1 = new Child();
        Child child1 = (Child) parent1;
        child1.childMethod(); //문제 없음

        Parent parent2 = new Parent();
        Child child2 = (Child) parent2; //런타임 오류 - ClassCastException
        child2.childMethod(); //실행 불가
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-21.png" width="600"></p>

&ensp;실행 결과를 보면 child1.childMethod()는 잘 호출되었지만, child2.childMethod()는 실행되지 못하고 그 전에 오류가 발생했다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-22.png" width="600"></p>

&ensp;예제의 parent1의 경우 다운캐스팅을 해도 문제가 되지 않는다.<br/>

다운캐스팅이 불가능한 경우
-------

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-23.png" width="600"></p>

&ensp;예제의 parent2를 다운캐스팅하면 ClassCastException이라는 심각한 런타입 오류가 발생한다.<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-24.png" width="600"></p>

&ensp;먼저 new Parent()로 부모 타입으로 객체를 생성한다. 따라서 메모리 상에 자식 타입은 전혀 존재하지 않는다. 생성 결과를 parent2에 담아둔다. 이 경우 같은 타입이므로 여기서는 문제가 발생하지 않는다.<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-25.png" width="600"></p>

&ensp;다음으로 parent2를 Child타입으로 다운캐스팅한다. 그런데 parent2는 Parent로 생성이 되었다. 따라서 메모리 상에 Child 자체가 존재하지 않는다. Child 자체를 사용할 수 없는 것이다.<br/>
&ensp;자바에서는 이렇게 사용할 수 없는 타입으로 다운캐스팅하는 경우에 ClassCastException이라는 예외를 발생시킨다. 예외가 발생하면 다음 동작이 실행되지 않고 프로그램이 종료된다. 따라서 child2.childMethod() 코드 자체가 실행되지 않는다.<br/>

업캐스팅이 안전하고 다운캐스팅이 위험한 이유
-------

&ensp;업캐스팅의 경우 이런 문제가 절대로 발생하지 않는다. 왜냐하면 객체를 생성하면 해당 타입의 상위 부모 타입은 모두 함께 생성된다! 따라서 위로만 타입을 변경하는 업캐스팅은 메모리 상에 인스턴스가 모두 존재하기 때문에 항상 안전하다. 따라서 캐스팅을 생략할 수 있다. <br/>
&ensp;반면에 다운캐스팅의 경우 인스턴스에 존재하지 않는 하위 타입으로 캐스팅하는 문제가 발생할 수 있다. 왜냐하면 객체를 생성하면 부모 타입은 모두 함께 생성되지만 자식 타입은 생성되지 않는다. 따라서 개발자가 이런 문제를 인지하고 사용해야 한다는 의미로 명시적으로 캐스팅을 해주어야 한다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-26.png" width="600"></p>

&ensp;클래스 A, B, C는 상속 관계다.<br/>
&ensp;new C()로 인스턴스를 생성하면 인스턴스 내부에 자신과 부모인 A, B, C가 모두 생성된다. 따라서 C의 부모 타입인 A, B, C 모두 C 인스턴스를 참조할 수 있다. 상위로 올라가는 업케스팅은 인스턴스 내부에 부모가 모두 생성되기 때문에 문제가 발생하지 않는다.<br/>
* A a = new C(): A로 업케스팅
* B b = new C(): B로 업케스팅
* C c = new C(): 자신과 같은 타입

&ensp;그림으로 설명 - 다운케스팅<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-27.png" width="600"></p>

&ensp;new B()로 인스턴스를 생성하면 인스턴스 내부에 자신과 부모인 A, B가 생성된다. 따라서 B의 부모 타입인 A, B 모두 B 인스턴스를 참조할 수 있다. 상위로 올라가는 업케스팅은 인스턴스 내부에 부모가 모두 생성되기 때문에 문제가 발생하지 않는다. 하지만 객체를 생성할 때 하위 자식은 생성되지 않기 때문에 하위로 내려가는 다운케스팅은 인스턴스 내부에 없는 부분을 선택하는 문제가 발생할 수 있다.<br/>

&ensp;컴파일 오류 vs 런타임 오류<br/>
&ensp;컴파일 오류는 변수명 오타, 잘못된 클래스 이름 사용등 자바 프로그램을 실행하기 전에 발생하는 오류이다. 이런 오류는 IDE에서 즉시 확인할 수 있기 때문에 안전하고 좋은 오류이다. 반면에 런타임 오류는 이름 그대로 프로그램이 실행되고 있는 시점에 발생하는 오류이다. 런타임 오류는 매우 안좋은 오류이다. 왜냐하면 보통 고객이 해당 프로그램을 실행하는 도중에 발생하기 때문이다.<br/>

instanceof
======

&ensp;다형성에서 참조형 변수는 이름 그대로 다양한 자식을 대상으로 참조할 수 있다. 그런데 참조하는 대상이 다양하기 때문에 어떤 인스턴스를 참조하고 있는지 확인하려면 어떻게 해야할까?<br/>

```java
Parent parent1 = new Parent()
Parent parent2 = new Child()
```

&ensp;여기서 Parent는 자신과 같은 Parent의 인스턴스도 참조할 수 있고 자식 타입인 Child의 인스턴스도 참조할 수 있다. 이때 parent1, parent2 변수가 참조하는 인스턴스의 타입을 확인하고 싶다면 instanceof키워드를 사용하면 된다.<br/>

```java
package poly.basic;

public class CastingMain5 {

     public static void main(String[] args) {
        Parent parent1 = new Parent();
        System.out.println("parent1 호출");
        call(parent1);

        Parent parent2 = new Child();
        System.out.println("parent2 호출");
        call(parent2);
    }

    private static void call(Parent parent) {
        parent.parentMethod();
        if (parent instanceof Child) {
            System.out.println("Child 인스턴스 맞음");
            Child child = (Child) parent;
            child.childMethod();
        }
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-28.png" width="600"></p>

&ensp;call(Parent parent)메서드를 보자<br/>
&ensp;이 메서드는 매개변수로 넘어온 parent가 참조하는 타입에 따라서 다른 명령을 수행한다. 참고로 지금처럼 다운캐스팅을 수행하기 전에는 먼저 instanceof를 사용해서 원하는 타입으로 변경이 가능한지 확인한 다음에 다운캐스팅을 수행하는 것이 안전하다.<br/>

&ensp;해당 메서드를 처음 호출할 때 parent는 Parent의 인스턴스를 참조한다.<br/>
```java
parent instanceof Child //parent는 Parent의 인스턴스
new Parent() instanceof Child //false
```

&ensp;parent는 Parent의 인스턴스를 참조하므로 false를 반환한다.<br/>
&ensp;해당 메서드를 다음으로 호출할 때 parent는 Child의 인스턴스를 참조한다.<br/>

```java
parent instanceof Child //parent는 Child의 인스턴스
new Child() instanceof Child //true
```

&ensp;parent는 Child의 인스턴스를 참조하므로 true를 반환한다.<br/>
&ensp;참고로 instanceof키워드는 오른쪽 대상의 자식 타입을 왼쪽에서 참조하는 경우에도 true를 반환한다.<br/>

```java
parent instanceof Parent //parent는 Child의 인스턴스

new Parent() instanceof Parent //parent가 Parent의 인스턴스를 참조하는 경우: true
new Child() instanceof Parent //parent가 Child의 인스턴스를 참조하는 경우: true
```

&ensp;쉽게 이야기해서 오른쪽에 있는 타입에 왼쪽에 있는 인스턴스의 타입이 들어갈 수 있는지 대입해보면 된다. 대입이 가능하면 true, 불가능하면 false가 된다.<br/>

```java
new Parent() instanceof Parent
Parent p = new Parent() //같은 타입 true

new Child() instanceof Parent
Parent p = new Child() //부모는 자식을 담을 수 있다. true

new Parent() instanceof Child
Child c = new Parent() //자식은 부모를 담을 수 없다. false

new Child() instanceof Child
Child c = new Child() //같은 타입 true
```

자바 16 - Pattern Matching for instanceof
------

&ensp;자바 16부터는 instanceof를 사용하면서 동시에 변수를 선언할 수 있다.<br/>

```java
package poly.basic;

public class CastingMain6 {

    public static void main(String[] args) {
        Parent parent1 = new Parent();
        System.out.println("parent1 호출");
        call(parent1);

        Parent parent2 = new Child();
        System.out.println("parent2 호출");
        call(parent2);
    }

    private static void call(Parent parent) {
        parent.parentMethod();
        //Child 인스턴스인 경우 childMethod() 실행
        if (parent instanceof Child child) {
            System.out.println("Child 인스턴스 맞음");
            child.childMethod();
        }
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-29.png" width="600"></p>

&ensp;덕분에 인스턴스가 맞는 경우 직접 다운캐스팅 하는 코드를 생략할 수 있다.<br/>

다형성과 메서드 오버라이딩
=======

&ensp;다형성을 이루는 또 하나의 중요한 핵심 이론은 바로 메서드 오버라이딩이다.
메서드 오버라이딩에서 꼭! 기억해야 할 점은 오버라이딩 된 메서드가 항상 우선권을 가진다.는 점이다. 그래서  이름도 기존 기능을 덮어 새로운 기능을 재정의 한다는 뜻의 오버라이딩이다.<br/>
&ensp;앞서 메서드 오버라이딩을 학습했지만 지금까지 학습한 메서드 오버라이딩은 반쪽짜리다. 메서드 오버라이딩의 진짜 힘은 다형성과 함께 사용할 때 나타난다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-30.png" width="600"></p>

* Parent, Child 모두 value라는 같은 멤버 변수를 가지고 있다.
    - 멤버 변수는 오버라이딩 되지 않는다.
* Parent, Child 모두 method() 라는 같은 메서드를 가지고 있다. Child에서 메서드를 오버라이딩 했다.
    - 메서드는 오버라이딩 된다.

```java
package poly.overriding;

 public class Parent {

    public String value = "parent";
        public void method() {
        System.out.println("Parent.method");
    }
}
```

```java
package poly.overriding;

public class Child extends Parent {

    public String value = "child";

    @Override
    public void method() {
        System.out.println("Child.method");
    }
}
```

* Child에서 Parent의 method()를 재정의(오버라이딩)했다.

```java
package poly.overriding;

public class OverridingMain {

    public static void main(String[] args) {

        //자식 변수가 자식 인스턴스 참조
        Child child = new Child();
        System.out.println("Child -> Child");
        System.out.println("value = " + child.value);
        child.method();

        //부모 변수가 부모 인스턴스 참조
        Parent parent = new Parent();
        System.out.println("Parent -> Parent");
        System.out.println("value = " + parent.value);
        parent.method();

        //부모 변수가 자식 인스턴스 참조(다형적 참조)
        Parent poly = new Child();
        System.out.println("Parent -> Child");
        System.out.println("value = " + poly.value); //변수는 오버라이딩X
        poly.method(); //메서드 오버라이딩!
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-31.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-32.png" width="600"></p>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-33.png" width="600"></p>

* child변수는 Child 타입이다. 따라서 child.value, child.method()를 호출하면 인스턴스의 Child 타입에서 기능을 찾아서 실행한다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-34.png" width="600"></p>

* parent변수는 Parent타입이다. 따라서 parent.value, parent.method()를 호출하면 인스턴스의 Parent 타입에서 기능을 찾아서 실행한다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-35.png" width="600"></p>

* poly변수는 Parent타입이다. 따라서 poly.value, poly.method()를 호출하면 인스턴스의 Parent 타입에서 기능을 찾아서 실행한다.
    - poly.value: Parent타입에 있는 value값을 읽는다.
    - poly.method(): Parent타입에 있는 method()를 실행하려고 한다. 그런데 하위 타입인 Child.method()가 오버라이딩 되어 있다. 오버라이딩 된 메서드는 항상 우선권을 가진다. 따라서 Parent.method()가 아니라 Child.method()가 실행된다.

&ensp;**오버라이딩된 메서드는 항상 우선권을 가진다.** 오버라이딩은 부모 타입에서 정의한 기능을 자식 타입에서 재정의하는 것이다. 만약 자식에서도 오버라이딩 하고 손자에서도 같은 메서드를 오버라이딩을 하면 손자의 오버라이딩 메서드가 우선권을 가진다. 더 하위 자식의 오버라이딩 된 메서드가 우선권을 가지는 것이다.<br/>
&ensp;지금까지 다형성을 이루는 핵심 이론인 다형적 참조와 메서드 오버라이딩에 대해 학습했다.<br/>
* 다형적 참조: 하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능
* 메서드 오버라이딩: 기존 기능을 하위 타입에서 새로운 기능으로 재정의

다형성 활용
======

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-36.png" width="600"></p>

&ensp;개, 고양이, 소의 울음 소리를 테스트하는 프로그램을 작성해보자. 먼저 다형성을 사용하지 않고 코드를 작성해보자.<br/>

```java
package poly.ex1;

public class Dog {
    public void sound() {
        System.out.println("멍멍");
    }
}
```

```java
package poly.ex1;

public class Cat {
    public void sound() {
        System.out.println("냐옹");
    }
}
```

```java
package poly.ex1;

public class Cow {
    public void sound() {
        System.out.println("음매");
    }
}
```

```java
package poly.ex1;

public class AnimalSoundMain {

    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();
        Cow cow = new Cow();

        System.out.println("동물 소리 테스트 시작");
        dog.sound();
        System.out.println("동물 소리 테스트 종료");

        System.out.println("동물 소리 테스트 시작");
        cat.sound();
        System.out.println("동물 소리 테스트 종료");

        System.out.println("동물 소리 테스트 시작");
        cow.sound();
        System.out.println("동물 소리 테스트 종료");
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-37.png" width="600"></p>

&ensp;단순히 개, 고양이,  소 동물들의 울음 소리를 출력하는 프로그램이다. 만약 여기서 새로운 동물이 추가되면 어떻게 될까?<br/>
&ensp;만약 기존 코드에 소가 없었다고 가정해보자, 소가 추가된다고 가정하면 Cow클래스를 만들고 다음 코드도 추가해야 한다.<br/>

```java
//Cow를 생성하는 코드
Cow cow = new Cow();
//Cow를 사용하는 코드
System.out.println("동물 소리 테스트 시작");
cow.sound();
System.out.println("동물 소리 테스트 종료");
```

&ensp;Cow를 생성하는 부분은 당연히 필요하니 크게 상관이 없지만 Dog, Cat, Cow를 사용해서 출력하는 부분은 계속 중복을 증가한다.<br/>

&ensp;중복코드<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-38.png" width="600"></p>

&ensp;이 부분의 중복을 제거할 수 있을까?<br/>

&ensp;중복을 제거하기 위해서는 메서드를 사용하거나 또는 배열과 for문을 사용하면 된다. 그런데 Dog, Cat, Cow는 서로 완전히 다른 클래스다.<br/>

&ensp;중복 제거 시도<br/>
&ensp;메서드를 사용하면 다음과 같이 매개변수의 클래스를 Cow, Dog, Cat 중에 하나로 정해야 한다.<br/>
```java
private static void soundCow(Cow cow) {
    System.out.println("동물 소리 테스트 시작");
    cow.sound();
    System.out.println("동물 소리 테스트 종료");
}
```

&ensp;따라서 이 메서드는 Cow전용 메서드가 되고 Dog, Cat은 인수로 사용할 수 없다. Dog, Cat, Cow의 타입(클래스)이 서로 다르기 때문에 soundCow 메서드를 함께 사용하는 것은 불가능하다.<br/>

&ensp;배열과 for문을 통한 중복 제거 시도<br/>
```java
Cow[] cowArr = {cat, dog, cow}; //컴파일 오류 발생!
System.out.println("동물 소리 테스트 시작");
for (Cow cow : cowArr) {
    cowArr.sound();
}
System.out.println("동물 소리 테스트 종료");
```

&ensp;배열과 for문 사용해서 중복을 제거하려고 해도 배열의 타입을 Dog, Cat, Cow 중에 하나로 지정해야 한다. 같은 Cow들을 배열에 담아서 처리하는 것은 가능하지만 타입이 서로 다른 Dog, Cat, Cow을 하나의 배열에 담는 것은 불가능하다.<br/>

&ensp;결과적으로 지금 상황에서는 해결 방법이 없다. 새로운 동물이 추가될 때 마다 더 많은 중복 코드를 작성해야 한다.<br/>

&ensp;지금까지 설명한 모든 중복 제거 시도가 Dog, Cat, Cow의 타입이 서로 다르기 때문에 불가능하다. 문제의 핵심은 바로 타입이 다르다는 점이다. 반대로 이야기하면 Dog, Cat, Cow가 모두 같은 타입ㅇ르 사용할 수 있는 방법이 있다면 메서드와 배열을 활용해서 코드의 중복을 제거할 수 있다는 것이다.<br/>

&ensp;다형성의 핵심은 다형성 참조와 메서드 오버라이딩이다. 이 둘을 활용하면 Dog, Cat, Cow가 모두 같은 타입을 사용하고 각자 자신의 메서드도 호출할 수 있다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-39.png" width="600"></p>

&ensp;다형성을 사용하기 위해 여기서는 상속 관계를 사용한다. Animal(동물)이라는 부모 클래스를 만들고 sound()메서드를 정의한다. 이 메서드는 자식 클래스에서 오버라이딩할 목적으로 만들었다. Dog, Cat, Cow는 Animal 클래스를 상속받았다. 그리고 각각 부모의 sound() 메서드를 오버라이딩한다.<br/>

&ensp;주의 패키지 이름에 주의. import를 사용해서 다른 패키지에 있는 같은 이름의 클래스를 사용하면 안된다.<br/>

```java
package poly.ex2;

public class Animal {

    public void sound() {
        System.out.println("동물 울음 소리");
    }
}
```

```java
 package poly.ex2;

 public class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("멍멍");
    }
}
```

```java
 package poly.ex2;

 public class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("냐옹");
    }
}
```

```java
package poly.ex2;

 public class Cow extends Animal{
    @Override
    public void sound() {
        System.out.println("음매");
    }
 }
```

```java
package poly.ex2;

public class AnimalPolyMain1 {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();
        Cow cow = new Cow();

        soundAnimal(dog);
        soundAnimal(cat);
        soundAnimal(cow);
    }

    //동물이 추가 되어도 변하지 않는 코드
    private static void soundAnimal(Animal animal) {
        System.out.println("동물 소리 테스트 시작");
        animal.sound();
        System.out.println("동물 소리 테스트 종료");
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-40.png" width="600"></p>

* soundAnimal(dog)을 호출하면
* soundAnimal(Animal animal)에 Dog 인스턴스가 전달한다.
    - Animal animal = dog로 이해하면 된다. 부모는 자식을 담을 수 있다. Animal은 Dog의 부모다.
* 메서드 안에서 animal.sound()메서드를 호출한다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-41.png" width="600"></p>

* animal 변수의 타입은 Animal이므로 Dog 인스턴스에 있는 Animal 클래스 부분을 찾아서 sound()메서드 호출을 시도한다. 그런데 하위 클래스인 Dog에서 sound()메서드를 오버라이딩했다. 따라서 오버라이딩한 메서드가 우선권을 가진다. 
* Dog 클래스에 있는 sound()메서드가 호출되므로 "멍멍"이 출력된다.
* 참고로 이때 Animal의 sound()는 실행되지 않는다. (오버라이딩한 메서드가 우선권ㅇ르 가지므로 Dog의 sound()가 실행된다.)

&ensp;이 코드의 핵심은 Animal animal 부분이다.<br/>
* 다형적 참조 덕분에 animal 변수는 자식인 Dog, Cat, Cow의 인스턴스를 참조할 수 있다.(부모는 자식을 담을 수 있다.)
* 메서드 오버라이딩 덕분에 animal.sound()를 호출해도 Dog.sound()를 호출해도 Dog.sound(), Cat.sound(), Cow.sound()와 같이 각 인스턴스의 메서드를 호출할 수 있다. 만약 자바에 메서드 오버라이딩이 없었다면 모두 Animal의 sound()가 호출되었을 것이다.

&ensp;다형성 덕분에 이후에 새로운 동물을 추가해도 다음 코드를 그대로 재사용 할 수 있다. 물론 다형성을 사용하기 위해 새로운 Animal의 sound()가 호출되었을 것이다.<br/>

```java
 private static void soundAnimal(Animal animal) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
 }
```

&ensp;이번에는 배열과 for문을 사용해서 중복을 제거해보자<br/>
```java
package poly.ex2;

public class AnimalPolyMain2 {

    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();
        Cow cow = new Cow();
        Animal[] animalArr = {dog, cat, cow};

        //변하지 않는 부분
        for (Animal animal : animalArr) {
            System.out.println("동물 소리 테스트 시작");
            animal.sound();
            System.out.println("동물 소리 테스트 종료");
        }
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-42.png" width="600"></p>

&ensp;배열은 같은 타입의 데이터를 나열할 수 있다. Dog, Cat, Cow 모두 Animal의 자식이므로 Animal타입이다.<br/>

&ensp;Animal 타입의 배열의 만들고 다형적 참조를 사용하면 된다.<br/>
```java
//둘은 같은 코드이다.
Animal[] animalArr = new Animal[]{dog, cat, cow};
Animal[] animalArr = {dog, cat, cow}
```

&ensp;다형적 참조 덕분에 Dog, Cat, Cow 의 부모 타입이니 Animal 타입으로 배열을 만들고 각각을 배열에 포함했다.<br/>

&ensp;이제 배열을 for문을 사용해서 반복하면 된다.<br/>
```java
//변하지 않는 부분
for (Animal animal : animalArr) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
}
```

&ensp;animal.sound()를 호출하지만 배열에는 Dog, Cat, Cow의 인스턴스가 들어있다. 메서드 오버라이딩에 의해 각 인스턴스의 오버라이딩 된 sound()메서드가 호출된다.<br/>

&ensp;조금 더 개선<br/>
```java
package poly.ex2;

public class AnimalPolyMain3 {

    public static void main(String[] args) {
        Animal[] animalArr = {new Dog(), new Cat(), new Cow()};
        for (Animal animal : animalArr) {
            soundAnimal(animal);
        }
    }

     //동물이 추가 되어도 변하지 않는 코드
    private static void soundAnimal(Animal animal) {
        System.out.println("동물 소리 테스트 시작");
        animal.sound();
        System.out.println("동물 소리 테스트 종료");
    }
}
```

* Animal[] animalArr를 통해서 배열을 사용한다.
* soundAnimal(Animal animal)
    - 하나의 동물을 받아서 로직을 처리한다.

&ensp;새로운 동물이 추가되어도 soundAnimal(...)메서드는 코드 변경 없이 유지할 수 있다. 이렇게 할 수 있는 이유는 이 메서드는 Dog, Cat, Cow 같은 구체적인 클래스를 참조하는 것이 아니라 Animal이라는 추상적인 부모를 참조하기 때문이다. 따라서 Animal을 상속 받은 새로운 동물이 추가되어도 이 메서드의 코드는 변경 없이 유지할 수 있다.<br/>

&ensp;여기서 잘 보면 새로운 동물이 추가되었을 때 코드가 변하는 부분과 변하지 않는 부분이 있다. main()은 코드가 변하는 부분이다. 새로운 동물을 생성하고 필요한 메서드를 호출한다. soundAnimal(..)는 코드가 변하지 않는 부분이다.<br/>

&ensp;로운 기능이 추가되었을 때 변하는 부분을 최소화 하는 것이 잘 작성된 코드이다. 이렇게 하기 위해서는 코드에서 변하는 부분과 변하지 않는 부분을 명확하게 구분하는 것이 좋다.<br/>

&ensp;지금까지 설명한 코드에는 사실 2가지 문제가 있다.<br/>
* Animal 클래스를 생성할 수 있는 문제
* Animal 클래스를 상속 받는 곳에서 sound() 메서드 오버라이딩을 하지 않을 가능성

&ensp;Animal 클래스를 생성할 수 있는 문제<br/>
&ensp;Animal클래스는 동물이라는 클래스이다. 이 클래스를 다음과 같이 직접 생성해서 사용할 일이 있을까?<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-43.png" width="600"></p>

&ensp;개, 고양이, 소가 실제 존재하는 것은 당연하지만, 동물이라는 추상적인 개념이 실제로 존재하는 것은 이상하다. 사실 이 클래스는 다형성을 위해서 필요한 것이지 직접 인스턴스를 생성해서 사용할 일은 없다.<br/>
&ensp;하지만 Animal도 클래스이기 때문에 인스턴스를 생성하고 사용하는데 아무런 제약이 없다. 누군가 실수로 new Animal()을 사용해서 Animal의 인스턴스를 생성할 수 있다는 것이다. 이렇게 생성된 인스턴스는 작동은 하지만 제대로된 기능을 수행하지는 않는다.<br/>

&ensp;Animal 클래스를 상속 받는 곳에서 sound()메서드 오버라이딩을 하지 않을 가능성<br/>
&ensp;예를 들어서 Animal을 상속 받은 Pig 클래스를 만든다고 가정해보자. 우리가 기대하는 것은 Pig 클래스가 sound()메서드를 오버라이딩해서 "꿀꿀"이라는 소리가 나도록 하는 것이다. 그런데 개발자가 실수로 sound() 메서드를 오버라이딩 하는 것을 빠트릴 수 있다. 이렇게 되면 부모의 기능을 상속 받는다. 따라서 코드상 아무런 문제가 발생하지 않는다. 물론 프로그램을 실행하면 기대와 다르게 "꿀꿀"이 아니라 부모 클래스에 있는 Animal.sound()가 호출될 것이다.<br/>

&ensp;좋은 프로그램은 제약이 있는 프로그램이다. 추상 클래스와 추상 메서드를 사용하면 이런 문제를 한번에 해결할 수 있다.<br/>

추상 클래스
======

&ensp;동물(Animal)과 같이 부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스라 한다. 추상 클래스는 이름 그대로 추상적인 개념을 제공하는 클래스이다. 따라서 실체인 인스턴스가 존재하지 않는다. 대신에 상속을 목적으로 사용되고, 부모 클래스 역할을 담당한다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-44.png" width="600"></p>

* 추상 클래스는 클래스를 선언할 때 앞에 추상이라는 의미의 abstract 키워드를 붙여주면 된다.
* 추상 클래스는 기존 클래스와 완전히 같다. 다만 new AbstractAnimal() 와 같이 직접 인스턴스를 생성하지 못하는 제약이 추가된 것이다.

추상 메서드
------

&ensp;부모 클래스를 상속 받는 자식 클래스가 반드시 오버라이딩 해야 하는 메서드를 부모 클래스에 정의할 수 있다. 이것을 추상 메서드라 한다. 추상 메서드는 이름 그대로 추상적인 개념을 제공하는 메서드이다. 따라서 실체가 존재하지 않고, 메서드 바디가 없다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-45.png" width="600"></p>

* 추상 메서드는 선언할 때 메서드 앞에 추상이라는 의미의 abstract 키워드를 붙여주면 된다.
* 추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.
    - 그렇지 않으면 컴파일 오류가 발생한다.
    - 추상 메서드는 메서드 바디가 없다. 따라서 작동하지 않는 메서드를 가진 불완전한 클래스로 볼 수 있다. 따라서 직접 생성하지 못하도록 추상 클래스로 선언해야 한다.
* 추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.
    - 그렇지 않으면 컴파일 오류가 발생한다.
    - 추상 메서드는 자식 클래스가 반드시 오버라이딩 해야 하기 때문에 메서드 바디 부분이 없다. 바디 부분을 만들면 컴파일 오류가 발생한다.
    - 오버라이딩 하지 않으면 자식도 추상 클래스가 되어야 한다.
* 추상 메서드는 기존 메서드와 완전히 같다. 다만 메서드 바디가 없고, 자식 클래스가 해당 메서드를 반드시 오버라이딩 해야 한다는 제약이 추가된 것이다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-46.png" width="600"></p>

```java
 package poly.ex3;

public abstract class AbstractAnimal {
    public abstract void sound();

    public void move() {
        System.out.println("동물이 움직입니다.");
    }
}
```

* AbstractAnimal은 abstract가 붙은 추상 클래스이다. 이 클래스는 직접 인스턴스를 생성할 수 없다. 
* sound()는 abstract가 붙은 추상 메서드이다. 이 메서드는 자식이 반드시 오버라이딩해야 한다.

&ensp;이 클래스는 move()라는 메서드를 가지고 있는데 이 메서드는 추상 메서드가 아니다. 따라서 자식 클래스가 오버라이딩 하지 않아도 된다.<br/>

&ensp;참고로 추상 클래스라고 AbstractAnimal처럼 클래스 이름 앞에 꼭 Abstract를 써야하는 것은 아니다. 그냥 Animal이라는 클래스 이름으로도 충분하다. 여기서는 예제 코드를 다른 예제 코드와 구분해서 설명하기 위해 앞에 Abstract를 붙였다.<br/>

```java
 package poly.ex3;

 public class Dog extends AbstractAnimal {
    @Override
    public void sound() {
        System.out.println("멍멍");
    }
 }
```

```java
package poly.ex3;

 public class Cat extends AbstractAnimal {
    @Override
    public void sound() {
        System.out.println("냐옹");
    }
 }
```

```java
package poly.ex3;

 public class Caw extends AbstractAnimal {
    @Override
    public void sound() {
        System.out.println("음매");
    }
 }
```

```java
 package poly.ex3;

 public class AbstractMain {
    public static void main(String[] args) {

        //추상클래스 생성 불가
        //AbstractAnimal animal = new AbstractAnimal();

        Dog dog = new Dog();
        Cat cat = new Cat();
        Caw caw = new Caw();

        cat.sound();
        cat.move();

        soundAnimal(cat);
        soundAnimal(dog);
        soundAnimal(caw);
    }

    //동물이 추가 되어도 변하지 않는 코드
    private static void soundAnimal(AbstractAnimal animal) {
        System.out.println("동물 소리 테스트 시작");
        animal.sound();
        System.out.println("동물 소리 테스트 종료");
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-47.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-48.png" width="600"></p>

&ensp;추상 클래스는 생성이 불가능하다. 다음 코드의 주석을 풀고 실행하면 컴파일 오류가 발생한다.<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-49.png" width="600"></p>

&ensp;컴파일 오류 - 인스턴스 생성<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-50.png" width="600"></p>

&ensp;AbstractAnimal가 추상이어서 인스턴스 생성이 불가능하다는 뜻이다.<br/>

&ensp;추상 메서드는 반드시 오버라이딩 해야 한다. 만약 자식에서 오버라이딩 메서드를 만들지 않으면 다음과 같이 컴파일 오류가 발생한다.<br/>

```java
package poly.ex3;

 public class Dog extends AbstractAnimal {
 /*
    @Override
    public void sound() {
        System.out.println("멍멍");
    }
 */
 }
```

&ensp;컴파일 오류 - 오버라이딩X<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-51.png" width="600"></p>

&ensp;Dog는 추상클래스가 아닌데 sound() 가 오버라이딩 되지 않았다는 뜻이다.<br/>

&ensp;지금까지 설명한 제약을 제외하고 나머지는 모두 일반적인 클래스와 동일하다. 추상 클래스는 제약이 추가된 클래스일 뿐이다. 메모리 구조, 실행 결과 모두 동일하다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-52.png" width="600"></p>

&ensp;정리<br/>
* 추상 클래스 덕분에 실수로 Animal 인스턴스를 생성할 문제를 근본적으로 방지해준다.
* 추상 메서드 덕분에 새로운 동물의 자식 클래스를 만들때 실수로 sound()를 오버라이딩 하지 않을 문제를 근본적으로 방지해준다.

&ensp;순수 추상 클래스: 모든 메서드가 추상 메서드인 추상 클래스<br/>
&ensp;앞서 만든 예제에서 move()도 추상 메서드로 만들어야 한다고 가정해보자.<br/>
&ensp;이 경우 AbstractAnimal 클래스의 모든 메서드가 추상 메서드가 된다. 이런 클래스를 순수 추상 클래스라 한다.<br/>

&ensp;move()가 추상 메서드가 되었으니 자식들은 AbstractAnimal 의 모든 기능을 오버라이딩 해야 한다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-53.png" width="600"></p>

```java
 package poly.ex4;

 public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
 }
```

```java
package poly.ex4;

public class Dog extends AbstractAnimal {
    @Override
    public void sound() {
        System.out.println("멍멍");
    }

    @Override
    public void move() {
        System.out.println("개 이동");
    }
}
```

```java
package poly.ex4;

public class Cat extends AbstractAnimal {
    @Override
    public void sound() {
        System.out.println("냐옹");
    }

    @Override
    public void move() {
        System.out.println("고양이 이동");
    }
}
```

```java
package poly.ex4;

public class Caw extends AbstractAnimal {
    @Override
    public void sound() {
        System.out.println("음매");
    }

    @Override
    public void move() {
        System.out.println("소 이동");
    }
}
```

```java
package poly.ex4;

public class AbstractMain {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();
        Caw caw = new Caw();

        soundAnimal(cat);
        soundAnimal(dog);
        soundAnimal(caw);
        moveAnimal(cat);
        moveAnimal(dog);
        moveAnimal(caw);
    }

        //동물이 추가 되어도 변하지 않는 코드
    private static void soundAnimal(AbstractAnimal animal) {
        System.out.println("동물 소리 테스트 시작");
        animal.sound();
        System.out.println("동물 소리 테스트 종료");
    }

    //동물이 추가 되어도 변하지 않는 코드
    private static void moveAnimal(AbstractAnimal animal) {
        System.out.println("동물 이동 테스트 시작");
        animal.move();
        System.out.println("동물 이동 테스트 종료");
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-54.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-55.png" width="600"></p>

순수 추상 클래스
-----

&ensp;모든 메서드가 추상 메서드인 순수 추상 클래스는 코드를 실행할 바디 부분이 전혀 없다.<br/>

```java
public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
}
```

&ensp;이러한 순수 추상 클래스는 실행 로직을 전혀 가지고 있지 않다. 단지 다형성을 위한 부모 타입으로써 껍데기 역할만 제공할 뿐이다.<br/>

&ensp;순수 추상 클래스는 다음과 같은 특징을 가진다.<br/>
* 인스턴스를 생성할 수 없다.
* 상속시 자식은 모든 메서드를 오버라이딩 해야 한다.
* 주로 다형성을 위해 사용된다.

&ensp;상속하는 클래스는 모든 메서드를 구현해야 한다.<br/>
&ensp; "상속시 자식은 모든 메서드를 오버라이딩 해야 한다."라는 특징은 상속 받는 클래스 입장에서 보면 부모의 모든 메서드를 구현해야 하는 것이다. 이런 특징을 잘 생각해보면 순수 추상 클래스는 마치 어떤 규격을 지켜서 구현해야 하는 것 처럼 느껴진다. AbstractAnimal의 경우 sound(), move()라는 규격에 맞추어 구현을 해야 한다.<br/>

&ensp;이것은 우리가 일반적으로 이야기하는 인터페이스와 같이 느껴진다. 예를 들어서 USB 인터페이스를 생각해보자. USB 인터페이스는 분명한 규격이 있다. 이 규격에 맞추어 제품을 개발해야 연결이 된다. 순수 추상 클래스가 USB 인터페이스 규격이라고 한다면 USB 인터페이스에 맞추어 마우스, 키보드 같은 연결 장치들을 구현할 수 있다.<br/>

&ensp;이런 순수 추상 클래스의 개념은 프로그래밍에서 매우 자주 사용된다. 자바는 순수 추상 클래스를 더 편리하게 사용할 수 있도록 인터페이스라는 개념을 제공한다.<br/>

인터페이스
------

&ensp;자바는 순수 추상 클래스를 더 편리하게 사용할 수 있는 인터페이스라는 기능을 제공한다.<br/>

&ensp;순수 추상 클래스<br/>
```java
public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
}
```

&ensp;인터페이스는 class가 아니라 interface 키워드르 사용하면 된다.<br/>

&ensp;인터페이스<br/>
```java
public interface InterfaceAnimal {
    public abstract void sound();
    public abstract void move();
}
```

&ensp;인터페이스 - public abstract 키워드 생략 가능<br/>
```java
public interface InterfaceAnimal {
    void sound();
    void move();
}
```

&ensp;순수 추상 클래스는 다음과 같은 특징을 가진다.<br/>
* 인스턴스를 생성할 수 없다.
* 상속시 모든 메서드를 오버라이딩 해야 한다.
* 주로 다형성을 위해 사용된다.

&ensp;인터페이스는 앞서 설명한 순수 추상 클래스와 같다. 여기에 약간의 편의 기능이 추가된다.<br/>

* 인터페이스의 메서드는 모두 public, abstract이다.
* 메서드에 public abstract를 생략할 수 있다. 참고로 생략이 권장한다.
* 인터페이스는 다중 구현(다중 상속)을 지원한다.

&ensp;인터페이스와 멤버 변수<br/>
```java
public interface InterfaceAnimal {
    public static final double MY_PI = 3.14;
}
```

&ensp;인터페이스에서 멤버 변수는 public, static, final이 모두 포함되었다고 간주된다. final은 변수의 값을 한 번 설정하면 수정할 수 없다는 뜻이다.<br/>
&ensp;자바에서 static final을 사용해 정적이면서 고칠 수 없는 변수를 상수라 하고 관례상 상수는 대문자에 언더스코어(_)로 구분한다.<br/>

&ensp;해당 키워드는 다음과 같이 생략할 수 있다. (생략이 권장된다.)<br/>
```java
public interface InterfaceAnimal {
    double MY_PI = 3.14;
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-56.png" width="600"></p>

&ensp;클래스 상속 관계는 UML에서 실선을 사용하지만, 인터페이스 구현(상속) 관계는 UML에서 점선을 사용한다.<br/>

```java
package poly.ex5;

public interface InterfaceAnimal {
    void sound();
    void move();
}
```

&ensp;인터페이스는 class대신에 interface로 선언하면 된다. sound(), move() 는 앞에 public abstract가 생략되어 있다. 따라서 상속 받는 곳에서 모든 메서드를 오버라이딩해야 한다.<br/> 

```java
 package poly.ex5;

 public class Dog implements InterfaceAnimal {
    @Override
    public void sound() {
        System.out.println("멍멍");
    }

    @Override
    public void move() {
        System.out.println("개 이동");
    }
 }
```

&ensp;인터페이스를 상속 받을 때는 extends 대신에 implements라는 **구현** 이라는 키워드를 사용해야 한다. 인터페이스는 그래서 상속이라 하지 않고 구현이라 한다.<br/>

```java
package poly.ex5;

public class Cat implements InterfaceAnimal {
    @Override
    public void sound() {
        System.out.println("냐옹");
    }

    @Override
    public void move() {
        System.out.println("고양이 이동");
    }
}
```

```java
package poly.ex5;

public class Caw implements InterfaceAnimal {
    @Override
    public void sound() {
        System.out.println("음매");
    }

    @Override
    public void move() {
        System.out.println("소 이동");
    }
}
```

```java
 package poly.ex5;

 public class InterfaceMain { 
    public static void main(String[] args) {

    //인터페이스 생성 불가
    //InterfaceAnimal interfaceMain1 = new InterfaceAnimal();

    Cat cat = new Cat();
    Dog dog = new Dog();
    Cow c0w = new Cow();
    soundAnimal(cat);
    soundAnimal(dog);
    soundAnimal(cow);
    }

    //동물이 추가 되어도 변하지 않는 코드
    private static void soundAnimal(InterfaceAnimal animal) {
        System.out.println("동물 소리 테스트 시작");
        animal.sound();
        System.out.println("동물 소리 테스트 종료");
    }
 }
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-57.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-58.png" width="600"></p>

&ensp;앞서 설명한 순수 추상 클래스 예제와 거의 유사하다. 순수 추상 클래스가 인터페이스가 되었을 뿐이다.<br/>

&ensp;<b>클래스, 추상 클래스, 인터페이스는 모두 똑같다.</b><br/>
* 클래스, 추상 클래스, 인터페이스는 프로그램 코드, 메모리 구조상 모두 똑같다. 모두 자바에서는 .class로 다루어진다. 인터페이스를 작성할 때도 .java에 인터페이스를 정의한다.
* 인터페이스는 순수 추상 클래스와 비슷하다고 생각하면 된다.

&ensp;상속 vs 구현<br/>
&ensp;부모 클래스의 기능을 자식 클래스가 상속 받을 때, 클래스는 상속 받는다고 표현하지만, 부모 인터페이스의 기능을 자식이 상속 받을 때는 인터페이스를 구현한다고 표현한다. 이렇게 서로 다르게 표현하는 이유는 알아보자. 상속은 이름 그대로 부모의 기능을 물려 받는 것이 목적이다. 하지만 인터페이스는 모든 메서드가 추상 메서드이다. 따라서 물려받을 수 있는 기능이 없고, 오히려 인터페이스에 정의한 모든 메서드를 자식이 오버라이딩 해서 기능을 구현해야 한다. 따라서 구현한다고 표현한다.<br/>
&ensp;인터페이스는 메서드 이름만 있는 설계도이고, 이 설계도가 실제 어떻게 작동하는지는 하위 클래스에서 모두 구현해야 한다. 따라서 인터페이스의 경우 상속이 아니라 해당 인터페이스를 구현한다고 표현한다.<br/>
&ensp;상속과 구현은 사람이 표현하는 단어만 다를 뿐이지 자바 입장에서는 똑같다. 일반 상속 구조와 동일하게 작동한다.<br/>

&ensp;인터페이스를 사용해야 하는 이유<br/>
&ensp;모든 메서드가 추상 메서드인 경우 순수 추상 클래스를 만들어도 되고, 인터페이스를 만들어도 된다. 그런대 왜 인터페이스를 사용해야 할까? 단순히 편리하다는 이유를 넘어서 다음과 같은 이유가 있다.<br/>
* 제약: 인터페이스를 만드는 이유는 인터페이스를 구현하는 곳에서 인터페이스의 메서드를 반드시 구현해라는 규약(제약)을 주는 것이다. USB 인터페이스를 생각해보자. USB 인터페이스에 맞추어 키보드, 마우스를 개발하고 연결해야 한다. 그렇지 않으면 작동하지 않는다. 인터페이스의 규약(제약)은 반드시 구현해야 하는 것이다. 그런데 순수 추상 클래스의 경우 미래에 누군가 그곳에 실행 가능한 메서드를 끼워 넣을 수 있다. 이렇게 되면 추가된 기능을 자식 클래스에서 구현하지 않을 수도 있고, 또 더는 순수 추상 클래스가 아니게 된다. 인터페이스는 모든 메서드가 추상 메서드이다. 따라서 이런 문제를 원천 차단할 수 있다.
* 다중 구현: 자바에서 클래스 상속은 부모를 하나만 지정할 수 있다. 반면에 인터페이스는 부모를 여러명 두는 다중 구현(다중 상속)이 가능하다.

인터페이스 - 다중 구현
------

&ensp;자바가 다중 상속을 지원하지 않는 이유<br/>
&ensp;자바는 다중 상속을 지원하지 않는다. 그래서 extends 대상은 하나만 선택할 수 있다. 부모를 하나만 선택할 수 있다는 뜻이다. 물론 부모가 또 부모를 가지는 것은 괜찮다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-59.png" width="600"></p>

&ensp;만약 비행기와 자동차를 상속 받아서 하늘을 나는 자동차를 만든다고 가정해보자. 만약 그림과 같이 다중 상속을 사용하게 되면 AirplaneCar입장에서 move()를 호출할 때 어떤 부모의 move()를 사용해야 할지 애매한 문제가 발생한다. 이것을 다이아몬드 문제라 한다. 그리고 다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해지 수 있다. 이런 문제점 때문에 자바는 클래스의 다중 상속을 허용하지 않는다. 대신에 인터페이스의 다중 구현을 허용하여 이러한 문제를 피한다.<br/>

&ensp;클래스는 앞서 설명한 이유로 다중 상속이 안되는데, 인터페이스의 다중 구현은 허용한 이유는 뭘까? 인터페이스는 모두 추상 메서드로 이루어져 있기 때문이다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-60.png" width="600"></p>

&ensp;InterfaceA, InterfaceB 둘다 같은 methodCommon()을 가지고 있따. 그리고 Child는 두 인터페이스를 구현했다. 상속 관계의 경우 두 부모 중에 어떤 한 부모의 methodCommon()을 사용해야 할지 결정해야 하는 다이아몬드 문제가 발생한다.<br/>
&ensp;하지만 인터페이스 자신은 구현을 가지지 않는다. 대신에 인터페이스를 구현하는 곳에서 해당 기능을 모두 구현해야 한다. 여기서 InterfeaceA, InterfaceB는 같은 이름의 methodCommon()를 제공하지만 이것은 기능은 Child가 구현한다.  그리고 오버라이딩에 의해 어차피 Child에 있는 methodCommon()이 호출된다. 결과적으로 두 부모 중에 어떤 한 부모의 methodCommon()을 선택하는 것이 아니라 그냥 인터페이스들을 구현한 Child에 있는 methodCommon()이 사용된다. 이런 이유로 인터페이스는 다이아몬드 문제가 발생하지 않는다. 따라서 인터페이스의 경우 다중 구현을 허용한다.<br/>

```java
 package poly.diamond;

 public interface InterfaceA {
    void methodA();
    void methodCommon();
 }
```

```java
 package poly.diamond;

 public interface InterfaceB {
    void methodB();
    void methodCommon();
 }
```

```java
 package poly.diamond;

 public class Child implements InterfaceA, InterfaceB {
    @Override
    public void methodA() {
        System.out.println("Child.methodA");
    }

    @Override
    public void methodB() {
        System.out.println("Child.methodB");
    }

    @Override
    public void methodCommon() {
        System.out.println("Child.methodCommon");
    }
 }
```

* mplements InterfaceA, InterfaceB와 같이 다중 구현을 할 수 있다. implements키워드 위에 , 로 여러 인터페이스를 구분하면 된다.
* methodCommon()의 경우 양쪽 인터페이스에 다 있지만 같은 메서드이므로 구현은 하나만 하면 된다.

```java
package poly.diamond;

//인터페이스 다중 구현
public class DiamondMain {
    public static void main(String[] args) {
        InterfaceA a = new Child();
        a.methodA();
        a.methodCommon();

        InterfaceB b = new Child();
        b.methodB();
        b.methodCommon();
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-61.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-62.png" width="600"></p>

1. a.methodCommon()을 호출하면 먼저 x001 Child인스턴스를 찾는다.
2. 변수 a가 InterfaceA 타입이므로 해당 타입에서 methodCommon()을 찾는다.
3. methodCommon()은 하위 타입인 Child에서 오버라이딩 되어 있다. 따라서 Child의 methodCommon()이 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-63.png" width="600"></p>

&ensp;4. b.methodCommon()을 호출하면 x002 Child 인스턴스를 찾는다.<br/>
&ensp;5. 변수 b가 InterfaceB타입이므로 해당 타입에서 methodCommon()을 찾는다.<br/>
&ensp;methodCommon()은 하위 타입인 Child에서 오버라이딩 되어 있다. 따라서 Child의 methodCommon()이 호출된다.

클래스와 인터페이스 활용
=======

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-64.png" width="600"></p>

* AbstractAnimal은 추상 클래스다.
    - sound(): 동물의 소리를 내기 위한 sound() 추상 메서드를 제공한다.
    - move(): 동물의 이동을 표현하기 위한 메서드이다. 이 메서드는 추상 메서드가 아니다. 상속을 목적으로 사용된다.
* Fly는 인터페이스이다. 나는 동물은 이 인터페이스를 구현할 수 있다.
    - Bird, Chicken은 날 수 있는 동물이다. fly() 메서드를 구현해야 한다.

```java
package poly.ex6;

 public abstract class AbstractAnimal {
    public abstract void sound();
    public void move() {
        System.out.println("동물이 이동합니다.");
    }
 }
```

```java
 package poly.ex6;

 public interface Fly {
    void fly();
 }
```

```java
package poly.ex6;

 public class Dog extends AbstractAnimal {
    @Override
    public void sound() {
        System.out.println("멍멍");
    }
 }
```

&ensp;Dog는 AbstractAnimal만 상속 받는다.<br/>

```java
 package poly.ex6;

 public class Bird extends AbstractAnimal implements Fly {
    @Override
    public void sound() {
        System.out.println("짹짹");
    }

    @Override
    public void fly() {
        System.out.println("새 날기");
    }
 }
```

&ensp;Bird는 AbstractAnimal 클래스를 상속하고 Fly 인터페이스를 구현한다.<br/>

&ensp;하나의 클래스 여러 인터페이스 예시<br/>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-65.png" width="600"></p>

&ensp;extends를 통한 상속은 하나만 할 수 있고 implements 를 통한 인터페이스는 다중 구현 할 수 있기 때문에 둘이 함께 나온 경우 extends가 먼저 나와야 한다.<br/>

```java
package poly.ex6;

public class Chicken extends AbstractAnimal implements Fly {
    @Override
    public void sound() {
        System.out.println("꼬끼오");
    }

    @Override
    public void fly() {
        System.out.println("닭 날기");
    }
}
```

```java
 package poly.ex6;

 public class SoundFlyMain {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Bird bird = new Bird();
        Chicken chicken = new Chicken();

        soundAnimal(dog);
        soundAnimal(bird);
        soundAnimal(chicken);
        flyAnimal(bird);
        flyAnimal(chicken);
    }

    //AbstractAnimal 사용 가능
    private static void soundAnimal(AbstractAnimal animal) {
        System.out.println("동물 소리 테스트 시작");
        animal.sound();
        System.out.println("동물 소리 테스트 종료");
    }

    //Fly 인터페이스가 있으면 사용 가능
    private static void flyAnimal(Fly fly) {
        System.out.println("날기 테스트 시작");
        fly.fly();
        System.out.println("날기 테스트 종료");
    }
 }
```

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-66.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-67.png" width="600"></p>

&ensp; soundAnimal(AbstractAnimal animal)<br/>
&ensp;AbstractAnimal를 상속한 Dog, Bird, Chicken을 전달해서 실행할 수 있다.

&ensp;실행과정<br/>
* soundAnimal(bird)를 호출한다고 가정하자
* 메서드 안에서 animal.sound()를 호출하면 참조 대상인 x001 Bird 인스턴스를 찾는다.
* 호출한 animal 변수는 AbstractAnimal 타입이다. 따라서 AbstractAnimal.sound()를 찾는다. 해당 메서드는 Bird.sound()에 오버라이딩 되어 있다.
* Bird.sound()가 호출된다.

<p align="center"><img src="/assets/img/김영한의 자바/19. 다형성/19-68.png" width="600"></p>

&ensp;flyAnimal(Fly fly)<br/>
&ensp;Fly 인터페이스를 구현한 Bird, Chicken을 전달해서 실행할 수 있다.

&ensp;실행 과정<br/>
* fly(bird)를 호출한다고 가정하자.
* 메서드 안에서 fly.fly()를 호출하면 참조 대상인 x001 Bird 인스턴스를 찾는다.
* 호출한 fly 변수는 Fly 타입이다. 따라서 Fly.fly()를 찾는다. 해당 메서드는 Bird.fly()에 오버라이딩 되어 있다.
* Bird.fly()가 호출된다.

