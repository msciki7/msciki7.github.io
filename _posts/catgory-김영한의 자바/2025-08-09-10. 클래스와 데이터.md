---
title: "10주차 메서드"
excerpt: ""

wirter: sohee Kim
categories:
  - 김영한의 자바
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-08-09
last_modified_at: 2025-08-09
---

클래스 도입
======

&ensp;클래스를 사용해서 학생이라는 개념을 만들고 각각의 학생 별로 본인의 이름, 나이, 성적을 관리하는 것이다.<br/>

&ensp;Student 클래스<br/>

```java
public class Student{
  String name;
  int age;
  int grade;
}
```

&ensp;class 키워드를 사용해서 학생 클래스(Student)를 정의한다. 학생 클래스는 내부에 이름(name), 나이(age), 성적(grade) 변수를 가진다.<br/>

&ensp;이렇게 클래스에 정의한 변수들을  멤버 변수, 또는 필드라 한다.<br/>
* 멤버 변수(Member Variable): 이 변수들은 특정 클래스에 소속도니 멤버이기 때문에 이렇게 부른다.
* 필드(Field): 데이터 항목을 가리키는 전통적인 용어이다. 데이터베이스, 엑셀 등에서 데이터 각각의 항목을 필드라 한다.
* 자바에서 멤버 변수, 필드는 같은 뜻이다. 클래스에 소속된 변수를 뜻한다.

&ensp;클래스는 관례상 대문자로 시작하고 낙타표기법을 사용한다.<br/>

&ensp;학생 클래스를 사용하는 코드<br/>

```java
public class ClassStart3 {
  public static void main(String[] args) {
    Student student1;
    student1 = new Student();
    student1.name = "학생1";
    student1.age = 15;
    student1.grade = 90;

    Student student2 = new Student();
    student2.name = "학생2";
    student2.age = 16;
    student2.grade = 80;

    System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);
    System.out.println("이름:" + student2.name + " 나이:" + student2.age + " 성적:" + student2.grade);
    }
}
```

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-1.png" width="600"></p>

&ensp;클래스와 사용자 정의 타입<br/>
* 타입은 데이터의 종류나 형태를 나타낸다.
* int라고 하면 정수 타입, String 이라고 하면 문자 타입이다.
* 학생(Student)이라는 타입을 만드면 되지 않을까?
* 클래스를 사용하면 int, String과 같은 타입을 직접 만들 수 있다.
* 사용자가 직접 정의하는 사용자 정의 타입을 만들려면 설계도가 필요하다. 이 **설계도가 바로 클래스** 이다.
* 설계도인 클래스를 사용해서 실제 메모리에 만들어진 실체를 객체 또는 인스턴스라 한다.
* 클래스를 통해서 사용자가 원하는 종류의 데이터 타입을 마음껏 정의할 수 있다.

&ensp;용어: 클래스, 객체, 인스턴스<br/>
&ensp;클래스는 설계도이고 이 설계도를 기반으로 실제 메모리에 만들어진 실체를 객체 또는 인스턴스라 한다. 둘다 같은 의미로 사용된다. 여기서는 학생(Student) 클래스를 기반으로 학생1(Studnet)클래스를 기반으로 학생1(student1), 학생2(studnet2) 객체 또는 인스턴스를 만들었다.<br/>

&ensp;1. 변수 선언<br/>

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-2.png" width="600"></p>

* Student student1
  - Student 타입을 받을 수 있는 변수를 선언한다.
  - int는 정수를, String은 문자를 담을 수 있듯이 Student는 Student 타입의 객체(인스턴스)를 받을 수 있다.

&ensp;2. 객체 생성<br/>

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-3.png" width="600"></p>

&ensp;student1 = new Student() 코드를 나누어 분석해보면<br/>
* 객체를 사용하려면 먼저 설계도인 클래스를 기반으로 객체(인스턴스)를 생성해야 한다.
* new Student(): new는 새로 생성한다는 뜻이다. new Student()는 Student 클래스 정보를 기반으로 새로운 객체를 생성하라는 뜻이다. 이렇게 하면 메모리 실제 Student 객체(인스턴스)를 생성한다.
* Student 클래스는 String name, int age, int grade 멤버 변수를 가지고 있다ㅏ. 이 변수를 사용하는 데 필요한 메모리 공간도 함께 확보한다.

&ensp;3. 참조값 보관<br/>

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-4.png" width="600"></p>

* 객체를 생성하면 자바는 메모리 어딘가에 있는 이 객체에 접근할 수 있는 참조형(주소)(x001)을 반환한다.
  - 여기서 x001이라고 표현한 것이 참조값이다.(실제로 x001처럼 표현되는 것은 아니고 이해를 돕기 위한 예시이다.)
* new 키워드를 통해 객체가 생성되고 나면 참조값을 반환한다. 앞서 선언한 변수인 Student student1에 생성된 객체의 참조값(x001)을 보관한다.
* Student student1 변수는 이제 메모리에 존재하는 실제 Student 객체(인스턴스)의 참조값을 가지고 있다.
  - student1 변수는 방금 만든 객체에 접근할 수 있는 참조값을 가지고 있다. 따라서 이 변수를 통해서 객체를 접근(참조)할 수 있다. 쉽게 이야기해서 student1 변수를 통해 메모리에 있는 실제 객체를 접근하고 사용할 수 있다.

&ensp;참조값을 변수에 보관해야 하는 이유<br/>
&ensp;객체를 생성하는 new Student() 코드 자체에는 아무런 이름이 없다. 이 코드는 단순히 Student 클래스를 기반으로 메모리에 실제 객체를 만드는 것이다. 따라서 생성한 객체에 접근할 수 있는 방법이 필요하다. 이런 이유로 객체를 생성할 때 반환되는 참조값을 어딘가 보관해두어야 한다. 앞서 Student student1 변수에 참조값(x001)을 저장해두었으므로 저장한 참조값(x001)을 통해서 실제 메모리에 존재하는 객체에 접근할 수 있다.<br/>

```java
Student student1 = new Student(); //1. Student 객체 생성
Student student1 = x001; //2. new Student()의 결과로 x001 참조값 반환
student1 = x001; //3. 최종 결과
```

&ensp;이후에 학생2(student2)까지 생성하면 다음과 같이 Student객체(인스턴스)가 메모리에 2개 생성된다. 각각 참조값이 다르므로 서로 구분할 수 있다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-5.png" width="600"></p>

&ensp;참조값을 확인하고 싶다면 다음과 같이 객체를 담고 있는 변수를 출력해보면 된다.<br/>

```java
System.out.println(student1);
System.out.println(student2);
```

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-6.png" width="600"></p>

&ensp;@앞은 패키지 + 클래스 정보를 뜻한다. @뒤에 16진수는 참조값을 뜻한다.<br/>

객체 사용
======

&ensp;클래스를 통해 생성한 객체를 사용하려면 먼저 메모리에 존재하는 객체에 접근해야 한다. 객체에 접근하려면 .(점, dot)을 사용하면 된다.<br/>

```java
//객체 값 대입
student1.name = "학생1";
 student1.age = 15;
 student1.grade = 90;

 //객체 값 사용
System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);
```

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-7.png" width="600"></p>

객체에 값 대입
------

&ensp;객체가 가지고 있는 멤버 변수(name, age, grade)에 값을 대입하려면 먼저 객체에 접근해야 한다.<br/>
&ensp;객체에 접근하려면 .(점, dot)키워드를 사용하면 된다. 이 키워드는 변수(student1)에 들어있는 참조값(x001)을 읽어서 메모리에 존재하는 객체에 접근한다.<br/>

```java
student1.name="학생1" //1. student1 객체의 name 멤버 변수에 값 대입
x001.name="학생1" //2.변수에 있는 참조값을 통해 실제 객체에 접근, 해당 객체의 name 멤버 변수에 값 대입
```

&ensp;student1.(dot)이라고 하면 student1 변수가 가지고 있는 참조값을 통해 실제 객체에 접근한다.<br/>
&ensp;student1은 x001이라는 참조값을 가지고 있으므로 x001 위치에 있는 Student 객체에 접근한다.<br/>

&ensp;student1.name="학생1" 코드 실행 전<br/>

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-8.png" width="600"></p>

&ensp;student1.name="학생1" 코드 실행 후<br/>

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-9.png" width="600"></p>

* student1.name코드를 통해 .(dot)키워드가 사용되었다. student1 변수가 가지고 있는 참조값을 통해 실제 객체에 접근한다.
* x001.name = "학생1": x001 객체가 있는 곳의 name 멤버 변수에 "학생1" 데이터가 저장된다.

객체 값 읽기
------

&ensp;객체의 값을 읽는 것도 앞서 설명한 내용과 같다. .(dot)키워드를 통해 참조값을 통해 참조값을 사용해서 객체에 접근한 다음에 원하는 작업을 하면 된다. 다음 예제를 보면<br/>

```java
//1. 객체 값 읽기
System.out.println("이름:" + student1.name);
//2. 변수에 있는 참조값을 통해 실제 객체에 접근하고, name 멤버 변수에 접근한다.
System.out.println("이름:" + x001.name);
//3. 객체의 멤버 변수의 값을 읽어옴
System.out.println("이름:" + "학생1");
```

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-10.png" width="600"></p>
<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-11.png" width="600"></p>

클래스, 객체, 인스턴스 정리
------

&ensp;<b>클래스-Class</b><br/>
&ensp;클래스는 객체를 생성하기 위한 틀 또는 설계도이다. 클래스는 객체가 가져야 할 속성(변수)과 가능(메서드)를 정의한다. 예를 들어 학생이라는 클래스는 속성으로 name, age, grade를 가진다.<br/>
* 틀: 붕어빵 틀을 생각해보면 붕어빵 틀은 붕어빵이 아니다. 이렇게 생긴 붕어빵이 나왔으면 좋겠다고 만드는 틀일 뿐이다. 실제 먹을 수 있는 것이 아니다. 실제 먹을 수 있는 팥 붕어빵을 객체 또는 인스턴스라 한다.
* 설계도: 자동차 설계도를 생각해보면 자동차 설계도는 자동차가 아니다. 설계도는 실제 존재하는 것이 아니라 개념으로만 있는 것이다. 설계도를 통해 생산한 실제 존재하는 흰색 테슬라 모델 Y 자동차를 객체 또는 인스턴스라 한다.

&ensp;<b>객체-Object</b><br/>
&ensp;객체는 클래스에서 정의한 속성과 기능을 가진 실체이다. 객체는 서로 독립적인 상태를 가진다. 예를 들어 위 코드에서 student1은 학생1의 속성을 가지는 객체이고 student2는 학생2의 속성을 가지는 객체이다. student1과 student2는 같은 클래스에서 만들어졌지만 서로 다른 객체이다.

&ensp;<b>인스턴스-Instance</b><br/>
&ensp;인스턴스는 특정 클래스로부터 생성된 객체를 의미한다. 그래서 객체와 인스턴스라는 용어는 자주 혼용된다. 인스턴스는 주로 객체가 어떤 클래스에 속해 있는지 강조할 때 사용한다. 예를 들어서 student1 객체는 student 클래스의 인스턴스다.라고 표현한다.<br/>

&ensp;<b>객체 vs 인스턴스</b><br/>
&ensp;둘다 클래스에서 나온 실체라는 의미에서 비슷하게 사용되지만 용어상 인스턴스는 객체보다 좀 더 관계에 초점을 맞춘 단어이다. 보통 student1은 Student의 객체이다. 라고 말하는 대신 student1은 Student의 인스턴스이다. 라고 특정 클래스와의 관계를 명확히 할 때 인스턴스라는 용어를 주로 사용한다.<br/>
&ensp;좀 더 쉽게 풀어보자면 모든 인스턴스는 객체이지만 우리가 인스턴스라고 부르는 순간은 특정 클래스로부터 그 객체가 생성되었음을 강조하고 싶을 때이다. 예를 들어 student1은 객체이지만 이 객체가 Studnet 클래스로부터 생성된다는 점을 명호가히 하기 위해 studnet1을 Student의 인스턴스라고 부른다.<br/>

&ensp;하지만 둘다 클래스에서 나온 실체라는 핵심 의미는 같기 때문에 보통 둘을 구분하지 않고 사용한다.<br/>

배열 도입
======

&ensp;클래스와 객체 덕분에 학생 데이터를 구조적으로 이해하기 쉽게 변경할 수 있었다. 하지만 코드를 보면 아쉬운 부분이 있는데 바로 학생을 출력하는 부분이다.<br/>

```java
System.out.println("이름:" + student1.name + " 나이:" + student1.age + ...);
System.out.println("이름:" + student2.name + " 나이:" + student2.age + ...);
```

&ensp;새로운 학생이 추가될 때마다 출력하는 부분도 함께 추가해야 한다.<br/>
&ensp;배열을 사용하면 특정 타입을 연속한 데이터 구조로 묶어서 편리하게 관리할 수 있다. Student 클래스를 사용한 변수들도 Student 타입이기 때문에 학생도 배열을 사용해서 하나의 데이터 구조로 묶어서 관리할 수 있다.<br/>

* Student 타입을 사용하는 배열

```java
public class ClassStart4 {
  public static void main(String[] args) {
    Student student1 = new Student();
    student1.name = "학생1";
    student1.age = 15;
    student1.grade = 90;

    Student student2 = new Student();
    student2.name = "학생2";
    student2.age = 16;
    student2.grade = 80;

    Student[] students = new Student[2];
    students[0] = student1;
    students[1] = student2;

    System.out.println("이름:" + students[0].name + " 나이:" + students[0].age + " 성적:" + students[0].grade);
    System.out.println("이름:" + students[1].name + " 나이:" + students[1].age + " 성적:" + students[1].grade);
  }  
}
```

&ensp;코드를 분석해보면<br/>

```java
Student student1 = new Student();
student1.name = "학생1";
student1.age = 15;
student1.grade = 90;

Student student2 = new Student();
student2.name = "학생2";
student2.age = 16;
student2.grade = 80;
```

&ensp;Student 클래스를 기반으로 student1, student2 인스턴스를 생성한다. 그리고 필요한 값을 채워둔다.<br/>

<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-12.png" width="600"></p>

배열에 참조값 대입
------

&ensp;이번에는 Student를 담을 수 있는 배열을 생성하고 해당 배열에 student1, student2 인스턴스를 보관하자<br/>

```java
Student[] students = new Student[2];
```
<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-13.png" width="600"></p>

* Student 변수를 2개 보관할 수 있는 사이즈 2의 배열을 만든다.
* Student 타입의 변수는 Student 인스턴스의 참조값을 보관한다. Student 배열은 각각의 항목도 Student 타입의 변수일 뿐이다. 따라서 Student 타입의 참조값을 보관한다.
  - student1, student2 변수를 생각해보면 Student 타입의 참조값을 보관한다.
* 배열에는 아직 참조값을 대입하지 않았기 때문에 참조값이 없다는 의미의 null 값으로 초기화 된다.

&ensp;이제 배열에 객체를 보관하자<br/>

```java
students[0] = student1;
students[1] = student2;

//자바에서 대입은 항상 변수에 들어 있는 값을 복사한다.
students[0] = x001;
students[1] = x002;
```

&ensp;<b>자바에서 대입은 항상 변수에 들어 있는 값을 복사한다.</b><br/>
&ensp;student1, student2 에는 참조값이 보관되어 있다. 따라서 이 참조값이 배열에 저장된다. 또는 student1, student2에 보관된 참조값을 읽고 복사해서 배열에 대입한다고 표현한다.<br/>

&ensp;배열에 참조값에 대입한 이후 배열 그림<br/>
<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-14.png" width="600"></p>

&ensp;이제 배열은 x001, x002의 참조값을 가진다. 참조값을 가지고 있기 때문에 x001(학생1), x002(학생2) Student 인스턴스에 모두 접근할 수 있다.<br/>
<p align="center"><img src="/assets/img/김영한의 자바/10. 클래스/10-15.png" width="600"></p>

&ensp;<b>자바에서 대입은 항상 변수에 들어 있는 값을 복사해서 전달한다.</b><br/>

```java
students[0] = student1;
students[1] = student2;

//자바에서 대입은 항상 변수에 들어 있는 값을 복사한다.
students[0] = x001;
students[1] = x002;
```

&ensp;자바에서 변수의 대입(=)은 모든 변수에 들어있는 값을 복사해서 전달하는 것이다. 이 경우 오른쪽 변수인 student1, student2에는 참조값이 들어있다. 그래서 이 값을 복사해서 왼쪽에 있는 배열에 전달한다. 따라서 기본 student1, student2 에 들어있던 참조값은 당연히 그래로 유지된다.<br/>

&ensp;주의!: 변수에는 인스턴스 자체가 들어있는 것이 아니다. 인스턴스의 위치를 가리키는 참조값이 들어있을 뿐이다. 따라서 대입(=)시에 인스턴스가 복사되는 것이 아니라 참조값만 복사된다.<br/>

배열에 들어있는 객체 사용
------

&ensp;배열에 들어있는 객체를 사용하려면 먼저 배열에 접근하고 그 다음에 객체에 접근하면 된다. 이전에 설명한 그림과 코드를 함께 보면 쉽게 이해가 될 것이다.<br/>

&ensp;학생1 예제<br/>

```java
System.out.println(students[0].name); //배열 접근 시작
System.out.println(x005[0].name); //[0]를 사용해서 x005 배열의 0번 요소에 접근
System.out.println(x001.name); //.(dot)을 사용해서 참조값으로 객체에 접근
System.out.println("학생1");
```

&ensp;학생2 예제<br/>

```java
System.out.println(students[1].name); //배열 접근 시작
System.out.println(x005[1].name); //[1]를 사용해서 x005 배열의 1번 요소에 접근
System.out.println(x002.name); //.(dot)을 사용해서 참조값으로 객체에 접근
System.out.println("학생2");
```

배열 도입
=======

&ensp;배열을 사용한 덕분에 출력에서 다음과 같이 for문을 도입할 수 있게 되었다.<br/>

```java
public class ClassStart5 {
  public static void main(String[] args) {
    Student student1 = new Student();
    student1.name = "학생1";
    student1.age = 15;
    student1.grade = 90;

    Student student2 = new Student();
    student2.name = "학생2";
    student2.age = 16;
    student2.grade = 80;

    //배열 선언
    Student[] students = new Student[]{student1, student2};

    //for문 적용
    for (int i = 0; i < students.length; i++) {
    System.out.println("이름:" + students[i].name + " 나이:" + students[i].age + " 성적:" + students[i].grade);
    }
  }
}
```

배열 선언 최적화
------

&ensp;우리가 직접 정의한 Student 타입도 일반적인 변수와 동일하게 배열을 생성할 때 포함할 수 있다.<br/>

```java
Student[] students = new Student[]{student1, student2};
```

&ensp;생성과 선언을 동시에 하는 경우 다음과 같이 더 최적화 할 수 있다.<br/>

```java
Student[] students = {student1, student2};
```

for문 최적화
------

&ensp;배열을 사용한 덕분에 for문을 사용해서 반복 작업을 깔끔하게 처리할 수 있다.<br/>

&ensp;for문 도입<br/>

```java
for (int i = 0; i < students.length; i++) {
 System.out.println("이름:" + students[i].name + " 나이:" + students[i].age + ...);
}
```

&ensp;for문-반복 요소를 변수에 담아서 처리하기<br/>

```java
for (int i = 0; i < students.length; i++) {
  Student s = students[i];
  System.out.println("이름:" + s.name + " 나이:" + s.age + ...);
}
```

&ensp;student[i].name, students[i].age 처럼 students[i]를 자주 접근하는 것이 번거롭다면 반복해서 사용하는 객체를 Students s와 같은 변수에 담아두고 사용해도 된다.<br/>
&ensp;물론 이런 경우에는 다음과 같이 향상된 for문을 사용하는 것이 가장 깔끔하다.<br/>

&ensp;향상된 for문(Enhanced For Loop)<br/>

```java
for (Student s : students) {
  System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" + s.grade);
}
```