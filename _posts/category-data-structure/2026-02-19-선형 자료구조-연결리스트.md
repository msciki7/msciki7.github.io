---
title: "선형 자료구조 - 연결 리스트"
excerpt: ""

wirter: sohee Kim
categories:
  - data structure
tags:
  - 자료구조

toc: true
toc_sticky: true

date: 2026-02-19
last_modified_at: 2026-02-19
---

개념
===

&ensp;연결 리스트는 데이터와 다음 노드의 주소를 저장해서 연결하는 구조이다.<br/>

&ensp;배열과 연결 리스트 비교<br/>

| 배열         | 연결 리스트      |
| ---------- | ----------- |
| 메모리에 연속 저장 | 흩어져 저장됨     |
| 인덱스로 접근 가능 | 순서대로 이동해야 함 |
| 크기 고정      | 크기 동적 변경    |

구조 이해
====

&ensp;노드 구조<br/>
```
[데이터 | 다음 노드 주소]
```

&ensp;전체 연결 모습<br/>
```css
[10 | * ] → [20 | * ] → [30 | * ] → NULL
```

* 첫 번째 노드: head
* 마지막 노드: next = NULL

시간 복잡도
===

| 연산     | 시간   |
| ------ | ---- |
| 탐색     | O(n) |
| 맨 앞 삽입 | O(1) |
| 중간 삽입  | O(n) |
| 삭제     | O(n) |

연결 리스트 기본 구조
===

&ensp;노드 정의<br/>
```cpp
#include <iostream>
using namesapce std;

struct Node{
    int data;
    Node *next;
};
```

노드 생성 함수
====

```cpp
Node* createNode(int value){
    Node* newNode = new Node;
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}
```

맨 앞에 삽입 (가장 기본 연산)
====

```cpp
void insertFront(Node** head, int value){
    Node* newNode = creteNode(value);
    newNode->next = *head;
    *head = newNode;
}
```

&ensp;동작 과정<br/>
&ensp;기존:<br/>
```css
head → [10] → [20]
```

&ensp;insertFront(5) 후:<br/>
```css
head → [5] → [10] → [20]
```

맨 뒤에 삽입
====

```cpp
void insertBack(Node** head, int value){
    Node* newNode = createNode(value);

    if(*head == NULL){
        *head = newNode;
        return;
    }

    Node* temp = *head;
    while(temp->next != NULL){
        temp = temp->next;
    }

    temp->next = newNode;
}
```

특정 값 삭제
===

```cpp
void deleteValue(Node** head, int value){
    Node* temp = *head;
    Node* prev = NULL;

    // 첫 노드가 삭제 대상
    if(temp != NULL && temp->data == value){
        *head = temp->next;
        delete temp;
        return;
    }

    while(temp != NULL && temp->data != value){
        prev = temp;
        temp = temp->next;
    }

    if(temp == NULL) return;

    prev->next = temp->next;
    delete temp;
}
```

리스트 출력
===

```cpp
void printList(Node* head){
    Node* temp = head;
    while(temp != NULL){
        cout << temp->data << " -> ";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
```

전체 테스트 코드(main)
===

```cpp
int main(){
    Node* head = NULL;

    insertFront(&head, 20);
    insertFront(&head, 10);
    insertBack(&head, 30);

    printList(head);
    // 10 -> 20 -> 30 -> NULL

    deleteValue(&head, 20);
    printList(head);
    // 10 -> 30 -> NULL

    return 0;
}
```

반드시 이해해야 할 핵심 개념
====

노드는 데이터 + 주소
---

```cpp
struct Node{
    int data;
    Node* next;
}
```

head는 첫 노드를 가리킴
----

```bash
head → 첫 번째 노드
```

포인터의 포인터(Node**)
----

```cpp
void insertFront(Node** head, int value)
```

&ensp;head 자체를 바꿔야 하기 때문에 필요함<br/>

&ensp;예<br/>
```bash
기존: head → [10]
삽입: head → [5] → [10]
```

&ensp;->head 값이 바뀜<br/>
&ensp;->그래서 head의 주소(Node**)를 전달<br/>
