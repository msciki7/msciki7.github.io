---
title: "선형 자료구조 - 연결 리스트"
excerpt: ""

wirter: sohee Kim
categories:
  - data structure
tags:
  - 자료구조

toc: true
toc_sticky: true

date: 2026-02-19
last_modified_at: 2026-02-22
---

개념
===

&ensp;연결 리스트는 데이터와 다음 노드의 주소를 저장해서 연결하는 구조이다.<br/>

&ensp;배열과 연결 리스트 비교<br/>

| 배열         | 연결 리스트      |
| ---------- | ----------- |
| 메모리에 연속 저장 | 흩어져 저장됨     |
| 인덱스로 접근 가능 | 순서대로 이동해야 함 |
| 크기 고정      | 크기 동적 변경    |

구조 이해
====

&ensp;노드 구조<br/>
```
[데이터 | 다음 노드 주소]
```

&ensp;전체 연결 모습<br/>
```css
[10 | * ] → [20 | * ] → [30 | * ] → NULL
```

* 첫 번째 노드: head
* 마지막 노드: next = NULL

시간 복잡도
===

| 연산     | 시간   |
| ------ | ---- |
| 탐색     | O(n) |
| 맨 앞 삽입 | O(1) |
| 중간 삽입  | O(n) |
| 삭제     | O(n) |

연결 리스트 기본 구조
===

&ensp;노드 정의<br/>
```cpp
#include <iostream>
using namesapce std;

struct Node{
    int data;
    Node *next;
};
```

노드 생성 함수
====

```cpp
Node* createNode(int value){
    Node* newNode = new Node;
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}
```

맨 앞에 삽입 (가장 기본 연산)
====

```cpp
void insertFront(Node** head, int value){
    Node* newNode = creteNode(value);
    newNode->next = *head;
    *head = newNode;
}
```

&ensp;동작 과정<br/>
&ensp;기존:<br/>
```css
head → [10] → [20]
```

&ensp;insertFront(5) 후:<br/>
```css
head → [5] → [10] → [20]
```

맨 뒤에 삽입
====

```cpp
void insertBack(Node** head, int value){
    Node* newNode = createNode(value);

    if(*head == NULL){
        *head = newNode;
        return;
    }

    Node* temp = *head;
    while(temp->next != NULL){
        temp = temp->next;
    }

    temp->next = newNode;
}
```

특정 값 삭제
===

```cpp
void deleteValue(Node** head, int value){
    Node* temp = *head;
    Node* prev = NULL;

    // 첫 노드가 삭제 대상
    if(temp != NULL && temp->data == value){
        *head = temp->next;
        delete temp;
        return;
    }

    while(temp != NULL && temp->data != value){
        prev = temp;
        temp = temp->next;
    }

    if(temp == NULL) return;

    prev->next = temp->next;
    delete temp;
}
```

리스트 출력
===

```cpp
void printList(Node* head){
    Node* temp = head;
    while(temp != NULL){
        cout << temp->data << " -> ";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
```

전체 테스트 코드(main)
===

```cpp
int main(){
    Node* head = NULL;

    insertFront(&head, 20);
    insertFront(&head, 10);
    insertBack(&head, 30);

    printList(head);
    // 10 -> 20 -> 30 -> NULL

    deleteValue(&head, 20);
    printList(head);
    // 10 -> 30 -> NULL

    return 0;
}
```

반드시 이해해야 할 핵심 개념
====

노드와 포인터
----

&ensp;노드는 데이터 + 주소

```cpp
struct Node{
    int data;  // 값
    Node* next;  // 다음 노드의 주소
}
```

&ensp;포인터의 포인터(Node**)

```cpp
void insertFront(Node** head, int value)
```

&ensp;head 자체를 바꿔야 하기 때문에 필요함<br/>

&ensp;예<br/>
```bash
기존: head → [10]
삽입: head → [5] → [10]
```

&ensp;->head 값이 바뀜<br/>
&ensp;->그래서 head의 주소(Node**)를 전달<br/>

head와 노드들의 연결
----

&ensp;head는 첫 노드를 가리킴

```bash
head → 첫 번째 노드
```

&ensp;예를 들어 리스트가 이렇게 있다고 하면<br/>
```css
head ──► [10|next] ──► [20|next] ──► [30|NULL]
```

* `head`는 첫 번째 노드(10)의 주소를 저장하는 포인터
* 마지막 노드의 `next`는 NULL (더 이상 없음)

```css
head = 0x100

0x100: [10 | 0x200]
0x200: [20 | 0x300]
0x300: [30 | NULL]
```

printList에서 포인터가 움직이는 과정
----

```cpp
Node* temp = head;
while(temp != NULL){
    cout << temp->data;
    temp = temp->next;
}
```

&ensp;동작 그림<br/>

&ensp;시작<br/>
```css
temp ──► [10] ──► [20] ──► [30] ──► NULL
```

&ensp;1회 반복 후<br/>
* 출력: 10
* `temp = temp->next;`

```css
temp ─────────► [20] ──► [30] ──► NULL
```

&ensp;2회 반복 후<br/>
* 출력: 20

```css
temp ─────────────────► [30] ──► NULL
```

&ensp;3회 반복 후<br/>
* 출력: 30

```css
temp ───────────────────────► NULL
```

insertFront(맨 앞 삽입)에서 "head가 왜 바뀌는지"
----

&ensp;초기 리스트:<br/>
```css
head ──► [10] ──► [20] ──► NULL
```

&ensp;`insertFront(&head, 5)` 를 한다고 하자<br/>

&ensp;(1) newNode 생성<br/>
```css
newNode ──► [5 | NULL]
head    ──► [10] ──► [20] ──► NULL
```

&ensp;(2) newNode->next = head<br/>
&ensp;새 노드가 기존 첫 노드를 가리키게 함<br/>
```css
newNode ──► [5 |  ───────┐ ]
                     ▼
head    ──► [10] ──► [20] ──► NULL
```

&ensp;(3) head = nexNode<br/>
&ensp;head가 이제 새 노드를 첫 노드로 가리킴<br/>
```css
head ──► [5] ──► [10] ──► [20] ──► NULL
```

&ensp;결론: 맨 앞 삽입은 head 자체가 바뀌는 작업이라서 `Node**`가 필요<br/>

&ensp;(4) 왜 Node**(포인터의 포인터)가 필요?<br/>
&ensp;1. Node* head를 함수에 그냥 넘기면?<br/>
```cpp
void insertFront(Node* head, int v) { ... }
```

&ensp;이 경우 함수는 `head`의 복사본을 받는다.<br/>

```css
main의 head ──► [10] ─► [20]

함수 안 head(복사본) ──► [10] ─► [20]
```

&ensp;함수 안에서 head를 바꿔도 복사본만 바뀌고 main의 head는 그대로<br/>

&ensp;2. Node** head를 넘기면?<br/>
```css
void insertFront(Node** head, int v) { ... }
```

&ensp;이건 main의 head 변수 자체의 주소를 받는 것<br/>

```
main의 head 변수 (주소: 0xAAA) = 0x100(첫 노드 주소)

함수는 0xAAA를 알고 있음 → *head를 바꾸면 main의 head가 바뀜
```

* `head`(Node **)는 head 변수의 주소
* `*head`(Node*)는 첫 노드의 주소
* `(*head)->data`는 첫 노드의 데이터

&ensp;이 3단계가 연결 리스트의 핵심<br/>

deleteValue에서 prev / temp가 움직이는 그림
----

&ensp;리스트:<br/>
```css
head ─► [10] ─► [20] ─► [30] ─► NULL
```

&ensp;20를 지우고 싶다.<br/>

&ensp;초기<br/>
```css
prev = NULL
temp ─► [10] ─► [20] ─► [30]
```

&ensp;루프 1번:<br/>
* prev = temp(prev가 10 가리킴)
* temp = temp->next(temp가 20 가리킴)

```
prev ─► [10] ─► [20] ─► [30]
temp ─────────► [20] ─► [30]
```

&ensp;이제 temp->data==20이니까 삭제:<br/>

```cpp
prev->next = temp->next;
```

* prev(10)의 next가 temp(20)의 다음(30)을 가리키게 바뀜

```css
head ─► [10] ─────────► [30] ─► NULL
          (20은 끊김)
temp ─► [20] ─► [30]  (하지만 이제 리스트에서는 분리됨)
```

&ensp;그 다음<br/>
```css
delete temp;
```

&ensp;-> 20 노드 메모리 해제

연결 리스트에서 헷갈리는 케이스 2개
---

&ensp;케이스 1: 빈 리스트에 insertBack<br/>
```cpp
head = NULL
```

&ensp;이때는 끝까지 이동이 아니라<br/>
```cpp
head = newNode
```

&ensp;로 바로 넣어야 함<br/>

&ensp;케이스 2: 첫 노드르 삭제<br/>
&ensp;삭제 대상이 head라면<br/>
```cpp
head = head->next
```

&ensp;로 head가 다음으로 넘어가야 함<br/>
&ensp;그래서 deleteValue에서 첫 노드가 삭제 대상인지를 먼저 검사했던 것<br/>

1. `head`는 첫 노드 주소를 지정한다.
2. `next`는 다음 노드 주소를 저장한다.
3. 삽입/삭제는 주소 연결을 바뀌는 작업이다.
4. head가 바뀌는 연산을 `Node**`가 필요하다.