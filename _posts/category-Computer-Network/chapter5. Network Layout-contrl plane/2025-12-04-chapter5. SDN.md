---
title: "chapter5-5. Network Layer: SDN control plane"
excerpt: ""

writer: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-12-04
last_modified_at: 2025-12-04
---

&ensp;Control Plane 로드맵에서 SDN이 등장하는 이유<br/>
&ensp;Control plane은 라우터가 포워딩 테이블을 만들고 업데이트하는 두뇌 부분이다. 기존 방식은 OSPF, BGP 같은 routing protocol로 각 라우터가 스스로 계산한다.<br/>
&ensp;그런데 여기서 문제가 생긴다.<br/>
* 너무 복잡함(라우터마다 설정 다 해야 함)
* 중간중간 middebox(방화벽, NAT, 로드밸런서) 때문에 네트워크가 점점 더 난잡해짐
* ISP 네트워크가 커지면서 라우터마다 따로 계산하는 구조가 비효율적

&ensp;그래서 2005년쯤 "이거 새로 생각해보자" 하는 흐름이 생김 → 이게 바로 SDN.<br/>

기존 방식: Per-router Control Plane
====

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-29.png" width="500"></p>

&ensp;구조 특징<br/>
* 각 라우터가 자신만의 라우팅 알고리즘을 실행함
    - 자기 neighbor들과 정보 교화하면서 routing table 계산
    - OSPF, RIP, BGP 등
* 각각이 독립적인 두뇌를 가짐 → 분산 제어

&ensp;단점<br/>
* 하나하나 설정해야 해서 관리 어려움
* 잘못 설정하면 라우팅 루프 같은 치명적 문제 발생
* 트래픽 엔지니어링(Traffic Engineering)이 어려움(ex: 특정 흐름만 빨리 보내고 싶어도, 라우터들에게 일일이 규칙 넣어야 함)

SDN
====

&ensp;**SDN(Software-Defined Networking)**은 기존 구조와 정반대 개념<br/>

&ensp;SDN의 핵심 아이디어<br/>

> Control Plane을 중앙 컨트롤러로 빼버리고, 라우터를 멍청하게 만들자.

* 모든 라우터는 데이터 플레인만 수행(packet forwarding만 함)
* Control Plane은 중앙의 Remote Controller가 담당

## Per-router Control Plane vs SDN Control Plane

&ensp;기존 Per-router 구조<br/>
* 각 라우터 안에 Routing Algorithm이 있음
* 라우터들까리 상호 정보 교환
* 각자 자신의 Forwarding Table 계산

&ensp;→ 라우터가 똑똑함 / 관리자는 힘듦<br/>

## SDN Control Plane 구조

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-30.png" width="500"></p>

* 중앙 SDN Controller가 네트워크 전체를 보고 테이블 계산
* 계산된 테이블을 각 라우터(스위치)에 설치(install) 함
* 라우터는 단순히 테이블에 따라 forward만 수행

&ensp;→ 라우터는 단순함 / 관리자는 매우 편해짐<br/>

&ensp;SDN이 왜 "논리적으로 중앙화된(logically centralized)"가 되는가?<br/>
&ensp;실제로 컨트롤러는 여러 대일 수 있지만 동작 관점에서 하나처럼 보이는 것을 의미함<br/>
&ensp;SDN의 장점<br/>
&ensp;1. 네트워크 관리가 훨씬 쉬움<br/>
* 사람이 일일이 라우터 들어가 설정할 필요 없음
* 컨트롤러에서 한 번 설정하면 전체 반영됨
* misconfiguration(설정 실수) 줄어듦

&ensp;2. 트래픽 흐름을 유연하게 제어 가능<br/>
&ensp;예: 1번 서버 → 3번 서버 트래픽은 빠른 경로, 2번 서버 → 4번 서버 트래픽은 저렴한 경로 사용<br/>
&ensp;기존 라우팅 프로토콜로는 거의 불가능한 일<br/>

&ensp;3. 테이블 기반의 프로그래밍 가능 (OpenFlow API)<br/>
* 만약 패킷 헤더가 X면 포트 2로 보내라
* 이런 규칙을 컨트롤러가 직접 설치함
* 라우터를 프로그래밍할 수 있음

&ensp;4. 오픈 표준 기반<br/>
* Cisco 같은 제조사 OS 의존 없어짐
* 누구나 컨트롤러를 개발할 수 있음 → 혁신 증가

&ensp;Per-router vs SDN<br/>

| 항목               | Per-router Control Plane | SDN Control Plane    |
| ---------------- | ------------------------ | -------------------- |
| Control Plane 위치 | 라우터 내부                   | 중앙 컨트롤러              |
| 라우팅 계산 방식        | 분산(distributed)          | 중앙집중(centralized)    |
| 라우터 역할           | 똑똑함 (계산 + 포워딩)           | 멍청함 (포워딩만 함)         |
| 관리               | 어려움 (각각 설정)              | 쉬움 (중앙에서 통합 관리)      |
| 커스터마이징           | 불가(벤더 종속)                | 가능 (OpenFlow로 프로그래밍) |
| 트래픽 엔지니어링        | 제한적                      | 매우 유연                |

&ensp;SDN 비유: 메인프레임 → PC 혁명<br/>
&ensp;기존 네트워크(= 메인프레임 시대)<br/>
* 장비(라우터)가 하드웨어 + 운영체제 + 기능(라우팅/방화벽 등)이 모두 묶여 있는 구조
* 폐쇄적(closed), 벤더 종속(proprietary)
* 기능을 변경하거나 새로운 서비스를 만들기 매우 어려움
* 시장도 작고 혁신도 느림

&ensp;SDN 이후 네트워크(= PC 시대)
&ensp;PC는<br/>
* 누구나 CPU(개방형 HW)를 쓰고 
* 그 위에 Windows/Linux/MacOS 같은 개방형 OS를 올리고 
* 누구나 이 앱을 만들어 올릴 수 있었지? → 이 구조 덕분에 폭발적 혁신이 일어났고 IT 시장 자체가 커졌음.

&ensp;SDN도 똑같은 길을 감<br/>
* 라우터 하드웨어는 단순한 "포워딩 장치"로 만들고
* Control Plane(두뇌)은 **소프트웨어(컨트롤러)**에서 실행
* 인터페이스(OpenFlow 등)을 "개방형"으로 제공

&ensp;결과:<br/>
* 누구나 새로운 네트워크 기능을 개발할 수 있음
* 혁신 속도 증가
* 네트워크 시장 자체가 커짐

### 트래픽 엔지니어링이 기존 라우팅에서 어려운 이유

&ensp;첫 번째 문제: 특정 경로로 트래픽을 보내고 싶을 때<br/>
&ensp;예: 운영자가 u → z로 가는 트래픽을 uvwz 경로로 보내고 싶다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-31.png" width="500"></p>
 
&ensp;하지만 전통적인 라우팅 알고리즘은<br/>
* 링크 가중치(link weight)
* 목적지 기반 라우팅

&ensp;만 사용함<br/>

&ensp;문제점<br/>
* 우리가 원하는 경로를 쓰게 하려면 링크 weight를 바꿔서 알고리즘을 속여야 함
* weight 조정은 전체 네트워크 경로에 영향을 줌 → 부작용 많음
* 결국 원하는 대로 흐름 제어하기 거의 불가능

&ensp;결론: link weight는 “조절 가능한 손잡이(knob)”가 너무 부족하다.<br/>

&ensp;두 번째 문제: 트래픽을 여러 경로로 나누고 싶을 때<br/>
&ensp;예: u → z 트래픽을 일부는 uvwz, 일부는 uxyz로 로드밸런싱하고 싶다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-32.png" width="500"></p>

&ensp;전통적 라우팅에서는 불가능<br/>
* 목적지가 같으면 항상 최단 경로 하나만 선택함(Equal-cost multi-path는 있지만 제한적)
* 두 경로가 cost가 다르면 절대 나눠지지 않음

&ensp;결론: 로드밸런싱도 매우 어렵다.<br/>

&ensp;세 번째 문제: 트래픽 종류(blue/red)에 따라 다른 경로로 보내고 싶을 때<br/>
&ensp;예: 노드 w가 빨간 트래픽 → 경로 A, 파란 트래픽 → 경로 B 로 보내고 싶다고 하자.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-33.png" width="500"></p>

&ensp;전통적인 라우팅 특징<br/>
* 목적지 기반(destination-based) 라우팅
* 목적지가 같으면 경로가 무조건 동일해야 함
* 패킷의 색(종류)에 따라 라우팅을 차별하는 기능 없음

&ensp;Traffic class-based routing은 절대 불가능<br/>

&ensp;전통적 라우팅 알고리즘(LS, DV)은<br/>
* 목적지만 보고 경로 선택
* 패킷별 정책 라우팅 불가능
* 유연성 제로

&ensp그래서 traffic Engineering(TE)작업을 하려면<br/>
* weight 변경 → 네트워크 전체 영향을 줘서 위험
* 기능 자체가 안 되는 경우도 많음

&ensp;→ 운영자는 원하는 흐름 제어를 거의 못함<br/>

&ensp;SDN이 이 문제를 모두 해결한다.<br/>
&ensp;SDN과 generalized forwarding을 이용하면 원하는 어떤 라우팅 정책이든 만들 수 있다.<br/>
&ensp;왜냐하면 컨트롤러가 포워딩 테이블을 직접 설치하기 때문이다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-34.png" width="500"></p>

&ensp;(1) generalized "flow-based" forwarding<br/>
* 기존 라우터: "목적지 주소"만 보고 경로 결정
* SDN 스위치: 패킷의 여러 필드(헤더 값 전체)를 보고 하나의 flow로 분류
* 즉 flow table을 사용해 더 유연한 forwarding 수행 가능
* 예:
    - TCP port = 443 인 흐름만 특정 경로로 보내기
    - 영상 스트리밍 트래픽만 따로 라우팅하기
    - 빨간/파란 트래픽 분리하기

&ensp;전통적 라우팅 ≠ SDN forwarding<br/>
&ensp;SDN이 강력해지는 기반 기술<br/>

&ensp;(2) control plane ↔ data plane 분리<br/>
* 스위치(라우터): forwarding만 함 → "행동하는 팔"
* 컨트롤러: forwarding table 계산 → "두뇌 역할"

&ensp;기존 라우터에서 한 장비가 모두 하던 일을 → SDN에서는 두뇌와 팔을 분리한 것<br/>
&ensp;덕분에<br/>
* 네트워크의 모든 forwarding 정책을 중앙에서 통합적으로 관리
* 실수 줄고, 네트워크 전체 최적화 가능

&ensp;(3) control plane 기능이 스위치 밖으로 이동<br/>
* 기존 router 내부에 있던 Routing Algorithm이 → 컨트롤러로 완전히 이동
* 스위치는 단순화 → 빠르고 싸지고 대량 생산 가능

&ensp;이것이 네트워크를 PC 구조처럼 수평화(horizontal)시키는 이유<br/>

&ensp;(4) programmable control applications<br/>
&ensp;컨트롤러 위에서 앱처럼 실행되는 네트워크 프로그램을 말함<br/>
* routing app
* access control app (방화벽/ACL)
* load balancer
* TE(트래픽 엔지니어링) 앱
* QoS 앱

&ensp;이제 네트워크 기능은 "박스(라우터)"가 아니라 소프트웨어 앱이 제공한다는 개념<br/>
&ensp;→ 이것이 SDN에서 가장 혁신적인 부분<br/>
&ensp;→ 제 3자(3rd party)도 앱을 만들 수 있어 혁신 속도 증가<br/>

### Data Plane Switches

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-35.png" width="500"></p>

&ensp;**SDN의 스위치는 이렇게 동작함:**<br/>
* 빠르고 단순함
* 오직 flow table 기반으로 forwarding
* flow table은 컨트롤러가 설치

&ensp;중요한 점:<br/>
* 스위치는 "계산하지 않는다" (forwarding table을 스스로 만들지 않음 → 모든 계산은 컨트롤러에서 수행)
* 스위치는 OpenFlow API 같은 프로토콜로 컨트롤러와 통신 (컨트롤러가 "이 flow는 포트 3으로 보내라"라고 명령, 스위치는 명령만 실행)

&ensp;data plane은 완전히 단순화함<br/>

### SDN Controller (Network OS)

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-36.png" width="500"></p>

&ensp;컨트롤러는 SDN의 핵심<br/>
&ensp;컨트롤러가 하는 일<br/>
&ensp;(1) network state 유지<br/>
* 모든 링크 상태
* 스위치 상태
* 호스트 정보
* 통계

&ensp;즉 "네트워크 전체 지도를 항상 최신으로 유지"<br/>

&ensp;(2) 윗단(network-control apps)과 소통 → northbound API<br/>
* 예: REST API, network graph API, intent API
* 앱들이 컨트롤러에게 “이런 정책 적용해줘”라고 요청하는 통로

&ensp;(3) 스위치들과 소통 → southbound API<br/>
* 가장 대표적인 예: OpenFlow

&ensp;스위치에게<br/>
* flow table 설치
* 삭제
* 수정<br/>
&ensp;요청을 보냄.<br/>

&ensp;(4) 분산 시스템으로 구현됨<br/>
&ensp;왜냐하면:<br/>
* 네트워크는 매우 큼
* 장애가 발생해도 복구해야 하고
* 확장성 필요

&ensp;따라서 단일 서버가 아니라 여러 서버가 컨트롤러 역할을 나눠 가짐.<br/>

### Network-control Apps

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-37.png" width="500"></p>

&ensp;이 앱들이 SDN의 진짜 '지능' 역할을 함.<br/>
* routing app
* access control app
* load balancer
* firewall
* TE optimization 앱
* 보안 앱

&ensp;핵심 특징<br/>
* 앱은 컨트롤러가 제공하는 API를 통해 동작
    - 네트워크를 직접 제어하지 않음
    - 컨트롤러를 통해 제어
* unbundled(언번들된 구조)
    - 전통적으로 모든 기능은 라우터 제조사가 제공
    - SDN에서는 누구나 앱 개발 가능

&ensp;즉 라우팅 기능을 Cisco나 Juniper가 아니라, 3rd-party 앱 개발자가 제공할 수도 있음<br/>

### Components of an SDN Controller

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-38.png" width="500"></p>

&ensp;1. Interface layer (앱을 위한 API 계층)<br/>
* network graph
* RESTful API
* intent system

&ensp;→ 앱 개발자가 SDN을 쉽게 사용할 수 있게 함<br/>

&ensp;2. Network-wide state management (네트워크 상태 저장소)
* statistics (통계)
* link-state info
* host info
* switch info
* flow table info

&ensp;이 모든 정보를 저장하는 분산 데이터베이스가 컨트롤러의 핵심<br/>

&ensp;3. Communication layer (OpenFlow/SNMP 등)<br/>
* 스위치와 통신
* flow table 설치
* 상태 보고 받기

OpenFlow Protocol
----

&ensp;OpenFlow의 특징<br/>
&ensp;컨트롤러와 스위치 사이에서 동작<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-39.png" width="500"></p>

&ensp;컨트롤러가 스위치에게<br/>
* Flow table을 설치, 삭제
* 패킷을 처리하는 법 지시

&ensp;스위치는 컨트롤러에게<br/>
* 패킷 통보
* 포트 상태 보고

&ensp;메시지는 TCP로 전달<br/>
&ensp;기본적으로 TCP 사용<br>
* 필요하면 TLS(암호화) 추가 가능

&ensp;메시지 유형 3가지<br/>


| 종류                       | 방향         | 설명                  |
| ------------------------ | ---------- | ------------------- |
| **controller-to-switch** | 컨트롤러 → 스위치 | 스위치 설정·명령           |
| **asynchronous**         | 스위치 → 컨트롤러 | 이벤트/상태 변화 알림        |
| **symmetric**            | 양방향        | 헬로(hello) 같은 기본 메시지 |

&ensp;OpenFlow API와 protocol은 다름<br/>
* OpenFlow API: flow rule을 어떻게 정의하는지 (프로그래밍 인터페이스)
* OpenFlow protocol: 컨트롤러 ↔ 스위치 메시지 전송 방식

&ensp;둘은 목적이 다름<br/>

### Controller → Switch 메시지

&ensp;주요 controller-to-switch 메시지<br/>
&ensp;1) `features` <br/>
* 컨트롤러가 스위치에게 너 어떤 기능 지원해
* 스위치는 자신의 포트 정보, flow table 크기 등 기능을 답함

&ensp;2) `configure` <br/>
* 스위치의 설정(config)을 읽거나 변경 (예: 테이블 timeout 값 설정, 포트 동작 방식 설정)

&ensp;3) `modify-state` <br/>
&ensp;flow table 항목을 추가/삭제/수정 하는 메시지 = 우리가 흔히 말하는 flow-mod 메시지<br/>
&ensp;이 메시지로 컨트롤러는:<br/>
* 특정 흐름을 특정 경로로 보내라
* 특정 패킷은 drop하라
* NAT 정책을 적용하라

&ensp;4) `packet-out` <br/>
&ensp;컨트롤러가 스위치에게 이 패킷을 특정 포트로 작접 내보내라 라고 지시하는 메시지<br/>

### Switch → Controller 메시지

&ensp;이제 스위치가 컨트롤러에게 보내는 보고(report) 메시지들<br/>

&ensp;주요 switch-to-controller 메시지<br/>
&ensp;1) `packet-in`<br/>
&ensp;스위치가 flow table에 매칭되는 규칙이 없을 때: <br/>
* "이 패킷 어떻게 처리할까요?" 하고 컨트롤러에게 패킷을 전달하는 메시지

&ensp;SDN 흐름은 대부분 packet-in → controller’s decision → flow-mod 패턴으로 시작함.<br/>

&ensp;2) `flow-removed` <br/>
&ensp;스위치에게 flow entry가 삭제되면 → 컨트롤러에게 통보<br/>

&ensp;3) `port-status` <br/>
&ensp;스위치 포트에 변화가 있을 때 (링크 다운/업 등) → 컨트롤러에게 알려줌<br/>
&ensp;이 메시지는 SDN 네트워크의 "센서 역할" 같은 것<br/>

&ensp;SDN Control/Data Plane Interaction: 흐름 예시<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-40.png" width="500"></p>

&ensp;전체 흐름 요약: 링크 장애 발생 → 컨트롤러 감지 → 라우팅 앱 재계산 → 새로운 flow table 배포<br/>

&ensp;단계별 설명<br/>
&ensp;1. S1에서 링크 장애 발생 → port-status 메시지 전송<br/>
&ensp;스위치 S1이:<br/>
* 연결된 링크가 다운됨을 감지
* OpenFlow port-status 메시지로 컨트롤러에게 통보

&ensp;2. 컨트롤러는 해당 이벤트를 수신하고, 내부 DB의 link-state 정보 업데이트<br/>
&ensp;컨트롤러 내부 구성요소 중:<br/>
* link-state info
* switch info

&ensp;이 부분이 갱신됨<br/>

&ensp;3. 라우팅 애플리케이션이 이 이벤트를 감지하고 실행됨<br/>
&ensp;예: Dijkstra’s link-state routing 앱<br/>
&ensp;컨트롤러는 이벤트 기반:<br/>
* 링크 상태가 바뀌면 라우팅 앱이 호출되도록 등록(register)되어 있음

&ensp;4. 라우팅 앱은 네트워크 그래프와 link-state info를 읽고 새로운 라우팅 계산 수행<br/>
&ensp;새로운 최적 경로를 계산한다.<br/>

&ensp;5. 라우팅 앱은 'flow table 계산 컴포넌트'와 상호작용하여 새 flow table 생성<br/>
&ensp;라우트 계산 결과를 바탕으로<br/>
* 각 스위치에 어떤 flow rule이 설치되어야 하는지 계산

&ensp;6. 컨트롤러는 OpenFlow modify-state 메시지(flow-mod)를 이용해 각 스위치의 flow table 업데이트<br/>
* 필요한 스위치들에 새 규칙 설치
* 장애가 없는 경로로 트래픽이 자동 전환됨

OpenDaylight(ODL) Controller
----

&ensp;OpenDaylight(ODL)은 대표적인 오픈소스 SDN 컨트롤러 프레임워크이다. SDN의 핵심 목표인 **네트워크 제어의 중앙화 + 프로그램 가능성** 을 제대로 구현한 플렛폼이다.<br/>

&ensp;ODL 구조 한눈에 보기<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-41.png" width="500"></p>

&ensp;1. Northbound API — 위로 노출되는 인터페이스<br/>
&ensp;응용 프로그램(Traffic Engineering, Firewalling, Load Balancing 등)이
컨트롤러와 대화하는 REST/RESTCONF/NETCONF API 계층이다. 즉 개발자는 이 API를 이용해
"네트워크를 이렇게 동작시키고 싶다!" 라는 정책을 컨트롤러에게 전달하는 것이다.<br/>

&ensp;asic Network Functions — 기본 서비스<br/>
&ensp;ODL 내부에서 제공하는 핵심 기능들:<br/>
* Topology processing: 네트워크 전체 지도를 그려서 어떤 스위치/링크가 있는지 파악
* Switch Manager: 스위치들의 상태 관리
* Statistics Manager: 네트워크 트래픽, 포트 사용량 등 수집
* Forwarding Rules Manager: 플로우 테이블 관리 (어디로 포워딩할지 규칙 결정)
* Host Tracker: 네트워크에 어떤 호스트가 있는지 관리

&ensp;3. Enhanced Services — 확장 기능<br/>
&ensp;AAA(인증/권한관리) 같은 추가 네트워크 서비스도 제공할 수 있다.<br/>
&ensp;ODL은 모듈식이기 때문에 원하는 기능을 계속 붙일 수 있다는 특징이 있다.<br/>

&ensp;4. Service Abstraction Layer (SAL)<br/>
&ensp;SAL 수행하는 내용<br/>
* 남쪽의 다양한 프로토콜들(OpenFlow, NETCONF, SNMP, OVSDB)을 하나의 공통 인터페이스로 추상화
* 위쪽(Basic Functions, Applications)에서 프로토콜 차이를 신경쓰지 않도록 해줌

&ensp;컨트롤러는 여러 종류의 스위치를 제어해야 하는데 스위치마다 지원하는 프로토콜이 다르다.<br/>
&ensp;SAL이 중간에서 통일된 인터페이스를 제공해 주므로 컨트롤러 개발자는 스위치마다 다른 프로토콜에 신경 쓸 필요가 없게 되는 것이다.<br/>

ONOS Controller
----

&ensp;ONOS(Open Network Operating System)는 ODL과 마찬가지로 유명한 SDN 컨트롤러지만 **대규모 네트워크(통신사, 백본망)**에 좀 더 초점을 둔다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-42.png" width="500"></p>

&ensp;ONOS의 큰 특징 3가지<br/>
&ensp;1. Control Apps 가 Controller와 분리됨<br/>
&ensp;ONOS는 컨트롤러 코어와 애플리케이션을 완전히 분리해서 관리한다. 즉, 네트워크 기능(방화벽, TE 등)은 독립적인 앱으로 동작한다.<br/>

&ensp;2. Intent Framework — ONOS의 가장 중요한 차별점<br/>
&ensp;Intent는 "무엇을 할지(WHAT)"만 말하면 되고, "어떻게(HOW)"는 ONOS가 알아서 결정하는 방식이다.<br/>
&ensp;예를 들면:<br/>
* 개발자: "Host A와 Host B를 연결해 주세요."
* ONOS: "좋아, 최적 경로 계산하고 설치할게!"

&ensp;사람이 정책만 지정하면, ONOS가 최적 경로, 플로우 설치, 장애 처리까지 자동으로 수행함<br/>

&ensp;3. Distributed Core — 분산 시스템으로 설계됨<br/>
&ensp;여러 대의 컨트롤러가 협력해서 동작하도록 설계됨<br/>
&ensp;장점:<br/>
* 장애에 강함(fault-tolerant)
* 트래픽 많아도 잘 견딤(scalable)
* 통신사 레벨에서 신뢰성 확보

Internet Control Message Protocol 
====

&ensp;ICMP(Internet Control Message Protocol) 핵심 개념<br/>
&ensp;ICMP는 왜 필요한가?<br/>
&ensp;IP는 최선을 다해 전달(best-effort)만 제공해서 패킷이 사라지면 왜 사라졌는지 알려주지 않는다.<br/>
&ensp;그래서 라우터와 호스트가 네트워크 오류를 서로에게 알려주는 메커니즘이 필요함 → ICMP 등장<br/>

## ICMP가 하는 일 (시험 핵심)

&ensp;1. Error Reporting (오류 보고)<br/>
&ensp;예를 들어:<br/>
* 목적지 네트워크 없음
* 목적지 호스트 없음
* 목적지 포트 없음
* 프로토콜 지원 안 함
* TTL 만료(라우팅 루프 etc)

&ensp;IP가 실패하면 왜 실패했는지 알려주는 프로토콜<br/>

&ensp;2. Echo Request / Echo Reply (Ping 용)<br/>
&ensp;PING이 바로 이 ICMP 메시지를 사용함:<br/>
* Echo Request(Type 8)
* Echo Reply(Type 0)

&ensp;ICMP 메시지 구조<br/>

> Type + Code + (오류의 원인이 된 IP 헤더 + 첫 8바이트)

&ensp;오류가 났을 때 어떤 패킷 때문에 오류가 난 것인지 그 패킷의 앞 부분을 그대로 포함해서 보내줌<br/>

&ensp;자주 쓰는 ICMP 메시지<br/>

| Type | Code | 의미                                   |
| ---- | ---- | ------------------------------------ |
| 0    | 0    | Echo reply (ping 응답)                 |
| 3    | 0    | 네트워크 unreachable                     |
| 3    | 1    | 호스트 unreachable                      |
| 3    | 3    | 포트 unreachable (traceroute 마지막에서 사용) |
| 8    | 0    | Echo request (ping 요청)               |
| 11   | 0    | TTL expired (라우터가 TTL=0 되어 버림)       |
| 12   | 0    | Bad IP header                        |

## Traceroute와 ICMP – 실제 동작 흐름

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-43.png" width="500"></p>

&ensp;Traceroute는 "패킷이 목적지까지 어떤 경로를 지나가는지" 확인하는 도구이다.<br/>
&ensp;Traceroute가 사용하는 핵심 원리는 매우 단순함<br/>

> TTL을 1부터 하나씩 증가시키며 보내고 라우터가 TTL=0되어 버린 패킷을 버리면서 보내는 ICMP 메시지를 이요해 각 홉의 정보를 알아내는 것

&ensp;Traceroute 동작 절차<br/>
&ensp;1번째 세트: TTL = 1<br/>
&ensp;출발지 → 첫 번째 라우터 도착<br/>
&ensp;라우터에서 TTL=0 → 패킷 버림 → ICMP "TTL expired(Type 11)" 응답<br/>
&ensp;→ "첫 번째 라우터는 ○○○○(IP)" 라는 정보를 얻는다.<br/>
&ensp;→ RTT도 계산할 수 있음<br/>

&ensp;2번째 세트: TTL = 2<br/>
&ensp;이번엔 두 번째 라우터까지 도달. 두 번째 라우터가 TTL = 0을 만들어 버리므로 다시 "TTL expired" IMCP를 다시 보낸다.<br/>

&ensp;이런 식으로 TTL = n 까지 증가<br/>
&ensp;각 홉에 대해 라우터가 ICMP 메시지를 돌려주므로 인터넷 경로를 눈으로 관찰할 수 있게 된다.<br/>

&ensp;Traceroute의 마지막 단계: 목적지 도착 시<br/>
&ensp;UDP 패킷은 매우 큰 포트 번호(예: 33434~) 로 보내진다. 대부분의 서버는 이 포트가 열려 있지 않으므로, → 목적지 호스트가 ICMP Type 3 Code 3 (port unreachable) 을 보낸다. 이 메시지를 받으면 traceroute는 다음을 판단한다.: 목적지에 도착했구나 종료<br/>
