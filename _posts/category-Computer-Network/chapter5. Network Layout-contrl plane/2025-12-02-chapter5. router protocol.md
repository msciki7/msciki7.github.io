---
title: "chapter5-2. Network Layer: router protocol"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-12-02
last_modified_at: 2025-12-02
---

routing protocols
====

## Routing protocol이 하는 일

&ensp;Routing protocol이란?<br/>
* forwarding = 이미 정해진 표(포워딩 테이블)를 보고 패킷을 옮기는 일
* routing = 그 “표” 자체를 어떻게 채워 넣을지 계산하는 일

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-3.png" width="500"></p>

&ensp;**Routing protocol = 라우터들이 서로 정보를 주고받으면서 좋은 경로를 찾아내는 규칙/알고리즘**<br/>

&ensp;Routing protocol goal<br/>
&ensp;송신 호스트에서 수신 호스트까지 가는 좋은 경로(good path)를 결정하는 것<br/>

* path(경로)
    - 패킷이 지나가는 라우터들의 순서
    - 예: 집 → 학교근처라우터 → 서울백본라우터 → 학교라우터 → 목적지PC
* good path?
    - least cost: 비용이 가장 적음
        + 비용 = 거리, 지연시간, 돈(통신 사업자 입장) 등으로 정의 가능
    - fastest: 가장 빨리 도착
    - least congested: 덜 막힘(혼잡이 적음)

&ensp;실제로는 이 셋을 조합해서 비용(cost)라는 숫자로 표현해 놓고 총 cost가 최소가 되게 경로를 선택하는 게 목표<br/>

## 그래프 추상화: 링크 비용

&ensp;이제 네트워크를 수학 문제처럼 단순한 그림으로 바꾸는 작업을 한다. 그게 바로 그래프(graph) 추상화이다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-4.png" width="500"></p>

&ensp;그래프?<br/>
* 정점(node) + 간선(edge) 로 이루어진 그림
* N: 라우터 집합 = { u, v, w, x, y, z } → 각각 하나의 라우터를 의미
* E: 링크 집합 = { (u,v), (u,x), (v,x), ... } → 두 라우터 사이에 실제로 물리적인 선(케이블/무선)이 존재한다는 뜻

&ensp;라우터 = 동그라미, 링크 동그라미 사이를 잇는 선이라고 생각하면 된다.<br/>

&ensp;Link cost란?<br/>
> 라우터 a와 b를 직접 연결하는 링크의 cost(비용)

&ensp;예<br/>
* $C_{w, z} = 5$ → 라우터 w와 z 사이 링크의 비용이 5
* $C_{u, z} =  \infty$ → u와 z 사이에는 직접 연결된 선이 없다고 보면 됨

&ensp;이 cost값은 네트워크 운영자 마음대로 정할 수 있음<br/>
* 항상 1로 돌 수 있고
* 대역폭이 클수록 cost를 작게
* 혼잡이 심할수로 cost를 크게

## Routing algorithm 분류

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-5.png" width="500"></p>

1. 가로축: global vs decentralized 정보
    - 위쪽(글로벌, global) → 모든 라우터가 네트워크 전체 지도를 안다
    - 아래쪽(분산, decentralized) → 자기 주변(이웃 라우터들) 정보만 알고 시작해서 서로 조금씩 정보 교환하면서 경로를 알아감
2. 세로축: static vs dynamic
    - 왼쪽(static) → 경로가 잘 안 변한다. 네트워크 상황 변화 느림
    - 오른쪽(dynamic) → 경로가 자주/빠르게 변한다. 링크 비용 변화에 따라 주기적 업데이트 필요

&ensp;**Link state vs Distance vector 위치**<br/>
&ensp;Link state 알고리즘 (위쪽 global)<br/>
* 모든 라우터가 네트워크 전체 토폴로지(그림) + 링크 cost를 안다.
* 그러면 각 라우터는 자기 혼자서 최단 경로 알고리즘(예: 다익스트라)을 돌려서 각 목적지까지의 최단 경로를 계산할 수 있음
* 정보는 global이지만 계산은 각 라우터가 개별적으로 수행

&ensp;Distance vector 알고리즘 (아래쪽 decentralized)<br/>
* 초기에는 라우터가 자기와 직접 연결된 이웃끼리의 cost만 안다.
* 이후에
    - 이웃과 내가 아는 최단 거리표를 서로 주고받고
    - 그걸 바탕으로 조금씩 경로를 업데이트하는 방식
* 전체 지도를 한 번에 아는 게 아니라 **이웃들과 대화하면서 점점 더 멀리 있는 목적지까지의 비용을 알아가는 구조**

&ensp;**Static vs Dynamic과의 관계**<br/>
&ensp;실제 인터넷에서는 링크 비용이 바뀔 수 있기 때문에 대부분의 실제 라우팅 프로토콜은 dynamic이다.<br/>
* 링크 속도가 바뀌거나
* 장애가 나서 링크가 끊기거나
* 트래픽이 몰려서 delay가 커지거나<br/>
&ensp;이럴 때 link state / distance vetor 둘 다 주기적으로 혹은 이벤트가 발생할 때 업데이트 메시지를 보내서 새로운 최단 경로를 다시 계산한다.<br/>

link state
-----

&ensp;Link State란?<br/>
&ensp;라우터들이 네트워크 전체 지도 + 각 링크의 비용(cost)을 서로에게 방송해서 모든 라우터가 똑같은 네트워크 지도를 갖게 되는 구조이다.<br/>
&ensp;모든 라우터가 전체 지도를 알고 있다.(global knowledge)<br/>
&ensp;그래서 각 라우터가 자기 자신을 기준으로 최단 경로를 직접 계산한다.<br/>

### Dijkstra 알고리즘이 하는 일

&ensp;한 라우터(u)를 기준으로:<br/>
* u에서 모든 다른 라우터까지의 최단 경로 비용을 계산
* 그리고 그 비용 기반으로 포워딩 테이블을 채움

&ensp;이해해야 하는 변수들<br/>

| 기호       | 뜻                                         |
| -------- | ----------------------------------------- |
| **cₓ,y** | x와 y 사이의 **직접 연결된 링크 비용** (연결 안 되어 있으면 ∞) |
| **D(v)** | “u → v 까지 현재까지 알려진 최단 경로 비용”              |
| **p(v)** | “v 로 가는 최단 경로 상에서 v 바로 직전에 오는 노드”         |
| **N′**   | “최단 비용이 확정된 노드 집합”                        |

&ensp;N′은 완전히 확정된 노드(더 이상 바뀌지 않는 노드)<br/>
&ensp;D(v)는 아직 확정 안 되었을 때 계속 업데이트되는 값<br/>

### Dijkstra 알고리즘 흐름

&ensp;단계 1: 초기화<br/>
&ensp;1. 시작점 u 하나만 N′에 넣기<br/>
```mathematica
N′ = {u}
```

&ensp;2. 모든 노드 v에 대해 D(v) 초기화<br/>
* u와 직접 연결된 노드 v → 비용 = c(u, v)
* 연결 안 돼 있음 → 비용 = ∞

&ensp;초기에는 u가 단순히 직접 연결된 이웃까지만 비용을 알고 있음<br/>

&ensp;단계 2: 반복(Loop)<br/>
&ensp;반복하며 다음을 수행<br/>
1. N′에 아직 안 들어간 노드 중에서 D(w)가 가장 작은 노드 w 선택 → "지금까지 가장 가깝다고 알려진 노드 확정!"
2. w를 N′에 추가 (확정)
3. w의 이웃들에게 새로운 최단 경로 후보를 계산

&ensp;공식<br/>
```mathematica
D(v) = min( D(v), D(w) + c(w,v) )
```

* 기존에 알고 있던 D(v)가 더 작으면 그대로
* w를 거쳐가는 새로운 경로 `D(w) + c(W, V)` 가 더 작으면 업데이트

&ensp;이 작업을 "모든 노드가 N′에 들어갈 때까지" 반복<br/>

### 예제

&ensp;예제 1<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-6.png" width="500"></p>

&ensp;아래 그래프에서 u → 모든 노드에 대한 최단 경로를 구하는 상황<br/>

&ensp;Step 0 (초기화)<br/>
* N′ = {u}
* u와 직접 연결된 비용:
    - D(x)=1
    - D(v)=2
    - 나머지 = ∞<br/>
&ensp;→ u는 이제 자기 주변만 알고 있음<br/>

&ensp;Step 1: x 추가<br/>
&ensp;가장 작은 D = 1 (x)<br/>
* N′ = {u, x}<br/>
&ensp;x의 이웃 업데이트:<br/>
* y: 기존 $\infty$ → x→y=1+1=2
* v: 기존 2인데 x→v는 1+2=3 → 유지
* w: $\infty$ → x→w=1+3=4

&ensp;Step 2: y 추가<br/>
&ensp;다음 작은 D = 2 (y)<br/>
* N′ = {u, x, y}<br/>
&ensp;y의 이웃 업데이트:<br/>
* v: min(2, 2+2=4) → 2 유지
* w: min(4, 2+1=3) → 3로 업데이트
* z: $\infty$ → 2+2=4

&ensp;Step 3: v 추가<br/>
&ensp;D(v) = 2<br/>
* N′ = {u, x, y, v}<br/>
&ensp;v의 이웃 업데이트:<br/>
* w: min(3, 2+3=5) → 3 유지

&ensp;Step 4: w 추가<br/>
&ensp;D(w)=3<br/>
* N′ = {u, x, y, v, w}<br/>
&ensp;w의 이웃 업데이트:<br/>
* z: min(4, 3+5=8) → 4 유지

&ensp;Step 5: z 추가<br/>
&ensp;D = 4<br/>
* N′ = 전체 노드 확정<br/>
&ensp;최종 D 값:<br/>
* v = 2 (via u)
* x = 1 (via u)
* y = 2 (via x)
* w = 3 (via y)
* z = 4 (via y)

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-7.png" width="500"></p>

&ensp;마지막 결과<br/>
&ensp;1) 최단 경로 트리<br/>
&ensp;u에서 뻗어나가는 최단 경로만 남긴 트리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-8.png" width="500"></p>

&ensp;2) 포워딩 테이블<br/>
&ensp;목적지 | u가 처음으로 보내야 할 이웃<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-9.png" width="500"></p>

&ensp;대부분 목적지로 가는 경로는 먼저 x 방향으로 나간 후 이동해야 함.<br/>

&ensp;예제 2<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-10.png" width="500"></p>

&ensp;(1) Step-by-step 최단 경로 확정 과정<br/>
&ensp;표에서<br/>
* N′ : 최단 경로 "확정(confired)"된 노드 집합
* D(v) : u → v 현재까지 알려진 최소 비용
* p(v) : 그 비용이 나오게 한 직전 노드(부모 노드, predecessor)

&ensp;전체 과정은 이전 슬라이드와 동일하지만 값만 다르게 나옴.<br/>

&ensp;Step 0 (초기화)<br/>
* N′ = {u}
* D(v)=7, D(w)=3, D(x)=5, D(y)=$\infty$ , D(z)=$\infty$ → u가 직접 연결된 비용만 먼저 알고 있음

&ensp;Step 1<br/>
&ensp;확장되지 않은 노드 중 가장 작은 비용 = 3(w)<br/>
&ensp;→ w 확정<br/>
&ensp;→ N′ = {u, w}<br/>

&ensp;그 다음 w의 이웃들 업데이트<br/>
* v: 기존 7 vs (3 + w→v=3) = 6 → 새 값 6, parent=w
* x: 기존 5 vs (3 + 3) = 6 → 그대로 5
* y: 기존 ∞ vs (3 + 8) = 11 → 업데이트 11, parent=w

&ensp;Step 2<br/>
&ensp;N′에 없는 노드 중 최소 비용 = 5(x)<br/>
&ensp;→ x 확정<br/>
&ensp;→ N′ = {u, w, x}<br/>

&ensp;x의 이웃 업데이트:<br/>
* w: 이미 확정됨
* z: 기존 ∞ vs (5 + 9) = 14 → 업데이트 14, parent=x

&ensp;Step 3<br/>
&ensp;남은 노드 중 최소 비용 = 6(v)<br/>
&ensp;→ v 확정<br/>
&ensp;→ N′ = {u, w, x, v}<br/>

&ensp;v의 이웃:<br/>
* y: 기존 11 vs (6 + 4) = 10 → 업데이트 → 10, parent=v

&ensp;step 4<br/>
&ensp;남은 노드 중 최소 = 10(y)<br/>
&ensp;→ y 확정<br/>
&ensp;→ N′ = {u, w, x, v, y}<br/>

&ensp;y의 이웃:<br/>
* z: 기존 14 vs (10 + 2) = 12 → 업데이트 → 12, parent=y

&ensp;Step 5<br/>
&ensp;남은 노드 = z(12)<br/>
&ensp;→ z 확정<br/>
&ensp;→ 끝<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-11.png" width="500"></p>

&ensp;(3) 최단 경로 트리는 predecessor 기반으로 그림<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-12.png" width="500"></p>

### Dijkstra 알고리즘 Discussion

&ensp;(1) Algorithm Complexity (알고리즘 수행 시간)<br/>
&ensp;모든 라우터는 전체 그래프 정보를 가지고 있으므로 Dijkstra를 직접 계산해야 함<br/>
* 노드 수 = n
* 한 번 확정할 때마다 남은 모든 노드의 D값 비교 필요 → O(n)
* 그 작업을 n번 반복 → O(n²)<br/>
&ensp;**Dijkstra 기본 구현 = O(n²)**<br/>

&ensp;하지만 자료구조(우선순위 큐)를 쓰면<br/>
* O(n log n)까지 줄일 수 있음 

&ensp;(2) Message Complexity (네트워크 메시지 양)<br/>
&ensp;Link-State 알고리즘의 핵심은:<br/>
> 각 라우터가 자신의 링크 상태 정보를 모든 라우터에게 broadcast 해야 한다.

* 라우터 하나가 broadcast 하면 전체 네트워크 링크를 O(n)번 지나감
* 라우터가 총 n개니까 → 전체 메시지 양 = O(n²)

&ensp;Link-state의 단점: 메시지가 많음(오버헤드)<br/>
&ensp;Routing update traffic 때문에 네트워크 부하가 생길 수 있음<br/>

### Dijkstra’s Algorithm: Oscillations

> 만약 링크 비용이 "트래픽 양에 따라" 변한다면 Dijkstra 알고리즘 결과가 계속 바뀌면서 경로가 흔들리는(oscillation) 문제가 생긴다.

&ensp;흔들리는 이유<br/>
1. 현재 트래픽이 적어서 "A → B" 경로가 최단 경로임
2. 많은 트래픽이 이 경로(B)를 이용하기 시작함
3. 그러면 비용이 높아짐(혼잡 ↑ = cost ↑)
4. 알고리즘이 "다른 경로로 가는 게 더 싸다"고 계산
5. 모든 트래픽이 그쪽으로 몰림
6. 그 경로가 다시 혼잡해져서 cost ↑
7. 또 다른 경로로 이동함
8. 다시 혼잡…<br/>
&ensp;→ 루프처럼 계속 경로가 바뀌는 현상<br/>
&ensp;링크 cost가 고정되어 있지 않고 트래픽에 따라 바뀌면 라우터들이 계속 경로를 재계산하면서 안정되지 않고 왔다 갔다 하는 문제가 발생함<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-13.png" width="500"></p>

&ensp;첫 그림<br/>
* d→c→b→a 로 가는 경로가 좋다고 계산됨
* 각 링크의 cost는 트래픽 양 e 또는 1 등으로 표시됨

&ensp;다음 그림들<br/>
* 트래픽이 몰리면서 cost가 바뀜
* 바뀐 cost에 맞춰 새로운 최단 경로를 계산
* 다시 트래픽이 몰리면서 cost 바뀜…<br/>
&ensp;이 과정이 반복되면서 경로가 계속 바뀐다. → oscillation<br/>

Distance Vector Algorithm
----

&ensp;Distance Vector는 **라우터가 자기 이웃에게만 경로 비용 정보를 주고받아서** 최단 경로를 점점 알아가는 알고리즘이다.<br/>

| Link State         | Distance Vector           |
| ------------------ | ------------------------- |
| 전체 네트워크 지도 공유함     | 이웃에게만 정보 공유               |
| 각 노드가 전체 그래프 알고 있음 | 각 노드는 “이웃이 알려준 정보”만 알고 있음 |
| Dijkstra 사용        | Bellman-Ford 사용           |

&ensp;DV = 이웃과만 소통하는 분산적 방식<br/>
&ensp;LS = 전체 정보 갖는 중앙집중적 방식<br/>

### Bellman-Ford Equation

&ensp;Bellman-Ford 식<br/>

$$ 
D_x(y) = min_v\{c_{x, v} + D_v(y)\}
$$

&ensp;해석<br/>
* x → y 의 최소 비용은
* x의 이웃 v를 통해 가는 모든 비용 후보 중
* 가장 싸게 나오는 경로 선택

&ensp;내가 목적지 y로 가고 싶다면 내 이웃 v가 y까지 가는 비용 + 내가 v까지 가는 비용 중에서 가장 싼 걸 선택하면 됨<br/>

* $c_{x, v}$ : x→v까지의 직접 링크 비용
* $D_v(y)$ : 이웃 v가 알고 있는 y까지의 최단 경로 비용
* min: 이웃 여러 개 중에서 최소값을 선택

&ensp;이웃이 알려주는 정보를 듣고 스스로 갱신하는 방식!<br/>

&ensp;Bellman-Ford Example<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-14.png" width="500"></p>

&ensp;u가 목적지 z까지 가는 비용을 계산<br/>
&ensp;u의 이웃: x, v, w<br/>
&ensp;이웃들의 정보: <br/>
* $D_v(z) = 5$
* $D_w(z) = 3$
* $D_x(z) = 3$

&ensp;링크 비용<br/>
* c(u, v) = 2
* c(u, x) = 1
* c(u, w) = 5

&ensp;이제 Bellman-Ford 식 적용:<br/>

$$
D_u(z) = min\{2 + 5, 1 + 3, 5 + 3\} = min\{7, 4, 8\}
$$

&ensp;결과:<br/>
* 최소값은 4 (x를 통해 가는 경로)
* 따라서 u → z 의 next hop = x

&ensp;Distance Vector Algorithm 핵심 아이디어<br/>
1. 각 노드는 주기적으로 자신의 Distance Vector(DV)를 이웃에게 보낸다.
2. 이웃에게서 새로운 DV를 받으면 BF 식으로 자신의 DV를 갱신한다.
3. 비용이 바뀌면 이웃에게 다시 알린다.
4. 시간이 지나면 모든 노드의 DV가 실제 최단 비용으로 수렴한다.

&ensp;이웃이 정보를 주면, 계산해서 바뀌면 또 알려주고 계속 이 과정을 반복하면서 모두가 최단 경로를 알아가게 된다.<br/>

### DV Algorithm 동작 구조

&ensp;**iterative + asynchronous + distributed**<br/>

&ensp;1) iterative (반복적)<br/>
* 변화가 생길 때마다 DV 갱신 → 또 변화가 생기면 또 갱신
* 한 번에 끝나는 게 아님
* "최단 경로가 수렴될 때까지 계속 반복"

&ensp;2) asynchronous (비동기적)<br/>
&ensp;DV는 동시에 계산되지 않음<br/>
&ensp;각 노드는 다음 두 경우에만 계산함<br/>
1. 링크 비용이 바뀌었을 때
2. 이웃으로부터 DV 업데이트 메시지를 받았을 때

&ensp;따라서 모든 노드가 동시에 계산하는 게 아니라 필요할 때만 계산하는 방식<br/>

&ensp;3) distributed, self-stopping<br/>
&ensp;아주 중요한 특징:<br/>
> 노드는 자신의 DV 값이 바뀐 경우에만 이웃들에게 알린다(Notify)

* DV가 바뀌지 않으면 아무 행동도 하지 않음
* 네트워크 전체가 자연스럽게 멈추는 형태 (= self-stopping)

&ensp;전체 동작 순서<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-15.png" width="500"></p>

1. wait
* 링크 비용 변화 OR 이웃의 DV 메시지 기다림
2. recompute
* 벨만포드 식으로 스스로 DV 업데이트
3. if changed → notify
* 값이 바뀌었으면 이웃들에게 DV를 전송
* 안 바뀌면 조용히 있음

&ensp;→ 이 구조가 DV의 기본 동작 메커니즘<br/>

### Distance Vector 예제

&ensp;각 라우터(노드)는 이웃에게 "지금 내가 어떤 목적지까지 얼마나 비용이 드는지" 계속 알려준다.<br/>
&ensp;그리고 이웃의 정보를 들으면 → "혹시 내가 그 이웃을 거쳐 가면 더 싸게 갈 수 있나?" 를 계산한다.<br/>

&ensp;t=0 상태<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-16.png" width="500"></p>

&ensp;모든 노드는 직접 연결된 이웃까지만 거리 알고 있음<br/>
&ensp;예: 노드 a<br/>
* a→a : 0
* a→b : 8 (직접연결 비용)
* a→d : 1
* 나머지 모두 : ∞ (모름)

&ensp;자기가 바로 연결된 애들만 알고 있고 그 외는 전부 ∞ 로 시작함.<br/>
&ensp;그리고 t=0에 모든 노드가 자기 거리 벡터(DV)를 이웃에게 보냄<br/>
&ensp;a는 DV(a)를 b와 d에게 보냄<br/>
&ensp;b는 DV(b)를 a와 c에게 보냄<br/>

&ensp;t=1 — 이웃의 DV 수신 단계<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-17.png" width="500"></p>

&ensp;이 단계에서 하는 일은 딱 하나: 이웃들로부터 DV를 받기만 한다.<br/>

&ensp;이제 모든 노드가 계산을 시작한다.<br/>
&ensp;노드 a를 예를 들어보면<br/>
&ensp;a가 알고 싶은 것: 각 목적지(y)에 대해 min( c(a,v) + Dᵥ(y) ) 를 계산해보자<br/>
&ensp;여기서 v는 a의 이웃(b, d)<br/>

&ensp;a → e 로 가는 비용을 계산<br/>
1. b를 거쳐서 가는 방법
* a→b = 8
* b→e = 1
* 합치면: 9
2. d를 거쳐서
* a→d = 1
* d→e = 1
* 합치면: 2

&ensp;따라서 a→e = 2 (d 통해서)<br/>
&ensp;이런 식으로 모든 노드가 "이웃 + 이웃이 가진 거리"를 보고 계산을 한다.<br/>

&ensp;계산이 끝나면 모든 노드가 업데이트된 자기 DV를 다시 이웃에게 전달한다.<br/>

&ensp;t=2<br/>
&ensp;이제 더 많은 목적지의 비용이 업데이트되기 시작한다.<br/>
&ensp;예를 들어<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-18.png" width="500"></p>

&ensp;a → g 비용을 계산<br/>
&ensp;가능한 경로<br/>
* a→d→g
    - a→d = 1
    - d→g = 1 → 총 2

&ensp;t=0에서는 a→g = ∞ 였지만 t=2에서는 2 라고 알게 되는 것<br/>

&ensp;업데이트된 결과가 또 전송된다.<br/>

&ensp;결론<br/>
1. 처음엔 이웃만 알고 있다
2. 이웃에게 DV를 보낸다
3. 이웃들의 DV를 받는다
4. Bellman-Ford 식으로 계산한다
5. DV가 변하면 다시 이웃에게 보낸다
6. 이걸 반복하면 결국 전체 네트워크의 최단 비용을 모두 알게 된다 (수렴 convergence)

&ensp;계산 과정<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-19.png" width="500"></p>

&ensp;예시 1: D_b(a) 계산<br/>
&ensp;b가 a까지 가려면?<br/>
&ensp;가능한 경로<br/>
1. b→a 직접
* 비용 = 8
2. b→c→a
* b→c = 1
* c→a = ∞
* 합 = ∞
3. b→e→a
* b→e = 1
* e→a = ∞
* 합 = ∞

&ensp;따라서 min = 8 <br/>

&ensp;예시 2: D_b(c)<br/>
1. b→c 직접 = 1
2. b→a→c = 8 + ∞ = ∞
3. b→e→c = 1 + ∞ = ∞

&ensp;min: 1<br/>

&ensp;예시 3: D_b(d)<br/>
1. b→a→d = 8 + 1 = 9
2. b→c→d = 1 + ∞ = ∞
3. b→e→d = 1 + 1 = 2

&ensp;예시 4: D_b(e)<br/>
1. b→e 직접 = 1
2. b→a→e = 8 + ∞ = ∞
3. b→c→e = 1 + ∞ = ∞

&ensp;정리: b의 새 Distance Vector<br/>
* D_b(a) = 8
* D_b(b) = 0
* D_b(c) = 1
* D_b(d) = 2
* D_b(e) = 1
* D_b(f) = 2
* D_b(h) = 2
* 나머지 ∞

&ensp;c는 이웃이 b밖에 없으므로 b의 DV만 받고 계산 시작.<br/>

&ensp;c가 목적지 하나씩 계산한다.<br/>
&ensp;예시 1: D_c(a)<br/>
&ensp;c → b → a<br/>
* c→b = 1
* b→a = 8 → 합 = 9

&ensp;예시 2: D_c(d)<br/>
&ensp;c → b → d<br/>
* 1 + 2 = 3

&ensp;c의 최종 DV<br/>
* D_c(a) = 9
* D_c(b) = 1
* D_c(c) = 0
* D_c(d) = 3
* 나머지는 ∞

&ensp;e는 이웃 4개로부터 DV를 받는다.<br/>
* b
* d
* f
* h

&ensp;e는 훨씬 많은 정보를 한 번에 보게 된다.<br/>

&ensp;왜 DV는 여러 번 iteration이 필요하고 왜 링크 변화가 생기면 전체 네트워크가 흔들릴까?<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-20.png" width="500"></p>

&ensp;t = 0 — c 혼자만 알고 있음<br/>
&ensp;상태<br/>
* c는 "나는 목적지 c까지 비용이 0이다(D_c(c)=0)"를 알고 있음
* 하지만 다른 노드들은 모름 (전부 ∞)

&ensp;t = 1 — 정보가 1-hop까지 퍼짐<br/>
&ensp;c → b: c가 자신의 DV를 b에게 보냄.<br/>
&ensp;b는 처음으로 c까지 1의 비용으로 갈 수 있다는 걸 알게 됨<br/>
&ensp;영향 범위:<br/>
&ensp;**1-hop 이웃(b)**까지만 c의 정보가 전달됨.<br/>

&ensp;t = 2 — 2-hop까지 퍼짐<br/>
&ensp;이제 b가 업데이트된 DV(b)를 이웃에게 다시 보냄<br/>
&ensp;b의 이웃: a, e<br/>
&ensp;둘 다 b의 DV에서 b가 c까지 1에 도달 가능하다는 정보를 확인함<br/>

&ensp;결과<br/>
* a는 c까지 비용 = a→b→c = 8+1 = 9
* e는 c까지 비용 = e→b→c = 1+1 = 2

&ensp;c의 정보가 a와 e까지 도달함 → 2-hop까지 확장<br/>

&ensp;t = 3 — 3-hop까지 퍼짐<br/>
&ensp;이번엔 a와 e가 DV를 다시 보냄.<br/>
&ensp;a의 이웃: d → d는 a를 통해 c까지 갈 수 있음을 처음 앎<br/>
&ensp;e의 이웃: f, h → 얘네도 "c까지 갈 수 있음"을 처음 앎<br/>
&ensp;따라서 3-hop 거리의 노드(d, f, h)에게 c의 정보가 퍼짐<br/>

&ensp;t = 4 — 4-hop까지 퍼짐 (g, i)<br/>
&ensp;다시 d, f, h가 DV를 모든 이웃에게 전파.<br/>
&ensp;d의 이웃: g → g가 처음으로 c까지 갈 수 있음을 앎<br/>
&ensp;f의 이웃: i → i도 처음으로 c까지 갈 수 있음을 앎<br/>
&ensp;4-hop 떨어진 g, i도 c의 정보를 알게 됨<br/>

&ensp;**네트워크 전체가 새로운 정보를 알게 되려면 네트워크의 diameter(최대 hop 수)만큼 iteration이 필요하다!**<br/>

### Distance Vector: Link Cost Changes

&ensp;링크 비용이 변하면 어떤 일이 일어나는가?<br/>
&ensp;노드들은 항상 **자기 주변(이웃)**에게서 DV(거리 벡터)를 받아서 최단 경로를 계산한다. 문제는 링크 비용 증가가 네트워크 전체에 퍼지는 과정이 매우 느리다는 점이다.<br/>

&ensp;예시 상황<br/>
&ensp;노드 Y–X 링크의 비용이 4 ➜ 60으로 증가하는 순간 발생하는 문제.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-21.png" width="500"></p>

&ensp;기존 상태<br/>
* X–Z 비용 = 50
* Y는 Z에게서 "나 X까지 5에 갈 수 있어" 라는 DV를 알고 있음
* 그래서 Y는 "나는 X까지 4+1 = 5에 갈 수 있네!"라고 믿고 있음

&ensp;링크 비용이 급격히 증가했을 때 문제<br/>
&ensp;1. Y가 링크 비용 증가를 감지<br/>
&ensp;직접 연결된 X 링크 비용이 4 → 60이 됨 하지만 Y는 Z에게 받은 DV 때문에 이렇게 계산함:<br/>
* "Z는 X까지 비용이 5래!"
* "그럼 나는 1 + 5 = 6 에서 X로 갈 수 있네!"

&ensp;잘못된 우회 경로를 믿어버림. 따라서 Y는 Z에게 “내가 X까지 가는 비용은 6이야”라고 알림.<br/>

&ensp;2. Z가 Y에게 받은 DV를 기반으로 잘못 계산<br/>
* "Y가 X까지 6이라면 나는 Y 통해 1 + 6 = 7이네!"
* 그래서 Z는 Y에게 "내가 X까지 7이야"라고 다시 알려줌.

&ensp;3. Y는 또 Z에게 받은 값을 기반으로 계산<br/>
* "Z가 7이라면 나는 1 + 7 = 8!"
* Z에게 "나는 8이다"라고 보내고…

&ensp;이런 식으로 계속 반복됨<br/>
&ensp;**이것이 바로 Count-to-Infinity 문제**<br/>
&ensp;실제 값은 60(즉 매우 멀어짐)인데 Y와 Z는 서로에게 계속 잘못된 우회 경로가 있다고 오해하면서 무한히 증가하는 DV를 교환함.<br/>
* 6 → 7 → 8 → 9 → … → (최대 16, RIP에서는 Infinity=16)

&ensp;나쁜 소식(링크 끊김, 비용 증가)은 네트워크 전체로 천천히 전파됨<br/>
&ensp;루핑이 생겨서 비용이 계속 증가<br/>
&ensp;DV의 가장 큰 약점<br/>

&ensp;Count-to-Infinity 해결법<br/>
1. Split Horizon: 내가 너를 통해 도착한 경로를 너에게 다시 알려주지 않기
2. Poisoned Reverse: 너를 통해 온 경로는 내가 무한대(∞)라고 너에게 알려주기
3. Triggered Update: 비용이 급격히 변하면 즉시 업데이트 패킷 보내기

| 항목    | Link State(OSPF)  | Distance Vector(RIP)      |
| ----- | ----------------- | ------------------------- |
| 정보    | 전체 topology 알고 있음 | 이웃 정보만 알고 있음              |
| 메시지 수 | O(n²) 많음          | 적음                        |
| 속도    | 빠른 수렴             | 느린 수렴                     |
| 문제점   | 계산 부담 / flooding  | 루프 가능 / count-to-infinity |
| 오류 전파 | 작음                | 크고 위험함                    |
