---
title: "chapter5-1. Network Layer: control plane-introduction"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-11-27
last_modified_at: 2025-11-27
---

Network Layer: Control Plane
=====

&ensp;Network Control Plane이란?<br/>
&ensp;네트워크에서 패킷이 어떤 경로로 이동할지 결정하는 두뇌 역할을 한다.<br/>
* 실제 패킷을 옮기는 건 Data Plane(= 실행)
* 그 패킷이 어느 길로 가야 할지 정하는 건 Control Plane(= 의사결정)

## Network-layer Functions (핵심 두 가지)

&ensp;1) Forwarding (데이터 플레인)<br/>
* 라우터에 도착한 패킷을 적저란 출력 포트로 이동시키는 것
* 매우 빠르게 동작해야 해서 하드웨어 중심

&ensp;2) Routing (컨트롤 플레인)<br/>
* 출발지 → 목적지까지 최적 경로를 계산
* 라우터들이 서로 정보를 주고 받으며 라우팅 알고리즘으로 결정

## Control Plane 구조: 2가지 접근

&ensp;(1) Per-router Control Plane (전통적 방식)<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-1.png" width="500"></p>

&ensp;개념<br/>
* 각 라우터가 스스로 라우팅 알고리즘을 돌려서 경로를 계산한다.
* OSPF, RIP 같은 라우팅 프로토콜이 여기에 해당

&ensp;특징<br/>
* 분산처리
* 각각의 라우터가 자기 머리(알고리즘)를 갖고 있음
* 서로 업데이트 교환하며 테이블을 만든다.

&ensp;그림 설명<br/>
* 큰 기둥 = 라우터
* 기둥 안의 Routing Alogrithm = 각 라우터가 스스로 계산
* 빨간 선 = 라우터끼리 정보 교환
* 아래 파란 영역 = 실제 네트워크(데이터 플레인)
* 위쪽 = control plane

&ensp;**각 라우터가 똑똑해서 자기 라우팅 테이블을 직접 계산하는 방식**<br/>

&ensp;(2) Software-Defined Networking (SDN) Control Plane<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-2.png" width="500"></p>

&ensp;개념<br/>
* 컨트롤러(중앙 서버)가 라우팅 결정을 대신 수행
* 라우터는 계산하지 않고 그저 forwarding table 명령만 받는다.

&ensp;특징<br/>
* 중앙 집중식 제어
* 라우터는 단순한 장비가 되고 컨트롤러가 모든 결정 수행
* OpenFlow 기반

&ensp;그림 설명<br/>
* Remote Controller(커다란 타원) = 네트워크의 두뇌
* 아래 라우터들ㅇ느 CA(Control Agent)를 통해 명령을 받음
* 빨간 화살표 = 컨트롤러 → 라우터로 명령 전달

&ensp;**중앙 서버가 모든 경로 계산을 하고 라우터는 명령만 따르는 방식** <br/>

&ensp;Per-router vs SDN<br/>

| 구분        | Per-router (전통) | SDN(중앙집중)       |
| --------- | --------------- | --------------- |
| **계산 주체** | 각 라우터           | 중앙 컨트롤러         |
| **구조**    | 분산형             | 중앙집중형           |
| **유연성**   | 낮음              | 매우 높음           |
| **장비 요구** | 라우터가 똑똑해야 함     | 라우터는 단순해도 됨     |
| **변경/관리** | 어렵고 느리다         | 중앙에서 쉽게 설정      |
| **예시**    | OSPF, RIP       | OpenFlow 기반 SDN |

routing protocols
====

## Routing protocol이 하는 일

&ensp;Routing protocol이란?<br/>
* forwarding = 이미 정해진 표(포워딩 테이블)를 보고 패킷을 옮기는 일
* routing = 그 “표” 자체를 어떻게 채워 넣을지 계산하는 일

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-3.png" width="500"></p>

&ensp;**Routing protocol = 라우터들이 서로 정보를 주고받으면서 좋은 경로를 찾아내는 규칙/알고리즘**<br/>

&ensp;Routing protocol goal<br/>
&ensp;송신 호스트에서 수신 호스트까지 가는 좋은 경로(good path)를 결정하는 것<br/>

* path(경로)
    - 패킷이 지나가는 라우터들의 순서
    - 예: 집 → 학교근처라우터 → 서울백본라우터 → 학교라우터 → 목적지PC
* good path?
    - least cost: 비용이 가장 적음
        + 비용 = 거리, 지연시간, 돈(통신 사업자 입장) 등으로 정의 가능
    - fastest: 가장 빨리 도착
    - least congested: 덜 막힘(혼잡이 적음)

&ensp;실제로는 이 셋을 조합해서 비용(cost)라는 숫자로 표현해 놓고 총 cost가 최소가 되게 경로를 선택하는 게 목표<br/>

## 그래프 추상화: 링크 비용

&ensp;이제 네트워크를 수학 문제처럼 단순한 그림으로 바꾸는 작업을 한다. 그게 바로 그래프(graph) 추상화이다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-4.png" width="500"></p>

&ensp;그래프?<br/>
* 정점(node) + 간선(edge) 로 이루어진 그림
* N: 라우터 집합 = { u, v, w, x, y, z } → 각각 하나의 라우터를 의미
* E: 링크 집합 = { (u,v), (u,x), (v,x), ... } → 두 라우터 사이에 실제로 물리적인 선(케이블/무선)이 존재한다는 뜻

&ensp;라우터 = 동그라미, 링크 동그라미 사이를 잇는 선이라고 생각하면 된다.<br/>

&ensp;Link cost란?<br/>
> 라우터 a와 b를 직접 연결하는 링크의 cost(비용)

&ensp;예<br/>
* $C_{w, z} = 5$ → 라우터 w와 z 사이 링크의 비용이 5
* $C_{u, z} =  \infty$ → u와 z 사이에는 직접 연결된 선이 없다고 보면 됨

&ensp;이 cost값은 네트워크 운영자 마음대로 정할 수 있음<br/>
* 항상 1로 돌 수 있고
* 대역폭이 클수록 cost를 작게
* 혼잡이 심할수로 cost를 크게

## Routing algorithm 분류

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-5.png" width="500"></p>

1. 가로축: global vs decentralized 정보
    - 위쪽(글로벌, global) → 모든 라우터가 네트워크 전체 지도를 안다
    - 아래쪽(분산, decentralized) → 자기 주변(이웃 라우터들) 정보만 알고 시작해서 서로 조금씩 정보 교환하면서 경로를 알아감
2. 세로축: static vs dynamic
    - 왼쪽(static) → 경로가 잘 안 변한다. 네트워크 상황 변화 느림
    - 오른쪽(dynamic) → 경로가 자주/빠르게 변한다. 링크 비용 변화에 따라 주기적 업데이트 필요

&ensp;**Link state vs Distance vector 위치**<br/>
&ensp;Link state 알고리즘 (위쪽 global)<br/>
* 모든 라우터가 네트워크 전체 토폴로지(그림) + 링크 cost를 안다.
* 그러면 각 라우터는 자기 혼자서 최단 경로 알고리즘(예: 다익스트라)을 돌려서 각 목적지까지의 최단 경로를 계산할 수 있음
* 정보는 global이지만 계산은 각 라우터가 개별적으로 수행

&ensp;Distance vector 알고리즘 (아래쪽 decentralized)<br/>
* 초기에는 라우터가 자기와 직접 연결된 이웃끼리의 cost만 안다.
* 이후에
    - 이웃과 내가 아는 최단 거리표를 서로 주고받고
    - 그걸 바탕으로 조금씩 경로를 업데이트하는 방식
* 전체 지도를 한 번에 아는 게 아니라 **이웃들과 대화하면서 점점 더 멀리 있는 목적지까지의 비용을 알아가는 구조**

&ensp;**Static vs Dynamic과의 관계**<br/>
&ensp;실제 인터넷에서는 링크 비용이 바뀔 수 있기 때문에 대부분의 실제 라우팅 프로토콜은 dynamic이다.<br/>
* 링크 속도가 바뀌거나
* 장애가 나서 링크가 끊기거나
* 트래픽이 몰려서 delay가 커지거나<br/>
&ensp;이럴 때 link state / distance vetor 둘 다 주기적으로 혹은 이벤트가 발생할 때 업데이트 메시지를 보내서 새로운 최단 경로를 다시 계산한다.<br/>

## link state

&ensp;Link State란?<br/>
&ensp;라우터들이 네트워크 전체 지도 + 각 링크의 비용(cost)을 서로에게 방송해서 모든 라우터가 똑같은 네트워크 지도를 갖게 되는 구조이다.<br/>
&ensp;모든 라우터가 전체 지도를 알고 있다.(global knowledge)<br/>
&ensp;그래서 각 라우터가 자기 자신을 기준으로 최단 경로를 직접 계산한다.<br/>

### Dijkstra 알고리즘이 하는 일

&ensp;한 라우터(u)를 기준으로:<br/>
* u에서 모든 다른 라우터까지의 최단 경로 비용을 계산
* 그리고 그 비용 기반으로 포워딩 테이블을 채움

&ensp;이해해야 하는 변수들<br/>

| 기호       | 뜻                                         |
| -------- | ----------------------------------------- |
| **cₓ,y** | x와 y 사이의 **직접 연결된 링크 비용** (연결 안 되어 있으면 ∞) |
| **D(v)** | “u → v 까지 현재까지 알려진 최단 경로 비용”              |
| **p(v)** | “v 로 가는 최단 경로 상에서 v 바로 직전에 오는 노드”         |
| **N′**   | “최단 비용이 확정된 노드 집합”                        |

&ensp;N′은 완전히 확정된 노드(더 이상 바뀌지 않는 노드)<br/>
&ensp;D(v)는 아직 확정 안 되었을 때 계속 업데이트되는 값<br/>

### Dijkstra 알고리즘 흐름

&ensp;단계 1: 초기화<br/>
&ensp;1. 시작점 u 하나만 N′에 넣기<br/>
```mathematica
N′ = {u}
```

&ensp;2. 모든 노드 v에 대해 D(v) 초기화<br/>
* u와 직접 연결된 노드 v → 비용 = c(u, v)
* 연결 안 돼 있음 → 비용 = ∞

&ensp;초기에는 u가 단순히 직접 연결된 이웃까지만 비용을 알고 있음<br/>

&ensp;단계 2: 반복(Loop)<br/>
&ensp;반복하며 다음을 수행<br/>
1. N′에 아직 안 들어간 노드 중에서 D(w)가 가장 작은 노드 w 선택 → "지금까지 가장 가깝다고 알려진 노드 확정!"
2. w를 N′에 추가 (확정)
3. w의 이웃들에게 새로운 최단 경로 후보를 계산

&ensp;공식<br/>
```mathematica
D(v) = min( D(v), D(w) + c(w,v) )
```

* 기존에 알고 있던 D(v)가 더 작으면 그대로
* w를 거쳐가는 새로운 경로 `D(w) + c(W, V)` 가 더 작으면 업데이트

&ensp;이 작업을 "모든 노드가 N′에 들어갈 때까지" 반복<br/>

### 예제

&ensp;예제 1<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-6.png" width="500"></p>

&ensp;아래 그래프에서 u → 모든 노드에 대한 최단 경로를 구하는 상황<br/>

&ensp;Step 0 (초기화)<br/>
* N′ = {u}
* u와 직접 연결된 비용:
    - D(x)=1
    - D(v)=2
    - 나머지 = ∞<br/>
&ensp;→ u는 이제 자기 주변만 알고 있음<br/>

&ensp;Step 1: x 추가<br/>
&ensp;가장 작은 D = 1 (x)<br/>
* N′ = {u, x}<br/>
&ensp;x의 이웃 업데이트:<br/>
* y: 기존 $\infty$ → x→y=1+1=2
* v: 기존 2인데 x→v는 1+2=3 → 유지
* w: $\infty$ → x→w=1+3=4

&ensp;Step 2: y 추가<br/>
&ensp;다음 작은 D = 2 (y)<br/>
* N′ = {u, x, y}<br/>
&ensp;y의 이웃 업데이트:<br/>
* v: min(2, 2+2=4) → 2 유지
* w: min(4, 2+1=3) → 3로 업데이트
* z: $\infty$ → 2+2=4

&ensp;Step 3: v 추가<br/>
&ensp;D(v) = 2<br/>
* N′ = {u, x, y, v}<br/>
&ensp;v의 이웃 업데이트:<br/>
* w: min(3, 2+3=5) → 3 유지

&ensp;Step 4: w 추가<br/>
&ensp;D(w)=3<br/>
* N′ = {u, x, y, v, w}<br/>
&ensp;w의 이웃 업데이트:<br/>
* z: min(4, 3+5=8) → 4 유지

&ensp;Step 5: z 추가<br/>
&ensp;D = 4<br/>
* N′ = 전체 노드 확정<br/>
&ensp;최종 D 값:<br/>
* v = 2 (via u)
* x = 1 (via u)
* y = 2 (via x)
* w = 3 (via y)
* z = 4 (via y)

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-7.png" width="500"></p>

&ensp;마지막 결과<br/>
&ensp;1) 최단 경로 트리<br/>
&ensp;u에서 뻗어나가는 최단 경로만 남긴 트리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-8.png" width="500"></p>

&ensp;2) 포워딩 테이블<br/>
&ensp;목적지 | u가 처음으로 보내야 할 이웃<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-9.png" width="500"></p>

&ensp;대부분 목적지로 가는 경로는 먼저 x 방향으로 나간 후 이동해야 함.<br/>

&ensp;예제 2<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-10.png" width="500"></p>

&ensp;(1) Step-by-step 최단 경로 확정 과정<br/>
&ensp;표에서<br/>
* N′ : 최단 경로 "확정(confired)"된 노드 집합
* D(v) : u → v 현재까지 알려진 최소 비용
* p(v) : 그 비용이 나오게 한 직전 노드(부모 노드, predecessor)

&ensp;전체 과정은 이전 슬라이드와 동일하지만 값만 다르게 나옴.<br/>

&ensp;Step 0 (초기화)<br/>
* N′ = {u}
* D(v)=7, D(w)=3, D(x)=5, D(y)=$\infty$ , D(z)=$\infty$ → u가 직접 연결된 비용만 먼저 알고 있음

&ensp;Step 1<br/>
&ensp;확장되지 않은 노드 중 가장 작은 비용 = 3(w)<br/>
&ensp;→ w 확정<br/>
&ensp;→ N′ = {u, w}<br/>

&ensp;그 다음 w의 이웃들 업데이트<br/>
* v: 기존 7 vs (3 + w→v=3) = 6 → 새 값 6, parent=w
* x: 기존 5 vs (3 + 3) = 6 → 그대로 5
* y: 기존 ∞ vs (3 + 8) = 11 → 업데이트 11, parent=w

&ensp;Step 2<br/>
&ensp;N′에 없는 노드 중 최소 비용 = 5(x)<br/>
&ensp;→ x 확정<br/>
&ensp;→ N′ = {u, w, x}<br/>

&ensp;x의 이웃 업데이트:<br/>
* w: 이미 확정됨
* z: 기존 ∞ vs (5 + 9) = 14 → 업데이트 14, parent=x

&ensp;Step 3<br/>
&ensp;남은 노드 중 최소 비용 = 6(v)<br/>
&ensp;→ v 확정<br/>
&ensp;→ N′ = {u, w, x, v}<br/>

&ensp;v의 이웃:<br/>
* y: 기존 11 vs (6 + 4) = 10 → 업데이트 → 10, parent=v

&ensp;step 4<br/>
&ensp;남은 노드 중 최소 = 10(y)<br/>
&ensp;→ y 확정<br/>
&ensp;→ N′ = {u, w, x, v, y}<br/>

&ensp;y의 이웃:<br/>
* z: 기존 14 vs (10 + 2) = 12 → 업데이트 → 12, parent=y

&ensp;Step 5<br/>
&ensp;남은 노드 = z(12)<br/>
&ensp;→ z 확정<br/>
&ensp;→ 끝<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-11.png" width="500"></p>

&ensp;(3) 최단 경로 트리는 predecessor 기반으로 그림<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-12.png" width="500"></p>

### Dijkstra 알고리즘 Discussion

&ensp;(1) Algorithm Complexity (알고리즘 수행 시간)<br/>
&ensp;모든 라우터는 전체 그래프 정보를 가지고 있으므로 Dijkstra를 직접 계산해야 함<br/>
* 노드 수 = n
* 한 번 확정할 때마다 남은 모든 노드의 D값 비교 필요 → O(n)
* 그 작업을 n번 반복 → O(n²)<br/>
&ensp;**Dijkstra 기본 구현 = O(n²)**<br/>

&ensp;하지만 자료구조(우선순위 큐)를 쓰면<br/>
* O(n log n)까지 줄일 수 있음 

&ensp;(2) Message Complexity (네트워크 메시지 양)<br/>
&ensp;Link-State 알고리즘의 핵심은:<br/>
> 각 라우터가 자신의 링크 상태 정보를 모든 라우터에게 broadcast 해야 한다.

* 라우터 하나가 broadcast 하면 전체 네트워크 링크를 O(n)번 지나감
* 라우터가 총 n개니까 → 전체 메시지 양 = O(n²)

&ensp;Link-state의 단점: 메시지가 많음(오버헤드)<br/>
&ensp;Routing update traffic 때문에 네트워크 부하가 생길 수 있음<br/>

### Dijkstra’s Algorithm: Oscillations

> 만약 링크 비용이 "트래픽 양에 따라" 변한다면 Dijkstra 알고리즘 결과가 계속 바뀌면서 경로가 흔들리는(oscillation) 문제가 생긴다.

&ensp;흔들리는 이유<br/>
1. 현재 트래픽이 적어서 "A → B" 경로가 최단 경로임
2. 많은 트래픽이 이 경로(B)를 이용하기 시작함
3. 그러면 비용이 높아짐(혼잡 ↑ = cost ↑)
4. 알고리즘이 "다른 경로로 가는 게 더 싸다"고 계산
5. 모든 트래픽이 그쪽으로 몰림
6. 그 경로가 다시 혼잡해져서 cost ↑
7. 또 다른 경로로 이동함
8. 다시 혼잡…<br/>
&ensp;→ 루프처럼 계속 경로가 바뀌는 현상<br/>
&ensp;링크 cost가 고정되어 있지 않고 트래픽에 따라 바뀌면 라우터들이 계속 경로를 재계산하면서 안정되지 않고 왔다 갔다 하는 문제가 발생함<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter5. Network Layer-Control Plane/5-13.png" width="500"></p>

&ensp;첫 그림<br/>
* d→c→b→a 로 가는 경로가 좋다고 계산됨
* 각 링크의 cost는 트래픽 양 e 또는 1 등으로 표시됨

&ensp;다음 그림들<br/>
* 트래픽이 몰리면서 cost가 바뀜
* 바뀐 cost에 맞춰 새로운 최단 경로를 계산
* 다시 트래픽이 몰리면서 cost 바뀜…<br/>
&ensp;이 과정이 반복되면서 경로가 계속 바뀐다. → oscillation<br/>

