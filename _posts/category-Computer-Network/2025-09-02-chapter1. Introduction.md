---
title: "chapter1. Introduction"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-09-02
last_modified_at: 2025-09-16
---

인터넷
======

* 정의: 전 세계 수많은 네트워크가 서로 연결된 "네트워크들의 네트워크"
* 핵심 아이디어: 데이터를 작은 조각(패킷)으로 쪼개어 라우터와 링크를 통해 전달한다.

인터넷 구조
------

* 호스트(PC, 스마트폰) = 편지 보내는 사람
* 라우터/스위치 = 교통 경찰(데이터를 어디로 보낼지 결정)
* 링크(광케이블, Wi-Fi, LTE 등) = 도로
* 패킷(Packet) = 작은 상자(주소표를 붙여 이동)
* 프로토콜 = 교통 규칙(HTTP, TCP, IP, Wi-Fi...)

인터넷 관점
------

&ensp;nuts and bolts 관점<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-1.png" width="300"></p>

* Billions of devices = Hosts(종단 시스템)
    - PC, 스마트폰, 서버, 냉장고, 카메라 등
    - 네트워크 앱(웹, 메신저, 스트리밍 등)을 엣지(edge)에서 실행
* Packet switches(라우터/스위치)
    - 데이터는 패킷으로 쪼개져 이동
    - 우터/스위치가 다음 목적지로 포워딩
* Communication links
    - 광섬유, 구리선, 무선(Wi-Fi/4G/5G), 위성
    - 대역폭(bandwidth) = 1초에 보낼 수 있는 최대 비트 수(도로 폭)
* Networks
    - 장치, 라우터, 링크 묶음을 ISP(회사/조직)가 관리
    - 이 네트워크들이 연결되어 거대한 인터넷 형성

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-2.png" width="300"></p>

* home / enterprise network -> 집·회사 내부망
* mobile network -> 기지국 통해 인터넷 코어 진입
* local/regional ISP <-> national/global ISP → 통신사 간 계층적 연결
* content provider / datacenter -> 유튜브, 넷플릭스, 클라우드

&ensp;호스트(엣지)에서 실행도니 앱 데이터는 패킷으로 잘려 라우터, 링크를 타고 여러 ISP를 거쳐 서버(목적지)에 도착한다.<br/>

&ensp;프로토콜 & 표준<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-3.png" width="300"></p>

* Internet = "network of networks"
    - IS들이 상호 연결된 거대한 네트워크
* Protocols are everywhere
    - 메시지 송수신 규칙
    - 예:
        + HTTP(웹), Streaming video, Skype -> 응용 계층
        + TCP -> 전송 계층
        + IP -> 네트워크 계층
        + Wi-Fi, 4G, Ethernet -> 링크/물리 계층
* Internet standards
    - RFC (Request for Comments): 프로토콜 표준 문서
    - IETF: RFC를 만드는 국제 커뮤니티

* 링크/물리 -> WiFi, Ethernet, 4G (이웃까지 전송)
* 네트워크 -> IP (경로 결정·라우팅)
* 전송 -> TCP (신뢰성 보장, 순서 유지)
* 응용 -> HTTP, Streaming, Skype (서비스 규칙)

&ensp;집/회사/모바일 -> 지역 ISP -> 글로벌 ISP -> 콘텐츠 제공자/데이터센터 즉, 엔드-투-엔드 데이터 경로<br/>

&ensp;계층화 덕분에 각 계층이 역할만 수행하면 전 세계 누구와도 통신 가능 -> 이 약속(프로토콜)을 RFC/IETF가 표준화<br/>

1. 엣지(호스트/앱) <-> 코어(라우터/링크) 구조, 데이터는 패킷 교환으로 이동
2. 엣지는 PC → IoT/의료기기까지 확장 -> 보안·지연·전력 고려 필요
3. 계층 구조(링크->IP->TCP->HTTP) + 표준(RFC/IETF) 덕분에
이질적인 네트워크도 상호운용된다.

&ensp;service 관점<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-4.png" width="300"></p>

* Infrastructure that provides services to applications

&ensp;인터넷은 라우터/케이블 묶음이 아니라, 애플리케이션이 쓰는 전송 서비스를 제공하는 인프라로 볼 수 있다. (예: 웹, 스트리밍, 화상회의, 이메일, 게임, 전자상거래, SNS, 가전/센서 등)<br/>

* provides programming interface to distributed applications

&ensp;분산 애플리케이션(양쪽 끝에 앱이 있는 구조)을 위해 프로그래밍 인터페이스(= 소켓 API 같은 “연결 훅(hook)”)를 제공한다. -> 개발자는 socket(), connect(), send() 같은 호출만 쓰면 인터넷 전송 서비스(TCP/UDP)에 연결가능<br/>

* provides service options, analogous to postal service

&ensp;우체국에서 “등기/일반/특급”을 고르듯, 네트워크도 서비스 특성을 고를 수 있다.<br/>
* TCP: 신뢰성·순서 보장(정확성↑, 지연/오버헤드↑)
* UDP: 빠름·가벼움(손실 가능, 대신 지연↓)
* 응용은 필요에 따라 선택(예: 스트리밍/게임은 UDP 선호, 결제/웹 전송은 TCP)

* Skype, HTTP, Streaming video 라벨이 엔드-투-엔드로 그려져 있다.
집/회사/모바일망 → 지역/국가 ISP → 콘텐츠 제공자/데이터센터까지 응용계층 대화가 이어진다.
* 핵심은 “앱 개발자는 라우터 내부가 아니라 서비스(소켓/프로토콜) 로 인터넷을 바라본다”는 관점 전환.

&ensp;인터넷은 앱에게 전송 서비스를 제공하는 인프라이고, 앱은 소켓 API 를 통해 TCP/UDP 같은 서비스 옵션을 선택해 쓴다.<br/>

protocol
======

&ensp;왼쪽(사람의 프로토콜) ↔ 오른쪽(네트워크 프로토콜)<br/>
* 사람 사이에서도 “먼저 인사 → 질문 → 답변”처럼 메시지 순서/형식/상황별 행동이 정해져 있다.
* 네트워크도 똑같이 장치들 간 약속(프로토콜) 이 있어요. 인터넷의 모든 통신은 이 규칙에 의해 동작한다.

&ensp;프로토콜은 보내고 받는 메시지의 형식과 순서, 그리고 메시지를 보냈을 때/받았을 때 취할 행동을 정의한다.(= 메시지 타입/필드, 교환 순서(상태기계), 타이머·재전송·오류 처리까지 포함)<br/>

&ensp;예시로 이해하기<br/>
* HTTP: 요청줄/헤더/바디의 형식, GET/POST 등 메시지 종류, 200/404 같은 응답 코드, 캐시 규칙 등 행동
* TCP: SYN/SYN-ACK/ACK 연결 절차, 순서/재전송/흐름·혼잡 제어 행동
* DNS: 질의/응답 메시지 포맷, 재귀/반복 질의 동작

&ensp;프로토콜 = 형식 + 순서 + 행동(state machine)<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-5.png" width="300"></p>

&ensp;사람 대화<br/>
1. Hi -> Hi (인사 교환)
2. Got the time? (질문) → 2:00(응답) -> 정해진 순서와 문장 형식을 따르고, 상황별 행동이 있다.

&ensp;컴퓨터 대화: 클라이언트 <-> 서버<br/>
1. TCP connection request
    - 클라이언트가 서버에 “연결하자” 요청한다.
    - 실제 TCP는 3-way handshake(SYN → SYN-ACK → ACK) 인데, 그림에선 간단히 요청/응답으로 표현한다.
2. TCP connection response
    - 서버가 수락 응답
3. HTTP GET …
    - 연결이 성립되면, 클라이언트가 HTTP 요청(예: GET /kurose_ross) 전송한다.
4. \<file\>
    - 서버가 응답 본문(파일/문서) 전달한다.

&ensp;매핑(사람 <-> 컴퓨터)<br/>
* "Hi/Hi” <-> TCP 핸드셰이크
* “몇 시야?” <-> HTTP GET 요청
* “2:00” <-> HTTP 응답(콘텐츠)

&ensp;네트워크 통신도 사람 대화처럼 정해진 순서와 형식을 지키며, 각 단계에서 정해진 행동을 수행한다.(TCP 위에 HTTP)<br/>

Network edge: hosts, access network, physical media
======


* Network edge(네트워크의 가장자리)에 초점: osts(기기), access network(접속망), physical media(실제 길: 선/공기)

&ensp;인터넷을 한 동네 지도로 보면 가장자리는 사람들이 사는 집이다. 집 안의 기기(호스트): 컴퓨터, 폰, 태블릿, 접속망은 집에서 큰길(통신사)로 나가는 골목(와이파이, 인터넷선, 휴대폰 기지국), 실제 길(물리 매체): 광케이블, 전화선, 공기(전파)라고 볼 수 있다.<br/>

&ensp;Network edge: hosts, clients/servers<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-6.png" width="300"></p>

* 빨간 동그라미가 엣지(가장자리) 기기를 표시: 클라이언트(우리 폰/PC), 서버(보통 데이터센터에 있는 컴퓨터)

&ensp;클라이언트(손님): “영상 보여주세요!” 하고 먼저 말을 거는 우리 폰/PC, 서버(가게 주인): 요청을 받고 영상/사진/문서를 보내주는 튼튼한 컴퓨터, 서버는 보통 데이터센터(컴퓨터 건물) 안에 많이 모여 있다. 시원하게 관리하고, 전기도 안정적이다.<br/>

&ensp;엣지에는 손님(클라이언트) 과 주인(서버) 이 있다. 주인은 보통 데이터센터에 산다.<br/>

&ensp;Access networks & physical media<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-7.png" width="300"></p>

* 집의 공유기, 회사의 스위치, 휴대폰 기지국 주변에 빨간 동그라미
* 밑줄: wired(유선), wireless(무선) 링크

&ensp;접속망은 “우리 집/회사/휴대폰”을 통신사 큰길에 이어주는 골목길이다. 유선 예시: 랜선, 광케이블(빛이 지나가는 빨대), 무선 예시: 와이파이, LTE/5G(공기를 타는 전파) 이 골목길을 통해 첫 번째 큰길(통신사 라우터) 로 들어간다.<br/>

&ensp;이 골목길을 통해 첫 번째 큰길(통신사 라우터) 로 들어간다.<br/>

접속망(Access Network)과 물리 매체(Physical Media)
-------

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-9.png" width="300"></p>

&ensp;접속망: 집이나 학교의 기기(끝단, end systems)를 통신사 첫 라우터(엣지 라우터)까지 연결하는 골목길이다.<br/>

* 🏠 가정용 접속망: 집에서 인터넷 나가는 길 (공유기, 케이블/광/DSL)
* 🏫 기관 접속망: 학교·회사에서 나가는 길 (스위치가 잔뜩)
* 📱 모바일 접속망: Wi-Fi, 4G/5G 같은 무선

&ensp;살펴볼 것 2가지<br/>
1. 전송 속도: 이 골목길이 1초에 몇 비트를 보낼 수 있나? (bps)
2. 공유 or 전용?
    - 공유(shared): 이웃이랑 같은 길을 씀 → 붐비면 느려질 수 있음
    - 전용(dedicated): 우리 집만 쓰는 길 → 이웃 영향 적음

&ensp;케이블 인터넷의 원리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-11.png" width="300"></p>

&ensp;한 케이블로 TV·인터넷을 같이? -> FDM!<br/>
&ensp;FDM(Frequency Division Multiplexing): 한 케이블을 주파수 칸으로 나눠 TV/데이터/제어 신호를 각각 다른 칸에 실는다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-10.png" width="300"></p>

* 우리 집 케이블 모뎀 <-> 동네 쪽의 케이블 허브(헤드엔드) 사이를 이웃들과 함께 공유합니다.

&ensp;HFC 구조
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-12.png" width="300"></p>

&ensp;집 근처는 동축(Coax), 그 뒤는 광(Fiber) 로 이어진 하이브리드 구조<br/>
* 집안: 케이블 모뎀 ↔ 골목선(동축) ↔ 케이블국(CMTS 장비)
* 그 뒤: 광섬유를 타고 ISP 라우터로!
* 특징
    - 공유 접속망: 같은 구역 이웃들이 대역폭을 나눠씀
    - 비대칭 속도(보통 다운로드가 더 빠름): 대략 수십 Mbps ~ 기가급 다운로드, 업로드는 수십~100 Mbps 수준(지역/요금제마다 다름)

&ensp;케이블 인터넷은 한 줄(동축) 을 이웃이 나눠 쓰고, 주파수 칸(FDM) 으로 TV와 데이터를 같이 보낸다.<br/>

&ensp;전화선으로 인터넷? DSL!<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-13.png" width="300"></p>

&ensp;집에 이미 있는 전화선을 이용해, 목소리와 데이터를 주파수로 분리해서 동시에 보낸다.<br/>

* 집안: 스플리터가 음성과 데이터를 나눈다.
    - ☎️ 음성 → 전화망
    - 💻 데이터 → DSL 모뎀 → 전화국의 DSLAM → ISP
    - 속도 예: 다운로드 24–52 Mbps, 업로드 3.5–16 Mbps(환경에 따라 다르다.)

&ensp;DSL은 전화선 하나로 전화+인터넷을 같이 쓰고, 집에서 전화국까지는 전용길에 가깝다.<br/>

&ensp;우리 집 네트워크 지도<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-14.png" width="300"></p>

&ensp;집안 장비들이 이렇게 이어진다고 보면 쉽다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-15.png" width="300"></p>

* Wi-Fi AP: 집안 기기들을 무선으로 연결(표준에 따라 수십~수백 Mbps)
* 공유기(라우터/방화벽/NAT): 집안 트래픽을 관리하고 사설IP ↔ 공인IP 변환
* 유선 이더넷: PC/TV를 케이블로 연결(보통 1 Gbps)
* 모뎀: 집안 신호 ↔ 통신사 신호 변환(케이블 모뎀 혹은 DSL 모뎀)
* 요즘은 모뎀+공유기 일체형도 많다.(그림의 “often combined in single box”).

&ensp;집 네트워크 팁<br/>
* 스트리밍/게임 흔들릴 땐 유선 LAN이 안정적
* 공유기 위치는 집 중앙·높은 곳이 유리(벽/복층/전자레인지 방해 주의)
* 이웃이 많은 아파트는 5GHz Wi-Fi가 간섭이 덜함(다만 벽 투과력은 2.4GHz가 나음)

&ensp;케이블 vs DSL vs 모바일<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-16.png" width="300"></p>

&ensp;실제 속도는 지역/요금제/장비 상태에 따라 다르다.<br/>

wireless access networks
-----

&ensp;핵심: 집, 학교, 카페의 와이파이나 밖에서 쓰는 휴대폰 데이터(LTE/5G)처럼, 무선으로 우리 기기를 인터넷의 라우터에 이어 주는 길이다.<br/>

&ensp;와이파이(Wi-Fi, WLAN)<br/>
* 어디서? 보통 건물 안/주변(약 30m = 100ft).
* 누가 중간에서 연결? 무선 공유기(= Access Point).
* 속도(이론 최대)
    - 802.11b: 11 Mbps
    - 802.11g: 54 Mbps
    - 802.11n: 450 Mbps
* 그림처럼 생각하기: 공유기는 “방 안의 무선 다리”. 노트북·폰이 다리를 건너 집 라우터 → 인터넷으로 나간다.

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-18.png" width="300"></p>

&ensp;셀룰러(휴대폰) 망 (4G/5G)
* 어디서? 도시 전체·수십 km까지.
* 누가 중간에서 연결? 기지국(통신사 안테나).
* 속도 느낌: 4G는 보통 수십 Mbps대, 5G는 그보다 더 빠르게 설계되어 있다.
* 그림처럼 생각하기: 동네 곳곳 **큰 탑(기지국)**이 있고, 휴대폰이 가장 가까운 탑에 무선으로 연결돼 인터넷에 나간다.

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-19.png" width="300"></p>

&ensp;Wi-Fi vs 셀룰러 간단 비교<br/>
* 범위: Wi-Fi(집·교실 등 좁은 범위) ↔ 셀룰러(도시처럼 넓은 범위)
* 관리 주체: Wi-Fi(집/학교가 설치) ↔ 셀룰러(이동통신사)
* 데이터 요금: Wi-Fi(보통 고정요금 인터넷) ↔ 셀룰러(요금제 데이터 소모)

Access networks: enterprise networks
------

&ensp;기업·학교 네트워크(Access networks: enterprise)<br/>
&ensp;회사/대학은 유선+무선 장비들을 섞어 많은 컴퓨터를 안전하게 인터넷에 연결한다.<br/>
* 스위치(Ethernet switch): 같은 건물 안의 PC들을 유선 케이블로 묶어 주는 분배기
* 무선 AP: 실내에 와이파이를 뿌려 주는 장치.
* 기관 라우터: 건물 내부망 ↔ 인터넷(통신사) 사이의 문지기.
* 내부 서버: 메일 서버·웹 서버처럼 기관 안에서 돌리는 컴퓨터.
* 속도 예시
    - 이더넷(유선): 100 Mbps / 1 Gbps / 10 Gbps
    - 와이파이: 11 / 54 / 450 Mbps (표기된 건 이론 최대)

&ensp;데이터 이동 예: 노트북 → (와이파이 AP) → 스위치 → 기관 라우터 → 통신사(ISP) → 인터넷 전체<br/>

Host: send packets of data
----

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-20.png" width="300"></p>

&ensp;컴퓨터(호스트)는 어떻게 데이터를 보낼까? — “패킷” 이야기<br/>
&ensp;큰 메시지를 **작은 상자들(=패킷)**로 잘라서 **차례대로 도로(네트워크)**에 밀어 넣는다.<br/>
* 엡에서 만든 메시지를 작게 쪼갠 조각이 패킷(packet)
    - 한 패킷의 길이를 L(비트)라고 한다.
* 네트워크 도로에는 제한 속도가 있다. -> 전송률 R(비트/초)
* 한 패킷을 도로에 올리는 데 걸리는 시간(전송 지연)

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-17.png" width="300"></p>

&ensp;비유: 수도꼭지에서 물이 나오는 속도(R)가 정해져 있으면 컵(L)을 채우는 데 L/R 초 걸리는 것과 같다.<br/>

링크(케이블/공기): 물리 매체(physical media)
-----

&ensp;0과 1(비트)이 무엇을 타고 이동하느냐의 차이다.<br/>
* 비트(bit): 전기가 “켰다(1)/껐다(0)”처럼 정보를 담는 가장 작은 단위.
* 물리 링크: 송신기 ↔ 수신기 사이에 실제로 놓인 길.
* 유도 매체(guided): 단단한 길을 따라감 → 구리선, 광섬유, 동축 케이블
* 비유도 매체(unguided): 공기 중으로 날아감 → 라디오/전파(와이파이, 블루투스)

&ensp;트위스티드 페어(Twisted Pair, 흔한 랜선)<br/>
* 구리선 두 가닥을 꼬아 외부 잡음을 줄인다.
* 카테고리(대략)
    - Cat5e: 보통 1 Gbps까지(약 100m)
    - Cat6: 10 Gbps(짧은 거리에서 가능)
* 끝 부분: 우리가 아는 RJ-45 커넥터(딱 “딱!” 소리 나는 그거)

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-21.png" width="300"></p>

&ensp;<b>동축 케이블(Coaxial cable)</b><br/>

&ensp;가운데 구리선과 바깥 구리망이 **동심원(동축)**으로 겹쳐 있는 케이블. 잡음에 강하고 양방향 통신이 된다.<br/>

* 구조
    - 중앙 구리선(신호가 지나는 길)
    - 절연층(서로 닿지 않게 분리)
    - 바깥 구리 망/호일(방패 역할)
    - 겉피복
* 양방향(bidirectional): 한 선로에서 보내고/받고가 모두 가능.
* 브로드밴드(broadband):
    - 케이블 하나에 여러 개의 주파수 채널을 나눠서 사용
    - 채널당 수백 Mbps급 속도까지 설계 가능
* 비유: **금속 빨대(중앙선)**를 **철망 실드(바깥 구리)**로 감싸 잡음 바람을 막는 느낌. 그래서 TV 케이블·옛날 인터넷 회선에 많이 쓰인다.   

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-23.png" width="300"></p>

&ensp;언제 좋을까?<br/>
* 긴 배선이 필요한 건물 배선, 케이블TV/케이블 모뎀 등에서 잡음에 비교적 강하고 안정적.

&ensp;<b>광섬유 케이블(Fiber optic cable)</b><br/>
&ensp;아주 가는 유리(혹은 플라스틱) 실 속으로 빛의 깜빡임을 보내 정보를 전달. 매우 빠르고, 매우 멀리, 오류가 적다!<br/>

* 어떻게 전달해?
    - **빛 펄스(깜빡임)**가 “0/1”을 대신합니다. (모스 부호처럼 빛으로 톡톡)
* 속도/거리
    - 고속·장거리 점대점 전송에 최강 (수십~수백 Gbps급도 실무에서 흔함)
    - 중계기(리피터) 간격을 멀리 둘 수 있어 장거리 백본에 적합
* 오류·잡음
    - 전자기 잡음에 거의 영향 없음(유리 속을 가는 빛이라 번개/전자파 간섭에 강함)
    - 오류율 낮음
* 비유: 빛만 지나가는 유리 터널이라 외부 소음이 안 들려요. 그래서 빠르고 조용하게 멀리 갑니다.

&ensp;언제 좋을까?<br/>
* 통신사/국가 간 백본, 건물 간 메인 회선, 데이터센터, 초고속 인터넷 등.

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-24.png" width="300"></p>

&ensp;<b>무선 라디오(Wireless radio)의 기본</b><br/>
&ensp;눈에 안 보이는 전파(전자기파)가 공기 중으로 퍼져서 정보를 실어 나릅니다. 선(케이블)이 필요 없고, 주변 환경 영향을 받는다.<br/>
* 물리적 선 없음: 전파는 공기 중으로 툭 뿌려짐(방송처럼).
* 방송 + 하프 듀플렉스
    - 기본적으로 한 번에 한쪽 방향으로 보내는 구조를 많이 씀(요즘은 프로토콜로 번갈아 빠르게).
* 환경 영향(중요!)
    - 반사(Reflection): 벽/천장에서 튕김 → 길이 돌아가 품질 저하
    - 차폐(Obstruction): 벽·사람·가구가 길을 가림 → 세기 약해짐
    - 간섭(Interference): 다른 전파가 섞여 서로 방해

&ensp;비유: 연못에 돌을 두 개 던지면 물결이 서로 섞여 모양이 흐트러지죠? 와이파이도 비슷하다.<br/>

&ensp;<b>무선 링크 종류(Radio link types)</b><br/>
&ensp;A. 지상 마이크로웨이브(terrestrial microwave)<br/>
* 특징: 안테나↔안테나가 서로 보이는(가시거리) 직선 경로에서 전송
* 속도 감각: 예시 슬라이드 기준 최대 수십 Mbps급 채널
* 용도: 산 꼭대기 중계소, 건물 간 전용 무선 백홀 등

&ensp;B. 무선 LAN(= Wi-Fi)<br/>
* 범위: 집·교실·카페 등 수십 m
* 속도 감각: 표준에 따라 수십~수백 Mbps(이론상은 그 이상도 존재)
* 포인트: **공유기(AP)**가 작게 방송, 기기들이 접속

&ensp;C. 광역(셀룰러: 4G/5G)<br/>
* 범위: 도시 전체(수 km)
* 속도 감각: 4G는 보통 수십 Mbps, 5G는 그 이상
* 포인트: 기지국이 동네 곳곳에 있어 빈틈을 메움

&ensp;D. 위성(satellite)<br/>
* 속도 감각: 채널당 수십 Mbps급 예시
* 지연 시간(왜 큰가?):
    - 정지궤도(GEO)는 지구 위 약 36,000 km.
    - 왕복으로는 약 72,000 km를 전파가 이동.
    - 빛의 속도 ≈ 300000 km/s -> 72,000/300,000 ≈ 0.24초, 즉 약 240 ms + 장비 처리/지상 구간 등 -> 대략 270 ms 수준
* LEO(저궤도) 위성은 더 낮게 떠서 지연이 훨씬 줄어듦(대신 많은 위성이 필요).

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-22.png" width="300"></p>


Network core: packet/circuit switching, internet structure
=====

&ensp;한눈에 보기<br/>
* 네트워크 코어 = 전 세계를 잇는 라우터들의 길망(mesh).
* 패킷 스위칭 = 큰 메시지를 **작은 상자(패킷)**로 잘라 릴레이처럼 옮김.
* 전송 지연(링크에 밀어 넣는 시간) = L/R 초. (L: 패킷 크기[비트], R: 링크 전송률[비트/초])
* 저장 후 전달(Store-and-Forward) = 패킷 전체가 라우터에 다 도착해야 다음 링크로 보냄.
* 대기열/손실 = 들어오는 속도 > 내보내는 속도면 줄 서고, 버퍼가 차면 버려짐(손실).
* 회선 스위칭은 전용 차선을 먼저 깔고 고정속도로 통신(전화식). 데이터가 뜸하면 비효율.
* 인터넷은 보통 지역/국가급 ISP가 서로 연결되어 거대한 그물망을 만듭니다.

The network core
-----

&ensp;집·학교의 끝단(엣지)을 지나면 인터넷의 속으로 들어갑니다. 그 속이 바로 네트워크 코어이다.<br/>
* 라우터(router): 패킷의 다음 목적지를 정해 앞으로 넘기는 우체국 같은 장비.
* 그물망(mesh): 라우터들이 여러 경로로 서로 연결되어 있어, 한쪽이 막혀도 우회 가능.
* ISP 계층:
    - 지역/로컬 ISP ↔ 국가/글로벌 ISP가 맞물려 전 세계를 있다.
    - 콘텐츠 제공자(대형 플랫폼, CDN)도 자기 네트워크를 갖고 코어에 직접 연결하기도 한다.

&ensp;도시 곳곳의 **환승역(라우터)**을 갈아타며 편지(패킷)가 최종 주소로 가는 느낌!<br/>

1. 엣지 = 우리 기기(호스트) 가 있는 곳.
2. 클라이언트(요청) ↔ 서버(응답, 보통 데이터센터).
3. 접속망 = 집/회사/휴대폰이 통신사로 들어가는 골목길.
4. 물리 매체 = 길의 재질(케이블/전파).
5. 코어 = 라우터가 잔뜩 연결된 고속도로, 즉 네트워크들의 네트워크.

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-25.png" width="300"></p>

Packet-switching
-----

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-28.png" width="300"></p>

&ensp;왜 “패킷”으로 자를까?<br/>
&ensp;큰 파일을 한 번에 들고 가면 길을 오래 점유해요. 대신 **작은 상자(패킷)**로 나눠
1, 2, 3… 순서로 도로(링크)에 쭉쭉 밀어 넣으면 여러 사람이 도로를 공평하게 나눠 쓸 수 있다.<br/>

* 각 패킷은 독립적으로 라우터를 거쳐 감.
* 각 링크에서는 그 링크가 낼 수 있는 **최대 속도(R)**로 패킷을 보냄.

&ensp;전송 지연(Transmission delay)<br/>
&ensp;한 패킷을 링크에 밀어 넣는 시간<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-26.png" width="300"></p>

* 예시: L = 19 Kbits(= 10,000 비트), R = 100 Mbps(= 100,000,000 비트/초) -> 10,000/100,000,000 = 0.0001초 = 0.1m

&ensp;저장 후 전달(Store-and-Forward)<br/>
* 라우터는 패킷 전체가 다 도착하면(저장) → 다음 링크로 보냄(전달).
* 두 홉(송신자→라우터→수신자)만 있을 때, 전파/처리 지연 무시하면
끝-끝 지연 ≈ $ 2\times \frac{L}{R}$ 

&ensp;(링크가 두 번 있으니 두 번 밀어 넣는 시간)<br/>
&ensp;비유: 택배 상자가 완전히 도착해야 다음 트럭에 온전히 실을 수 있다.<br/>

&ensp;<b>대기열(큐) 지연과 손실 (Queueing delay & loss)</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-29.png" width="300"></p>

&ensp;왜 줄을 설까?<br/>
* 일정 시간 동안 **들어오는 비트율(도착률)**이 링크의 **처리 속도(R)**보다 크면,
라우터 버퍼에 **대기열(큐)**가 생긴다.

&ensp;무슨 일이 생기나?<br/>
* 큐잉 지연: 내 차례를 기다리는 시간 증가.
* 패킷 손실(drop): 버퍼가 가득 차면 늦게 온 상자는 바로 버림.

&ensp;→ 상위 프로토콜(TCP)이 다시 보내기로 회복하려고 함 → 더 느려질 수 있음.<br/>
&ensp;비유: 좁은 문을 여러 사람이 동시에 지나가려 하면 줄이 길어지고(지연), 너무 많은 사람이 한꺼번에 몰리면 문 밖에서 입장 컷(손실) 되는 것과 같아요.<br/>

&ensp;회선 스위칭 vs 패킷 스위칭<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-27.png" width="300"></p>

&ensp;지연의 4종 세트 (참고로 깔끔 정리)<br/>
1. 처리 지연: 라우터가 패킷 검사·결정하는 시간(아주 짧음)
2. 큐잉 지연: 줄 서 있는 시간(혼잡할수록 증가)
3. 전송 지연: 링크에 밀어 넣는 시간 = L/R
4. 전파 지연: 신호가 거리 d를 **속도 s(빛에 가까움)**로 가는 시간 = d/s

Two key network-core function: 포워딩(Forwarding) vs 라우팅(Routing)
------

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-30.png" width="300"></p>

&ensp;포워딩 = 근처에서 하는 즉시 분류<br/>
* 무슨 일? 라우터에 들어온 패킷을 어느 출구로 보낼지 바로 결정해서 출구 링크로 넘긴다.
* 어떻게? 라우터 안의 포워딩 테이블을 보고,
    - 패킷 겉면(= 헤더)의 목적지 주소를 조회 → 출구 번호를 찾음.
* 비유: 택배 물류센터의 작업자가 상자 주소를 보고 “이 문!” 하고 컨베이어벨트로 휙 보내는 것.

&ensp;포인트: 포워딩은 로컬(지역) 동작이에요. “지금 막 들어온 이 상자를 어디로 보낼까?”에만 집중.<br/>

&ensp;라우팅 = 멀리까지 길을 미리 그려두기<br/>
* 무슨 일? 출발지 → 목적지까지 패킷이 어떤 경로로 가야 할지 전반적으로 결정
* 어떻게? 여러 라우터가 라우팅 알고리즘(예: 최단경로)을 돌려서 각자의 포워딩 테이블을 만들어 둡니다.
* 비유: 내비게이션이 전체 지도를 보고 “이 길이 가장 빠르네!” 하고 노선을 잡아 주는 것

&ensp;포인트: 라우팅은 글로벌(전역) 동작이에요. “전체 지형을 보고 길을 설계” → 그 결과가 포워딩 테이블<br/>

Alternative to packet switching: circuit switching
------

&ensp;슬라이드처럼 빨간 선이 출발~도착을 전용 차선으로 예약한 모습이다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-31.png" width="300"></p>

* 자원 예약: 통화(연결) 동안 각 링크의 일부 자원을 독점으로 배정.
* 공유 없음: 다른 사용자는 그 구간을 함부로 못 씀 → 지연이 안정적(보장 성능).
* 비효율 가능: 내가 말을 안 하고 조용히 있어도 전용 차선은 빈 채로 묶여 있다.
* 어디서? 전통적인 전화망이 이 방식.

&ensp;패킷 스위칭은 작은 상자로 쪼개 도로를 함께 쓰는 방식, 회선 스위칭은 전용 도로를 아예 확보해 두고 달리는 방식<br/>

회선 스위칭을 구현하는 두 방법: FDM & TDM
-----

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-33.png" width="300"></p>

&ensp;FDM (Frequency Division Multiplexing, 주파수 분할)<br/>
* 방법: 하나의 링크(길)에서 주파수를 여러 칸으로 쪼갬. 사용자마다 **자기 칸(대역)**을 항상 가짐.
* 비유: 라디오 방송국이 주파수를 다르게 써서 동시에 방송하는 것.
* 특징: 각 사용자는 자기 대역 최대 속도로 연속 통신.

&ensp;TDM (Time Division Multiplexing, 시간 분할)<br/>
* 방법: 시간을 작은 슬롯으로 쪼갬. 사용자마다 **자기 차례(슬롯)**에만 번갈아 말함.
* 비유: 신호등처럼 번갈아 지나감. 내 차례에만 전용도로가 완전히 내 것이 됨.
* 특징: 내 슬롯 시간에는 링크 전체 속도를 쓰지만, 평균으로는 **(전체/사용자 수)**가 됨.

&ensp;숫자 감각(쉬운 예)<br/>
* 링크 용량 4 Mbps, 사용자 4명:
    - FDM: 각자 1 Mbps를 항상 보유.
    - TDM: 내 차례엔 4 Mbps를 쓰지만 시간이 1/4이므로 평균 1 Mbps.
* 결론: 평균으론 비슷하지만, FDM은 항상 조금씩, TDM은 번갈아 왕창 쓰는 차이.

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-32.png" width="300"></p>

Packet switching vs circuit switching
------

&ensp;1) 상황 설정<br/>
* 링크 용량: 1Gbps = 1000 Mbps
* 각 사용자: 활동(전송)할 때 100Mbps 사용 (활동하는 시간 비율 = 10%(=0.1), 나머지 90%는 쉬는 중)
* 동시에 활동 가능한 최대 사용자 수(물리 한계): 1000 / 100 = 10명

&ensp;2) circuit 스위칭이면?<br/>
&ensp;circuit 스위칭은 전용 차선을 먼저 깔아둔다. 따라서 무조건 10명까지만 수용 가능하다.(도로가 쉬어도 차선은 묶어 있음 -> 비효율)<br/>

&ensp;3) 패킷 스위칭이면? (확률 모델)<br/>
&ensp;모두가 늘 활동하지는 않으니 동시에 활동 중인 사람만 링크를 공유해서 쓴다.<br/>
* 사용자 수를 N이라 하고
* 한 사용자가 어떤 순간에 활동 중일 확률 p = 0.1(독립 가정)

&ensp;그러면 한 순간에 활동 중인 사람 수 X는 이항 분포 X ~ Binomial(n = N, p = 0.1)<br/>
* 평균(기대값): $E[X] = Np$
* 표준편차: $\sqrt{Np(1-p)}$

&ensp;4) N=35명일 때, 동시에 10명 초과가 될 확률은 왜 0.0004?<br/>
&ensp;링크는 동시에 10명까지만 감당 가능이니 문제 상황은 $X\geq 11$
&ensp;정확한 식<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-34.png" width="300"></p>

&ensp;이걸 계산하면<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-35.png" width="300"></p>

&ensp;즉 0.0042% 수준<br/>
&ensp;말 그대로 거의 안 겹친다는 뜻이다.<br/>
&ensp;직관 체크: 평균은 35 x 0.1 = 3.5명이다. 보통은 3~4명만 동시에 활동하니 10명을 넘길 일이 매우 드물다.<br/>

&ensp;5) 그럼 35명보다 더 많이 붙이면? (N ↑)<br/>
&ensp;N이 커질수록 동시에 10명 초과 확률은 빨리 증가한다.(여전히 각 사용자는 10%만 활동한다고 가정)<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-36.png" width="300"></p>


* 의미: N = 50이면 동시에 10명 초과 상황이 약 1% 확률로 발생
* N을 더 키우면 혼잡, 대기열, 손실이 눈에 띄게 늘어난다.(패킷 스위칭은 동작은 하지만 지연, 손실이 커짐)

&ensp;6) 왜 패킷 스위칭이 “더 많은 사용자”를 수용할까?<br/>
* 대부분의 앱은 툭툭(bursty) 보낸다.(항상 100Mbps를 꽉 채우지 않음)
* packet 스위칭은 필요할 때만 링크를 공유해서 쓰므로 빈 시간을 서로 채워 효율 ↑
* circuit 스위칭은 전용 차선이므로 쉬는 시간도 비어 있는 차선을 계속 점유 -> 효율 ↓

&ensp;7) But, 패킷 스위칭이 항상 최고? (한계와 보완)<br/>
* 혼잡이 심하면: 대기열 지연↑, 버퍼 오버플로우로 손실 발생
    - 신뢰성 있는 전송(TCP 재전송), 혼잡 제어 같은 프로토콜이 필요
* 회선 같은 품질 보장이 필요할 땐?
    - 전용선, QoS 예약/보장 대역폭(오디오/비디오 실시간용) 등으로 보장형 서비스를 곁들임

&ensp;8) 요약<br/>
* circuit switching: 전용 차선 예약 -> 10명 고정, 단순·지연 안정 but 비효율
* packet switching: 필요 시 공유 -> 35명이 붙여도 동시 10명 초과 확률 ≈ 0.0004. 단 N이 커지면 혼잡·지연·손실 증가 -> 프로토콜과 QoS로 보완

Internet structure: a network of networks
-----

&ensp;인터넷 접속(Access ISP)<br/>
* 인터넷은 수많은 네트워크가 서로 연결된 그물이다.
* 사용자는 접속 사용자(Access ISP)를 통해 인터넷에 들어간다.
* 접속 ISP는 동네 인터넷 입구 같은 곳이다. 여기서 바깥 세상으로 나가는 큰 길로 합류한다.

&ensp;모두-모두 직접 연결”의 비확장성<br/>
* 전 세계에 접속망이 N개 존재한다고 가정할 때 서로를 직접 연결하려면 필요한 연결 수는 

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-37.png" width="300"></p>

* 예시: N=1,000 → 499{,}500개 연결 필요, N = 1,000,000 -> 약 $5\times 10^{11}$ 개 연결 필요
* 비용·구축·운영이 현실적으로 불가능함
* 결론: 계층 구조와 교환 지점을 도입하여 연결 수를 줄이고 운영을 단순화해야 함

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-38.png" width="300"></p>

&ensp;모든 Access ISP를 한 개의 글로벌 사업자에 연결하면?<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-39.png" width="300"></p>

* 상황: 각 지역의 Access ISP가 단 하나의 글로벌 transit ISP에 상향 연결(uplink)하는 구조를 가정함
* 관계: Access ISP(고객, customer) <-> 글로벌 ISP(제공자, provider)
    - 글로벌 ISP는 전 세계 어느 곳이든 갈 수 있는 경로(reachability)를 대가를 받고 제공함(paid transit)
    - Access ISP의 트래픽을 글로벌 ISP가 받아 외부에 전달하고 외부에서 들어오는 트래픽도 되돌려 보냄
* 장점
    1. 구성 단순: 계약·운영 창구가 한 곳임
    2. 전역 경로 보장: 고객망이 별도의 추가 연결 없이 세계 대부분과 통신 가능함
* 단점
    1. 단일 사업자 의존(vendor lock-in) 및 단일 장애 지점 형성 가능
    2. 가격 협상력 약화: 경쟁 부재 시 요금·품질에서 불리할 수 있음
    3. 경로 비효율: 더 가까운 이웃망과 바로 교환하면 짧을 경로가, 글로벌 사업자를 경유하며 길어질 수 있음

&ensp;하나의 글로벌 ISP가 가능하면 경쟁자도 생김<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-40.png" width="300"></p>

* 현실: 글로벌 규모의 사업자가 여럿 존재함(ISP A/B/C)
* 효과
    - Access ISP는 사업자 선택권을 갖게 되며 필요하면 여러 곳에 동시에 연결(multihoming)하여 장애 대비와 품질을 향상함
    - 그런 A↔B↔C 서로 간 트래픽 교환이 필요해지므로 사업자 간 연결 정책과 정산 방식이 중요해짐

&ensp;IXP, peering link<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-41.png" width="300"></p>

* IXP(Internet eXchange Point): 다수의 네트워크가 한 장소에서 직접 트래픽을 교환하는 공용 접속 지점.
    - 보통 대형 스위치/라우터 패브릭을 통해 **공유 이더넷(공용 페브릭)**으로 연결함(public peering)
    - 대량 교환이 필요하면 전용 케이블로 1:1 연결을 추가하기도 함(private peering)
* Peering: 두 사업자가 상호 합의로 트래픽을 직접 주고받는 연결
    - Settlement-free peering: 정산 없이 상호 교환(트래픽 비율·지역성 등 조건 충족 시)
    - Paid peering: 일반 또는 쌍방이 대가를 지급하고 직접 연결
* 필요한 이유
    1. 경로 단축·지연 감소: 가까운 곳에서 바로 교환하면 왕복 시간이 줄어듦.
    2. 비용 절감: 제 3의 transit을 경유하지 않아 트랜짓 요금을 절약함
    3. 품질·제어: 혼잡 구간을 우회하고 특정 트래픽을 원하는 경로로 유도 가능(BGP 정책)
* 요약: IXP와 peering은 모두를 모두와 직접이 아닌 효율적인 선택적 직접 연결을 제공함

&ensp;Regional ISP<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-42.png" width="300"></p>

* 필요성: 소규모 Access ISP가 곧바로 글로벌 사업자나 여러 IXP에 연결하기에는 규모
* 역할: Regional ISP는 여러 Access ISP의 트래픽을 지역 단위에서 모아 상위 사업자, 다른 지역망, IXP로 연결해 주는 중간 사업자이다.
* 효과
    - 소규모 사업자는 Regional ISP 한 곳만 연결해도 넓은 도달성 확보 가능
    - 지역 내에서 짧은 경로의 교환이 가능하여 지연이 줄고 국제 회선 의존이 낮아진다.
    - 장애 시 우회 경로를 제공하여 복원력(resilience)을 높인다.

&ensp;콘텐츠 제공자 네트워크(Content provider network, CDN)의 병행 운용<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-43.png" width="300"></p>

* 현실: Google, Microsoft, Akamai 등 콘텐츠/클라우드 사업자는 자체 사설 네트워크(private backbone)와 엣지 PoP/캐시 서버(Edge, CDN)를 운영함
* 배치 위치: IXP 내부 또는 Access/Regional ISP의 시설 안쪽(so-called on-net cache)에 서버를 설치한다.
* 동작
    - 이용자 요청은 가장 가까운 엣지로 라우팅됨(Anacast, DNS 지능형 응답, BGP 정책 등)
    - 자주 쓰는 동영상·이미지·소프트웨어 업데이트는 근접 서버에서 직접 제공되어 원거리 전송을 최소화함
* 효과
    1. 지연·버퍼링 감소 및 전송 속도 향상
    2. Access/Regional/글로벌 사업자 모두의 국제 구간의 트래픽 부담 완호
    3. 대규모 이벤트(신작 공개, OS 업데이트 등)에서도 안정적인 품질 유지

&ensp;인터넷의 network of networks 요약<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-44.png" width="300"></p>

* Access ISP: 가정·학교·기업 단말이 직접 연결되는 지역 사업자
* Regional ISP: 여러 Access ISP의 트래픽을 모아 상위와 교환하는 광역 사업자(aggregation 역할)
* IXP(Internet eXchange Point): 서로 다른 네트워크가 직접 트래픽을 교환하는 고용 접속 지점
* Tier-1 ISP: 전 세계를 대상으로 운영되는 대형 사업자. 일반적으로 타 대형 사업자와 상호 무정산 피어링을 통해 제 3자 없이 전 세계 도달성을 제공함
* 콘텐츠 제공자 네트워크(예: Google): 자체 사설망과 데이터센터/엣지 노드를 보유한 사업자. IXP나 개별 ISP와 직접 연결하여 사용자에게 더 가까운 곳에서 서비스를 제공함

&ensp;핵심 메시지<br/>
* 인터넷의 중심에는 소수의 대형 네트워크(Tier-1, 대형 콘텐츠 사업자)가 있고 이들과 Regional/Access ISP, IXP가 얽혀 메시형+계층형 구조를 이룬다.
* 콘텐츠 사업자는 IXP나 개별 ISP에 바로 접속해 트래픽을 주고받으므로 경우에 따라 Tier-1/Regional 경우를 건너뛰는(bypass)경로가 형성됨 -> 지연 감소, 비용 절감, 품질 향상에 유리함
* 이런 연결과 경로 선택은 주로 BGP정책(피어링/트랜짓 계약, 우선순위 등)에 의해 결정된다.

&ensp;Tier-1 ISP 예시: Sprint(2019) 네트워크 맵 해설<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-45.png" width="300"></p>

&ensp;PoP (Point-of-Presence): 사업자가 장비를 설치해 고객·타 사업자와 실제로 접속하는 거점. 도시마다 여러 PoP가 배치되어 있다.<br/>
* 삽화에 보이는 라우터 묶음은 한 PoP 내에서의 내부 연결(코어 라우터 ↔ 옛지 라우터 등)을 단순화해 표현한 것

&ensp;ore/long-haul links(지도에 굵은 선): 주요 도시의 PoP 사이를 잇는 장거리·대용량 회선. 국가 내부를 가로지르며 다중 경로로 구성되어 **복원력(resilience)**을 확보한다.<br/>
&ensp;Links to peering networks: 다른 사업자망과 연결되는 피어링 회선. IXP 또는 전용 1:1 링크 형태<br/>
&ensp;Links to/from customer networks: Sprint 고객(Access/기업 고객 등)과 연결되는 고객 접속 회선.<br/>
&ensp;Landing station 표식: 해저케이블이 육지로 올라오는 지점. 국제 구간 트래픽이 드나드는 관문으로, 해안 도시 PoP와 긴밀히 연결된다.<br/>
&ensp;Coverage 색상 영역: 서비스 제공 범위를 개략적으로 표시. 물리적 경로(선)와 상업적 제공 범위(색 면적)는 구분해야 한다.<br/>

&ensp;왜 이렇게 설계되는가<br/>
* 지리적 분산: 이용자와 가까운 곳에 PoP를 두면 접속 지연이 줄고, 장애 시 우회 경로를 쉽게 확보할 수 있음.
* 다중 경로: PoP 간에 서로 다른 경로를 여러 개 두어(링, 메쉬 등) 단선·재해에도 서비스가 지속되도록 함.
* 국제 연동: 해저케이블 랜딩 스테이션과 인접 PoP를 통해 해외 트래픽을 주고받음. 이 구간에서도 타 사업자와 피어링/트랜짓 조합으로 경로를 최적화함.

&ensp;정리<br/>
* Tier-1 ISP는 전국/대륙 규모의 PoP와 장거리 링크를 촘촘히 배치해, 국내외 어디로든 트래픽을 운반할 수 있는 광범위한 도달성과 고가용성을 제공한다.
* 실제 이용자는 Access ISP → (Regional/IXP) → Tier-1 또는 콘텐츠 네트워크로 이어지는 경로 중 가장 정책상 유리한 길을 통해 통신하게 된다.

Performance: loss, delay, throughput
====

&ensp;손실과 지연은 왜 생길까?<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-46.png" width="300"></p>

&ensp;네트워크는 계산대(라우터) + 즐(버퍼/대기열)같음<br/>
* 패킷은 라우터에 도착하면 줄을 섬 → 자기 차례가 오면 전송됨
* 어떤 순간에 들어오는 속도(도착률)가 내보내는 속도(링크 속도)보다 크면 줄이 길어져 지연이 커짐
* 줄(버퍼)이 꽉 차면 뒤에 오는 패킷은 들어갈 자리 없음 → 버림(loss)

&ensp;한 줄 요약: 잠깐 몰리면 = 지연↑, 오래 몰리면 = 손실↑<br/>

Packet delay: four sources
------

&ensp;지연(delay)에는 4가지가 섞여 있음<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-47.png" width="300"></p>

&ensp;1. 처리 지연(nodal processing): $d_{proc}$ :<br/>
&ensp;라우터가 헤더 확인·오류 검사·출구 선택에 쓰는 시간(보통 < 1 ms)
&ensp;2. 대기열 지연(queueing delay) $d_{queue}$ :<br/>
&ensp;내 차례가 올 때까지 줄 서는 시간. 혼잡할수록 커지고 한가하면 거의 0<br/>
&ensp;3. 전송 지연(transmission delay) $d_{trans}$ : <br/>
&ensp;링크로 밀어 넣는 시간<br/>

&ensp;$d_{trans} = \frac{L}{R}$ <br/>
* L: 패킷 길이(비트)
* R: 링크 속도(bps)

&ensp;4. 전파 지연 $d_{prop}$ <br/>
&ensp;물리적 거리를 신호가 달려가는 시간<br/>

&ensp;$d_{prop} = \frac{d}{s}$ <br/>
* d: 선 길이(미터)
* s: 매체에서의 신호 속도(광섬유 대략 $2\times 10^8m/s$)

&ensp;숫자로 보기<br/>
&ensp;전송 지연 $d_{trans} = L/R$ <br/>
* 예: L = 1,500 Byte = 12,000 bit
    - 100Mbps 링크 → 12,000/100,000,000 = 0.00012 s = 0.12ms(120 µs)
    - 1 Gbps 링크 → 0.012 ms (12 µs)
    - 10 Mbps 링크 → 1.2 ms

&ensp;같은 패킷이라도 링크가 빠를수록 전송 지연은 비례해서 작아진다.<br/>

&ensp;전파 지연 $d_{prop} = d/s$ <br/>
* 예) 광섬유 속도 $2 \approx 2 \times 10^{8} m/s$ 
    - 1,000 km(=1,000,000 m) → 1,000,000/200,000,000 = 0.005s = 5ms
    - 5,000 km → 25 ms (한 번에 대륙 간 왕복이면 50 ms 이상 가능)

&ensp;전파 지연은 속도 R을 올려도 줄어들지 않음. 거리를 줄여야 줄어듦(CDN·가까운 서버).<br/>

&ensp;대기열 지연<br/>
&ensp;내 앞에 같은 크기 패킷이 n개 대기 중이면<br/>
&ensp;$d_{queue} \approx n\cdot \frac{L}{R}$ <br/>
&ensp;앞에 3개, L = 1,500B, R = 100Mpbs → 3 x 120μs=360μs<br/>

&ensp;한 번에 합쳐 보기<br/>
&ensp;가정<br/>
&ensp;L=1,500B, R=100Mbps, 거리 d = 1,000km, 앞에 3개 대기, 처리 지연 $d_{proc} = 0.2ms$

* 계산
    - $d_{trans} = 0.12ms$
    - $d_{prop} = 5ms$
    - $d_{queue} = 0.36ms$
    - $d_{proc} = 0.2ms$
* 합계 $d_{nodal} \approx 0.2 + 0.36 + 0.12 + 5 = 5.68 ms$

&ensp;홉이 늘면(라우터를 더 거치면) 비슷한 값이 홉 수만큼 누적됨<br/>

&ensp;손실(loss)은 언제 생기나? — 버퍼 꽉 찰 때<br/>
&ensp;상황 시뮬레이션<br/>
&ensp;링크 속도 R = 100Mbps, 잠깐 트래픽이 150 Mbps로 몰림 → 초당 50 Mbps가 처리 못 하고 줄로 쌓인다.<br/>

&ensp;버퍼 크기 1MB(=8 Mbit)라고 하면 <br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-48.png" width="300"></p>

&ensp;160 ms동안 몰림이 계속되면 버퍼가 포화 → 그 다음 패킷부터 드롭 발생<br/>
&ensp;혼잡이 시작되면 먼저 지연이 급증, 계속되면 손실로 이어진다.<br/>

&ensp;느리거나 끊길 때, 무엇을 바꾸면 좋아지나?<br/>
* 거리 줄이기(전파 지연↓): 가까운 서버 사용, CDN/캐시 활용.
* 링크 속도 올리기(전송 지연·혼잡↓): 100 Mbps → 1 Gbps 등
* 대기열 관리(대기열 지연·손실↓): 버퍼 적정화, AQM(CoDel/RED), QoS 우선순위
* 처리 최적화(처리 지연↓): 라우터 성능, 하드웨어 가속
* 트래픽 모양 잡기: 피크 분산(스케줄링), 패킷 크기 조정(작은 제어 패킷 우선)

&ensp;미니 연습문제<br/>
&ensp;L = 1,200B, R = 50 Mbps, 거리 d = 800km(광섬유), 앞에 5개 대기 $d_{proc} = 0.1ms$ . 한 홉 지연을 구하라<br/>

* L = 1,200B = 9,600 bit
* $d_{trans}$ = 9,600/50,000,000=0.000192 s = 0.192 ms
* $d_{prop}$ = 800,000/200,000,000=0.004 s = 4 ms
* $d_{queue}$ ≈ 5×0.192=∗∗0.96ms
* 합: 0.1 + 0.96 + 0.192 + 4 = 5.252 ms

Caranan analogy
------

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-49.png" width="300"></p>

&ensp;속도 100 km/h, 톨게이트 1대당 12초<br/>
&ensp;상황<br/>
* 차 10대가 한 묶음(=패킷)으로 줄줄이 이동
* 차들은 시속 100 km로 달림(=전파 속도)
* 톨게이트는 차 한 대 처리에 12초 걸림(=전송 지연)
* 톨게이트 사이 거리는 100 km

&ensp;먼저 첫 톨게이트에서 모두 밀어 내는 데 걸리는 시간<br/>
* 1대 12초 x 10대 = 120초(=2분)

&ensp;그다음 맨 마지막 차의 이동(전파) 시간<br/>
* 100 km / 100km/h = 1시간(=60분)

&ensp;질문: 두 번째 톨게이트 앞에 카라반이 줄을 선 때는 언제인가?<br/>
&ensp;→ 마지막 차까지 도착한 순간이니까<br/>
* 시작 후 2분 (밀어냄) + 60분(이동) = 62분

&ensp;첫 번째 차는 1번째 톨게이트를 12초 후 통과했고 그때부터 100km를 달러 60분 뒤 도착 → 시작 기준 60분 12초에 2번째 톨게이트에 도착한다. 하지만 카라반 전체가 줄 선 시점은 마지막 차 기준이어서 62분이 정답<br/>

&ensp;속도 1000 km/h, 톨게이트 1대당 1분<br/>
&ensp;상황 변경<br/>
* 차 속도: 1000 km/h (아주 빠름)
* 톨게이트 처리: 1대당 1분(오히려 느려짐)
* 거리: 100 km (그대로)

&ensp;첫 차가 2번째 톨게이트에 도착하는 시간<br/>
* 첫 차가 1번째 톨게이트 통과: 1분 후
* 그다음 100km 이동 시간: 100 / 1000h = 0.1 시간 = 6분
* 합계 1 + 6 = 7분 => 7분에 도착

&ensp;질문: “첫 톨게이트에서 모두 처리되기 전에 2번째에 먼저 도착하나?” → 네! 7분에 도착할 때, 첫 톨게이트는 1분에 한 대씩 처리 중이므로 아직 3대가 남아 있음(10대 중 7대 처리 완료)<br/>

&ensp;도로가 엄청 빨라도 톨게이트(= 라우터 출력 속도)가 느리면 대기열 지연이 생긴다.<br/>

패킷 대기열 지연(다시 보기): 혼잡 정도
------

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-50.png" width="300"></p>

* R: 링크 속도(bps, 초당 보낼 수 있는 비트)
* L: 패킷 길이(비트)
* a: 초당 들어오는 패킷 수(arrival rate)
* $\rho =\frac{La}{R}$ 를 혼잡 정도(traffic intensity)라고 부름 → 초당 들어오는 비트양(La) / 내보내는 능력(R)

&ensp;해석<br/>
* ρ ≈ 0 이면 한가함 → 대기열 지연 거의 0
* ρ → 1 이면 처리 능력에 딱 맞게 들어옴 → 대기열 급증(그래프가 위로 솟음)
* ρ > 1 이면 들어오는 게 내보내는 것보다 많음 → 줄이 계속 쌓여 평균 지연이 무한대로 발산(결국 드롭 발생)

&ensp;숫자 감각(예시)<br/>
* L = 1,500B = 12,000비트, R = 100Mbps
* ρ = 1 이 되려면 a = R/L = 100,000,000/12,000 ≈ 8,333 패킷/초
    - a = 2,000 패킷/초 → 𝜌 ≈ 0.24 → 여유
    - a = 8,000 패킷/초 → 𝜌 ≈ 0.96 → 조금만 더 몰려도 대기열 폭증

&ensp;고속도로 비유: 빈 도로(ρ≈0)는 빠르고 퇴근길 정체(ρ→1)는 살짝만 차가 늘어도 금방 꽉 막힌다.<br/>

진짜 인터넷 지연·경로를 보는 법: traceroute(트레이스라우트)
------

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-51.png" width="300"></p>

&ensp;traceroute의 역할<br/>
* 내 컴퓨터에서 목적지까지 가는 패킷의 경로(라우터 목록)와 각 중간 라우터까지 걸린 왕복시간(RTT)을 측정해 보여줌
* 운영체제 명령:
    - Windows: tracert www.example.com
    - macOS/Linux: traceroute www.example.com (기본은 UDP, 옵션으로 ICMP/TCP 가능)

&ensp;동작 원리<br/>
&ensp;인터넷 패킷에는 TTL(Time To Live, IPv6에선 Hop Limit) 이라는 숫자가 있다. 라우터를 하나 지날 때마다 TTL이 1씩 감소, 0이 되면 패킷은 폐기되고 그 라우터가 ICMP Time Exceeded라는 에러 메시지를 보내준다.<br/>
&ensp;traceroute는 이 점을 이용해 TTL을 1,2,3… 순서대로 늘려 보낸다.<br/>
1. TTL=1 패킷 전송 → 첫 번째 라우터에서 0이 되어 버려짐 → 그 라우터가 나에게 ICMP Time Exceeded 회신 → 보낸~받은 왕복시간 = 1홉 지연으로 기록
2. TTL=2 → 두 번째 라우터에서 버려짐 → 두 번째 라우터의 회신 시간 기록
3. 이런 식으로 TTL을 3,4,5… 늘려가다가 목적지까지 도달하면(UDP 기반일 경우) 목적지에서 ICMP Port Unreachable로 답장을 보내며 종료

&ensp;보통 한 홉당 3번씩 보내서 결과가 들쭉날쭉하지 않도록 표본 3개의 RTT를 보여준다. 세 값이 차이나면 그 홉이 바쁘다(큐잉 지연 변동)는 뜻<br/>

&ensp;출력 읽는 법<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-52.png" width="300"></p>

&ensp;각 줄 = 한 홉<br/>
&ensp;형식: 홉번호 라우터이름(IP) rtt1 rtt2 rtt3
* 초반 17홉: **122 ms** 정도 → 같은 대륙/국가 내부일 가능성
* 7→8홉 사이에 22 ms → 100+ ms로 급점프 → 흔히 대양 횡단(미국↔유럽) 같은 긴 물리 거리
    - 계산으로 감 잡기: 대서양 약 6,000 km / 광섬유 속도 $2 \times 10^8m/s ≈ 30 ms$ (편도) → 왕복만 60 ms + 장비·큐잉 지연 합치면 100 ms대 현실적
* 이후 819홉: 100135 ms 범위 → 유럽 내부 라우터들을 지나 목적지(132~136 ms) 도착
* \* \* \* : 응답 없음
    - 사라진 게 아니라 그 라우터가 ICMP 응답을 차단/속도제한(rate-limit)하거나, 손실이 났을 수 있음. 다음 홉이 보이면 실패가 아니라 비응답일 뿐
* 지연이 줄어드는 것처럼 보인다(looks like delays decrease)
    - 각 숫자는 그 홉까지의 왕복시간이지, 직전 홉에서 추가된 시간이 아님.
    - 또한 되돌아오는 경로가 매번 다르거나(경로 비대칭), 라우터가 ICMP 응답을 낮은 우선순위로 처리하면 앞 홉 값이 더 크게 보일 수 있어 단조증가하지 않습니다.

&ensp;왜 3개의 시간이 다를까?<br/>
* 대기열(큐) 상황이 순간순간 달라서 같은 홉도 RTT가 출렁
* ECMP(부하분산) 때문에 3개의 probe가 다른 하위 경로로 갈 수도 있어요(세 IP가 번갈아 보이기도 함)
* ICMP rate-limit: 라우터가 응답을 천천히 주거나 일부만 주기도 함

&ensp;traceroute로 유추할 수 있는 것<br/>
* 큰 점프 구간 → 물리 거리가 긴 구간(해저케이블/대륙 간)일 확률 큼
* 별표(*)가 연속 → 중간 장비가 비응답(방화벽/정책)일 가능성. 다음 홉이 계속 나오면 경로 자체는 살아 있음
* RTT가 끝으로 갈수록 커짐 → 정상적. 다만 앞서 말했듯 가끔 줄어들기도 함(측정 아티팩트)
* 목적지까지의 RTT ≈ 체감 지연의 하한선(앱 지연은 여기에 서버 처리·TCP 핸드셰이크·재전송 등이 더해짐)

Packet loss
-----

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-53.png" width="300"></p>

&ensp;인터넷에서 패킷은 편지 한 통처럼 작은 데이터 조각이다.<br/>
&ensp;라우터(중간 우체국)에는 패킷이 잠깐 기다리는 대기실(=버퍼/큐)이 있다. 의자 수는 한정되어 있다.<br/>
&ensp;어떤 순간에 패킷이 물려오면 대기실이 가득 찬다. -> 늦게 온 패킷은 밖에서 떨어뜨려진다. = 손실<br/>

&ensp;떨어진 패킷은<br/>
1. 바로 앞 라우터가 “다시 보내 주세요” 하고 재전송하거나
2. 처음 보낸 컴퓨터가 “답이 없네?” 하고 다시 보낼 수 있음
3. 아니면 그냥 버려져서 사라질 수도 있음(서비스에 따라 다름)

&ensp;비유<br/>
* 놀이공원(라우터) 입구 대기실 의자가 5개뿐이라고 가정.
* 6번째 손님이 오면 들어갈 자리가 없어서 되돌아감(손실).
* 손님이 덜 몰릴 때 다시 오면 입장 가능.


Throughput
-----

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-54.png" width="300"></p>

* 처리속도(스루풋) = 단위 시간(1초) 에 도착지로 도착한 비트 수
    - 순간 처리속도: 지금 이 순간의 속도
    - 평균 처리속도: 쭉-오랜 시간의 평균 속도
* 물 파이프 비유
    - 서버가 물을 붓고(데이터 전송), 굵기가 서로 다른 파이프 여러 개를 지나 최종 컴퓨터로 감
    - 가장 가는 파이프가 전체 물의 양을 결정함 -> 이게 병목(bottleneck)

&ensp;두 구간의 속도가 다를 때: 병목은 "더 느린 쪽"<br/>
* $R_s$ : 서버 쪽 파이프가 감당하는 최대 속도(예: 서버/업로드 구간).
* $R_c$ : 클라이언트 쪽 파이프가 감당하는 최대 속도(예: 집/휴대폰 구간)

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-55.png" width="300"></p>

&ensp;경우 A) $R_s < R_c$ <br/>
* 서버 쪽이 느림 -> 전체 처리속도 = $R_s$
* 예: $R_s = 30Mb/s, R_c = 100Mb/s -> 30Mb/s$ 가 최대

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-56.png" width="300"></p>

&ensp;경우 B) $R_s > R_c$ <br/>
* 내 단말 쪽이 느림 -> 전체 처리속도 = $R_c$
* 예: $R_s = 200Mb/s, R_c = 50Mb/s -> 50Mb/s$ 가 최대

&ensp;전체는 가장 느린 구간(병목)만큼만 빨라진다.<br/>

&ensp;여러 연결이 한 길을 "공유"하면?<br/>

&ensp;상황: 가운데 공용 구간이 있고 동시에 10개의 연결이 이 구간을 함께 사용<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-57.png" width="300"></p>

* 공유 구간의 최대 속도: R(모두가 나눠 쓰는 제한 속도)

&ensp;각 연결의 처리속도는 보수적으로<br/>
&ensp;$min(R_c, R_s, R/10)$ 로 생각하면 됨<br/>

* 이유
    - 내 앞/뒤 구간이 느리면( $R_S$ 또는 $R_c$ )거기서 막힘
    - 중간 공용 구간은 10명이 공평하게 나눠 갖는다고 보면 1명당 R/10정도가 현실적인 상한

&ensp;숫자 예제1<br/>
* $R_S = 50Mb/s, R_c = 20Mb/s, R = 100Mb/s$
* R/10 = 10Mb/s -> min(20, 50, 10) = 10
* 결과: 한 연결 평균 ≈ 10Mb/s(공용 구간이 병목)

&ensp;숫자 예제2<br/>
* $R_S = 15Mb/s, R_c = 40Mb/s, R = 200Mb/s$
* R/10 = 20Mb/s -> min(40, 15, 20) = 15
* 결과: 서버 쪽이 병목이라 15Mb/s

&ensp;숫자 예제3<br/>
* $R_S = 300Mb/s, R_c = 30Mb/s, R = 1000Mb/s$
* R/10 = 100Mb/s -> min(30, 300, 100) = 30
* 결과: 내 단말/가정 회선이 병목이라 30Mb/s

&ensp;왜 느려지고, 어떻게 좋아질까?<br/>
* 패킷 손실: 대기실이 꽉 차서 생김 → 재전송이 많아져 더 느려짐.
* 혼잡: 동시에 많은 사람이 같은 길(링크)을 쓰면 기다림(지연) 이 길어짐.
* 개선법 예시
    - 더 큰 대역폭 요금제(굵은 파이프)로 바꾸기(= $R_c$ 업그레이드)
    - Wi-Fi보다 유선 랜을 쓰거나, 공유기 가까이에서 사용.
    - 같은 시간에 대용량 다운로드를 줄여 공유 구간 혼잡 완화.
    - 서버 쪽(클라우드/업로드)이 병목이면 $R_s$ 가 더 큰 서비스/지역으로 전환.

Security
====

Network security
-----

&ensp;나쁜 사람이 인터넷에서 엿보기, 훔치기, 방해하기를 하지 못하게 막는 일<br/>
&ensp;무엇을 연구?<br/>
1. 나쁜 사람이 어떻게 공격하는지
2. 우리는 어떻게 막는지
3. 처음부터 튼튼하게 설계하는 방법

&ensp;중요한 이유: 인터넷은 처음에 "서로 믿는 사람들끼리 쓰는 길"처럼 만들어져서 보안이 약하게 시작했다. 그래서 **모든 층(앱, 전송, 네트워크, 링크, 물리)**에서 보안을 챙겨야 한다.<br/>

&ensp;<b>말웨어(malware)</b><br/>
&ensp;몸에 들어오는 세균과 비슷하다.<br/>

* 바이러스(virus):
    - 메일 첨부파일처럼 “열어야” 퍼짐.
    - 내가 실행하면 내 컴퓨터에 붙고, 또 다른 파일에 붙어서 전파.
* 웜(worm):
    - 스스로 퍼짐. 누가 열어주지 않아도 빈틈(취약점)을 찾아 이 컴퓨터, 저 컴퓨터로 이동.
* 스파이웨어(spyware):
    - 키보드 입력, 방문한 사이트 같은 정보를 몰래 모아 보냄.
* 봇넷(botnet):
    - 감염된 많은 컴퓨터를 몰래 군대처럼 묶어 주인이 시키는 대로 공격에 사용.

&ensp;생활 수비법<br/>
&ensp;모르는 파일/링크 열지 않기, OS·브라우저·앱 자동 업데이트, 백신 켜두기<br/>

&ensp;<b>서비스 방해(DoS/DDoS)</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-58.png" width="300"></p>

&ensp;비유: 인기 빵집에 괴짜 손님 수천 명이 한꺼번에 줄 서면, 진짜 손님은 못 사죠.<br/>
* DoS: 한 곳에서 가짜 트래픽을 왕창 보내 서버를 지치게 함.
* DDoS: 봇넷처럼 많은 감염 PC가 동시에 공격(더 세다!).
* 공격 단계(그림 순서)
* 목표 정하기 → 2) 곳곳의 컴퓨터를 감염(봇넷 만들기) → 3) 가짜 요청을 한꺼번에 발사
* 수비 아이디어: 트래픽 걸러내는 방화벽/스크러빙 센터, 콘텐츠 분산(CDN), 요청 속도 제한, CAPTCHA 등.

&ensp;<b>패킷 엿보기(스니핑, packet interception)</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-59.png" width="300"></p>

&ensp;비유: 같은 교실에 있으면 누군가의 쪽지를 훔쳐볼 수 있죠<br/>
* 공유되는 매체(공용 이더넷, 공용 와이파이)에서는, 장비를 스니퍼 모드로 두면 지나가는 패킷을 전부 읽을 수 있어요.
* Wireshark 같은 도구로 패킷 내용을 볼 수 있어요(교육·분석용 합법 사용).
* 그래서 암호화가 필수!
    - 웹은 HTTPS(자물쇠 표시), 와이파이는 WPA2/3 사용.
    - 공용 와이파이에서는 VPN 쓰면 더 안전.
    - http(자물쇠 없음) 로그인은 절대 금지!

&ensp;<b>IP 스푸핑(IP spoofing, 가짜 주소)</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-60.png" width="300"></p>

&ensp;편지에 보낸 사람 주소를 거짓으로 쓰기<br/>
* 공격자가 패킷의 **보낸 주소(IP)**를 거짓으로 적어 보냄.
* 목적: 자기 정체 숨기기, 또는 증폭 공격(특정 서버가 대신 큰 답장을 목표로 보내게) 등에 사용
* 수비
    - 통신사/망에서 필터링(들어올 때·나갈 때 말이 안 되는 출발지 주소 걸러내기).
    - 인증과 **암호화(TLS/HTTPS)**로 “진짜 누구인지” 확인.

Protocol layers, service models
====

&ensp;<b>레이어(층)으로 나누는 이유</b><br/>
* 인터넷은 부품이 많고 복잡하다: 앱, 컴퓨터(호스트), 라우터, 여러 가지 전송 매체(와이파이, 광케이블…), 수많은 프로토콜…
* 복잡할수록 구획을 나눠 생각해야 관리가 쉽다. → 그래서 기능을 층(layer) 으로 나눠서 설계하고 각 층끼리 약속(인터페이스)만 잘 지키면 된다.

&ensp;비유: 비행기 여행 절차 = 여러 서비스 층<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-61.png" width="300"></p>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-62.png" width="300"></p>

* 비행기 타려면 "표 사기 → 짐 맡기기 → 탑승구 → 활주로 이륙 → 하늘길 따라 이동 → 착륙 → 짐 찾기 → 민원"처럼 여러 단계가 순서대로 협력한다.
* 각 단계는 자기 할 일(서비스) 에 집중하고 아래 단계가 제공하는 결과를 믿고 다음 일을 한다.

&ensp;예) 활주로 팀은 “항로(라우팅) 팀”이 잡아준 경로를 전제로 이륙만 잘 하면 됨.<br/>
&ensp;→ 네트워크도 똑같이 층을 나눠서 각 층이 자기 서비스만 책임지고 윗층은 그 서비스를 빌려 쓴다.<br/>

&ensp;<b>레이어로 나누면 좋은 점</b><br/>
* 보기 쉽다: 무슨 부품이 있고 서로 어떤 관계인지 명확.
* 고치기 쉽다: 한 층의 내부 구현을 바꿔도 약속한 겉모습(인터페이스)만 유지하면 다른 층은 손댈 필요가 없음. (탑승구 절차를 바꿔도 활주로 운영 전체를 바꿀 필요가 없는 것처럼)
* 단점: 층이 많으면 중복/오버헤드가 조금 생길 수 있음. 그래도 관리 이점이 훨씬 크다.

&ensp;<b>인터넷 프로토콜 스택: 5개 층</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-63.png" width="300"></p>

1. Application(응용)
* 우리가 쓰는 서비스: 웹(HTTP), 메일(IMAP/SMTP), 메신저 등.
* 이 내용을 저쪽 앱에 보내 줘라고 요청.
2. Transport(전송)
* 앱↔앱 사이의 데이터 이동을 담당.
* TCP: 순서 보장, 재전송, 흐름/혼잡 제어까지 해주는 신뢰성 있는 통로.
* UDP: 가볍고 빠르지만 보장은 거의 없는 베스트-에포트 통로.
3. Network(네트워크)
* 출발지→목적지까지 길 찾기(라우팅)와 주소(IP) 처리.
* 대표: IP(Internet Protocol).
4. Link(링크)
* 이웃 장치끼리 한 구간을 전달. 이 층에서 스위치가 동작.
* 예: Ethernet, Wi-Fi(802.11).
5. Physical(물리)
* 전기 신호, 빛, 전파로 비트를 실제로 흘려보내는 층.

&ensp;요약: 물리/링크는 한 구간을 넘기고 네트워크는 큰 지도에서 경로, 전송은 앱끼리의 통로 품질, 응용은 사용자 기능을 담당한다.<br/>

&ensp;<b>캡슐화(Encapsulation): "봉투를 여러 겹 씌우기"</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-64.png" width="300"></p>

&ensp;데이터가 내려갈수록 각 층 헤더가 앞에 붙어 ‘포장’됩니다. 도착지에선 역순으로 포장을 벗긴다.<br/>

1. Application: 메시지 M 생성 (예: “로그인 요청”)
2. Transport: H_t(전송 헤더, TCP/UDP) + M → 세그먼트(segment)
* TCP라면 포트번호, 순서번호, 체크섬 같은 정보가 H_t에 들어감.
3. Network: H_n(IP 헤더) + H_t M → 데이터그램(datagram)
* 출발지/목적지 IP 주소 등이 여기에.
4. Link: H_l(링크 헤더) + H_n H_t M → 프레임(frame)
* 이웃 장치의 하드웨어 주소(MAC) 등.
5. Physical: 프레임을 비트 신호로 내보냄.
* 스위치는 Link 층만 보고 프레임을 옆으로 전달.
* 라우터는 Network 층(IP 헤더) 를 읽고 다음 경유지를 결정해 보낸다.
* 목적지에 도착하면 Link→Network→Transport→Application 순서로 헤더를 하나씩 벗겨 원래 메시지 M을 앱에 건네준다.

&ensp;작은 예시<br/>
* 내가 웹페이지를 요청(HTTP)하면:
    - 응용: HTTP 요청 M
    - 전송: TCP가 포트 443으로 보낼 세그먼트(H_t+M)
    - 네트워크: 목적지 IP(예: 142.250… 구글)를 적은 IP 헤더(H_n)
    - 링크: 현재 구간의 MAC 헤더(H_l)를 붙여 프레임으로 전송
    - 라우터들을 거치며 링크 헤더만 매 구간에 맞게 갈아끼우고, IP 헤더는 유지되면서 목적지까지 이동

&ensp;용어 정리<br/>
* M: 응용 메시지
* H_t: Transport 헤더(TCP/UDP)
* H_n: Network 헤더(IP)
* H_l: Link 헤더(Ethernet/Wi-Fi)
* 이름: message → segment → datagram → frame (위→아래로 내려가며 붙는 이름)

추가
====

ISO/OSI 참조 모델(7계층)
-----

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-65.png" width="300"></p>

&ensp;오른쪽에 7개의 층이 쌓여 있다(아래→위):<br/>
&ensp;physical → link → network → transport → session → presentation → application<br/>

&ensp;인터넷에서 우리가 흔히 배우는 "TCP/IP 스택"은 physical–link–network–transport–application(5계층) 으로 설명하곤 하는데 여기 OSI 모델에는 2층이 더 있다:<br/>
* presentation(표현)
* session(세션)

&ensp;인터넷 스택엔 이 둘이 딱 떨어지는 ‘계층’으로는 없다가 포인트이다. 필요하면 응용 프로그램 쪽에서 구현하게 했다.(설계 철학: 필요한 기능은 끝단에서!)<br/>

* physical(물리): 전선을 통해 빛/전기 신호로 0과 1을 보냄.
* link(링크): 같은 선을 공유하는 이웃끼리 차례 지키기/주소 붙이기(예: 이더넷, Wi-Fi).
* network(네트워크): 길 찾기 내비게이션. 멀리 있는 곳까지 IP 주소로 라우팅.
* transport(전송): 택배 상자 관리. 상자(데이터 조각)를 번호붙여 보내고 분실하면 다시 받음(TCP), 빠르게만 보낼 땐 단순 전송(UDP).
* session(세션): 대화방 유지 관리자. 대화 시작/유지/잠깐 멈춤/다시 시작(동기화, 체크포인트). → 인터넷에선 로그인 유지 같은 건 앱(웹서버+쿠키) 가 주로 처리, 연결 설정/해제는 TCP 가 일부 담당.
* presentation(표현): 언어 통역사. 데이터를 암호화/압축/형식 맞춤(문자 인코딩 등) 해서 서로 이해 가능하게. → 인터넷에선 TLS(https의 자물쇠), gzip 압축, UTF-8 같은 걸 응용/라이브러리가 처리.
* application(응용): 우리가 쓰는 앱 그 자체(웹, 메일, 채팅 등).

&ensp;왜 인터넷 스택엔 세션/표현이 없게 보일까?<br/>
&ensp;초창기 인터넷은 서로 믿는 연구기관끼리 단순하게 연결이 목표였고 다양한 앱이 빠르게 생기도록 유연성을 주려 했다. 그래서 세션/표현 기능은 필요한 앱이 알아서(라이브러리로) 구현하도록 했다.<br/>
* 예) 표현: TLS 암호화(https), 동영상 코덱(H.264)·압축은 앱이 사용
* 예) 세션: 웹의 로그인 유지(쿠키/세션ID), 스트리밍의 재연결/구간복구 등

Wireshark
-----

<p align="center"><img src="/assets/img/Computer Network/chapter1. Introduction/1-66.png" width="300"></p>

* 네트워크 현미경이다. 내 컴퓨터의 네트워크 카드(NIC)가 지나가는 모든 프레임의 복사본을 만들고(pcap) Wireshark가 그걸 해석(분석기) 해서 사람이 읽기 좋게 보여준다.

&ensp;그림 설명<br/>
* 왼쪽 PC ↔ (케이블) ↔ 오른쪽 공유기
* 파란 박스 안에 두 부분:
1. packet capture(pcap): 운영체제/드라이버가 이더넷 프레임 복사 떠오기
2. packet analyzer: 복사해 온 걸 프로토콜별로 해석(IP·TCP·HTTP… 헤더와 내용 보기)
* 위쪽 표는 계층들(Physical→Link→Network→Transport→Application).
Wireshark는 이 계층들을 층층이 분해해서 보여준다.(양파 까듯이)

&ensp;무엇을 볼 수 있나?<br/>
* 출발/도착 주소(MAC, IP), 포트번호, 프로토콜 종류, 헤더 필드들,
암호화되지 않았다면 내용(예: HTTP 요청) 까지.
* 연결 과정도 관찰 가능: TCP의 SYN→SYN-ACK→ACK 3단계, 재전송 여부, 속도/지연 등.

&ensp;사용하는 곳<br/>
* 수업 실습, 문제 해결(왜 느리지?), 보안 점검, 성능 측정.
* 쉬운 실험 예:
    - ping 을 보내고 ICMP 패킷 왕복시간이 어떻게 보이는지 확인
    - HTTP vs HTTPS 비교: HTTPS는 내용이 암호화돼 평문이 안 보임

