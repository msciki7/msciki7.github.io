---
title: "chapter2. Application Layer"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
toc_sticky: true

date: 2025-09-18
last_modified_at: 2025-09-18
---

Application Layer: 개요
=====

&ensp;응용 계층은 우리가 실제로 사용하는 인터넷 서비스(웹, 이메일, 채팅, 스트리밍, 게임 등)을 담당하는 계층이다.<br/>
&ensp;즉 우리가 직접 접하는 서비스 = 응용 계층 프로토콜 위에서 동작한다.<br/>

&ensp;학습 목표 (Our Goals)<br/>
&ensp;응용 계층을 배우면서 우리가 얻을 목표는 크게 두 가지이다.<br/>
1. 개념적 + 구현적 이해
    * 단순히 "HTTP는 웹을 만든다" 정도가 아니라, 실제로 어떻게 동작하는지 깊게 이해.
    * 즉, “이론”과 “코딩” 두 가지를 같이 배움.

2. 응용 계층과 하위 계층 관계
    - 응용 계층이 쓰는 전송 계층 서비스 이해하기 (TCP/UDP 차이).
    - 클라이언트-서버 모델과 P2P 모델 배우기.
3. 실제 프로토콜 학습
    - HTTP, SMTP, IMAP, DNS 같은 프로토콜 구조와 흐름 분석.
4. 프로그래밍 경험
    - 소켓 API를 이용해서 간단한 네트워크 프로그램 만들어보기.

&ensp;3. 네트워크 응용 프로그램의 예시
&ensp;우리가 평소 사용하는 앱 대부분이 응용 계층에 속해요.<br/>
* 소셜 네트워킹 (인스타그램, 페이스북)
* 웹 (크롬, 네이버, 구글)
* 메시지 앱 (카톡, WhatsApp)
* 이메일 (Gmail, Outlook)
* 온라인 게임 (롤, 배그)
* 동영상 스트리밍 (유튜브, 넷플릭스)
* P2P 파일 공유 (토렌트)
* VoIP (음성통화) → Skype, Zoom
* 실시간 화상회의 (Google Meet, Teams)
* 인터넷 검색 (네이버, 구글)
* 원격 로그인 (SSH)

&ensp;👉 즉, 우리가 매일 쓰는 대부분의 서비스가 응용 계층 프로토콜을 기반으로 만들어져 있다.<br/>

&ensp;네트워크 앱 만들기<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-1.png" width="600"></p>

&ensp;네트워크 앱을 만들 때 핵심은 엔드 시스템(end systems) 이다.<br/>
* 프로그램은 엔드 시스템에서 실행된다. (예: 웹 브라우저 = 내 PC, 웹 서버 = 구글 서버)
* 이 둘은 네트워크를 통해 통신합니다. (예: 브라우저가 서버에 HTTP 요청, 서버가 응답)
* 네트워크 코어(라우터, 스위치 등)에선 앱을 만들 필요 없음 → 라우터는 단순히 데이터를 전달만 하고, 실제 앱 동작은 서버/클라이언트에서만 이루어짐.

&ensp;👉 정리: 앱 개발자는 서버/클라이언트용 소프트웨어만 만들면 됨!<br/>

Client-Server Paradigm (클라이언트-서버 구조)
-----

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-2.png" width="600"></p>

* 서버(Server)
    - 항상 켜져 있는 컴퓨터(always-on host) → 예: 네이버, 구글 서버
    - 고정된 IP 주소를 가짐 (permanent IP)
    - 보통 데이터 센터에 위치해서 대규모 서비스 처리 가능
* 클라이언트(Clients)
    - 서버에 접속해서 통신하는 쪽
    - 항상 켜져 있는 건 아님 (간헐적 연결 → 모바일, PC)
    - IP 주소가 매번 바뀔 수 있음 (동적 IP)
    - 서로 직접 연결하지 않고, 서버를 통해서만 통신
    - 예: HTTP (웹), IMAP (메일), FTP (파일 전송)

&ensp;비유: 식당처럼 생각할 수 있음<br/>
* 서버 = 식당 주방(항상 열려있음, 고정된 위치)
* 클라이언트 = 손님(왔다 갔다 함, 주문할 때만 연결)

Peer-to-Peer (P2P) Architecture (피어-투-피어 구조)
-----

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-3.png" width="600"></p>

* 항상 켜져 있는 서버 없음
* 서버-클라이언트 관계가 아니라, 모든 노드가 동등 (peer)
* 피어들끼리 직접 연결해서 서비스 요청/제공
* Self Scalability (자체 확장성)
    - 새로운 피어가 들어오면, 서비스 수요도 늘지만 공급 능력도 같이 늘어남
    - 예: 토렌트 → 더 많은 사람이 접속하면 다운로드 속도가 오히려 빨라짐
* 단점:
    - 피어가 자주 접속했다 끊김 → 관리 복잡
    - IP 주소가 자주 변함 → 연결 유지 어려움
* 예: P2P 파일 공유 (토렌트)

&ensp;👉 비유: 친구들끼리 서로 음식을 나눠주는 potluck 파티.<br/>
&ensp;손님이 많아지면 음식도 많아져서 전체 자원이 늘어남.<br/>

Processes Communicating (프로세스 간 통신)
-----

* 프로세스 (Process): 실행 중인 프로그램 (예: 웹 브라우저, 웹 서버)
* 한 컴퓨터 안에서는 OS가 제공하는 프로세스 간 통신(IPC) 으로 데이터 교환
* 다른 컴퓨터끼리는 메시지를 주고받아서 통신
* Client Process
    - 통신을 시작하는 프로세스 (예: 브라우저 → 서버로 요청 보냄)
* Server Process
    - 요청을 기다리고 응답하는 프로세스 (예: 웹 서버)

&ensp;👉 P2P도 결국은 어떤 프로세스는 클라이언트 역할, 어떤 프로세스는 서버 역할을 함.<br/>

Sockets (소켓)
-----

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-4.png" width="600"></p>

* 프로세스가 메시지를 주고받는 출입구(door) 같은 것
* 송신 프로세스:
    - 소켓을 통해 메시지를 “밖으로 밀어냄”
    - 전송 계층(TCP/UDP)에 맡겨서 반대편 소켓까지 전달
* 수신 프로세스:
    - 자기 소켓에서 메시지를 “받아 읽음”
* 양쪽에 소켓이 하나씩 있어야 통신 가능
* 앱 개발자는 소켓 위에서 프로그램 작성, 나머지는 OS가 담당

&ensp;👉 비유: 집에 문이 있어야 택배를 보낼 수 있음.<br/>
&ensp;소켓 = 문, 운송 서비스(TCP/UDP) = 택배 회사, 프로세스 = 집 주인<br/>

Addressing Processes (프로세스 주소 지정)
------

* 메시지를 받으려면 프로세스는 식별자(identifier) 필요
* 식별자 = IP 주소 + 포트 번호
    - IP 주소 → 어떤 컴퓨터인지
    - 포트 번호 → 그 컴퓨터 안의 어떤 앱인지

&ensp;왜 IP만으로는 부족할까?<br/>
&ensp;한 컴퓨터에서 여러 프로그램이 동시에 실행될 수 있기 때문 (예: 웹 브라우저, 메일 서버, 게임 서버)<br/>

&ensp;예시:<br/>
&ensp;HTTP 서버: 포트 80<br/>
&ensp;메일 서버: 포트 25<br/>

&ensp;실제 예:<br/>
&ensp;128.119.245.12:80 → 특정 웹 서버의 HTTP 서비스<br/>

&ensp;👉 비유:<br/>
* IP 주소 = 아파트 주소
* 포트 번호 = 아파트 동/호수<br/>
&ensp;즉, IP만 알면 아파트 건물까지만 갈 수 있고, 포트 번호가 있어야 정확한 집(프로세스)까지 도착 가능.<br/>

Application-Layer Protocol 
-----

&ensp;응용 계층 프로토콜은 네트워크에서 프로그램들이 서로 대화하는 규칙을 정한다.<br/>
* 메시지 유형(Types of messages)
    - 요청(request), 응답(response)같은 종류 정의
    - 예: 브라우저가 GET 요청 → 서버가 200 OK 응답
* 메시지 구문 (Syntax)
    - 메시지 안에 어떤 필드가 있고, 어떻게 구분되는지 정의
    - 예: HTTP 헤더의 Host, User-Agent, Content-Length
* 메시지 의미 (Semantics)
    - 각 필드가 어떤 의미를 가지는지
    - 예: Content-Length: 100 → 메시지 본문이 100바이트라는 뜻
* 교환 규칙 (Rules)
    - 언제, 어떤 상황에서 메시지를 보내고 응답할지
    - 예: 클라이언트가 GET 보내면 서버는 항상 응답해야 함

&ensp;Open vs Proprietary Protocols<br/>
* Open Protocols
    - RFC에 정의, 누구나 접근 가능
    - 예: HTTP, SMTP (인터넷에서 대부분 사용)
* Proprietary Protocols
    - 특정 회사가 비공개로 운영
    - 예: Skype → 내부 프로토콜은 공개되지 않음

&ensp;<b>앱이 필요로 하는 전송 서비스</b><br/>
&ensp;앱마다 원하는 네트워크 특성이 다르다.<br/>
* Data Integrity (데이터 무결성)
    - 파일 전송, 웹 거래 → 절대 데이터 손실 허용 불가
    - 오디오 스트리밍 → 약간의 손실 허용
* Timing (타이밍, 지연 시간)
    - 인터넷 전화, 온라인 게임 → 지연이 크면 사용 불가
* Throughput (처리율, 대역폭)
    - 동영상 스트리밍 → 최소 전송 속도 필요 (예: 5Mbps 이상)
    - 웹 브라우징 → 대역폭이 크면 빨라지지만, 필수는 아님
* Security (보안)
    - 암호화, 무결성, 인증 필요
    - 예: HTTPS → SSL/TLS로 보안 강화

&ensp;앱별 요구사항 정리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-5.png" width="600"></p>

&ensp;👉 요약:<br/>
* 파일 전송/이메일/웹 → TCP 필수 (신뢰성 중요)
* 실시간 오디오/게임 → UDP 선호 (빠른 반응 중요, 약간의 손실 허용)

Internet Transport Protocols: TCP vs UDP
-----

&ensp;TCP (Transmission Control Protocol)<br/>
* Reliable Transport: 손실된 데이터 자동 재전송
* Flow Control: 송신자가 너무 많이 보내지 않도록 제어
* Congestion Control: 네트워크 혼잡 시 속도 줄임
* Connection-Oriented: 연결을 먼저 맺고 통신 (3-way handshake)
* 단점: 속도가 느려지고, 지연 증가

&ensp;UDP (User Datagram Protocol)<br/>
* Unreliable: 데이터 손실 가능
* No flow/congestion control: 단순하게 빠르게 전송
* No connection setup: 즉시 전송 가능
* 장점: 오버헤드 적고 빠름 → 실시간 앱에 적합 (게임, 스트리밍)

&ensp;👉 Q: UDP는 왜 필요할까?<br/>
* TCP는 너무 무겁고 지연이 커서 실시간 앱엔 부적합
* UDP는 단순해서 속도가 빠르고 지연이 적음

&ensp;Application Protocols + Transport Protocols 매칭<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-6.png" width="600"></p>

&ensp;👉 실제로는 HTTP 기반 스트리밍이 많아서 TCP를 주로 쓰지만, 실시간 통화/게임은 UDP를 더 선호한다.<br/>

&ensp;<b>Securing TCP (TCP 보안)</b><br/>
&ensp;기본 TCP/UDP (Vanilla TCP & UDP sockets)<br/>
* 암호화 없음 → 데이터가 평문(cleartext)으로 인터넷을 지나감
* 예: 아이디/비밀번호가 그대로 전송된다면, 중간에서 가로채면 그대로 보임

&ensp;TLS (Transport Layer Security)<br/>
* TCP 위에 보안 계층 추가
* 제공 기능:
    - 암호화된 연결 (데이터 도청 불가)
    - 무결성 (Integrity): 데이터 변조 방지
    - 인증(Authentication): 상대방이 진짜 서버인지 확인
* 즉, HTTPS = HTTP + TLS + TCP

&ensp;👉 비유<br/>
* 그냥 TCP = 엽서 (누구나 내용을 읽을 수 있음)
* TLS TCP = 봉투에 넣은 편지 (중간에서 봐도 못 읽음)

Web and HTTP
=====

&ensp;웹과 HTTP는 응용 계층의 대표 사례이다.<br/>
* 웹 페이지 구조
    - 웹 페이지 = 여러 객체(objects) 로 구성
    - 객체: HTML 파일, 이미지(JPEG), 오디오, 동영상 등
    - 하나의 기본 HTML 파일 (base HTML) 안에 여러 객체 포함
    - 각 객체는 URL 로 접근 가능
        + URL = 호스트 이름 + 경로 이름
        + 예: www.someschool.edu/someDept/pic.gif

&ensp;👉 비유<br/>
* 웹 페이지 = 책 한 권
* HTML 파일 = 책의 목차
* 이미지/동영상 = 목차가 가리키는 다른 페이지

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-7.png" width="600"></p>

&ensp;<b>HTTP Overview</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-8.png" width="600"></p>

HTTP (HyperText Transfer Protocol)
-----

* 웹에서 쓰는 응용 계층 프로토콜
* 클라이언트-서버 모델 사용
    - 클라이언트: 웹 브라우저 (크롬, 사파리 등) → 요청(request) 보냄
    - 서버: 웹 서버 (Apache, Nginx 등) → 응답(response) 보냄

&ensp;동작 흐름<br/>
1. 브라우저(클라이언트) → HTTP Request (예: GET /index.html)
2. 서버 → HTTP Response (예: 200 OK + HTML 데이터)
3. 브라우저가 응답을 해석해서 사용자에게 보여줌

&ensp;👉 비유<br/>
* 클라이언트 = 식당 손님 (메뉴 주문)
* 서버 = 주방 (주문에 맞춰 음식 제공)
* HTTP Request = 주문서, HTTP Response = 음식

&ensp;HTTP와 TCP<br/>
* HTTP는 TCP 위에서 동작 (보통 포트 80)
* 과정:
1. 클라이언트가 서버와 TCP 연결 (소켓 생성)
2. 연결 위에서 HTTP 메시지를 교환
3. 데이터 전송 끝나면 TCP 연결 종료

* HTTP는 Stateless (무상태)
    - 서버는 이전 클라이언트 요청을 기억하지 않음
    - 각 요청은 독립적으로 처리됨
    - 장점: 단순하고 확장성 좋음
    - 단점: 로그인/장바구니 같은 기능 구현 어려움 → 쿠키/세션 필요

&ensp;👉 비유<br/>
* Stateless HTTP = 패스트푸드점
    - 매번 주문할 때마다 새로 주문서 작성 (직원이 이전 기록 기억 X)
* Stateful Protocol = 단골식당
    - 직원이 저번에 오셨던 손님 기억 → 추가 서비스 가능

&ensp;요약 표<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-9.png" width="600"></p>

&ensp;<b>HTTP Connections: Two Types</b><br/>
* Non-persistent HTTP (비지속 연결, HTTP/1.0 기본)
1. 클라이언트가 서버에 TCP 연결 생성
2. 한 개 객체(object) 만 요청/응답 가능
3. 객체 전송 후, TCP 연결 종료
4. 다른 객체를 받으려면 새로운 TCP 연결 필요

&ensp;👉 즉, 웹페이지 안에 이미지 10개가 있으면 → 10번 TCP 연결<br/>

* Persistent HTTP (지속 연결, HTTP/1.1 기본)
1. 클라이언트가 서버에 TCP 연결 생성
2. 여러 객체를 한 번의 연결로 전송 가능
3. 페이지의 HTML, 이미지, CSS, JS 모두 하나의 TCP 연결로 처리
4. 다 끝나면 TCP 연결 종료

&ensp;👉 즉, 웹페이지 안에 이미지 10개가 있어도 → 1번 TCP 연결<br/>

Non-persistent HTTP
----

&ensp;Non-persistent HTTP 예제<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-10.png" width="600"></p>

&ensp;(안에 HTML + JPEG 이미지 10개 포함)<br/>
&ensp;과정<br/>
&ensp;1a. 클라이언트 → 서버에 TCP 연결 요청 (포트 80)<br/>
&ensp;1b. 서버 → 연결 허용 (accept)<br/>
&ensp;2. 클라이언트 → HTTP 요청 메시지 전송 (GET /home.index)<br/>
&ensp;3. 서버 → 응답 메시지 전송 (HTML 파일 내용)<br/>
&ensp;4. 서버 → TCP 연결 닫음<br/>
&ensp;5. 클라이언트 → HTML 파일 해석, 안에 JPEG 10개 참조 발견<br/>
&ensp;6. JPEG 하나 받을 때마다 다시 TCP 연결 생성 + 종료 반복 (총 10번)<br/>
&ensp;👉 결과: 비효율적 (연결 과정 때문에 지연 발생)<br/>

&ensp;비유<br/>
* Non-persistent HTTP = 택배를 매번 따로 시키는 것
    - 책 1권, 연필 1개, 지우개 1개를 따로따로 주문 → 매번 배송기사 옮

&ensp;RTT와 Non-persistent HTTP 응답 시간<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-11.png" width="600"></p>

&ensp;RTT란?<br/>
* Round Trip Time (왕복 지연 시간) → 클라이언트(내 컴퓨터)에서 서버(웹사이트)까지 작은 패킷 하나가 갔다가 돌아오는 데 걸리는 시간
* 예: 내가 친구한테 "안녕?" 하고 카톡 보냈을 때, "응" 하고 답이 올 때까지 걸리는 시간 = RTT

&ensp;Non-persistent HTTP 응답 시간<br/>
* 웹페이지의 객체 1개(예: HTML 파일 하나) 받을 때 필요한 시간:
1. TCP 연결 맺기 → 1 RTT
2. 요청(request) 보내고, 응답(response) 받기 시작 → 1 RTT
3. 실제 파일 전송 시간 (파일 크기에 따라 달라짐)

&ensp;👉 따라서 총 응답 시간 = 2 RTT + 파일 전송 시간<br/>

Persistent HTTP (HTTP/1.1)
----

&ensp;Non-persistent HTTP의 문제점<br/>
* 매 파일마다 2 RTT 필요 → 너무 느림
* 브라우저가 이미지 10개를 동시에 받으려면 TCP 연결을 10번 따로 열어야 함 → 운영체제(OS) 부담 커짐

&ensp;Persistent HTTP의 장점<br/>
* TCP 연결을 한 번 열고 그대로 유지
* 여러 객체(HTML, 이미지, CSS 등)를 같은 연결로 전송
* 따라서 2 RTT → 1 RTT 로 줄어듦 → 속도가 확실히 빨라짐 🚀

&ensp;👉 비유<br/>
* Non-persistent HTTP = 택배를 물건 하나하나 따로 시킴 (매번 기사님이 왔다갔다)
* Persistent HTTP = 장바구니에 다 담아서 한 번에 주문 (기사님 한 번만 옴)

&ensp;HTTP Request Message (HTTP 요청 메시지)<br/>
&ensp;웹 브라우저가 서버에 "이거 줘!" 하고 요청할 때 보내는 편지 형식이다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-12.png" width="600"></p>

&ensp;구성<br/>
1. Request line (요청 줄)
* 무슨 동작을 할지 명령 (예: GET, POST)
* 예: GET /index.html HTTP/1.1 → index.html 파일을 달라, HTTP 1.1 버전 사용
2. Header lines (헤더 줄)
* 추가 정보들
* 예:
    - Host: 요청할 서버 주소
    - User-Agent: 어떤 브라우저인지 (크롬, 파이어폭스 등)
    - Accept-Language: 어떤 언어 선호 (한국어, 영어 등)
    - Connection: keep-alive → TCP 연결 유지
3. Entity body (본문)
* POST 요청일 경우, 로그인 정보 같은 데이터를 여기에 넣음

&ensp;👉 비유<br/>
* Request line = “내가 피자 주문할게! (종류: 페퍼로니)”
* Header = “주소는 여기, 전화번호는 이거, 카드결제 할게”
* Body = “추가 요청사항: 치즈 많이 주세요”

&ensp;요약표<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-13.png" width="600"></p>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-14.png" width="600"></p>

&ensp;정리:<br/>
* RTT = 왕복 지연 시간 (카톡 보내고 답 올 때까지 시간)
* Non-persistent HTTP = 객체마다 TCP 연결 새로 맺음 → 느림
* Persistent HTTP = 연결을 유지하면서 여러 객체 전송 → 빠름
* HTTP 요청 메시지 = 편지와 비슷, (요청 줄 + 헤더 + 본문) 구조

HTTP 요청 메시지 종류 (Request Methods)
-----

&ensp;HTTP 요청은 **클라이언트(브라우저)**가 서버에게 “이런 행동 좀 해줘!”라고 말하는 것이다.<br/>
&ensp;(1) GET<br/>
* 서버에게 정보를 달라고 요청
* 데이터는 URL에 붙어서 전송됨 예) www.site.com/search?keyword=banana
* 특징: 주소창에 보이기 때문에 보안에 취약, 하지만 단순 조회에는 빠르고 가볍다.
* 시험 포인트: GET은 데이터를 URL에 붙여서 보낸다! (보안 취약, 캐싱 가능)

&ensp;(2) POST<br/>
* 서버에게 데이터를 보내는 요청
* 예: 회원가입, 로그인, 글쓰기
* 데이터는 HTTP 메시지 body에 담겨서 전송됨 → URL에는 안 보임
* 특징: 보안성↑, 대용량 데이터 가능
* 시험 포인트: POST는 body 사용, GET은 URL 사용

&ensp;(3) HEAD<br/>
* GET처럼 요청하지만, 본문(body) 없이 헤더 정보만 받음
* 용도: 서버 상태 확인, 리소스 존재 여부 확인
* 예: “이 파일이 있니?” 확인할 때
* 시험 포인트: HEAD는 응답 본문 없음!

&ensp;(4) PUT<br/>
* 서버에 파일 업로드 or 교체
* 예: 기존 파일을 완전히 새 파일로 바꿔치기
* 시험 포인트: PUT은 새로 업로드 + 기존 걸 완전히 대체

&ensp;비유<br/>
* GET: 책 도서관에서 "이 책 좀 보여주세요" → 책 내용 그대로 보여줌
* POST: "새로운 책 내용을 제출할게요" → 도서관이 받아서 등록
* HEAD: "그 책 있나요? 제목만 알려주세요" → 책은 안 보여주고 메타정보만
* PUT: "이 책을 새로운 책으로 완전히 교체해주세요"

&ensp;HTTP 응답 메시지 구조<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-15.png" width="600"></p>

&ensp;서버가 클라이언트에게 주는 답변 편지<br/>
&ensp;구성 요소:<br/>
&ensp;1. Status line (상태줄): 프로토콜 버전 + 상태 코드 + 상태 설명<br/>
&ensp;예: HTTP/1.1 200 OK<br/>
&ensp;2. Header lines (헤더): 부가 정보<br/>
&ensp;예: 날짜, 서버 종류, 컨텐츠 길이, 타입<br/>
&ensp;3. Body (본문): 실제 데이터 (HTML, 이미지, JSON 등)<br/>

HTTP 상태 코드
----

&ensp;2xx (성공)<br/>
* 200 OK: 요청 성공 (시험: 무조건 기본 성공 코드)
* 3xx (리다이렉션)
    - 301 Moved Permanently: 리소스가 다른 주소로 완전히 이동 (시험: URL이 바뀔 때, 브라우저가 자동으로 새 주소로 요청)
* 4xx (클라이언트 에러)
    - 400 Bad Request: 요청이 잘못됨 (문법 오류 등)
    - 404 Not Found: 요청한 문서 없음 (시험에서 제일 많이 나옴)
* 5xx (서버 에러)
    - 505 HTTP Version Not Supported: 서버가 요청받은 HTTP 버전을 지원하지 않음

&ensp;비유<br/>
* 200 OK = "네, 여기 있습니다!"
* 301 Moved Permanently = "그 책은 이사 갔어요. 새 주소로 가세요"
* 400 Bad Request = "말이 이상해요. 무슨 뜻인지 모르겠어요"
* 404 Not Found = "그 책은 없네요"
* 505 Not Supported = "그 언어는 못 알아들어요"

&ensp;HTTP는 원래 Stateless 프로토콜<br/>
* Stateless(무상태): HTTP 요청(Request)과 응답(Response)은 각각 독립적이다.<br/>
&ensp;→ 서버는 "이 요청이 누구의 요청인지" 기억하지 않음.<br/>
&ensp;→ 예를 들어, 내가 쇼핑몰에 로그인하고 장바구니에 물건을 넣어도, 다음 요청 때 서버는 "너가 누구인지" 모름.<br/>

&ensp;장점: 단순하고 서버 부담이 적음<br/>
&ensp;단점: 로그인 유지, 장바구니, 개인화 서비스가 불가능함<br/>

쿠기(Cookies)
----

&ensp;상태(state)를 유지하기 위한 방법이 쿠기이다.<br/>
&ensp;쿠키는 브라우저와 서버가 협력해서 "사용자를 식별할 수 있는 정보"를 주고받는 방법이다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-16.png" width="600"></p>

&ensp;쿠키의 4가지 요소<br/>
1. HTTP Response 헤더에 Set-Cookie 값이 들어감 → 서버가 브라우저에게 “이 값 기억해!”라고 지시
2. 이후 브라우저는 HTTP Request 헤더에 Cookie 값으로 붙여 보냄
3. 브라우저 내부에 쿠키 파일로 저장됨 (예: cookies.txt)
4. 서버는 **백엔드 데이터베이스(DB)**에서 이 쿠키 값을 사용자 정보와 매핑

&ensp;즉, 서버는 “쿠키 ID = 12345는 홍길동”이라고 기억하는 방식<br/>

&ensp;쿠키의 동작 예시<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-17.png" width="600"></p>

1. 사용자가 처음 쇼핑몰 방문 → 서버가 Set-Cookie: 1678을 응답에 포함
2. 브라우저는 쿠키 1678을 저장
3. 이후 같은 사이트 방문 시 → 브라우저가 Cookie: 1678을 요청에 포함
4. 서버는 DB에서 1678 → 사용자 홍길동을 찾아내어 개인화된 응답 제공

&ensp;→ 그래서 로그인 유지, 장바구니 저장, 개인 추천 등이 가능해짐<br/>

&ensp;쿠키의 활용<br/>
* 로그인 세션 유지 (내가 로그인한 상태 기억)
* 장바구니 (사이트를 돌아다녀도 담은 물건 유지)
* 개인화 추천 (이전에 본 상품 기반으로 추천)
* 사용자 인증 (접속 권한 있는 사용자 구분)

&ensp;쿠키의 단점과 보안/프라이버시 문제<br/>
* 보안 문제: 세션 쿠키가 탈취되면, 공격자가 내 계정처럼 행동할 수 있음 (세션 하이재킹)
* 프라이버시 문제: 제3자(광고 회사)의 트래킹 쿠키가 여러 웹사이트에서 나를 추적 가능<br/>
&ensp;→ 예: 내가 쇼핑몰에서 신발을 봤더니, 다른 뉴스 사이트에서도 신발 광고가 뜨는 이유<br/>

Web caches (proxy servers)
----

&ensp;원래 방식: 클라이언트(내 컴퓨터)가 웹 서버(예: 네이버 서버)에게 직접 요청해서 데이터를 받아와야 한다.<br/>
&ensp;캐시 방식: 중간에 있는 프록시 서버(Proxy Server)가 대신 받아주고 자주 쓰는 데이터를 저장해둔다. → 다시 같은 요청이 들어오면 원 서버까지 가지 않고 캐시 서버에서 바로 응답해준다.<br/>

&ensp;즉 가까운 편의점에서 물건 사기" 같은 것이다. 마트(원래 서브)까지 멀리 가지 않고 근처 편의점(캐시 서버)에 있으면 거기서 바로 가져올 수 있는 것이다.<br/>

&ensp;동작 과정<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-18.png" width="600"></p>

1. 클라이언트(내 컴퓨터)가 웹 페이지를 요청 → 먼저 프록시 서버로 감
2. 프록시 서버가 확인:
    - 캐시에 있음 → 바로 응답(빠름)
    - 캐시에 없음 → 원래 서버로 요청해서 받아온 뒤 저장해두고, 클라이언트에게 전달
3. 이후 같은 요청이 오면 프록시 서버가 바로 줌

&ensp;Web Cache가 좋은 이유<br/>
* 응답 속도 빨라짐: 가까운 서버(프록시)에서 받으니까 시간 절약
* 트래픽 감소: 매번 원 서버까지 가지 않으니 네트워크 사용량 줄어듦
* 콘텐츠 제공자에게 도움: 서버가 약한(“가난한”) 사이트도 캐시 덕분에 빠르게 서비스 가능

&ensp;추가 개념<br/>
* Web Cache = Proxy Server → 캐시는 서버 역할(클라이언트에게 데이터 제공)과 클라이언트 역할(원 서버에 요청) 둘 다 함
* ISP(통신사, 학교, 회사) 가 보통 캐시 서버를 설치함
* 문제점: 캐시 데이터가 오래되면 실제 서버의 최신 내용과 다를 수 있음 → 이를 해결하려고 HTTP 캐시 제어 헤더(Cache-Control, If-Modified-Since 등) 사용

&ensp;Caching example<br/>

&ensp;1. 기본 상황<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-19.png" width="600"></p>

* 접속 링크 속도(access link rate): 1.54 Mbps
* RTT: 라우터 ↔ 서버 간 왕복 시간 = 2초
* 웹 객체 크기: 100K bits
* 요청률: 15개/초 → 평균 데이터 전송률(= 15 × 100K) 1.50 Mbps

&ensp;성능 계산<br/>
* LAN 이용률: LAN 속도는 1Gbps, 데이터율은 1.5Mbps니까 1.5/1000≈0.0015<br/>
&ensp;LAN은 충분히 여유로움<br/>

* Access link 이용률: 1.5/1.54≈0.97<br/>
&ensp;거의 꽉 찬 상태 (97% 사용)<br/>

* End-to-end delay (E2E 지연): = 인터넷 지연(2초 RTT) + 접속링크 지연(혼잡 큐잉 발생) + LAN 지연  = 2초 + "분 단위" + "μs 단위"<br/>
&ensp;링크 혼잡 때문에 지연이 아주 커짐<br/>

&ensp;여기서 문제는 요청이 몰리면(접속 링크 이용률 0.97 ≈ 97%) 딜레이가 급격히 증가한다는 점이다.<br/> 
&ensp;즉 인터넷을 통해 가져오는 시간이 너무 길어짐 → “병목 현상” 발생<br/>

&ensp;2. 해결책 1: 더 빠른 회선 구매<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-20.png" width="600"></p>

* 접속 링크 속도를 1.54 Mbps → 154 Mbps로 업그레이드
* 그러면 **접속 링크 이용률이 0.0097 (≈ 1%)**로 아주 여유로워짐
* end-to-end 지연은 “분 단위 → ms 단위”로 크게 줄어듦

&ensp;성능 계산<br/>
* Access link 이용률: 1.5/154≈0.0097<br/>
&ensp;1%도 안 씀 → 혼잡 없음<br/>

* End-to-end delay:
&ensp;= 2초 + ms 수준 (큐잉 거의 없음) + μs 수준<br/>
&ensp;체감 속도가 확 좋아짐<br/>

&ensp;하지만 단점: 비용이 매우 비쌈 (학교, 회사 입장에서 부담 큼)<br/>

&ensp;3. 해결책 2: 웹 캐시 설치<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-21.png" width="600"></p>

* 학교 내부(institutional network)에 캐시 서버 설치
* 자주 요청되는 파일은 캐시에 저장 → 이후엔 외부 서버까지 가지 않고 바로 전달

&ensp;성능<br/>
* 캐시 히트율 = 40% (40%는 캐시에서 해결, 60%만 외부 서버로)
* Access link 데이터율: 0.6×1.5=0.9 Mbps
* Access link 이용률: 0.9/1.54≈0.58

&ensp;트래픽이 줄어서 절반 정도 여유 있음<br/>

* 평균 E2E 지연: 0.6×(서버지연≈2s)+0.4×(캐시지연≈ms) = 0.6 × 2.01 + 0.4 × 0.001 ≈ 1.2s

&ensp;결과: 속도는 빨라지고, 비용은 훨씬 저렴!<br/>
&ensp;즉 캐시 설치가 고속 회선 구매보다 경제적<br/>

&ensp;Conditional GET<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-22.png" width="600"></p>

&ensp;캐시와 원 서버의 데이터가 달라질 수 있으니, 조건부 GET을 사용:<br/>
* 클라이언트가 요청할 때 If-Modified-Since: <date> 를 포함
* 서버가 확인: 
    - 파일이 수정 안 됨 → 304 Not Modified (데이터 안 보내고 OK만 줌)
    - 파일이 수정됨 → 200 OK + 새로운 데이터

&ensp;장점: 불필요한 데이터 전송 줄이고, 최신 데이터 유지 가능<br/>

&ensp;성능 계산 정리 (시험 포인트)<br/>

&ensp;1. 이용률(Utilization) 계산<br/>

&ensp;$ U =\frac{평균 데이터율}{링크 속도}$<br/>

&ensp;1에 가까울수록 혼잡 ↑, 큐잉 지연 ↑<br/>

&ensp;2. 평균 지연(E2E delay)<br/>
&ensp;$Delay = 인터넷지연(RTT) + 접속링크지연(혼잡큐잉) + LAN 지연$
&ensp;3. 해석<br/>
* U → 성능 병목 여부.
* Delay → 사용자 체감 속도.
* 캐시/회선 업그레이드 비교 → 비용 대비 효과 분석 문제로 출제.

&ensp;캐시 히트율을 고려해 가중 평균 계산<br/>