---
title: "chapter1. Application Layer"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
toc_sticky: true

date: 2025-09-18
last_modified_at: 2025-09-18
---

Application Layer: 개요
=====

&ensp;응용 계층은 우리가 실제로 사용하는 인터넷 서비스(웹, 이메일, 채팅, 스트리밍, 게임 등)을 담당하는 계층이다.<br/>
&ensp;즉 우리가 직접 접하는 서비스 = 응용 계층 프로토콜 위에서 동작한다.<br/>

&ensp;학습 목표 (Our Goals)<br/>
&ensp;응용 계층을 배우면서 우리가 얻을 목표는 크게 두 가지이다.<br/>
1. 개념적 + 구현적 이해
    * 단순히 "HTTP는 웹을 만든다" 정도가 아니라, 실제로 어떻게 동작하는지 깊게 이해.
    * 즉, “이론”과 “코딩” 두 가지를 같이 배움.

2. 응용 계층과 하위 계층 관계
    - 응용 계층이 쓰는 전송 계층 서비스 이해하기 (TCP/UDP 차이).
    - 클라이언트-서버 모델과 P2P 모델 배우기.
3. 실제 프로토콜 학습
    - HTTP, SMTP, IMAP, DNS 같은 프로토콜 구조와 흐름 분석.
4. 프로그래밍 경험
    - 소켓 API를 이용해서 간단한 네트워크 프로그램 만들어보기.

&ensp;3. 네트워크 응용 프로그램의 예시
&ensp;우리가 평소 사용하는 앱 대부분이 응용 계층에 속해요.<br/>
* 소셜 네트워킹 (인스타그램, 페이스북)
* 웹 (크롬, 네이버, 구글)
* 메시지 앱 (카톡, WhatsApp)
* 이메일 (Gmail, Outlook)
* 온라인 게임 (롤, 배그)
* 동영상 스트리밍 (유튜브, 넷플릭스)
* P2P 파일 공유 (토렌트)
* VoIP (음성통화) → Skype, Zoom
* 실시간 화상회의 (Google Meet, Teams)
* 인터넷 검색 (네이버, 구글)
* 원격 로그인 (SSH)

&ensp;👉 즉, 우리가 매일 쓰는 대부분의 서비스가 응용 계층 프로토콜을 기반으로 만들어져 있다.<br/>

&ensp;네트워크 앱 만들기<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-1.png" width="600"></p>

&ensp;네트워크 앱을 만들 때 핵심은 엔드 시스템(end systems) 이다.<br/>
* 프로그램은 엔드 시스템에서 실행된다. (예: 웹 브라우저 = 내 PC, 웹 서버 = 구글 서버)
* 이 둘은 네트워크를 통해 통신합니다. (예: 브라우저가 서버에 HTTP 요청, 서버가 응답)
* 네트워크 코어(라우터, 스위치 등)에선 앱을 만들 필요 없음 → 라우터는 단순히 데이터를 전달만 하고, 실제 앱 동작은 서버/클라이언트에서만 이루어짐.

&ensp;👉 정리: 앱 개발자는 서버/클라이언트용 소프트웨어만 만들면 됨!<br/>

Client-Server Paradigm (클라이언트-서버 구조)
-----

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-2.png" width="600"></p>

* 서버(Server)
    - 항상 켜져 있는 컴퓨터(always-on host) → 예: 네이버, 구글 서버
    - 고정된 IP 주소를 가짐 (permanent IP)
    - 보통 데이터 센터에 위치해서 대규모 서비스 처리 가능
* 클라이언트(Clients)
    - 서버에 접속해서 통신하는 쪽
    - 항상 켜져 있는 건 아님 (간헐적 연결 → 모바일, PC)
    - IP 주소가 매번 바뀔 수 있음 (동적 IP)
    - 서로 직접 연결하지 않고, 서버를 통해서만 통신
    - 예: HTTP (웹), IMAP (메일), FTP (파일 전송)

&ensp;비유: 식당처럼 생각할 수 있음<br/>
* 서버 = 식당 주방(항상 열려있음, 고정된 위치)
* 클라이언트 = 손님(왔다 갔다 함, 주문할 때만 연결)

Peer-to-Peer (P2P) Architecture (피어-투-피어 구조)
-----

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-3.png" width="600"></p>

* 항상 켜져 있는 서버 없음
* 서버-클라이언트 관계가 아니라, 모든 노드가 동등 (peer)
* 피어들끼리 직접 연결해서 서비스 요청/제공
* Self Scalability (자체 확장성)
    - 새로운 피어가 들어오면, 서비스 수요도 늘지만 공급 능력도 같이 늘어남
    - 예: 토렌트 → 더 많은 사람이 접속하면 다운로드 속도가 오히려 빨라짐
* 단점:
    - 피어가 자주 접속했다 끊김 → 관리 복잡
    - IP 주소가 자주 변함 → 연결 유지 어려움
* 예: P2P 파일 공유 (토렌트)

&ensp;👉 비유: 친구들끼리 서로 음식을 나눠주는 potluck 파티.<br/>
&ensp;손님이 많아지면 음식도 많아져서 전체 자원이 늘어남.<br/>

Processes Communicating (프로세스 간 통신)
-----

* 프로세스 (Process): 실행 중인 프로그램 (예: 웹 브라우저, 웹 서버)
* 한 컴퓨터 안에서는 OS가 제공하는 프로세스 간 통신(IPC) 으로 데이터 교환
* 다른 컴퓨터끼리는 메시지를 주고받아서 통신
* Client Process
    - 통신을 시작하는 프로세스 (예: 브라우저 → 서버로 요청 보냄)
* Server Process
    - 요청을 기다리고 응답하는 프로세스 (예: 웹 서버)

&ensp;👉 P2P도 결국은 어떤 프로세스는 클라이언트 역할, 어떤 프로세스는 서버 역할을 함.<br/>

Sockets (소켓)
-----

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-4.png" width="600"></p>

* 프로세스가 메시지를 주고받는 출입구(door) 같은 것
* 송신 프로세스:
    - 소켓을 통해 메시지를 “밖으로 밀어냄”
    - 전송 계층(TCP/UDP)에 맡겨서 반대편 소켓까지 전달
* 수신 프로세스:
    - 자기 소켓에서 메시지를 “받아 읽음”
* 양쪽에 소켓이 하나씩 있어야 통신 가능
* 앱 개발자는 소켓 위에서 프로그램 작성, 나머지는 OS가 담당

&ensp;👉 비유: 집에 문이 있어야 택배를 보낼 수 있음.<br/>
&ensp;소켓 = 문, 운송 서비스(TCP/UDP) = 택배 회사, 프로세스 = 집 주인<br/>

Addressing Processes (프로세스 주소 지정)
------

* 메시지를 받으려면 프로세스는 식별자(identifier) 필요
* 식별자 = IP 주소 + 포트 번호
    - IP 주소 → 어떤 컴퓨터인지
    - 포트 번호 → 그 컴퓨터 안의 어떤 앱인지

&ensp;왜 IP만으로는 부족할까?<br/>
&ensp;한 컴퓨터에서 여러 프로그램이 동시에 실행될 수 있기 때문 (예: 웹 브라우저, 메일 서버, 게임 서버)<br/>

&ensp;예시:<br/>
&ensp;HTTP 서버: 포트 80<br/>
&ensp;메일 서버: 포트 25<br/>

&ensp;실제 예:<br/>
&ensp;128.119.245.12:80 → 특정 웹 서버의 HTTP 서비스<br/>

&ensp;👉 비유:<br/>
* IP 주소 = 아파트 주소
* 포트 번호 = 아파트 동/호수<br/>
&ensp;즉, IP만 알면 아파트 건물까지만 갈 수 있고, 포트 번호가 있어야 정확한 집(프로세스)까지 도착 가능.<br/>

Application-Layer Protocol 
-----

&ensp;응용 계층 프로토콜은 네트워크에서 프로그램들이 서로 대화하는 규칙을 정한다.<br/>
* 메시지 유형(Types of messages)
    - 요청(request), 응답(response)같은 종류 정의
    - 예: 브라우저가 GET 요청 → 서버가 200 OK 응답
* 메시지 구문 (Syntax)
    - 메시지 안에 어떤 필드가 있고, 어떻게 구분되는지 정의
    - 예: HTTP 헤더의 Host, User-Agent, Content-Length
* 메시지 의미 (Semantics)
    - 각 필드가 어떤 의미를 가지는지
    - 예: Content-Length: 100 → 메시지 본문이 100바이트라는 뜻
* 교환 규칙 (Rules)
    - 언제, 어떤 상황에서 메시지를 보내고 응답할지
    - 예: 클라이언트가 GET 보내면 서버는 항상 응답해야 함

&ensp;Open vs Proprietary Protocols<br/>
* Open Protocols
    - RFC에 정의, 누구나 접근 가능
    - 예: HTTP, SMTP (인터넷에서 대부분 사용)
* Proprietary Protocols
    - 특정 회사가 비공개로 운영
    - 예: Skype → 내부 프로토콜은 공개되지 않음

&ensp;<b>앱이 필요로 하는 전송 서비스</b><br/>
&ensp;앱마다 원하는 네트워크 특성이 다르다.<br/>
* Data Integrity (데이터 무결성)
    - 파일 전송, 웹 거래 → 절대 데이터 손실 허용 불가
    - 오디오 스트리밍 → 약간의 손실 허용
* Timing (타이밍, 지연 시간)
    - 인터넷 전화, 온라인 게임 → 지연이 크면 사용 불가
* Throughput (처리율, 대역폭)
    - 동영상 스트리밍 → 최소 전송 속도 필요 (예: 5Mbps 이상)
    - 웹 브라우징 → 대역폭이 크면 빨라지지만, 필수는 아님
* Security (보안)
    - 암호화, 무결성, 인증 필요
    - 예: HTTPS → SSL/TLS로 보안 강화

&ensp;앱별 요구사항 정리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-5.png" width="600"></p>

&ensp;👉 요약:<br/>
* 파일 전송/이메일/웹 → TCP 필수 (신뢰성 중요)
* 실시간 오디오/게임 → UDP 선호 (빠른 반응 중요, 약간의 손실 허용)

Internet Transport Protocols: TCP vs UDP
-----

&ensp;TCP (Transmission Control Protocol)<br/>
* Reliable Transport: 손실된 데이터 자동 재전송
* Flow Control: 송신자가 너무 많이 보내지 않도록 제어
* Congestion Control: 네트워크 혼잡 시 속도 줄임
* Connection-Oriented: 연결을 먼저 맺고 통신 (3-way handshake)
* 단점: 속도가 느려지고, 지연 증가

&ensp;UDP (User Datagram Protocol)<br/>
* Unreliable: 데이터 손실 가능
* No flow/congestion control: 단순하게 빠르게 전송
* No connection setup: 즉시 전송 가능
* 장점: 오버헤드 적고 빠름 → 실시간 앱에 적합 (게임, 스트리밍)

&ensp;👉 Q: UDP는 왜 필요할까?<br/>
* TCP는 너무 무겁고 지연이 커서 실시간 앱엔 부적합
* UDP는 단순해서 속도가 빠르고 지연이 적음

&ensp;Application Protocols + Transport Protocols 매칭<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-6.png" width="600"></p>

&ensp;👉 실제로는 HTTP 기반 스트리밍이 많아서 TCP를 주로 쓰지만, 실시간 통화/게임은 UDP를 더 선호한다.<br/>

&ensp;<b>Securing TCP (TCP 보안)</b><br/>
&ensp;기본 TCP/UDP (Vanilla TCP & UDP sockets)<br/>
* 암호화 없음 → 데이터가 평문(cleartext)으로 인터넷을 지나감
* 예: 아이디/비밀번호가 그대로 전송된다면, 중간에서 가로채면 그대로 보임

&ensp;TLS (Transport Layer Security)<br/>
* TCP 위에 보안 계층 추가
* 제공 기능:
    - 암호화된 연결 (데이터 도청 불가)
    - 무결성 (Integrity): 데이터 변조 방지
    - 인증(Authentication): 상대방이 진짜 서버인지 확인
* 즉, HTTPS = HTTP + TLS + TCP

&ensp;👉 비유<br/>
* 그냥 TCP = 엽서 (누구나 내용을 읽을 수 있음)
* TLS TCP = 봉투에 넣은 편지 (중간에서 봐도 못 읽음)

Web and HTTP
=====

&ensp;웹과 HTTP는 응용 계층의 대표 사례이다.<br/>
* 웹 페이지 구조
    - 웹 페이지 = 여러 객체(objects) 로 구성
    - 객체: HTML 파일, 이미지(JPEG), 오디오, 동영상 등
    - 하나의 기본 HTML 파일 (base HTML) 안에 여러 객체 포함
    - 각 객체는 URL 로 접근 가능
        + URL = 호스트 이름 + 경로 이름
        + 예: www.someschool.edu/someDept/pic.gif

&ensp;👉 비유<br/>
* 웹 페이지 = 책 한 권
* HTML 파일 = 책의 목차
* 이미지/동영상 = 목차가 가리키는 다른 페이지

<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-7.png" width="600"></p>

&ensp;<b>HTTP Overview</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-8.png" width="600"></p>

HTTP (HyperText Transfer Protocol)
-----

* 웹에서 쓰는 응용 계층 프로토콜
* 클라이언트-서버 모델 사용
    - 클라이언트: 웹 브라우저 (크롬, 사파리 등) → 요청(request) 보냄
    - 서버: 웹 서버 (Apache, Nginx 등) → 응답(response) 보냄

&ensp;동작 흐름<br/>
1. 브라우저(클라이언트) → HTTP Request (예: GET /index.html)
2. 서버 → HTTP Response (예: 200 OK + HTML 데이터)
3. 브라우저가 응답을 해석해서 사용자에게 보여줌

&ensp;👉 비유<br/>
* 클라이언트 = 식당 손님 (메뉴 주문)
* 서버 = 주방 (주문에 맞춰 음식 제공)
* HTTP Request = 주문서, HTTP Response = 음식

&ensp;HTTP와 TCP<br/>
* HTTP는 TCP 위에서 동작 (보통 포트 80)
* 과정:
1. 클라이언트가 서버와 TCP 연결 (소켓 생성)
2. 연결 위에서 HTTP 메시지를 교환
3. 데이터 전송 끝나면 TCP 연결 종료

* HTTP는 Stateless (무상태)
    - 서버는 이전 클라이언트 요청을 기억하지 않음
    - 각 요청은 독립적으로 처리됨
    - 장점: 단순하고 확장성 좋음
    - 단점: 로그인/장바구니 같은 기능 구현 어려움 → 쿠키/세션 필요

&ensp;👉 비유<br/>
* Stateless HTTP = 패스트푸드점
    - 매번 주문할 때마다 새로 주문서 작성 (직원이 이전 기록 기억 X)
* Stateful Protocol = 단골식당
    - 직원이 저번에 오셨던 손님 기억 → 추가 서비스 가능

&ensp;요약 표<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-9.png" width="600"></p>

&ensp;<b>HTTP Connections: Two Types</b><br/>
* Non-persistent HTTP (비지속 연결, HTTP/1.0 기본)
1. 클라이언트가 서버에 TCP 연결 생성
2. 한 개 객체(object) 만 요청/응답 가능
3. 객체 전송 후, TCP 연결 종료
4. 다른 객체를 받으려면 새로운 TCP 연결 필요

&ensp;👉 즉, 웹페이지 안에 이미지 10개가 있으면 → 10번 TCP 연결<br/>

* Persistent HTTP (지속 연결, HTTP/1.1 기본)
1. 클라이언트가 서버에 TCP 연결 생성
2. 여러 객체를 한 번의 연결로 전송 가능
3. 페이지의 HTML, 이미지, CSS, JS 모두 하나의 TCP 연결로 처리
4. 다 끝나면 TCP 연결 종료

&ensp;👉 즉, 웹페이지 안에 이미지 10개가 있어도 → 1번 TCP 연결<br/>

&ensp;Non-persistent HTTP 예제<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter2. Application layer/2-10.png" width="600"></p>

&ensp;(안에 HTML + JPEG 이미지 10개 포함)<br/>
&ensp;과정<br/>
&ensp;1a. 클라이언트 → 서버에 TCP 연결 요청 (포트 80)<br/>
&ensp;1b. 서버 → 연결 허용 (accept)<br/>
&ensp;2. 클라이언트 → HTTP 요청 메시지 전송 (GET /home.index)<br/>
&ensp;3. 서버 → 응답 메시지 전송 (HTML 파일 내용)<br/>
&ensp;4. 서버 → TCP 연결 닫음<br/>
&ensp;5. 클라이언트 → HTML 파일 해석, 안에 JPEG 10개 참조 발견<br/>
&ensp;6. JPEG 하나 받을 때마다 다시 TCP 연결 생성 + 종료 반복 (총 10번)<br/>
&ensp;👉 결과: 비효율적 (연결 과정 때문에 지연 발생)<br/>

&ensp;비유<br/>
* Non-persistent HTTP = 택배를 매번 따로 시키는 것
    - 책 1권, 연필 1개, 지우개 1개를 따로따로 주문 → 매번 배송기사 옮