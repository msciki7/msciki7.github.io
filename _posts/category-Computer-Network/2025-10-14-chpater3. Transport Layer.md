---
title: "chapter3. Transport Layer"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-09-18
last_modified_at: 2025-09-27
---

Transport-layer services
====

## Transport Services and Protocols

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-1.png" width="500"></p>

* Logical communication<br/>
&ensp;→ 애플리케이션 프로세스들이 물리적으로 떨어져 있어도 논리적으로 연결된 것처럼 데이터를 주고받는 것<br/>
&ensp;(예: 서울에서 보낸 메시지가 뉴욕의 컴퓨터 애플리케이션으로 바로 도착하는 것처럼 보임)<br/>
* Sender 측:<br/>
&ensp;메시지를 **segment(세그멘트)** 로 나누어 네트워크 계층으로 전달<br/>
* Reciver 측:<br/>
&ensp;받은 세그먼트를 다시 **조립(reassemble)**해서 애플리케이션으로 전달

## Transport Layer vs Network Layer

&ensp;비유: 두 집의 아이들이 편지를 주고받는 상황<br/>

| 개념                              | 비유             |
| ------------------------------- | -------------- |
| **Host (호스트)**                  | 집              |
| **Process (프로세스)**              | 집 안의 아이들       |
| **Application message (앱 메시지)** | 편지 (봉투에 담긴 내용) |

* Network Layer(네트워크 계층): 두 집(호스트) 간의 연결을 담당<br/>
&ensp;→ "편지가 한 집에서 다른 집으로 가는 길"<br/>
* Transport Layer (전송 계층): 집 안의 여러 아이들(프로세스) 간 연결 담당<br/>
&ensp;→ "각 아이가 정확한 친구에게 편지를 받도록 배달하는 역할"<br/>

* Network Layer는 집과 집 간 연결
* Transport Layer는 아이와 아이(프로세스 간)연결이다.

&ensp;정리 요약<br/>

| 구분                  | 역할                              |
| ------------------- | ------------------------------- |
| **Network Layer**   | 호스트 간 데이터 전달                    |
| **Transport Layer** | 프로세스 간 논리적 통신                   |
| **UDP**             | 빠르지만 신뢰성 없는 전송                  |
| **TCP**             | 느리지만 신뢰성 높은 전송 (흐름제어 + 혼잡제어 포함) |

## Transport Layer Actions (전송 계층의 동작)

&ensp;전송 계층은 애플리케이션 계층과 네트워크 계층 사이의 중간 관리자처럼 작동한다. 애플리케이션이 보낸 데이터를 네트워크가 이해할 수 있는 형태로 바꿔 보내고 반대로 네트워크로부터 받은 데이터를 애플리케이션이 이해할 수 있는 형태로 돌려준다.<br/>

&ensp;📨 Sender Side (송신 측)<br/>
&ensp;전공 계층은 송신 측에서 다음과 같은 일을 한다.<br/>
1. 애플리케이션 계층으로부터 메시지를 전달받음
* 예: 웹브라우저가 서버에 보낼 HTTP 요청 데이터를 전송 계층에 넘김
2. 세그먼트 헤더(Segment Header) 값 설정
* 송신 포트 번호, 수신 포트 번호, 순서 번호 등
* 즉, “이 메시지가 어디로 가야 하는지” 주소표를 붙이는 작업
3. 세그먼트(Segment) 생성
* 헤더 + 데이터(payload) = 세그먼트 완성!
4. 세그먼트를 IP 계층으로 전달
* IP 계층은 이 세그먼트를 목적지 호스트로 라우팅함

&ensp;전송 계층은 데이터를 쪼개고 이름표를 붙이고 IP 계층으로 전달하는 일을 한다.<br/>

&ensp;📩 Receiver Side (수신 측)<br/>
&ensp;수신 측 전송 계층의 역할은 송신 측의 반대이다.<br/>
1. IP 계층으로부터 세그먼트를 받음
* 네트워크 계층이 목적지까지 데이터를 전달한 뒤 전송 계층으로 넘김
2. 헤더 정보 확인
* "누가 보냈는지", "어디로 가야 하는지", "순서가 맞는지" 등을 검사
3. 애플리케이션 계층 메시지를 추출
* 세그먼트 안의 데이터를 꺼냄
4. Demultiplexing (역다중화)
* 여러 애플리케이션 중, 해당 메시지를 받을 앱(예: 웹서버, 메일서버 등)을 식별하고 전달

&ensp;전송계층은 IP 계층으로부터 받은 데이터를 꺼내서 올바른 애플리케이션으로 보내주는 역할을 한다.<br/>

&ensp;Two Main Internet Transport Protocols<br/>
&ensp;인터넷이 실제로 사용하는 전송 계층 프로토콜은 두 가지이다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-2.png" width="500"></p>

&ensp;TCP 특징<br/>
* Reliable, In-order delivery<br/>
&ensp;→ 패킷이 손실되거나 순서가 바뀌지 않도록 확인 응답(ACK)과 재전송 수행<br/>
* Flow Control (흐름 제어)<br/>
&ensp;→ 수신자의 처리 속도에 맞춰 전송 속도 조절<br/>
* Congestion Control (혼잡 제어)<br/>
&ensp;→ 네트워크가 붐빌 때 자동으로 전송 속도를 줄임<br/>
* Connection Setup<br/>
&ensp;→ 통신 전, 송신자와 수신자가 연결을 먼저 확립 (3-way handshake)<br/>

&ensp;UDP 특징<br/>
* Unreliable, unordered delivery<br/>
&ensp;→ 패킷이 손실되거나 순서가 바뀌어도 신경 쓰지 않음<br/>
* Lightweight (가볍다)<br/>
&ensp;→ 헤더가 작고, 연결 과정이 없음 → 빠르지만 신뢰성은 낮음<br/>
* Best-effort IP 기반 확장<br/>
&ensp;→ IP 위에서 “최대한 잘 해보는” 방식 (보장 없음)<br/>

&ensp;전송 계층이 제공하지 않는 서비스<br/>
* 지연(delay) 보장 X → "언제 도착할지"는 보장하지 않음
* 대역폭(bandwidth) 보장 X → "얼마나 많은 데이터를 전송할 수 있는가"도 보장하지 않음

&ensp;요약 정리<br/>

| 구분    | TCP                    | UDP              |
| ----- | ---------------------- | ---------------- |
| 연결 방식 | 연결지향 (3-way handshake) | 비연결형             |
| 신뢰성   | 높음 (ACK, 재전송)          | 낮음 (Best-effort) |
| 속도    | 느림                     | 빠름               |
| 순서 보장 | 있음                     | 없음               |
| 대표 예시 | 웹, 메일, 파일전송            | 게임, 스트리밍, DNS    |

## Multiplexing & Demultiplexing (다중화와 역다중화)

&ensp;전공 계층은 여러 **애플리케이션(프로세스)** 들의 데이터를 하나의 네트워크 연결로 묶어 보내고(Multiplexing), 다시 각각의 앱으로 나누어 전달(Demultiplexing)한다.<br/>

&ensp;1. 비유로 이해하기<br/>
&ensp;당신이 살고 있는 집(컴퓨터)에는 여러 가족 구성원(프로세스)이 있고 각자 편지(데이터)를 주고받는다고 생각해보자<br/>
* Multiplexing (다중화):<br/>
&ensp;→ 가족들이 보낸 여러 편지를 우체통(송신 소켓) 하나에 모아 우체국(IP 계층)으로 전달<br/>
&ensp;(여러 앱 → 하나의 전송 계층 통로로 묶음)<br/>
* Demultiplexing (역다중화):<br/>
&ensp;→ 우체국에서 온 편지를 다시 받는 사람별로 나눠서 배달<br/>
&ensp;(수신 전송 계층이 세그먼트를 올바른 프로세스로 분배)<br/>

&ensp;Multiplexing은 여러 앱의 데이터를 한 줄로 묶어 보내는 것, Demultiplexing은 받은 데이터를 각각의 앱으로 나누는 것<br/>

&ensp;2. 실제 동작 과정
&ensp;💻 송신 측 (Multiplexing at Sender)<br/>
1. 여러 소켓(Socket) 으로부터 데이터를 받음
2. 각 데이터에 전송 계층 헤더(Transport Header) 를 붙임
*  헤더 안에는 출발지/도착지 포트 번호가 포함됨
3. 세그먼트를 만들어 네트워크 계층(IP)으로 전달

&ensp;이때 헤더에 포함된 포트 번호가 나중에 Demultiplexing에 사용됨<br/>

&ensp;🖥 수신 측 (Demultiplexing at Receiver)<br/>
1. IP 계층으로부터 세그먼트를 전달받음
2. 헤더의 포트 번호를 확인
* "이 세그먼트는 어떤 소켓으로 가야 하지?"
3. 해당 포트 번호에 연결된 소켓(Socket) 으로 데이터를 전달

&ensp;즉 받은 데이터를 “정확한 애플리케이션 프로세스”에 분배하는 단계이다.<br/>

&ensp;3. 포트 번호 (Port Number)의 역할<br/>

| 구분                           | 설명                               |
| ---------------------------- | -------------------------------- |
| **출발지 포트(Source Port)**      | 데이터를 보낸 프로세스 식별                  |
| **도착지 포트(Destination Port)** | 데이터를 받을 프로세스 식별                  |
| **대표 예시**                    | HTTP → 80, HTTPS → 443, DNS → 53 |

&ensp;포트 번호는 "앱을 구분하는 주소" 역할을 한다. (하나의 IP 안에서 여러 프로그램을 구분하기 위함)<br/>

&ensp;4. 시각적으로 보기<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-3.png" width="500"></p>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-4.png" width="500"></p>

* 클라이언트에는 여러 앱(예: Skype, Netflix, Firefox)
* 서버는 Apache HTTP Server(하나의 서버 프로그램)
* 각 클라이언트가 HTTP 요청을 보낼 때 전송 계층이 포트 번호를 붙여 구분
* 서버의 전송 계층은 들어온 요청의 포트 번호를 보고 각각의 클라이언트 소켓으로 데이터를 전달

&ensp;이 과정을 그림으로 보면 여러 개의 화살표(클라이언트 → 서버)가 하나의 전송 통로로 모이고 서버 쪽에서 다시 각 앱으로 나뉘는 구조이다.<br/>

&ensp;5. 요약 정리 표<br/>

| 구분    | Multiplexing       | Demultiplexing   |
| ----- | ------------------ | ---------------- |
| 담당 측  | 송신자(Sender)        | 수신자(Receiver)    |
| 역할    | 여러 앱 데이터 묶기        | 받은 데이터 분리        |
| 사용 정보 | 포트 번호(Header) 추가   | 포트 번호(Header) 확인 |
| 예시    | 여러 브라우저 탭에서 서버로 전송 | 서버가 각 탭으로 응답 분배  |

* Multiplexing (다중화): 송신 측에서 여러 애플리케이션의 데이터를 하나의 네트워크 채널로 묶어 전송
* Demultiplexing (역다중화): 수신 측에서 도착한 데이터를 다시 올바른 애플리케이션으로 분리

&ensp;**"여러 앱의 데이터를 하나로 합치고, 다시 나누는 과정"**이다.<br/>

&ensp;5. 송신자와 수신자의 역할 정리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-5.png" width="500"></p>

&ensp;Multiplexing at Sender (송신 측 다중화)<br/>
* 여러 소켓(Socket)으로부터 데이터를 받아옴
* 각 데이터에 전송 계층 헤더(Transport Header) 를 붙임 → 나중에 수신자가 구분할 수 있도록 “주소표”를 붙이는 것
* 헤더가 붙은 세그먼트를 네트워크 계층으로 전달

&ensp;즉 "누가 보낸 건지, 어디로 가야 하는지" 정보가 담긴 '포장 작업'을 하는 단계이다.<br/>

&ensp;**Demultiplexing at Receiver (수신 측 역다중화)**<br/>
* 네트워크 계층(IP)으로부터 세그먼트를 받음
* 헤더 정보(포트 번호 등) 를 확인해서 해당 세그먼트를 올바른 소켓으로 전달

&ensp;즉 "받은 데이터를 어떤 애플리케이션으로 보내야 하는가?"를 결정하는 과정이다.<br/>

&ensp;6. Demultiplexing의 실제 동작<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-6.png" width="500"></p>

&ensp;과정 요약<br/>
1. 호스트(host) 는 IP 계층으로부터 데이터그램(datagram)을 받음
2. 각 데이터그램에는
* 출발지 IP 주소
* 목적지 IP 주소
* 전송 계층 세그먼트(segment) 가 포함됨
3. 세그먼트는 또다시 정보를 포함
* 출발지 포트 번호 (source port #)
* 목적지 포트 번호 (destination port #)

&ensp;따라서 IP 주소 + 포트 번호의 조합으로 어떤 소켓으로 데이터를 전달할지 결정한다.<br/>

&ensp;포트 번호가 중요한 이유<br/>
&ensp;전송 계층은 네트워크 계층과 달리 **한 호스트 내부의 여러 앱(프로세스)** 을 구분해야 한다.<br/>
&ensp;그때 사용되는 식별자가 바로 **포트 번호(Port Number)** 이다.<br/>

| 구분            | 의미            | 예시                              |
| ------------- | ------------- | ------------------------------- |
| **출발지 포트 번호** | 보낸 쪽 앱의 소켓 번호 | 49152~65535 (임시 포트)             |
| **도착지 포트 번호** | 받을 쪽 앱의 소켓 번호 | 80(HTTP), 53(DNS), 443(HTTPS) 등 |

&ensp;**Connectionless Demultiplexing (비연결형 역다중화 — UDP)**<br/>
&ensp;UDP는 "비연결형(connectionless)" 전송 방식이다. 즉 통신 전 연결 설정을 하지 않고 바로 데이터를 보낸다.<br/>
&ensp;송신 층<br/>
```java
DatagramSocket mySocket = new DatagramSocket(12534);
```

&ensp;→ 로컬 포트 번호(12534)로 소켓을 생성<br/>

&ensp;데이터그램 전송 시에는 목적지 IP 주소, 목적지 포트 번호를 명시해야 한다.<br/>

&ensp;수신 측<br/>
&ensp;UDP 세그먼트를 받으면 수신자는:<br/>
1. 세그먼트의 목적지 포트 번호를 확인
2. 해당 번호에 연결된 소켓으로 데이터 전달

&ensp;같은 목적지 포트 번호(dest. port) 를 가진 데이터그램은
출발지가 달라도 같은 소켓으로 들어옴<br/>
&ensp;예시: DNS 서버는 53번 포트를 사용해 전 세계 수많은 요청을 하나의 소켓에서 처리함<br/>

&ensp;예제 분석<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-7.png" width="500"></p>

| 역할     | 소켓 생성 코드                   | 포트 번호 |
| ------ | -------------------------- | ----- |
| 클라이언트1 | `new DatagramSocket(9157)` | 9157  |
| 서버     | `new DatagramSocket(6428)` | 6428  |
| 클라이언트2 | `new DatagramSocket(5775)` | 5775  |

&ensp;클라이언트1(P3) → 서버(P1):<br/>
* Source port = 9157
* Destination port = 6428

&ensp;서버(P1) → 클라이언트1(P3):<br/>
* Source port = 6428
* Destination port = 9157

&ensp;클라이언트2(P4) → 서버(P1):<br/>
* Source port = 5775
* Destination port = 6428

&ensp;서버는 6428번 포트 하나로 여러 클라이언트의 요청을 구분 없이 받아들인다. UDP는 출발지가 달라도 같은 목적지 포트로 들오기 때문이다.<br/>

&ensp;**Connection-Oriented Demultiplexing (연결지향형 역다중화)**<br/>
&ensp;핵심 개념 요약<br/>
&ensp;UDP에서는 목적지 포트 번호(dest.port) 하나만으로 데이터를 어느 소켓으로 보낼지 판단했다.<br/>
&ensp;하지만 TCP는 연결(Connection) 개념이 있기 때문에, 훨씬 더 세밀한 구분이 필요하다.<br/>
&ensp;그래서 TCP는 4개의 값(4-tuple)로 각 연결을 구분한다.<br/>

| 구성 요소                     | 설명         |
| ------------------------- | ---------- |
| ① Source IP Address       | 송신자 IP 주소  |
| ② Source Port Number      | 송신자의 포트 번호 |
| ③ Destination IP Address  | 수신자 IP 주소  |
| ④ Destination Port Number | 수신자의 포트 번호 |

&ensp;Demultiplexing 과정<br/>
&ensp;1. 서버가 TCP 세그먼트를 받으면 그 세그먼트의 4-tuple 정보를 읽는다.<br/>
```bash
(source IP, source port, dest IP, dest port)
```

&ensp;2. 이 정보가 서버가 관리 중인 연결 목록에 있는지 확인한다.<br/>
* 있으면 → 해당 소켓으로 세그먼트 전달
* 없으면 → 새로운 연결로 인식하여 새 소켓 생성 (예: HTTP 서버의 새로운 클라이언트 연결)

&ensp;즉, TCP는 "모든 연결을 4-tuple로 식별"하기 때문에 동일한 포트 번호(예: 80번)를 사용하더라도 각기 다른 클라이언트와 독립적인 연결을 유지할 수 있다.<br/>

&ensp;서버가 여러 클라이언트를 동시에 지원하는 이유<br/>
&ensp;TCP 서버(예: Apache HTTP Server)는 보통 80번 포트를 사용하지만 그 포트 하나로도 여러 사용자의 요청을 동시에 처리할 수 있다.<br/>
&ensp;이유는?<br/>
&ensp;각 클라이언트마다 출발지 IP/포트가 다르기 때문!<br/>

| 클라이언트    | 출발지 IP       | 출발지 포트 | 서버 IP       | 서버 포트 | 연결 구분 |
| -------- | ------------ | ------ | ----------- | ----- | ----- |
| Client A | 192.168.1.10 | 9157   | 203.0.113.1 | 80    | 연결①   |
| Client B | 192.168.1.20 | 5775   | 203.0.113.1 | 80    | 연결②   |
| Client C | 192.168.1.30 | 6428   | 203.0.113.1 | 80    | 연결③   |

&ensp;서버 입장에서는 "서버 포트는 모두 80번"이지만 각기 다른 클라이언트 조합(4-tuple)로 구분 가능하다.<br/>

&ensp;예시<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-8.png" width="500"></p>

&ensp;상황<br/>
* 서버: Apache HTTP Server (IP 주소 = B, 포트 = 80)
* 클라이언트 A, C가 각각 요청을 보냄

| 출발지           | 목적지              | 설명 |
| ------------- | ---------------- | -- |
| A:9157 → B:80 | 클라이언트 A의 요청      |    |
| C:5775 → B:80 | 클라이언트 C의 요청      |    |
| C:9157 → B:80 | 클라이언트 C의 두 번째 요청 |    |

&ensp;결과<br/>
&ensp;서버는 모두 80번 포트로 요청을 받지만 각 요청의 (source IP, source port)가 다르기 때문에 각기 다른 소켓(P4, P5, P6) 으로 연결을 관리한다.<br/>

&ensp;UDP vs TCP Demultiplexing 비교<br/>

| 구분                   | UDP (Connectionless) | TCP (Connection-oriented)         |
| -------------------- | -------------------- | --------------------------------- |
| 구분 기준                | 목적지 포트 번호만           | 4-tuple (출발지 IP, 포트 + 목적지 IP, 포트) |
| 연결 여부                | 없음 (비연결형)            | 있음 (연결 유지)                        |
| 하나의 포트에서 여러 클라이언트 지원 | 같은 소켓으로 수신           | 각기 다른 소켓으로 수신                     |
| 대표 예시                | DNS, 스트리밍, 게임        | HTTP, FTP, 이메일, SSH               |

Connectionless transport: UDP
=====

## UDP(User Datagram Protocol)

&ensp;UDP는 User Datagram Protocol의 약자로 인터넷 전송 계층(Transport Layer)의 대표적인 비연결형 프로토콜이다.(최소한의 기능만 제공하는 아주 가벼운 전송 프로토콜)<br/>
&ensp;TCP처럼 복잡한 연결 관리나 오류 제어를 하지 않고 그저 보내면 끝(send and forget) 방식으로 작동한다.<br/>

&ensp;UDP의 특징 정리<br/>

| 구분                         | 설명                                |
| -------------------------- | --------------------------------- |
| **No Frills / Bare Bones** | “군더더기 없는” 아주 단순한 프로토콜             |
| **Best Effort Service**    | 최대한 노력해서 보낼 뿐, 성공을 보장하지 않음        |
| **Connectionless (비연결형)**  | 송신자와 수신자 간 사전 연결(handshaking)이 없음 |
| **Independent Segments**   | 각 UDP 세그먼트는 서로 독립적으로 처리됨          |
| **손실 가능성**                 | 데이터가 유실되거나 순서가 바뀌어 도착할 수 있음       |

&ensp;UDP는 단순히 데이터그램(datagram) 단위로 데이터를 네트워크에 던지고 끝이다. 이후 성공 여부는 신경 쓰지 않는다.<br/>

&ensp;UDP를 사용하는 이유<br/>

| 이유              | 설명                                                  |
| --------------- | --------------------------------------------------- |
| **① 연결 설정이 없음** | TCP처럼 연결 수립(3-way handshake)이 없어 지연(RTT delay)이 줄어듦 |
| **② 상태 관리 불필요** | 송수신 측에서 연결 상태를 유지할 필요 없음 → 자원 절약                    |
| **③ 헤더가 작음**    | 오버헤드가 적어 전송 속도 빠름                                   |
| **④ 혼잡 제어 없음**  | 네트워크가 붐벼도 스스로 속도를 늦추지 않음 → 실시간 앱에 유리                |

&ensp;UDP는 최대한 빠르게 보내는 것을 목표로 하며 속도 > 신뢰성이 필요한 경우 탁월하다.<br/>

&ensp;UDP의 사용 사례<br/>

| 분야       | 예시                       | 이유                   |
| -------- | ------------------------ | -------------------- |
| 🎥 스트리밍  | YouTube, Zoom, Netflix 등 | 약간의 손실보다 실시간성이 중요    |
| 🌍 DNS   | 도메인 이름 → IP 주소 변환        | 매우 짧은 요청/응답 형태로 빠름   |
| 📡 SNMP  | 네트워크 장비 관리               | 단순 명령/응답 구조          |
| ⚡ HTTP/3 | QUIC 기반으로 UDP 위에서 동작     | TCP의 연결 지연 제거, 속도 향상 |

&ensp;신뢰성이 필요한 경우<br/>
&ensp;UDP 자체는 신뢰성(재전송, 순서 보장 등)을 제공하지 않지만 애플리케이션 계층(Application Layer)에서 직접 구현할 수 있다.<br/>
&ensp;예를 들어<br/>
* QUIC (HTTP/3)는 UDP 위에서 “애플리케이션 수준의 신뢰성”을 추가함
* 온라인 게임, 스트리밍 등에서도 필요 시 자체 오류 복구 기능을 가짐

&ensp;UDP의 구조(RFC 768)<br/>
&ensp;구조는 매우 단순하며 8바이트(header) + 데이터(payload)로 구성된다.<br/>

| 필드                   | 크기 (bytes) | 설명                    |
| -------------------- | ---------- | --------------------- |
| **Source Port**      | 2          | 송신 포트 번호              |
| **Destination Port** | 2          | 수신 포트 번호              |
| **Length**           | 2          | 전체 세그먼트 길이 (헤더 + 데이터) |
| **Checksum**         | 2          | 오류 검출용 값              |
| **Data**             | 가변         | 실제 전송할 데이터 (payload)  |

## UDP: Transport Layer Actions

&ensp;1. 예시 시나리오-SNMP 통신<br/>
&ensp;예제에서는 SNMP(Simple Network Management Protocol) 클라이언트와 서버가 UDP를 통해 통신한다. SNMP는 네트워크 장비 관리에 사용되는 대표적인 UDP 기반 프로토콜이다.<br/>

| 구성 요소                     | 설명                        |
| ------------------------- | ------------------------- |
| **Application Layer**     | SNMP 메시지를 생성 및 해석         |
| **Transport Layer (UDP)** | SNMP 메시지를 UDP 세그먼트에 담아 전달 |
| **Network Layer (IP)**    | 세그먼트를 IP 패킷으로 감싸서 네트워크 전송 |
| **Link / Physical Layer** | 실제 전송 (유선/무선) 수행          |

&ensp;UDP 송신 측 동작 (UDP Sender Actions)<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-9.png" width="500"></p>

&ensp;UDP Sender의 단계별 수행<br/>
1. Application Layer 메시지 전달
* SNMP 클라이언트는 전송할 SNMP 메시지를 UDP 계층으로 넘김 (예: "라우터 상태 요청 메시지")
2. UDP 헤더 생성 및 값 설정
* 송신 측은 UDP 세그먼트의 헤더를 구성:
    - Source Port
    - Destination Port
    - Length
    - Checksum
3. UDP 세그먼트 생성
* `[UDP 헤더 + SNMP 메시지 데이터]` 형태로 하나의 세그먼트 완성
4. IP 계층으로 전달
* UDP는 IP에 세그먼트를 넘김 → IP는 목적지 주소를 붙여 네트워크로 전송

&ensp;요약: SNMP 메시지 → UDP 헤더 추가 → UDP 세그먼트 완성 → IP 계층으로 전달<br/>

&ensp;UDP 수신 측 동작 (UDP Receiver Actions)<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-10.png" width="500"></p>

&ensp;UDP Receiver의 단계별 수행<br/>
1. IP 계층으로부터 UDP 세그먼트 수신
* IP 계층이 목적지 IP 주소를 기준으로 UDP 계층에 전달
2. Checksum 검사
* UDP 헤더의 Checksum 값을 통해 데이터 손상 여부 확인
* 오류 발생 시 세그먼트는 버림(drop)
3. 애플리케이션 데이터 추출
* 헤더를 제거하고 SNMP 메시지(SNMP msg) 부분만 남김
4. 소켓을 통해 애플리케이션으로 전달
* 목적지 포트 번호를 기준으로 올바른 소켓(SNMP 서버)으로 전달
* SNMP 서버가 메시지를 읽고 응답을 보냄

&ensp;요약: IP → UDP → SNMP 순으로 계층이 벗겨지며 SNMP 메시지는 “데이터 순수 형태”로 서버 애플리케이션에 도착한다.<br/>

&ensp;UDP Segment Header 구조<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-11.png" width="500"></p>

| 필드                             | 크기      | 설명                         |
| ------------------------------ | ------- | -------------------------- |
| **Source Port #**              | 2 bytes | 송신 측 포트 번호                 |
| **Destination Port #**         | 2 bytes | 수신 측 포트 번호                 |
| **Length**                     | 2 bytes | 전체 UDP 세그먼트의 길이 (헤더 + 데이터) |
| **Checksum**                   | 2 bytes | 오류 검출용 값                   |
| **Application Data (Payload)** | 가변      | 실제 전송할 데이터 (예: SNMP 메시지)   |

&ensp;UDP는 오류 검출은 가능하지만 재전송이나 복구 하지 않음 (Checksum이 틀리면 그냥 버린다.)<br/>

## UDP Checksum

&ensp;목표: 전송 중 발생한 비트 오류 (flipped bits)를 감지하는 것<br/>
&ensp;데이터가 네트워크를 지나면서 ‘1 → 0’ 혹은 ‘0 → 1’로 바뀌는 경우가 생길 수 있다. UDP는 이를 단순한 덧셈 검증 방식으로 탐지한다.<br/>

&ensp;Checksum의 기본 개념<br/>

| 단계                 | 설명                                     | 예시                |
| ------------------ | -------------------------------------- | ----------------- |
| 송신 시 (Transmitted) | 송신자가 2개의 숫자(예: 5와 6)를 더함               | 5 + 6 = **11**    |
| 수신 시 (Received)    | 전송 중 5가 4로 손상됨                         | 4 + 6 = **10**    |
| 비교 결과              | 송신자 계산값(11) ≠ 수신자 계산값(10) → **오류 감지!** | ⚠️ Error detected |

&ensp;송신자 계산 checksum ≠ 수신자 계산 checksum → 데이터 오류 발생<br/>

&ensp;Internet Checksum의 실제 동작<br/>
&ensp;UDP는 데이터를 16비트 단위로 쪼개서 계산한다.<br/>

&ensp;송신자(Sender) 측<br/>
1. UDP 세그먼트 전체(헤더 + 데이터)를 16비트 단위로 나눔
2. 모든 16비트 값을 더함 (One’s Complement Sum)
3. 결과의 1의 보수를 취해(Check complement) → Checksum 필드에 저장
4. 수신자에게 전송

&ensp;수신자(Receiver) 측<br/>
1. 받은 세그먼트의 모든 16비트 값을 다시 더함 (받은 Checksum 포함)
2. 결과가 **‘모두 1’**이면 정상, 그렇지 않으면 오류

&ensp;Internet Checksum 계산 예시<br/>
&ensp;두 개의 16비트 숫자를 더하는 경우<br/>
```markdown
1110001100110011
1101010101010101
----------------
1 0111010010001000   ← 맨 왼쪽 1은 넘침 (wraparound)
```

&ensp;넘친 1은 다시 뒤로 더함:<br/>
```markdown
0111010010001000
+              1
----------------
0111010010001001
```

&ensp;이제 1의 보수를 취하면 Checksum:<br/>
```markdown
1000101101110110
```

&ensp;Checksum = (모든 16비트의 합 + 넘침 처리) 의 1의 보수<br/>

&ensp;Checksum의 한계<br/>
&ensp;UDP Checksum은 완벽하지 않다. 즉 모든 오류를 100% 잡아내지 못한다.<br/>
&ensp;예시-약한 보호(Weak Protection)<br/>
&ensp;두 비트가 서로 반대로 바뀌면(bit flip):<br/>
```markdown
1 → 0
0 → 1
```

&ensp;합산 결과가 같게 나올 수 있다. 즉 Checksum은 동일하지만 실제 데이터는 손산된다. 그래서 UDP의 Checksum은 단순한 오류 감지용일 뿐 복잡한 전송 오류에는 대응하지 못한다.<br/>