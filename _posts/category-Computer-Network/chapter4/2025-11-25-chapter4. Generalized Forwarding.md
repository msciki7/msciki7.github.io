---
title: "chapter4. Generalized Forwarding, SDN"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-11-25
last_modified_at: 2025-11-25
---

Generalized Forwarding(일반화된 포워딩)
=====

&ensp;**"match + action" 모델**<br/>
&ensp;네트워크 라우터가 패킷을 처리할 때 사용하는 가장 핵심 논리는 아래 한 문장으로 요약된다.<br/>
&ensp;패킷 헤더의 특정 비트들을 보고(match), 그에 따라 특정 행동(action)을 한다.<br/>

* 어떤 패킷이 오면
* 그 패킷의 헤더(출발지/목적지 IP, 포트, 프로토콜 등)를 확인하고
* 거기에 맞는 규칙(rule)을 찾아
* 지정된 행동(전달/드롭/수정/로그 등)을 실행한다.

&ensp;기존 라우터 vs SDN 라우터 차이<br/>
&ensp;기존 라우터: Destination-based Forwarding<br/>
* 패킷의 목적지 IP 주소만 보고
* 어느 포트로 보내야 하는지 결정

&ensp;SDN 라우터: Generalized Forwarding<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-49.png" width="500"></p>

* 목적지 IP뿐 아니라 출발지 IP, 포트번호, 프로토콜, TCP flag, VLAN tag 등 다양한 헤더 요소를 보고
* 다양한 action 수행 가능

&ensp;예:<br/>
* 특정 패킷은 드롭
* 보안 패킷은 로그 생성
* QoS 패킷은 우선순위 높게 전달
* 특정 트래픽은 컨트롤러에게 전달

## Flow Table(플로우 테이블) = 라우터의 뇌

&ensp;Flow = "헤더 필드 값들의 조합으로 정의되는 트래픽 그룹"<br/>

&ensp;예:<br/>
* src=10.1.2.3, dest=8.8.8.8
* port=80인 모든 패킷
* TCP SYN 플래그만 켜진 패킷

&ensp;Flow Table 구성요소<br/>
&ensp;Flow table 안에는 여러 개의 rule(규칙)이 있고, 각 규칙은 아래 4가지 정보로 구성됨:<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-50.png" width="500"></p>

1. match
* 패킷 헤더에서 “어떤 패턴이 오면” 이 규칙을 적용할지 정의
* 예: `src=1.2.*.*, dest=3.4.*.*`
2. action
* 매칭 되면 어떤 행동을 할지
* 예:
    - forward(2번 포트로 보냄)
    - drop
    - modify(헤더 값 바꿈)
    - send to controller
3. priority
* 여러 규칙이 동시에 match될 때 어떤 규칙을 우선 적용할지
* (시험 단골) 가장 구체적인 패턴일수록 보통 우선순위가 높음
4. counters
* 해당 규칙이 몇 번 사용되었는지 (#packets, #bytes)

&ensp;예시<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-51.png" width="500"></p>

| 매칭 조건(match)                  | 행동(action)         |
| ----------------------------- | ------------------ |
| src = *. *.*.*, dest=3.4.*.*  | forward(2번 포트로)    |
| src = 1.2.*.*, dest=*. *.*.*  | drop               |
| src = 10.1.2.3, dest=*. *.*.* | send to controller |

&ensp;이해 포인트<br/>
* `*`(wildcard)는 아무 값이나 허용한다는 뜻
* 즉, 특정 필드만 신경 쓰고 나머지는 무시하는 규칙 작성 가능
* 더 구체적인 규칙이 있다면 priority를 이용해 우선 적용된다

&ensp;왜 이런 구조가 필요할까?<br/>
&ensp;SDN의 핵심은 유연성과 중앙제어<br/>
&ensp;전통 라우터는 목적지 주소 하나만 보고 행동했지만 SDN에서는 (controller가 관리) 복잡하고 다양한 트래픽을 세밀하게 제어할 수 있어야 했다.<br/>
* 패킷 "종류별로" 다른 행동 지정 가능
* 방화벽, NAT, QoS와 같은 기능을 하나의 모델로 통합
* 네트워크 정책을 중앙에서 쉽게 변경 가능

### OpenFlow: Flow Table Entries

&ensp;1. Flow Table는 3부분으로 구성됨<br/>
```sql
┌───────────┬──────────┬────────────┐
│   Match   │  Action  │   Stats    │
└───────────┴──────────┴────────────┘
```

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-52.png" width="500"></p>

&ensp;Match<br/>
* 패킷의 어떤 부분을 검사할지 정의
* 즉 "이런 헤더를 가진 패킷이 들어오면…"

&ensp;Action<br/>
* 해당 패킷을 발견했을 때 어떤 행동을 할지
* 시험에서 꼭 외우는 4가지:
1. 특정 포트로 전송 (forward)
2. 패킷 드롭
3. 헤더 수정
4. controller로 보내기 (send to controller)

&ensp;Stats (Counters)<br/>
* 이 규칙이 몇 번 사용되었는지 기록 (#packets, #bytes)

&ensp;2. Match할 수 있는 Header Fields<br/>
&ensp;Link Layer(2계층)<br/>
* Ingress Port
* Src MAC
* Dst MAC
* Eth type
* VLAN ID
* VLAN Priority

&ensp;Network Layer(3계층)<br/>
* IP Src
* IP Dst
* IP Protocol
* IP ToS(DSCP)

&ensp;Transport Layer(4계층)<br/>
* TCP/UDP Source Port
* TCP/UDP Destination Port

&ensp;OpenFlow는 L2 ~ L4 헤더 전체를 match할 수 있다 → 일반 라우터/스위치보다 훨씬 강력함.<br/>

&ensp;Examples<br/>
&ensp;Example 1 — 목적지 기반 포워딩<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-53.png" width="500"></p>

&ensp;규칙: IP Dst = 51.6.0.8 → output port = 6<br/>
&ensp;목적지 IP가 특정 값이면 port6으로 보냄 → 기존 라우팅 테이블과 거의 같은 동작<br/>

&ensp;Example 2 — Firewall<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-54.png" width="500"></p>

&ensp;Firewall rule 1<br/>
* TCP destination port = 22(SSH) → drop<br/>
&ensp;SSH 접속 패킷은 전부 차단<br/>

&ensp;Firewall rule 2<br/>
* Src IP = 128.119.1.1 → drop<br/>
&ensp;특정 출발지 IP에서 오는 모든 트래픽 차단<br/>

&ensp;Example 3 — L2 Switch 동작<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-55.png" width="500"></p>

&ensp;규칙: MAC dest = 22:A7:23:11:E1:02 → forward to port3<br/>
&ensp;이건 스위치의 MAC learning table과 똑같은 기능. 하지만 차이점은 기존 스위치는 L2 header만 보지만 OpenFlow는 L2~L4까지 전부 보고 match할 수 있음.<br/>

### OpenFlow Abstraction

&ensp;OpenFlow의 match+action 모델은 여러 네트워크 장비들의 공통된 동작을 하나로 통합하는 추상화이다.<br/>

&ensp;Router<br/>
* match: longest prefix match
* action: forward

&ensp;Switch<br/>
* match: destination MAC
* action: forward/flood

&ensp;Firewall<br/>
* match: IP + TCP/UDP port
* action: permit/deny

&ensp;NAT<br/>
* match: IP address & port
* action: rewrite address/port

&ensp;OpenFlow Example<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-56.png" width="500"></p>

&ensp;SDN 컨트롤러가 전체 네트워크를 통합적으로 제어 가능함을 보여주는 예시이다.<br/>

&ensp;목표<br/>
* host h5, h6 → h3/h4로 트래픽을 보내야 함
* 경로는: h5/h6 → s3 → s1 → s2 → h3/h4

&ensp;각 스위치(s1, s2, s3)의 flow table을 컨트롤러가 미리 적절하게 설정해놓으면 전체 네트워크 레벨에서 행동이 결정됨<br/>
* Control plane 중앙 집중화
* Data plane은 단순히 match+action만 수행
* 전체 경로를 프로그래밍하듯 제어 가능

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-57.png" width="500"></p>

&ensp;1. 스위치 s3의 Flow Table<br/>
&ensp;Match<br/>
* IP Src = 10.3.*.* (h5/h6)
* IP Dst = 10.2.*.* (h3/h4)

&ensp;Action<br/>
* forward(3)

&ensp;h5/h6 → h3/h4 방향 트래픽은 s3의 3번 포트로 보내라는 뜻이다. 그럼 s3 → (port3 연결된 곳) → s1로 전달된다.<br/>

&ensp;2. 스위치 s1의 Flow Table<br/>
&ensp;Match<br/>
* ingress port = 1 (즉, s3에서 온 패킷)
* IP Src = 10.3.*.*
* IP Dst = 10.2.*.*

&ensp;Action<br/>
* forward(4)

&ensp;s3에서 오는 트래픽을 s1의 4번 포트로 보내라 → s1 port4는 s2로 연결된다. s1은 이 트래픽을 s2에게 넘긴다.<br/>

&ensp;3. 스위치 s2의 Flow Table<br/>
&ensp;s2는 목적지에 따라 두 갈래로 forwarding 한다.<br/>
1. 목적지 = h3 (IP 10.2.0.3)
* ingress port = 2 (s1에서 옴)
* IP Dst = 10.2.0.3 → forward(3)
2. 목적지 = h4 (IP 10.2.0.4)
* ingress port = 2
* IP Dst = 10.2.0.4 → forward(4)

* h5/h6 → h3이면 port3
* h5/h6 → h4이면 port4 로 보내면 도착

Summary
=====

&ensp;**match + action 모델**<br/>
* 패킷 헤더의 비트를 보고(match)
* 정해진 행동을 한다(action)

&ensp;헤더 필드는 L2~L4 아무거나 가능:<br/>
* MAC 주소
* VLAN
* IP 주소
* 프로토콜
* TCP/UDP 포트 <br/>
&ensp;→ 모든 장비(스위치, 방화벽, 라우터, NAT)를 하나의 공통 모델로 설명 가능.<br/>

&ensp;**가능한 Action들**<br/>
* drop
* forward
* modify (헤더 수정)
* controller에게 보내기<br/>
&ensp;이 네 가지 조합으로 어떤 네트워크 장비든 만들 수 있음.<br/>

&ensp;**network-wide behaviors를 프로그래밍**<br/>
&ensp;SDN 컨트롤러는 네트워크 전체의 동작을 "프로그램"한다. 스위치는 데이터 플레인에서 match+action만 수행한다.<br/>

&ensp;**Network Programmability**<br/>
&ensp;OpenFlow는 프로그래머블 네트워크의 시작이며 오늘날에는 더 강력한 언어(P4; packet processing을 코딩하는 언어)로 확장됨.<br/>

Middleboxes
====

## Middbox 개념

&ensp;**IP 라우터의 기본 기능을 벗어난 추가적인 기능을 송신자와 수신자 사이의 경로(datapath)에서 수행하는 장비** <br/>
&ensp;라우터처럼 패킷을 전달하는 역할을 하는데 + 추가 기능이 들어 있는 중간 장비<br/>

&ensp;기본 라우터와의 차이<br/>
* 라우터: 목적지 주소 기반으로 패킷 전달
* Middlebox + 보안, 트래픽 제어, 변조, 로깅 등 부가 기능 수행

&ensp;대표적인 Middlebox 종류<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-58.png" width="500"></p>

&ensp;NAT<br/>
* 가정, 기업, 통신사에서 매우 흔함
* private IP ↔ public IP 변환

&ensp;방화벽(Firewall), IDS(침입 탐지 시스템)<br/>
* 패킷 검사 및 보안 기능 수행
* 기업/기관/ISP 필수 요소

&ensp;Load Balancer<br/>
* 서버로 가는 요청을 여러 서버로 분산
* 클라우드/데이터센터 필수

&ensp;Cache (CDN, ISP 캐시)<br/>
* 가까운 곳에서 콘텐츠 제공해 속도 개선

&ensp;Application-specific middleboxes<br/>
* CDN
* 동영상 최적화 박스
* VPN Gateway 등

&ensp;오늘날 인터넷 트래픽 대부분은 Middleboxes를 반드시 지나간다.<br/>

## Middlebox의 발전 과정

&ensp;1. 초기: 전용 하드웨어 기반(Closed box)<br/>
* Cisco/Juniper 등 특정 회사가 만든 하드웨어
* 블랙박스처럼 내부가 닫혀 있음
* 기능 추가/업데이트 어려움

&ensp;2. Whitebox hardware (오픈 API 지원)<br/>
* 일반적인 하드웨어+소프트웨어 기반 장비
* 누구나 API를 통해 제어 가능
* 비용↓ 유연성↑

&ensp;3. SDN과의 통합<br/>
* 컨트롤 플레인 중앙집중화
* middlebox 동작도 OpenFlow의 match+action처럼 "프로그래밍 가능"
* 네트워크 전체를 하나의 소프트웨어처럼 제어 가능

&ensp;4. NFV (Network Functions Virtualization)<br/>
* 방화벽, NAT, Load Balancer 등을 가상머신/컨테이너로 실행
* 클라우드 환경에서 빠르게 배포 가능
* 네트워크 기능을 SW로 제공하는 시대

## IP Hourglass 구조

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-59.png" width="500"></p>

&ensp;The IP Hourglass<br/>
&ensp;위쪽 (Application Layer)<br/>
* HTTP, SMTP, QUIC, RTP 등 다양한 프로토콜

&ensp;가운데 허리 (Network Layer)<br/>
* IP 하나만 존재
* 인터넷에 연결되는 모든 기기는 반드시 IP를 구현해야 한다 → 이를 **thin waist(얇은 허리)**라고 부름, 인터넷 확장·호환성의 기반

&ensp;아래쪽 (Link/Physical Layer)<br/>
* Ethernet, Wi-Fi, PPP, 5G PDCP, Bluetooth 등 다양한 프로토콜

&ensp;위·아래는 다양하지만, 중간(3계층)은 IP 하나로 통일되어 있기 때문에 인터넷은 확장이 쉬웠다.<br/>

&ensp;**Middleboxes가 등장하며 모래시계가 변형됨**<br/>
&ensp;중간 허리(= IP 계층)에 많은 역할(NAT, Firewall, Caching, NFV)이 끼어들면서 원래 깨끗하고 얇던 IP 계층이 점점 두꺼워졌다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-60.png" width="500"></p>

&ensp;IP 계층은 원래 단순해야 했다.<br/>
&ensp;하지만 middlebox가 많아지면서:<br/>
* 패킷 변조(NAT),
* 검사(Firewall),
* 차단,
* 재작성(load balancing)

&ensp;등 다양한 기능이 IP 계층 내부에서 일어나게 됨<br/>

&ensp;그 결과:<br/>
* 인터넷 아키텍처의 단순성이 무너지는 방향으로 진화
* 호환성/확장성 문제가 발생
* 프로토콜 설계가 복잡해짐

&ensp;이 때문에 연구자들은 SDN/NFV로 중간 기능을 소프트웨어로 재정비하려는 흐름을 만들었다.<br/>

End-to-End Argument (종단간 논쟁)
====

&ensp;**기능은 네트워크 내부(in-network)보다 끝단(end-to-end)에서 구현하는 것이 더 정확하다**<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-61.png" width="500"></p>

&ensp;두 가지 구현 방식<br/>

1. End-to-end 방식 (TCP처럼) → 인터넷 철학과 일치
* 오류 검사는 송신자 ↔ 수신자만 처리
* 중간 라우터는 건드리지 않음
* 네트워크 내부는 단순
2. Hop-by-hop(in network) 방식 → 인터넷 철학에 위배
* 각 라우터가 매번 오류를 검사하고 처리
* 장비가 복잡해짐
* 비용↑, 유연성↓, 확장 어려움

IP Fragmentation / Reassembly
====

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-62.png" width="500"></p>

&ensp;단편화가 필요한 이유<br/>
&ensp;링크마다 MTU(최대 전송 크기)가 다름<br/>
&ensp;예:<br/>
* Ethernet = 1500 bytes
* 다른 링크 = 1000 bytes

&ensp;큰 IP 패킷이 작은 MTU 링크를 지나가면? → 쪼개서(fragmentation) 여러 개로 나눠야 한다<br/>

&ensp;단편화 과정<br/>
&ensp;예:<br/>
&ensp;4000 byte datagram<br/>
&ensp;MTU = 1500 bytes<br/>

&ensp;IP header = 20 bytes라고 가정하면, 실제 데이터는 1480 bytes까지 넣을 수 있음.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-63.png" width="500"></p>

&ensp;MF (More Fragment bit)<br/>
* 1 = 뒤에 조각이 더 있음
* 0 = 마지막 조각

&ensp;offset 단위는 8 bytes → 그래서 1480/8 = 185<br/>

&ensp;재조립(reassembly)은 하는 곳<br/>
&ensp;**목적지에서만** 중간 라우터에서는 절대 재조립하지 않음.<br/>
* 라우터가 바빠짐
* 라우터가 조각을 저장할 메모리가 부족함
* 지능은 끝단(end-to-end)에 있어야 한다는 철학