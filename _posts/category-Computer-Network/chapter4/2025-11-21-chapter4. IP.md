---
title: "chapter4. IP: the Internet Protocol"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-11-21
last_modified_at: 2025-11-21
---

&ensp;Network Layer<br/>
&ensp;네트워크 계층이란?<br/>
&ensp;네트워크 계층은 인터넷 상에서 데이터를 목적지까지 전달하는 역할을 맡는다.(데이터를 어떻게 보내고 어떤 길을 통해 갈지 결정하는 층이다.)<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-28.png" width="500"></p>

&ensp;네트워크 계층은 크게 두 부분으로 나눈다.<br/>
&ensp;데이터 플레인(Data Plane)<br/>
* 패킷이 실제로 라우터를 통과하는 과정
* 지금 들어온 패킷을 어디로 보낼까? 를 처리
* 라우터의 forwarding table을 사용

&ensp;컨트롤 플레인(Control Plane)<br/>
* 경로를 계산하는 두뇌 역할
* OSPF, BGP 같은 라우팅 알고리즘이 동작
* 어떤 길이 최적인가? 를 결정

&ensp;네트워크 계층의 핵심 기능 두 가지<br/>
1. Routing (경로 선택)
* 목적지까지 가는 전체 경로(Path)를 계산
* 컨트롤 플레인에서 수행
* OSPF, BGP 같은 라우팅 알고리즘 담당
2. Forwarding (포워딩)
* 들어온 패킷을 다음 라우터로 전달
* 데이터 플레인이 수행
* 미리 만들어진 forwarding table을 참고

&ensp;Routing이 길을 만들고, Forwarding이 그 길로 데이터를 보낸다.<br/>

&ensp;IP 프로토콜: 인터넷 패킷의 기본 단위<br/>
&ensp;인터넷에서 오가는 모든 데이터는 IP 패킷(IP Datagram) 형태로 이동합니다.
IP는 다음과 같은 역할을 한다.<br/>
* 패킷의 형식 정의
* 출발지/도착지 주소(IP 주소) 관리
* 패킷이 손상되었는지 확인
* 패킷 전달 규칙 정의

&ensp;보조 프로토콜인 ICMP는<br/>
* 오류 보고(예: 목적지 도달 불가)
* 라우터 간 신호 전달

&ensp;IP Datagram<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-29.png" width="500"></p>

&ensp;IP Datagram은 인터넷에서 실제로 전달되는 패킷이다. 패킷을 택배 상자로 비유하면 이해가 쉽다.<br/>
* 상자 겉면 = 헤더(Header)
* 상자 내용물 = 데이터(payload)
* 상자에 붙은 주소 = IP 주소

&ensp;IP Datagram 구조<br/>
&ensp;Version (버전): IPv4인지 IPv6인지 표시<br/>
&ensp;Header Length: 헤더 크기 (기본 20바이트)<br/>
&ensp;Type of Service (서비스 유형): 우편에서의 "빠른 등기", "취급주의"와 같은 옵션 느낌, DiffServ, ECN 등 QoS 관련 기능<br/>
&ensp;Total Length: 패킷 전체 길이 (헤더 + 데이터)<br/>
&ensp;Identification / Flags / Fragment Offset: 패킷이 너무 커서 "조각(Fragment)"으로 나뉘어 전송될 때 사용, 목적지에서 조각을 다시 조립(Reassembly)<br/>
&ensp;TTL (Time To Live): 패킷이 지나갈 수 있는 최대 라우터 수, 값이 0이 되면 폐기 → 무한 루프 방지<br/>
&ensp;Protocol: 상위 계층 프로토콜(TCP/UDP)을 지정(이 패킷 안에 들어있는 데이터가 TCP인지 UDP인지 구분)<br/>
&ensp;Header Checksum: 헤더가 손상되었는지 검사<br/>
&ensp;Source / Destination IP Address: 출발지 / 도착지 주소<br/>
&ensp;Options: 거의 사용되지 않음 (경로 기록 같은 특수 기능)<br/>
&ensp;Payload: 실제 데이터 (TCP/UDP 세그먼트)<br/>

&ensp;전체 동작 흐름<br/>
1. 애플리케이션이 데이터를 생성
2. TCP/UDP가 세그먼트를 만들고
3. IP가 IP Datagram을 만들어 주소 작성
4. 우터는 forwarding table을 보고 패킷을 다음 경로로 전달
5. 문제 발생 시 ICMP가 오류를 전달

IP Address
=====

# IP Address

* 32 비트 숫자로 표현되는 인터넷 상의 집 주소
* 컴퓨터, 스마트폰, 라우터 등 네트워크에 연결된 모든 장비는 고유한 IP 주소를 가짐

```
223.1.1.1
223.1.1.2
223.1.3.1
```

&ensp;dotted-decimal 표기법<br/>
&ensp;IP는 사실 32비트 이진수지만 사람이 보기 쉽도록 223.1.1.1 처럼 4개의 숫자로 나눠 표기한다.<br/>

&ensp;예시<br/>
```
223.1.1.1 = 11011111 00000001 00000001 00000001
```

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-30.png" width="500"></p>

# Interface

* 호스트(PC/노트북/스마트폰) 또는 라우터가 네트워크와 연결되는 물리적 연결 지점
* 즉, 네트워크 케이블을 꽂는 자리, 와이파이 카드 등이 바로 인터페이스

&ensp;특징<br/>
* 라우터는 여러 네트워크와 연결되므로 인터페이스가 여러 개
* 보통 PC, 노트북은 인터페이스가 1~2개 (유선 LAN 1개 + 무선 WiFi 1개)

&ensp;따라서 라우터의 각 인터페이스마다 IP 주소가 따로 존재한다.<br/>

&ensp;인터페이스는 실제로 어떻게 연결될까?<br/>
&ensp;유선 인터페이스(wired)<br/>
* Ethernet 케이블로 연결
* 중간에는 **스위치(switch)**가 있음 (스위치는 같은 네트워크 안에서 기기들을 연결해주는 장비)

&ensp;무선 인터페이스(wireless)<br/>
* **WiFi 베이스 스테이션(무선 공유기)**를 통해 연결

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-31.png" width="500"></p>

* 왼쪽: 같은 교실에서 여러 PC가 유선으로 스위치에 연결됨
* 오른쪽 위: 또 다른 그룹이 유선 연결
* 아래쪽: WiFi로 연결된 그룹

&ensp;이렇게 하나의 라우터가 여러 네트워크를 연결하고 있기 때문에 각 네트워크는 서로 독립적인 공간처럼 동작한다.<br/>

# Subnet(서브넷)

&ensp;Subnet(서브넷)의 정의: 라우터를 거치지 않고 서로 통신할 수 있는 장치들의 집합<br/>

* 같은 스위치에 연결된 PC들
* 같은 WiFi AP에 연결된 장치들

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-32.png" width="500"></p>

&ensp;그림에서 3개의 서브넷이 표시됨:<br/>
1. 223.1.1.x
2. 223.1.2.x
3. 223.1.3.x

&ensp;각 영역의 PC들은 서로 직접 통신할 수 있지만 다른 영역과 통신하려면 반드시 라우터를 거쳐야 한다.<br/>

&ensp;IP 주소는 "서브넷 + 호스트" 구조로 이루어진다<br/>
&ensp;IP 주소는 단순히 네 자리 숫자가 아니라 내부적으로 두 부분으로 나뉜다.<br/>
1. 서브넷 부분(subnet part)
* 같은 서브넷에 속한 장비들은 IP 주소의 앞부분이 동일하다. (공통된 high-order bits)
* 예) 223.1.1.1, 223.1.1.2, 223.1.1.3 → 모두 같은 서브넷 223.1.1.x
2. 호스트 부분(host part)
* 서브넷 안에서 개별 장비를 구분하는 부분 (low-order bits)
* 예) 223.1.1.**1**, 223.1.1.**2**, 223.1.1.**3**

&ensp;전체 흐름 요약<br/>
* IP 주소는 인터넷 상의 주소
* 인터페이스는 장비가 네트워크와 연결되는 지점
* 라우터는 인터페이스를 여러 개 가지고 있다
* 서브넷은 라우터 없이 서로 통신 가능한 장비들의 묶음
* IP는 "서브넷 부분 + 호스트 부분" 구조로 구성된다

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-33.png" width="500"></p>

&ensp;모든 인터페이스(PC, 라우터 포트)를 떼어서 생각하면 각각이 고립된 섬(island) 처럼 보인다. 즉 라우터 없이 직접 연결된 기기들의 집합이 서브넷.<br/>
&ensp;이렇게 물리적으로 같은 네트워크에 있고 라우터 없이 연결된 그룹 하나가 서브넷이다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-34.png" width="500"></p>

&ensp;그림에서 파란색으로 칠해진 하나의 물리 네트워크가 각각 서브넷<br/>
&ensp;각 서브넷의 주소 앞 세 옥텟(a.b.c)이 공통이므로 a.b.c.0/24 가 서브넷 주소가 된다.<br/>

CIDR(Classless InterDomain Routing)
=====

&ensp;CIDR가 나온 이유<br/>
&ensp;옛날에는 IP 주소를 A/B/C Class라는 정해진 크기 단위로 나눴다.<br/>
&ensp;예: Class A → /8, Class B → /16, Class C → /24  → 그런데 이 방식에는 치명적인 문제가 있다.<br/>

&ensp;문제 1 — IP 주소 낭비 심함<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-35.png" width="500"></p>

&ensp;예를 들어<br/>
* 회사가 200개 호스트만 필요해도 Class C는 254개 가능 / Class B는 65,534개 가능

&ensp;중간 크기가 없음 → 필요한 만큼 딱 맞게 쓸 수 없음.<br/>

&ensp;문제 2 — 인터넷 라우팅 테이블 폭발<br/>
&ensp;많은 네트워크를 Class 단위로 등록해야 해서 전 세계 라우터의 라우팅 테이블 크기가 폭발적으로 증가<br/>

&ensp;CIDR는 무엇을 해결하나?<br/>
&ensp;CIDR는 주소 블록을 임의 길이로 나눌 수 있게 만든 방식이다.<br/>

&ensp;CIDR 표기 방식<br/>
```bash
a.b.c.d/x
```

&ensp;여기서 x = 서브넷 부분의 비트 수<br/>
* /8 → 앞 8비트가 서브넷
* /16 → 앞 16비트가 서브넷
* /24 → 앞 24비트가 서브넷
* /23 → 앞 23비트가 서브넷
* /29 → 앞 29비트가 서브넷

&ensp;CIDR의 핵심 개념<br/>
&ensp;서브넷 부분 = 네트워크를 구분하는 비트<br/>
&ensp;호스트 부분 = 서브넷 안에서 개별 장비를 구분하는 비트<br/>
&ensp;비트가 많아질수록 → 서브넷이 더 많이 생김<br/>
&ensp;비트가 적어질수록 → 한 서브넷 안에 호스트를 많이 만들 수 있음<br/>

DHCP
-----

&ensp;DHCP는 네트워크에 접속한 기기에 자동으로 IP 주소를 배정하는 프로토콜이다.<br/>
&ensp;DHCP는 lease(임대) 개념을 갖고 있어서 기기가 끄면 IP를 회수하고 다른 기기가 그 주소를 다시 쓸 수 있다. 그래서 주소가 절약되고 관리가 쉬워진다.<br/>

&ensp;DHCP server 위치 & 시나리오<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-36.png" width="500"></p>

&ensp;DHCP는 서버는 보통 라우터 안에 내장돼 있다.<br/>
&ensp;우리가 흔히 집에서 쓰는 공유기 속에 DHCP 서버가 들어있어서기기가 "와이파이에 접속"하면 바로 IP를 준다.<br/>

&ensp;클라이언트는 새로 네트워크에 들어오면 DHCP가 그 네트워크 안에서 사용할 IP를 배정한다.<br/>
* 노트북 켜기 → 와이파이에 접속 → DHCP가 IP 줌
* 스마트폰 연결 → DHCP가 또 IP 줌

&ensp;DHCP 메시지 흐름(4-way handshake)<br/>
&ensp;DHCP의 기본 동작 4단계 (DORA)<br/>
```scss
D – Discover (누구 없어요?)
O – Offer (여기 주소 있어요)
R – Request (저 그 주소 쓸게요)
A – ACK (네, 쓰세요)
```

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-37.png" width="500"></p>

&ensp;왜 모두 Broadcast인가?<br/>
* 아직 IP 주소가 없다 → 누구에게 보내야 할지 모른다
* 그래서 모든 장비에게 브로드캐스트로 요청함

&ensp;DHCP는 IP만 주는 게 아니다<br/>
&ensp;DHCP는 IP 주소뿐 아니라 네트워크 설정 전체를 알려준다.<br/>
&ensp;DHCP가 클라이언트에게 주는 정보:<br/>
1. IP 주소
2. 게이트웨이(First-hop router) 주소 → 패킷이 처음으로 보내지는 라우터
3. DNS 서버 주소 → google.com 같은 도메인을 IP로 바꿔주기 위해 필요
4. 서브넷 마스크 → 네트워크/호스트 비트 구분

&ensp;DHCP는 PC가 "네트워크에서 제대로 동작하는 데 필요한 모든 정보"를 자동으로 준다.<br/>

&ensp;DHCP 패킷이 네트워크에서 실제로 움직이는 방식<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-38.png" width="500"></p>

&ensp;DHCP 메시지가 네트워크에서 보내질 때:<br/>
* DHCP 메시지는 UDP로 보내짐
* UDP는 IP 안에 들어감
* IP는 이더넷 프레임 안에 들어감 → 즉, DHCP → UDP → IP → Ethernet 순으로 캡슐화됨

&ensp;초기 DHCP 메시지는 목적지 MAC 주소가 FF:FF:FF:FF:FF:FF (Broadcast)<br/>
* 클라이언트는 아직 router MAC도 모름
* DHCP 서버 MAC 주소도 모름

&ensp;그래서 LAN 전체에 뿌리는 형태로 시작된다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-39.png" width="500"></p>
&ensp;마지막 단계<br/>
&ensp;DHCP ACK를 받고 나면<br/>

* 클라이언트는 자신의 IP를 알게 되고
* DNS 서버 IP
* 서브넷 마스크
* 게이트웨이 주소

&ensp;까지 모두 갖추게 된다. 이제 완전히 정상적인 호스트가 된다.<br/>

네트워크는 IP 주소를 받는 과정
====

&ensp;개별 회사(조직)들은 ISP(인터넷 서비스 제공자)에게서 주소 블록을 할당받는다. ISP도 더 큰 주소 블록을 상위 기관에서 할당받는다.<br/>

&ensp;IP주소는 아래처럼 위계적(hierarchical) 구조로 분배된다.<br/>

&ensp;구조<br/>
&ensp;ICANN → 지역 레지스트리(RIR) → ISP → 기업/학교/기관 → 개별 호스트(DHCP)<br/>

# 계층적 주소(Hierarchical addressing) & route aggregation

&ensp;계층적 주소 구조는 라우팅 테이블을 작게 만든다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-40.png" width="500"></p>

&ensp;예시 상황<br/>
```bash
200.23.16.0/23  
200.23.18.0/23  
200.23.20.0/23  
...  
```

&ensp;이렇게 주소를 할당받았다고 가정<br/>
1. 이 회사들은 모두 **같은 ISP(Fly-By-Night-ISP)**에 연결됨.
2. ISP는 이 범위들을 하나의 큰 블록으로 묶어서 인터넷에 광고함: 200.23.16.0/20 → 이걸 **route aggregation(라우트 집약)**이라고 부른다.

&ensp;장점<br/>
* 인터넷의 다른 라우터들은 "200.23.16.0/20으로 시작하는 주소는 이 ISP로 보내면 된다" 라고만 기억하면 됨
* 개별 회사 주소 하나하나를 라우팅 테이블에 넣지 않아도 됨

&ensp;이게 바로 계층적 주소 구조가 효율적인 이유이다.<br/>

&ensp;조직이 ISP를 옮기면 어떻게 되나?<br/>
&ensp;더 구체적인(prefix가 긴) 라우트가 우선한다.<br/>
&ensp;원래<br/>
* Organization 1: 200.23.18.0/23
* ISP A(Fly-By-Night)가 이 회사를 담당
* 인터넷에는 "200.23.16.0/20은 ISP A로 가라" 가 광고됨

&ensp;그런데 Organization 1이 ISP B로 이동하면?<br/>
&ensp;ISP B는 이렇게 말함:<br/>
```
200.23.18.0/23은 우리에게 보내라
```

&ensp;그리고 라우터는<br/>
* /20보다
* /23이 더 구체적 (specific) 이라는 사실을 알고 있음

&ensp;그래서 트래픽은 ISP B로 감. 이게 Longest Prefix Match(가장 긴 prefix 매칭) 원리<br/>

&ensp;ICANN과 IPv4 고갈 문제<br/>
&ensp;ISP는 어떻게 IP 주소 블록을 받는가? → ICANN이 전 세계 IP 주소를 관리하며 5개의 지역 레지스트리(RIR)에 블록을 나눠준다. 지역 레지스트리는 이를 다시 국가/ISP에게 배분한다.<br/>
&ensp;32-bit IPv4 주소는 충분한가? → 이미 부족함, 2011년에 ICANN이 IPv4 주소 최종 블록을 모두 할당함 그래서 NAT가 주소 절약을 도와줌, IPv6는 128비트라 주소가 사실상 무한