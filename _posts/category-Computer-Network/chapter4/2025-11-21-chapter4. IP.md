---
title: "chapter4. IP: the Internet Protocol"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-11-21
last_modified_at: 2025-11-25
---

&ensp;Network Layer<br/>
&ensp;네트워크 계층이란?<br/>
&ensp;네트워크 계층은 인터넷 상에서 데이터를 목적지까지 전달하는 역할을 맡는다.(데이터를 어떻게 보내고 어떤 길을 통해 갈지 결정하는 층이다.)<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-28.png" width="500"></p>

&ensp;네트워크 계층은 크게 두 부분으로 나눈다.<br/>
&ensp;데이터 플레인(Data Plane)<br/>
* 패킷이 실제로 라우터를 통과하는 과정
* 지금 들어온 패킷을 어디로 보낼까? 를 처리
* 라우터의 forwarding table을 사용

&ensp;컨트롤 플레인(Control Plane)<br/>
* 경로를 계산하는 두뇌 역할
* OSPF, BGP 같은 라우팅 알고리즘이 동작
* 어떤 길이 최적인가? 를 결정

&ensp;네트워크 계층의 핵심 기능 두 가지<br/>
1. Routing (경로 선택)
* 목적지까지 가는 전체 경로(Path)를 계산
* 컨트롤 플레인에서 수행
* OSPF, BGP 같은 라우팅 알고리즘 담당
2. Forwarding (포워딩)
* 들어온 패킷을 다음 라우터로 전달
* 데이터 플레인이 수행
* 미리 만들어진 forwarding table을 참고

&ensp;Routing이 길을 만들고, Forwarding이 그 길로 데이터를 보낸다.<br/>

&ensp;IP 프로토콜: 인터넷 패킷의 기본 단위<br/>
&ensp;인터넷에서 오가는 모든 데이터는 IP 패킷(IP Datagram) 형태로 이동합니다.
IP는 다음과 같은 역할을 한다.<br/>
* 패킷의 형식 정의
* 출발지/도착지 주소(IP 주소) 관리
* 패킷이 손상되었는지 확인
* 패킷 전달 규칙 정의

&ensp;보조 프로토콜인 ICMP는<br/>
* 오류 보고(예: 목적지 도달 불가)
* 라우터 간 신호 전달

&ensp;IP Datagram<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-29.png" width="500"></p>

&ensp;IP Datagram은 인터넷에서 실제로 전달되는 패킷이다. 패킷을 택배 상자로 비유하면 이해가 쉽다.<br/>
* 상자 겉면 = 헤더(Header)
* 상자 내용물 = 데이터(payload)
* 상자에 붙은 주소 = IP 주소

&ensp;IP Datagram 구조<br/>
&ensp;Version (버전): IPv4인지 IPv6인지 표시<br/>
&ensp;Header Length: 헤더 크기 (기본 20바이트)<br/>
&ensp;Type of Service (서비스 유형): 우편에서의 "빠른 등기", "취급주의"와 같은 옵션 느낌, DiffServ, ECN 등 QoS 관련 기능<br/>
&ensp;Total Length: 패킷 전체 길이 (헤더 + 데이터)<br/>
&ensp;Identification / Flags / Fragment Offset: 패킷이 너무 커서 "조각(Fragment)"으로 나뉘어 전송될 때 사용, 목적지에서 조각을 다시 조립(Reassembly)<br/>
&ensp;TTL (Time To Live): 패킷이 지나갈 수 있는 최대 라우터 수, 값이 0이 되면 폐기 → 무한 루프 방지<br/>
&ensp;Protocol: 상위 계층 프로토콜(TCP/UDP)을 지정(이 패킷 안에 들어있는 데이터가 TCP인지 UDP인지 구분)<br/>
&ensp;Header Checksum: 헤더가 손상되었는지 검사<br/>
&ensp;Source / Destination IP Address: 출발지 / 도착지 주소<br/>
&ensp;Options: 거의 사용되지 않음 (경로 기록 같은 특수 기능)<br/>
&ensp;Payload: 실제 데이터 (TCP/UDP 세그먼트)<br/>

&ensp;전체 동작 흐름<br/>
1. 애플리케이션이 데이터를 생성
2. TCP/UDP가 세그먼트를 만들고
3. IP가 IP Datagram을 만들어 주소 작성
4. 우터는 forwarding table을 보고 패킷을 다음 경로로 전달
5. 문제 발생 시 ICMP가 오류를 전달

IP Address
=====

# IP Address

* 32 비트 숫자로 표현되는 인터넷 상의 집 주소
* 컴퓨터, 스마트폰, 라우터 등 네트워크에 연결된 모든 장비는 고유한 IP 주소를 가짐

```
223.1.1.1
223.1.1.2
223.1.3.1
```

&ensp;dotted-decimal 표기법<br/>
&ensp;IP는 사실 32비트 이진수지만 사람이 보기 쉽도록 223.1.1.1 처럼 4개의 숫자로 나눠 표기한다.<br/>

&ensp;예시<br/>
```
223.1.1.1 = 11011111 00000001 00000001 00000001
```

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-30.png" width="500"></p>

# Interface

* 호스트(PC/노트북/스마트폰) 또는 라우터가 네트워크와 연결되는 물리적 연결 지점
* 즉, 네트워크 케이블을 꽂는 자리, 와이파이 카드 등이 바로 인터페이스

&ensp;특징<br/>
* 라우터는 여러 네트워크와 연결되므로 인터페이스가 여러 개
* 보통 PC, 노트북은 인터페이스가 1~2개 (유선 LAN 1개 + 무선 WiFi 1개)

&ensp;따라서 라우터의 각 인터페이스마다 IP 주소가 따로 존재한다.<br/>

&ensp;인터페이스는 실제로 어떻게 연결될까?<br/>
&ensp;유선 인터페이스(wired)<br/>
* Ethernet 케이블로 연결
* 중간에는 **스위치(switch)**가 있음 (스위치는 같은 네트워크 안에서 기기들을 연결해주는 장비)

&ensp;무선 인터페이스(wireless)<br/>
* **WiFi 베이스 스테이션(무선 공유기)**를 통해 연결

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-31.png" width="500"></p>

* 왼쪽: 같은 교실에서 여러 PC가 유선으로 스위치에 연결됨
* 오른쪽 위: 또 다른 그룹이 유선 연결
* 아래쪽: WiFi로 연결된 그룹

&ensp;이렇게 하나의 라우터가 여러 네트워크를 연결하고 있기 때문에 각 네트워크는 서로 독립적인 공간처럼 동작한다.<br/>

# Subnet(서브넷)

&ensp;Subnet(서브넷)의 정의: 라우터를 거치지 않고 서로 통신할 수 있는 장치들의 집합<br/>

* 같은 스위치에 연결된 PC들
* 같은 WiFi AP에 연결된 장치들

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-32.png" width="500"></p>

&ensp;그림에서 3개의 서브넷이 표시됨:<br/>
1. 223.1.1.x
2. 223.1.2.x
3. 223.1.3.x

&ensp;각 영역의 PC들은 서로 직접 통신할 수 있지만 다른 영역과 통신하려면 반드시 라우터를 거쳐야 한다.<br/>

&ensp;IP 주소는 "서브넷 + 호스트" 구조로 이루어진다<br/>
&ensp;IP 주소는 단순히 네 자리 숫자가 아니라 내부적으로 두 부분으로 나뉜다.<br/>
1. 서브넷 부분(subnet part)
* 같은 서브넷에 속한 장비들은 IP 주소의 앞부분이 동일하다. (공통된 high-order bits)
* 예) 223.1.1.1, 223.1.1.2, 223.1.1.3 → 모두 같은 서브넷 223.1.1.x
2. 호스트 부분(host part)
* 서브넷 안에서 개별 장비를 구분하는 부분 (low-order bits)
* 예) 223.1.1.**1**, 223.1.1.**2**, 223.1.1.**3**

&ensp;전체 흐름 요약<br/>
* IP 주소는 인터넷 상의 주소
* 인터페이스는 장비가 네트워크와 연결되는 지점
* 라우터는 인터페이스를 여러 개 가지고 있다
* 서브넷은 라우터 없이 서로 통신 가능한 장비들의 묶음
* IP는 "서브넷 부분 + 호스트 부분" 구조로 구성된다

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-33.png" width="500"></p>

&ensp;모든 인터페이스(PC, 라우터 포트)를 떼어서 생각하면 각각이 고립된 섬(island) 처럼 보인다. 즉 라우터 없이 직접 연결된 기기들의 집합이 서브넷.<br/>
&ensp;이렇게 물리적으로 같은 네트워크에 있고 라우터 없이 연결된 그룹 하나가 서브넷이다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-34.png" width="500"></p>

&ensp;그림에서 파란색으로 칠해진 하나의 물리 네트워크가 각각 서브넷<br/>
&ensp;각 서브넷의 주소 앞 세 옥텟(a.b.c)이 공통이므로 a.b.c.0/24 가 서브넷 주소가 된다.<br/>

CIDR(Classless InterDomain Routing)
=====

&ensp;CIDR가 나온 이유<br/>
&ensp;옛날에는 IP 주소를 A/B/C Class라는 정해진 크기 단위로 나눴다.<br/>
&ensp;예: Class A → /8, Class B → /16, Class C → /24  → 그런데 이 방식에는 치명적인 문제가 있다.<br/>

&ensp;문제 1 — IP 주소 낭비 심함<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-35.png" width="500"></p>

&ensp;예를 들어<br/>
* 회사가 200개 호스트만 필요해도 Class C는 254개 가능 / Class B는 65,534개 가능

&ensp;중간 크기가 없음 → 필요한 만큼 딱 맞게 쓸 수 없음.<br/>

&ensp;문제 2 — 인터넷 라우팅 테이블 폭발<br/>
&ensp;많은 네트워크를 Class 단위로 등록해야 해서 전 세계 라우터의 라우팅 테이블 크기가 폭발적으로 증가<br/>

&ensp;CIDR는 무엇을 해결하나?<br/>
&ensp;CIDR는 주소 블록을 임의 길이로 나눌 수 있게 만든 방식이다.<br/>

&ensp;CIDR 표기 방식<br/>
```bash
a.b.c.d/x
```

&ensp;여기서 x = 서브넷 부분의 비트 수<br/>
* /8 → 앞 8비트가 서브넷
* /16 → 앞 16비트가 서브넷
* /24 → 앞 24비트가 서브넷
* /23 → 앞 23비트가 서브넷
* /29 → 앞 29비트가 서브넷

&ensp;CIDR의 핵심 개념<br/>
&ensp;서브넷 부분 = 네트워크를 구분하는 비트<br/>
&ensp;호스트 부분 = 서브넷 안에서 개별 장비를 구분하는 비트<br/>
&ensp;비트가 많아질수록 → 서브넷이 더 많이 생김<br/>
&ensp;비트가 적어질수록 → 한 서브넷 안에 호스트를 많이 만들 수 있음<br/>

DHCP
-----

&ensp;DHCP는 네트워크에 접속한 기기에 자동으로 IP 주소를 배정하는 프로토콜이다.<br/>
&ensp;DHCP는 lease(임대) 개념을 갖고 있어서 기기가 끄면 IP를 회수하고 다른 기기가 그 주소를 다시 쓸 수 있다. 그래서 주소가 절약되고 관리가 쉬워진다.<br/>

&ensp;DHCP server 위치 & 시나리오<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-36.png" width="500"></p>

&ensp;DHCP는 서버는 보통 라우터 안에 내장돼 있다.<br/>
&ensp;우리가 흔히 집에서 쓰는 공유기 속에 DHCP 서버가 들어있어서기기가 "와이파이에 접속"하면 바로 IP를 준다.<br/>

&ensp;클라이언트는 새로 네트워크에 들어오면 DHCP가 그 네트워크 안에서 사용할 IP를 배정한다.<br/>
* 노트북 켜기 → 와이파이에 접속 → DHCP가 IP 줌
* 스마트폰 연결 → DHCP가 또 IP 줌

&ensp;DHCP 메시지 흐름(4-way handshake)<br/>
&ensp;DHCP의 기본 동작 4단계 (DORA)<br/>
```scss
D – Discover (누구 없어요?)
O – Offer (여기 주소 있어요)
R – Request (저 그 주소 쓸게요)
A – ACK (네, 쓰세요)
```

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-37.png" width="500"></p>

&ensp;왜 모두 Broadcast인가?<br/>
* 아직 IP 주소가 없다 → 누구에게 보내야 할지 모른다
* 그래서 모든 장비에게 브로드캐스트로 요청함

&ensp;DHCP는 IP만 주는 게 아니다<br/>
&ensp;DHCP는 IP 주소뿐 아니라 네트워크 설정 전체를 알려준다.<br/>
&ensp;DHCP가 클라이언트에게 주는 정보:<br/>
1. IP 주소
2. 게이트웨이(First-hop router) 주소 → 패킷이 처음으로 보내지는 라우터
3. DNS 서버 주소 → google.com 같은 도메인을 IP로 바꿔주기 위해 필요
4. 서브넷 마스크 → 네트워크/호스트 비트 구분

&ensp;DHCP는 PC가 "네트워크에서 제대로 동작하는 데 필요한 모든 정보"를 자동으로 준다.<br/>

&ensp;DHCP 패킷이 네트워크에서 실제로 움직이는 방식<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-38.png" width="500"></p>

&ensp;DHCP 메시지가 네트워크에서 보내질 때:<br/>
* DHCP 메시지는 UDP로 보내짐
* UDP는 IP 안에 들어감
* IP는 이더넷 프레임 안에 들어감 → 즉, DHCP → UDP → IP → Ethernet 순으로 캡슐화됨

&ensp;초기 DHCP 메시지는 목적지 MAC 주소가 FF:FF:FF:FF:FF:FF (Broadcast)<br/>
* 클라이언트는 아직 router MAC도 모름
* DHCP 서버 MAC 주소도 모름

&ensp;그래서 LAN 전체에 뿌리는 형태로 시작된다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-39.png" width="500"></p>
&ensp;마지막 단계<br/>
&ensp;DHCP ACK를 받고 나면<br/>

* 클라이언트는 자신의 IP를 알게 되고
* DNS 서버 IP
* 서브넷 마스크
* 게이트웨이 주소

&ensp;까지 모두 갖추게 된다. 이제 완전히 정상적인 호스트가 된다.<br/>

네트워크는 IP 주소를 받는 과정
====

&ensp;개별 회사(조직)들은 ISP(인터넷 서비스 제공자)에게서 주소 블록을 할당받는다. ISP도 더 큰 주소 블록을 상위 기관에서 할당받는다.<br/>

&ensp;IP주소는 아래처럼 위계적(hierarchical) 구조로 분배된다.<br/>

&ensp;구조<br/>
&ensp;ICANN → 지역 레지스트리(RIR) → ISP → 기업/학교/기관 → 개별 호스트(DHCP)<br/>

# 계층적 주소(Hierarchical addressing) & route aggregation

&ensp;계층적 주소 구조는 라우팅 테이블을 작게 만든다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-40.png" width="500"></p>

&ensp;예시 상황<br/>
```bash
200.23.16.0/23  
200.23.18.0/23  
200.23.20.0/23  
...  
```

&ensp;이렇게 주소를 할당받았다고 가정<br/>
1. 이 회사들은 모두 **같은 ISP(Fly-By-Night-ISP)**에 연결됨.
2. ISP는 이 범위들을 하나의 큰 블록으로 묶어서 인터넷에 광고함: 200.23.16.0/20 → 이걸 **route aggregation(라우트 집약)**이라고 부른다.

&ensp;장점<br/>
* 인터넷의 다른 라우터들은 "200.23.16.0/20으로 시작하는 주소는 이 ISP로 보내면 된다" 라고만 기억하면 됨
* 개별 회사 주소 하나하나를 라우팅 테이블에 넣지 않아도 됨

&ensp;이게 바로 계층적 주소 구조가 효율적인 이유이다.<br/>

&ensp;조직이 ISP를 옮기면 어떻게 되나?<br/>
&ensp;더 구체적인(prefix가 긴) 라우트가 우선한다.<br/>
&ensp;원래<br/>
* Organization 1: 200.23.18.0/23
* ISP A(Fly-By-Night)가 이 회사를 담당
* 인터넷에는 "200.23.16.0/20은 ISP A로 가라" 가 광고됨

&ensp;그런데 Organization 1이 ISP B로 이동하면?<br/>
&ensp;ISP B는 이렇게 말함:<br/>
```
200.23.18.0/23은 우리에게 보내라
```

&ensp;그리고 라우터는<br/>
* /20보다
* /23이 더 구체적 (specific) 이라는 사실을 알고 있음

&ensp;그래서 트래픽은 ISP B로 감. 이게 Longest Prefix Match(가장 긴 prefix 매칭) 원리<br/>

&ensp;ICANN과 IPv4 고갈 문제<br/>
&ensp;ISP는 어떻게 IP 주소 블록을 받는가? → ICANN이 전 세계 IP 주소를 관리하며 5개의 지역 레지스트리(RIR)에 블록을 나눠준다. 지역 레지스트리는 이를 다시 국가/ISP에게 배분한다.<br/>
&ensp;32-bit IPv4 주소는 충분한가? → 이미 부족함, 2011년에 ICANN이 IPv4 주소 최종 블록을 모두 할당함 그래서 NAT가 주소 절약을 도와줌, IPv6는 128비트라 주소가 사실상 무한

NAT: network address translation
=====

&ensp;<b>1. NAT란 무엇인가?</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-41.png" width="500"></p>

&ensp;NAT = 여러 기기가 '하나의 공용 IP 주소'를 공유하도록 해주는 기술<br/>
* 집에 노트북, 스마트폰, 태블릿 여러 개 있다.
* 그런데 인터넷 제공업체(ISP)는 보통 "공용 IP 하나"만 준다.
* 그럼 기기마다 인터넷에 나갈 때 서로 다른 IP를 어떻게 갖게 할까?

&ensp;NAT가 내부 IP를 외부 IP 하나로 바꿔서 내보내기 때문에 가능함!<br/>

&ensp;외부에서 볼 때<br/>
* 집 안의 기기들은 전부 138.76.29.7(예시) 하나의 IP에서 오는 것처럼 보임
* 내부에서는 각 기기가 10.0.0.x 같은 사설 IP를 가짐

&ensp;<b>2. NAT 동작 핵심 요약</b><br/>
&ensp;내부 네트워크(사설망)<br/>
* 예: 10.0.0.0/24 → 10.0.0.1, 10.0.0.2, 10.0.0.3 …

&ensp;외부 네트워크(공인망)<br/>
* ISP가 제공한 공인 IP: 138.76.29.7

&ensp;NAT의 핵심 역할<br/>
1. 내부 → 외부
* 출발지 IP 주소를 내부(10.0.0.x) → 공인(138.76.29.7)으로 바꿈
* 대신 포트 번호를 각각 다르게 부여
2. 외부 → 내부
* NAT 테이블을 보고 "이 포트는 내부의 누구였지?" 확인
* 다시 내부 IP로 바꿔서 전달

&ensp;NAT는 주소 변환기 + 전화 교환기 같은 역할<br/>

&ensp;<b>3. NAT의 장점</b><br/>
1) 공인 IP를 하나만 받아도 됨 → IPv4 주소 부족 해결에 크게 기여
2) 내부 기기 주소는 외부에 공개되지 않음 → 보안 ↑
3) ISP를 바꿔도 내부 IP 체계는 바꿀 필요 없음
4) 내부 IP 구조를 마음대로 바꿀 수 있음 → 외부에 알려줄 필요 없음

&ensp;<b>4. NAT 구현 방식</b><br/>
&ensp;NAT 라우터가 해야 하는 3가지 작업<br/>

&ensp;1) 외부로 나가는 패킷 (Outgoing datagrams)<br/>
&ensp;**출발지 IP와 포트를 공인 IP + 새 포트로 바꾼다.**<br/>

&ensp;예: 원래: S: 10.0.0.1, 3345, 변환: S: 138.76.29.7, 5001<br/>

&ensp;2) NAT 변환 테이블에 저장<br/>
```nginx
WAN IP, port     LAN IP, port
138.76.29.7,5001   ←→   10.0.0.1,3345
```

&ensp;3) 들어오는 패킷 (Incoming datagrams)<br/>
&ensp;**목적지 IP와 포트를 내부 주소로 다시 바꾼다.**<br/>

&ensp;예: 원래: D: 138.76.29.7, 5001, 변환: D: 10.0.0.1, 3345<br/>

&ensp;<b>5. NAT 동작 예제</b><br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-42.png" width="500"></p>

&ensp;단계별로 쉽게 설명<br/>
&ensp;1. 내부 PC(10.0.0.1)가 웹 서버(128.119.40.186:80)에 요청<br/>
&ensp;패킷:<br/>
* 출발지 S = 10.0.0.1, 3345
* 목적지 D = 128.119.40.186, 80

&ensp;2. NAT 라우터가 패킷 변환<br/>
* S를 공인 IP로 변경 → S: 138.76.29.7, 5001
* NAT 테이블에 기록 `138.76.29.7:5001 ←→ 10.0.0.1:3345`

&ensp;3. 서버가 응답을 보냄<br/>
* D: 138.76.29.7, 5001

&ensp;4. NAT 라우터가 다시 내부 IP로 변환해 전달<br/>
* D: 10.0.0.1, 3345 → 정확한 PC에 전달됨

&ensp;<b>6. NAT 논란과 문제점</b><br/>
&ensp;라우터는 원래 3계층까지만 처리해야 하는데 → NAT는 포트 번호(4계층)까지 만짐<br/>
&ensp;IPv6가 나오면 사실 NAT 필요 없음 → 주소 부족 문제 완전 해결됨<br/>
&ensp;End-to-End 원칙 위반 → 원래는 두 호스트끼리 직접 주소/IP로 통신해야 하는데
NAT가 중간에서 주소를 바꾸니까 원칙 깨짐<br/>
&ensp;NAT Traversal 문제 → 외부에서 내부로 연결하기 어려움 (예: 게임 서버, 화상채팅, P2P 등)<br/>

IPv6
=====

&ensp;<b>1. 주소 고갈 문제 해결(Initial Motivation)</b><br/>
&ensp;IPv4 주소는 32비트 → 약 43억 개. 인터넷 초창기에는 이 정도면 충분하겠지?라고 생각했다.<br/>
&ensp;하지만 스마트폰, IoT, PC, 서버, 클라우드까지 폭발하면서 43억 개가 금방 소진됐다.<br/>
&ensp;그래서 더 큰 주소 공간이 필요했다 → IPv6 = 128비트 주소<br/>

* 2¹²⁸ = 약 3.4 × 10³⁸ 개

&ensp;<b>2. 라우터 처리 속도 개선 (Additional Motivation)</b><br/>
&ensp;IPv4헤더는 길이가 가변적(vaiable)이었다. 옵션 필드가 있어서 처리하기 불편했고 느렸다. IPv6는 헤더를 **40바이트 고정 길이**로 통일했다.<br/>

&ensp;장점<br/>
* 하드웨어 라우터가 더 빨리 처리 가능
* 네트워크가 튼튼해지고 성능도 좋아짐

&ensp;<b>3. Flow 기반 서비스 지원</b><br/>
&ensp;IPv6에는 “flow label”이라는 필드가 있다.<br/>
&ensp;flow = 같은 스트림의 패킷을 식별하는 개념(예: Youtube 영상 스트림, 화상통화 스트임 같은 것들)<br/>
&ensp;특정 스트림에 우선순위 or QoS 적용 가능<br/>

IPv6 Datagram Format (헤더 구조)
-----

&ensp;IPv6 헤더의 주요 필드<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-43.png" width="500"></p>

| 필드                   | 설명                   |
| -------------------- | -------------------- |
| **ver**              | IPv 버전(6)            |
| **pri (priority)**   | 같은 flow 안에서 패킷 우선순위  |
| **flow label**       | 같은 흐름(flow)의 패킷인지 식별 |
| **payload length**   | 데이터 길이               |
| **next header**      | 상위 계층 프로토콜(TCP/UDP…) |
| **hop limit**        | IPv4의 TTL과 동일        |
| **source addr**      | 128비트 출발지 주소         |
| **destination addr** | 128비트 목적지 주소         |

&ensp;1. 체크섬 없음<br/>
&ensp;라우터가 체크섬 계산(계속 더하고 뒤집고)을 하면 시간이 걸리니까 IPv6는 과감히 제거함<br/>

&ensp;2. 조각(Fragmentation) 기능 없음<br/>
&ensp;IPv4는 라우터가 패킷을 찢고 다시 조립했는데 IPv6는 패킷 조각화는 송신 측에서만 가능하고 라우터는 손 안 댐.<br/>

&ensp;3. 옵션 필드 없음<br/>
&ensp;옵션은 필요하면 “확장 헤더(Extension Header)”로 따로 분리함.<br/>

IPv4 → IPv6 전환 (Transition)
-----

&ensp;문제: IPv4 라우터와 IPv6 라우터가 섞여 있으면?<br/>
* 어떤 라우터는 IPv6 지원
* 어떤 라우터는 IPv4만 지원
* 네트워크 전체를 한꺼번에 업그레이드하는 건 불가능
&ensp;IPv6 패킷이 IPv4-only 라우터를 지나갈 수 없다. → IPv6 패킷이 막힘. 그래서 등장한 기술이 터널링.<br/>

### 터널링(Tunneling)과 캡슐화(Encapsulation)

&ensp;**터널링**<br/>
&ensp;IPv6 패킷을 IPv4 패킷 내부에 넣어버리는 기술.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-44.png" width="500"></p>

&ensp;IPv6 datagram을 "payload처럼" IPv4 패킷 속에 실어 보내는 방식<br/>

&ensp;상황 1: IPv6 라우터들이 직접 연결된 경우<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-45.png" width="500"></p>

&ensp;모두 IPv6 → 그냥 IPv6 패킷을 보내면 됨<br/>

&ensp;상황 2: IPv4-only 네트워크가 중간에 있음<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-46.png" width="500"></p>

&ensp;B와 E는 IPv4 + IPv6 지원 장비 하지만 중간 노드(C, D)는 IPv4만 지원<br/>
&ensp;→ B에서 IPv6 패킷을 IPv4 패킷에 감싸서 보냄<br/>
&ensp;→ E에서 다시 IPv6 패킷을 꺼냄<br/>

&ensp;**Encapsulation**<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-47.png" width="500"></p>

&ensp;터널 구간<br/>
&ensp;B ⇄ E (두 라우터는 IPv6+IPv4 지원)<br/>
&ensp;중간의 IPv4 네트워크 전체를 "터널"로 봄.<br/>

&ensp;패킷 구조<br/>
&ensp;IPv4 헤더<br/>
&ensp;└── IPv6 패킷 (원본)<br/>
&ensp;IPv6 패킷 전체가 IPv4의 payload가 됨.<br/>

&ensp;Logical view vs Physical view<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-48.png" width="500"></p>

&ensp;논리(Logical) 관점<br/>
```bash
A  →  B  =======( IPv4 tunnel )======  E  →  F
IPv6      IPv6/v4                    IPv6/v4    IPv6

```

&ensp;논리적으로는 "IPv6 라우터 A → F"로 그냥 IPv6 경로가 연결된 것처럼 보임<br/>
&ensp;그러나 실제로는 IPv4 라우터들이 중간에 숨어 있음<br/>

&ensp;실제(Physical) 관점<br/>
&ensp;A → B → (C → D → … → IPv4 네트워크) → E → F<br/>
* A → B: IPv6 패킷 그대로 전송
  - 둘 다 IPv6이므로 그냥 IPv6로 통신 가능
* B → C → D → E: IPv4 구간
  - 이 구간은 IPv6를 이해 못함 → 따라서 IPv6 패킷을 통과 못 시킴 → 그래서 IPv6 패킷을 IPv4 패킷 안에 넣어버림!
* E→F : IPv6

&ensp;패킷 주소를 보면: IPv6 원래 패킷<br/>
```less
src: A
dest: F
(data...)
```

&ensp;B에서 IPv4 캡슐화 후<br/>
&ensp;IPv4 header<br/>
```less
IPv4 Header (src: B, dest: E)
   └── IPv6 패킷 전체(payload)
          src: A
          dest: F
          data...
```

&ensp;A → B<br/>
* 둘 다 IPv6
* IPv6 패킷 (src=A, dest=F) 그대로 이동

&ensp;B → C → D → E (IPv4 터널 내부)<br/>
* B는 "터널 입구"
* E는 "터널 출구"

&ensp;B가 하는 일<br/>
1. IPv6 패킷을 받음
2. 그 전체를 IPv4 패킷의 payload로 넣음
3. IPv4 헤더를 붙임
* src = B
* dest = E
4. C, D는 IPv6의 존재 여부를 전혀 모름 → 그냥 IPv4 패킷이라고 생각하고 전달함

&ensp;C, D에서 보이는 패킷은 이렇게 보임:<br/>
```bash
IPv4 packet:
  src = B
  dest = E
  payload = (IPv6 packet)
```

&ensp;C, D 같은 IPv4 라우터는 겉의 IPv4 헤더만 보고 전달해줌.<br/>
&ensp;E에 도착하면 E가 “아 이건 터널의 끝이네?” 하고 IPv4 헤더를 벗기고 IPv6 패킷을 꺼냄.<br/>

&ensp;E → F<br/>
&ensp;E는 터널 출구<br/>
&ensp;E가 하는 일<br/>
1. IPv4 헤더 제거(벗김)
2. 속에 있는 원래 IPv6 패킷을 꺼냄
3. IPv6 라우팅으로 다시 F까지 전달

```less
src: A
dest: F
(data...)
```
