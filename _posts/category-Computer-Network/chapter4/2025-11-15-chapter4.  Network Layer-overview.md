---
title: "chapter4. Network Layer-overview"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-11-15
last_modified_at: 2025-11-15
---

Network-layer 
====

Services and Protocols
-----

&ensp;Transport Segment 이동<br/>
&ensp;전송 계층(segment)을 네트워크 계층이 datagram으로 캡슐화하여 네트워크로 전달한다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-1.png" width="500"></p>

&ensp;Sender(보내는 쪽)<br/>
* transport layer의 segment를 datagram으로 포장(encapsulate)
* link layer로 전달하여 실제 전송 시작

&ensp;Receiver(받는 쪽)<br/>
* datagram을 받아 세그먼트(segment)를 꺼내 전달
* transport layer로 보내 최종적으로 애플리케이션에 도착하게 함

&ensp;네트워크 계층은 모든 인터넷 장치에 존재<br/>
* PC, 스마트폰 같은 호스트(hosts)
* 라우터(routers)

&ensp;둘 다 네트워크 계층의 기능을 수행한다.<br/>

&ensp;Router의 역할<br/>
&ensp;라우터는 네트워크 계층의 핵심 장비이다.<br/>
* 모든 통과하는 IP datagram의 header를 검사
* input → output 포트로 datagram을 이동시킴
* 패킷이 목적지에 도달할 때까지 경로 상의 모든 라우터에서 반복됨

&ensp;라우터는 오는 편지를 보고 어디로 보낼지 계속 결정해주는 우체국 같은 장비<br/>

# Two key Network-layer Functions

&ensp;Forwarding (포워딩): 순간적인 "차선 선택"<br/>
* 라우터 내부에서 발생
* 패킷이 들어오는 순간 → 올바른 포트로 보내는 동작
* Decision speed(결정 속도)가 매우 빨라야 함

&ensp;비유<br/>
&ensp;고속도로 분기점에서 어느 방향으로 갈지 바로 선택하는 것<br/>

&ensp;Routing (라우팅): 전체 경로 "여행 계획 짜기"<br/>
* 네트워크 전체 관점
* 출발지에서 목적지까지 어떤 길이 최적인지 계산
* 라우터 간 정보를 교환하며 테이블을 만든다.

| 기능             | 의미                        |
| -------------- | ------------------------- |
| **Forwarding** | 라우터 내부에서 순간적으로 어디로 보낼지 결정 |
| **Routing**    | 전체 네트워크 경로를 계산            |

Data Plane vs Control Plane
-----

&ensp;Data Plane (데이터 평면)<br/>
* **각 라우터 내부(local)**에서 수행
* 들어온 패킷을 어느 포트로 보낼지 결정
* Forwarding 수행

&ensp;패킷의 header 정보(목적지 주소 등)를 읽고 빠르게 다음 포트로 전달
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-2.png" width="500"></p>

&ensp;Control Plane (제어 평면)<br/>
* 네트워크 전체(global) 관점
* 패킷이 어떤 경로를 따라가야 하는지 결정
* Routing 수행

&ensp;1) Traditional Routing<br/>
* 라우터들이 서로 정보를 교환하며 직접 경로 계산
* Dijkstra, Bellman-Ford 같은 알고리즘 사용

&ensp;2) SDN (Software-Defined Networking)<br/>
* 경로 계산을 **중앙 서버(컨트롤러)**가 수행
* 라우터는 명령만 받아 실행
* 네트워크 관리가 훨씬 단순해짐

# Per-router Control 

&ensp;네트워크 안의 모든 라우터가 각각 자체적으로 라우팅 알고리즘을 실행하는 방식<br/>
&ensp;라우터마다 라우팅 알고리즘 모듈이 있음 → 그림에서 라우터 위쪽의 “Routing Algorithm”이라고 적힌 부분<br/>

&ensp;각 라우터는 스스로 경로를 계산하고 다른 라우터와 정보를 교환해 포워딩 테이블을 만든다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-3.png" width="500"></p>

&ensp;그림 속에서 라우터들의 윗부분(분홍색 영역)이 Control Plane, 아랫부분(파란색 영역)이 Data Plane이다.<br/>

&ensp;Control Plane (라우팅 계산)<br/>
* 라우터들이 서로 빨간 화살표로 연결되어 정보 교환
* 라우팅 알고리즘(Dijkstra, Bellman-Ford 등)이 동작함
* 서로 데이터를 주고받으며 최적 경로 계산

&ensp;Data Plane (패킷 전달)<br/>
* 패킷 header의 목적지 주소(예: 0111)를 읽어서
* "Local forwarding table"에 따라 맞는 포트로 전달
* 테이블 예:

| Header | Output |
| ------ | ------ |
| 0111   | 2      |
| 0100   | 3      |

&ensp;핵심요약<br/>
* 라우터들은 서로 협력하여 전체 경로를 계산
* 각 라우터가 독립적으로 라우팅 알고리즘을 수행
* Control plane과 Data plane이 라우터 내부에서 모두 존재함

# SDN Control Plane

&ensp;**Software-Defined Networking(SDN)**을 설명한다. 이는 **전통 방식(per-router)**과 완전히 다른 제어 방식이다.<br/>

&ensp;SDN Control Plane이란?<br/>
* 모든 라우팅 계산을 중앙 서버(Controller)가 수행
* 라우터는 계산을 하지 않음
* Controller가 직접 라우터에게 포워딩 테이블을 내려줌 (빨간 화살표)

&ensp;라우터는 단순 작업자, 중앙 서버가 진짜 두뇌 역할을 하는 구조<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter 4. Network Layer/4-4.png" width="500"></p>

&ensp;Remote Controller<br/>
* 최상단의 큰 분홍색 영역
* 네트워크 전체의 라우팅 정보와 정책을 한 곳에서 처리
* SDN Controller라고 부름

&ensp;CA(Control Agent)<br/>
* 라우터 내부의 Control Agent
* Controller가 보낸 정보(포워딩 테이블)를 라우터 내부 Data Plane에 적용해줌

&ensp;비교<br/>

| Per-router 방식  | SDN 방식            |
| -------------- | ----------------- |
| 각 라우터가 스스로 계산  | Controller가 전체 계산 |
| 라우터 간 정보 교환 필요 | 중앙 집중식            |
| 설정이 복잡         | 관리 쉬움             |

&ensp;핵심 요약<br/>
* SDN은 네트워크 제어를 중앙화
* 라우터는 단순히 패킷 포워딩만 수행
* 관리성과 유연성 증가

Network Service Model
====

&ensp;Individual datagram에 대한 서비스 (단일 패킷 기준)<br/>
* Guaranteed delivery → 반드시 목적지 도달 보장
* Guaranteed delivery with < 40ms delay → 40ms 이하 지연 시간 보장

&ensp;이런 서비스는 개별 패킷 단위로 보장되는 특성을 가진다.<br/>

&ensp;Flow of datagrams (흐름 단위 서비스)<br/>
&ensp;여러 패킷이 이어지는 스트림(video, voice 등)에 대해 제공되는 서비스:<br/>
* In-order delivery → 순서 보장
* Minimum bandwidth guarantee → 최소 대역폭 보장
* Restrictions on packet spacing → 패킷 간 간격이 갑자기 넓어지거나 좁아지지 않도록 보장 (지터 제어)

# Best Effort

&ensp;인터넷 = Best Effort 모델<br/>
&ensp;Best Effort란 아무것도 보장하지 않는다는 뜻.<br/>
* 성공적으로 도착하는지? → 보장 x
* 순서가 유지되는지? → 보장 x
* 지연 시간 보장? → x
* 대역폭 보장? → x

&ensp;인터넷은 최선을 다하기 하지만 아무것도 약속하진 않는다.<br/>

| QoS 항목    | 보장 여부 |
| --------- | ----- |
| Bandwidth | none  |
| Loss      | no    |
| Order     | no    |
| Timing    | no    |

&ensp;인터넷은 빠르고 잘 동작하는 것처럼 보이지만 사실 TCP가 상위에서 안정성을 보완하고 있는 구조이다.<br/>

&ensp;Network-layer Service Model 비교<br/>

| Network  | Service Model      | Bandwidth      | Loss     | Order    | Timing |
| -------- | ------------------ | -------------- | -------- | -------- | ------ |
| Internet | Best effort        | none           | no       | no       | no     |
| ATM      | Constant Bit Rate  | Constant       | yes      | yes      | yes    |
| ATM      | Available Bit Rate | Guaranteed min | no       | yes      | no     |
| Internet | IntServ            | yes            | yes      | yes      | yes    |
| Internet | DiffServ           | possible       | possibly | possibly | no     |

&ensp;각 기술 간 차이 설명<br/>
&ensp;1) ATM(Constant Bit Rate)<br/>
* 전화망 기반 기술
* 대역폭, 순서, 타이밍까지 강력한 QoS 보장

&ensp;2) ATM(Available Bit Rate)<br/>
* 최소 대역폭 보장
* 타이밍 보장 없음

&ensp;3) Internet IntServ<br/>
* 고품질 실시간 서비스 제공
* RSVP 프로토콜로 리소스 예약
* 하지만 너무 무겁고 복잡함 → 실무에서 거의 사용 안 함

&ensp;4) Internet DiffServ<br/>
* 클래스별로 다른 서비스 품질 제공
* 가능성이 있음이라는 표현은 정책에 따라 달라질 수 있다는 의미
* 실무에서 널리 사용되는 Qos 기법

# Reflections on Best-effort Service

&ensp;인터넷이 왜 Best-effort 서비스 모델을 여전히 성공적으로 유지하고 있을까<br/>
&ensp;Best-effort는 아무것도 보장하지 않는 서비스 모델이다. 그런데도 인터넷은 잘 돌아간다. 이유는 다음과 같다.<br/>

&ensp;1. 간단한 구조(simplicity of mechanism)<br/>
&ensp;Best-effort 방식은 구조가 매우 단순하다. 복잡한 QoS 제어 없이 "최대한 빨리 보내고 보는" 방식이다.<br/>

&ensp;이 단순함 때문에<br/>
* 구현이 쉽고
* 장비 가격이 낮고
* 전 세계에 빠르게 보급될 수 있다.

&ensp;충분한 대역폭 확보(provisioning of bandwidth)<br/>
&ensp;최근에는 인터넷 대역폭이 충분히 커졌다.<br/>
&ensp;그래서<br/>
* 실시간 음성 통화
* 영상 스트리밍

&ensp;등도 대부분의 시간에 충분히 잘 동작한다.<br/>

&ensp;est-effort 모델이 완벽하진 않아도 지금의 대역폭이면 웬만한 건 다 잘 된다.<br/>

&ensp;3. 복제된 애플리케이션 레벨 분산 서비스<br/>
&ensp;CDN(Content Delivery Network) 덕분에 유튜브, 넷플릭스 등은 사용자 가까운 곳의 서버에서 데이터를 제공한다.<br/>
* 멀리 있는 서버에 의존하지 않아도 되고
* 지연(latency)와 손실(loss)이 줄어들며
* Best-effort 모델의 단점을 상위 계층이 보완해 줌

&ensp;4. 탄력적(elastic) 서비스의 혼잡 제어<br/>
&ensp;대부분의 인터넷 서비스(TCP 기반 웹 서비스 등)는 혼잡이 생기면 스스로 속도를 줄였다가 다시 올리는 탄력적(elastic) 성격을 가지고 있다.<br/>
&ensp;이런 서비스 덕분에 혼잡으로 인해 패킷이 조금 손실되더라도 시스템이 쉽게 회복된다.<br/>

&ensp;결론: Best-effort 모델은 “의외로 매우 성공적”<br/>
