---
title: "chapter3. Transport Layer-(소단원 4~7)"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Network
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-10-30
last_modified_at: 2025-10-30
---

Principles of reliable data transfer 
=====

&ensp;신뢰적 전송은 엉망인 네트워크(손실/오류/재정렬)위에 문제없어 보이는 파이프9(추상화)를 프로토콜(구체 구현)로 흉내 내는 기술이다. 보내는 쪽(sender)과 받는 쪽(receiver)의 서로의 상태를 볼 수 없고 오직 메시지(ACK/NAK 등)로만 확인한다.<br/>


&ensp;1. 신뢰적 채널은 추상화(absstraction)<br/>
* 애플리케이션(HTTP, gRPC 등)은 "데이터를 주면 그대로 잘 간다"라고 믿고 사용한다.
* 이 믿음이 바로 reliable service abstraction 

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-12.png" width="500"></p>

&ensp;2. 현실은 불신뢰 채널 - 그래서 구현(implementation)이 필요<br/>
* 실제 네트워크는 packet loss(손실), bit error(오염), reordering(순서 꼬임)가 생긴다.
* 이 문제를 가리기 위해 양 끝단(송신/수신)의 전송 프로토콜이 동작한다.

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-13.png" width="500"></p>

&ensp;3. 복잡도는 채널이 얼마나 엉망이냐에 비례<br/>
* 채널 특성에 따라 필요한 장치가 늘어난다.

| 채널 문제                      | 필요한 장치                           |
| -------------------------- | -------------------------------- |
| 비트 오염(corruption)          | **검출**(Checksum/CRC) + **재전송**   |
| 손실(loss)                   | **타이머/타임아웃** + **재전송**           |
| 재정렬(reorder)/중복(duplicate) | **시퀀스 번호(seq #)** + **중복 제거 로직** |
| ACK 유실                     | **타임아웃 후 재전송**, **누적 ACK** 등     |

&ensp;4. 커튼 메타포-상태는 보이지 않는다.<br/>
* 송신자와 수신자는 서로의 상태(state)를 직접 알 수 없다.
    - 그 패킷 갔나 그 ACK 받았니 → 메시지로만 확인 가능
* 그래서 프로토콜 메시지(ACK/NAK, 시퀀스 번호, 타이머)가 필수

# Reliable Data Transfer (RDT)

&ensp;RDT의 핵심 구성요소 — 도구 상자<br/>
1. 오류 검출(Error Detection)
* 체크섬/CRC로 패킷이 망가졌는지 검출
2. 피드백(Feedback)
* ACK(정상 수신), NAK(에러) 또는 중복 ACK로 수신 상황을 통지.
3. 재전송(Retransmission)
* NAK를 받거나, 타임아웃이 나면 다시 보냄
4. 시퀀스 번호(Sequence Numbers)
* 중복/재정렬을 구분하고 순서 보장
5. 타이머(Timer)
* ACK를 기다리다 시간 초과 시 손실로 간주하고 재전송

&ensp;RDT 프로토콜은 송신 측(sender)과 수신 측(receiver)이 서로 데이터를 주고 받는 구조로 이루어져 있다. 이들은 실제 하위 네트워크(비신뢰적 채널)위에서 동작하고 서로의 행동을 함수 호출처럼 인터페이스로 표현할 수 있다.<br/>

&ensp;주요 함수 정리<br/>

| 함수명                    | 호출 주체                   | 역할                                                  |
| ---------------------- | ----------------------- | --------------------------------------------------- |
| **rdt_send(data)**     | 상위 계층(App → Transport)  | 애플리케이션이 데이터를 전송할 때 호출됨. 이 데이터를 패킷으로 만들어 하위 채널로 보냄.  |
| **udt_send(packet)**   | RDT 내부 (Sender)         | 신뢰적 전송 프로토콜이 실제 비신뢰적 채널로 패킷을 보냄. (UDP 같은 역할)        |
| **rdt_rcv(packet)**    | RDT 내부 (Receiver)       | 수신 측에서 패킷이 도착했을 때 호출됨. 패킷을 받아서 데이터 추출 후 상위 계층에 전달함. |
| **deliver_data(data)** | Transport → Application | 받은 데이터를 애플리케이션에 넘겨줌. (즉, 최종 도착 단계)                  |

&ensp;정리 흐름(데이터의 이동 경로)<br/>
```scss
[Application Layer]     rdt_send(data)
        ↓
[Sender RDT Layer]      → make_pkt(data)
        ↓
        ↓ udt_send(packet)
        ↓
[Unreliable Channel]    ———> (전송)
        ↓
[Receiver RDT Layer]    rdt_rcv(packet)
        ↓
        ↓ deliver_data(data)
        ↓
[Application Layer]     ← 최종 도착!
```

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-14.png" width="500"></p>

&ensp;RDT 설계<br/>
1. 송신자와 수신자 각각을 독립적인 FSM으로 설계한다.
2. 데이터는 한 방향(unidirectional) 으로만 전송한다. → 단 ACK 같은 제어 메시지(control info) 는 반대 방향으로도 흐름
3. 각 FSM은 "상태(state)"와 "이벤트(event)"로 동작한다.

&ensp;FSM 기본 구조<br/>
&ensp;FSM은 "상태 → 이벤트 발생 → 행동 → 다음 상태로 전이"로 동작한다.<br/>
```scss
( state 1 ) --event/action--> ( state 2 )
```

* state: 현재 송신기나 수신기의 상태 (예: 대기 중, 전송 중 등)
* event: 발생한 사건 (예: rdt_send 호출됨, ACK 도착, timeout 등)
* action: 그에 따라 수행할 동작 (예: 데이터 전송, 타이머 시작, 재전송 등)

# RDT 1.0 — 완벽히 신뢰적인 채널 위의 전송

&ensp;이 단계는 이상적인 환경을 가정한다. 즉 채널이 완벽히 신뢰적이라 비트 오류도 없고 손실도 없다.<br/>

&ensp;가정<br/>
* No bit errors
* No packet loss
* 데이터가 항상 정상 도착

&ensp;UDP도 완벽하게 동작한다고 가정한 상태이다. 이 경우 신뢰성 기능(ACK, NAK, 시퀀스 번호 등)은 필요 없다.<br/>

&ensp;송신자 FSM<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-15.png" width="500"></p>

1. 상위 계층이 `rdt_send(data)` 호출
2. 송신자는 패킷을 생성 (`make_pkt(data)`)
3. 하위 계층으로 전송 (`udt_send(packet)`)
4. 다음 데이터 전송을 위해 다시 "상태 대기"로 돌아감

```scss
[Wait for call from above]
   rdt_send(data)
   → packet = make_pkt(data)
   → udt_send(packet)
   → (back to wait)
```

&ensp;수신자 FSM<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-16.png" width="500"></p>

1. 하위 채널에서 패킷 수신 (`rdt_rcv(packet)`)
2. 패킷에서 데이터 추출 (`extract(packet, data)`)
3. 상위 계층으로 전달 (`deliver_data(data)`)
4. 다음 패킷 수신 대기

```scss
[Wait for call from below]
   rdt_rcv(packet)
   → extract(packet, data)
   → deliver_data(data)
   → (back to wait)
```

&ensp;핵심 요약<br/>
| 항목             | 설명                                  |
| -------------- | ----------------------------------- |
| **rdt1.0의 전제** | 완벽한 채널 (no error, no loss)          |
| **필요한 기능**     | 단순 패킷 생성과 전송만                       |
| **FSM 상태 수**   | 송신자/수신자 각각 1개 상태 (대기 only)          |
| **복잡도**        | 아주 단순     |
| **의미**         | 이후 버전(rdt2.0, rdt3.0)으로 발전하기 위한 출발점 |


&ensp;RDT1.0은 "채널이 완벽하다면 신뢰적 전송은 너무 쉽다"를 보여주는 시작 단계이다.
이후 버전에서는 "오류 발생 → ACK/NAK 도입 → 손실 발생 → 타이머 추가"로 점점 복잡해진다.

# RDT 2.0 — Channel with Bit Errors

&ensp;1. 문제 상황: "채널이 완벽하지 않다"<br/>
&ensp;RDT 1.0에서는 채널이 완벽했다. 하지만 이제 현실적으로 비트 오류(bit error) 가 생길 수 있다고 가정한다. 즉 전송 중 일부 비트가 바뀌어서 데이터가 손상(corrupt) 될 수 있다.<br/>

&ensp;문제 정의<br/>
* Underlying channel may flip bits
* 즉 패킷 내부의 비트가 바뀌어 수신자가 엉뚱한 데이터를 받을 수 있다.
* 해결 방법은? -> "오류 검출 + 복구(recovery)"

&ensp;오류 검출(Error Detection)<br/>
* Checksum을 사용해 전송된 패킷의 무결성을 확인한다.
* 수신 측은 수신된 패킷을 검사해서 
    - 올바르면 → ACK
    - 오류면 → NAK 으로 응답한다.

&ensp;오류 복구 방법 (Error Recovery)<br/>
&ensp;수신자가 문제를 감지고 송신자에게 알려주면 된다. 이 방식이 Automatic Repeat reQuest (ARQ) 프로토콜의 기본 원리이다.<br/>

&ensp;핵심 아이디어-ACK / NAK 방식<br/>

| 구분                                 | 의미                | 송신자의 행동    |
| ---------------------------------- | ----------------- | ---------- |
| **ACK (Acknowledgement)**          | 수신 성공 (데이터 이상 없음) | 다음 데이터 전송  |
| **NAK (Negative Acknowledgement)** | 수신 실패 (데이터 손상됨)   | 같은 데이터 재전송 |

&ensp;수신자가 받았어(ACK) 또는 틀렸어(NAK)로 의사소통한다.<br/>

&ensp;Stop-and-Wait 동작 방식<br/>
&ensp;한 번에 하나만 보내고 응답(ACK/NAK)을 기다린다.<br/>
1. 송신자는 하나의 패킷을 보냄
2. 수신자의 ACK/NAK 응답을 기다림
3. ACK이면 다음 데이터 전송, NAK이면 재전송

&ensp;따라서 항상 보내기 → 기다리기 → 응답 확인 의 구조로 반복된다.<br/>

&ensp;RDT 2.0 FSM (Finite State Machine)<br/>
&ensp;송신자  (Sender)<br/>

| 상태                       | 이벤트               | 행동                                                 |
| ------------------------ | ----------------- | -------------------------------------------------- |
| Wait for call from above | `rdt_send(data)`  | `make_pkt(data, checksum)` 생성 → `udt_send(pkt)` 송신 |
| Wait for ACK or NAK      | `rdt_rcv(pkt)` 도착 | ACK이면 다음 전송으로 이동 / NAK이면 재전송                       |

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-17.png" width="500"></p>

```scss
[Wait for call from above]
   rdt_send(data)
   → make_pkt(data, checksum)
   → udt_send(packet)
   ↓
[Wait for ACK or NAK]
   rdt_rcv(ACK) → 다음 데이터 전송
   rdt_rcv(NAK) → 재전송
```

&ensp;수신자 (Receiver)<br/>

| 이벤트                         | 행동                             |
| --------------------------- | ------------------------------ |
| `rdt_rcv(packet)` & 데이터가 정상 | 데이터 추출 + 상위 계층 전달 + **ACK 송신** |
| `rdt_rcv(packet)` & 데이터 손상  | **NAK 송신 (재전송 요청)**            |

```scss
[Wait for call from below]
   if (packet not corrupt):
       extract(data)
       deliver_data(data)
       udt_send(ACK)
   else:
       udt_send(NAK)
```

&ensp;정상 동작 (No Error Case)<br/>
1. 송신자가 데이터 전송(`rdt_send`)
2. 수신자는 데이터 정상 수신 (`not corrupt`)
3. 수신자가 ACK 전송
4. 송신자가 ACK 수신 → 다음 패킷 전송

&ensp;데이터가 손상되지 않았을 때 → 한 번에 성공적으로 전송됨<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-18.png" width="500"></p>

&ensp;오류 발생 시 (Corrupted Packet Scenario)<br/>
1. 송신자가 데이터 전송
2. 수신자가 데이터 받음 → Checksum 오류 발생! (corrupt)
3. 수신자는 NAK 전송
4. 송신자는 NAK 수신 → 같은 데이터 재전송

&ensp;오류 감지 후 수신자가 NAK으로 알려 송신자가 다시 보냄<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-19.png" width="500"></p>

&ensp;근본적인 한계 (Fatal Flaw)<br/>
&ensp;문제: ACK이나 NAK 자체가 손상되면 어떻게 될까?<br/>

&ensp;문제 상황<br/>
* 송신자는 수신 상태를 알 수 없음
    - ACK이 손상되었는지 NAK이 손상되었는지 구분 불가
    - 그냥 다시 보내면? → 중복 패킷 가능성 발생!

&ensp;해결책 — Sequence Number 추가<br/>

| 문제                  | 해결 방법                           |
| ------------------- | ------------------------------- |
| ACK/NAK이 손상되어 중복 가능 | 각 패킷에 **시퀀스 번호(seq #)** 추가      |
| 수신자가 중복 패킷을 구분      | 같은 seq 번호면 → “이미 받은 거”라 판단, 무시함 |

&ensp;Stop-and-Wait 구조 유지<br/>
&ensp;여전히 한 번에 한 패킷만 전송하고, 응답이 올 때까지 기다린다. 하지만 RDT 2.0에서는 ACK/NAK 손상이 한계라 다음 단계인 RDT 3.0에서 “타임아웃 + 재전송”을 추가해 완전하게 만든다.<br/>

&ensp;한눈에 보는 RDT 발전 과정 요약<br/>

| 버전                | 채널 특성      | 주요 기능              | 한계                  |
| ----------------- | ---------- | ------------------ | ------------------- |
| **RDT 1.0**       | 완벽한 채널     | 단순 전송              | 비현실적                |
| **RDT 2.0**       | 비트 오류 존재   | Checksum + ACK/NAK | ACK/NAK 손상 문제       |
| **RDT 2.1 / 2.2** | ACK/NAK 손상 | 시퀀스 번호 추가          | 아직 손실(loss) 미해결     |
| **RDT 3.0**       | 손실까지 고려    | 타임아웃 + 재전송         | 완전한 Stop-and-Wait |

&ensp;RDT 2.0 = Checksum + ACK/NAK + Stop-and-Wait 기반 오류 복구 프로토콜, 하지만 ACK/NAK 손상 문제 → Sequence Number 필요<br/>

# RDT 2.1-Handlling Corrupted ACK/NAKs

&ensp;RDT 2.0의 한계<br/>
&ensp;RDT 2.0에서는 패킷에 비트 오류가 생기면 수신자가 NAK으로 알려주면 됐지만 만약 ACK/NAK 자체가 손상되면 송신자가 혼란에 빠진다.<br/>
&ensp;잘못된 ACK/NAK는 모호함(ambiguity)을 만든다.<br/>

&ensp;해결책-Sequence Number(시퀀스 번호)추가<br/>
&ensp;각 데이터 패킷에 번호를 붙인다.<br/>

| 목적                 | 설명                             |
| ------------------ | ------------------------------ |
| **중복 데이터 구분**      | 수신자는 “이건 이미 받은 데이터야”를 판별 가능    |
| **손상된 ACK/NAK 복구** | 송신자는 같은 패킷을 재전송해도 수신자가 혼동하지 않음 |


&ensp;번호는 0과 1 두 개면 충분<br/>
* 왜냐면 top-and-Wait 구조에서는 항상 "하나 보내고, 하나 확인받기" 이기 때문이다.
* 다음 패킷이 오면 무조건 이전과 벌갈아 가며(0 → 1 → 0 → 1 …) 구분 가능

&ensp;동작 요약<br/>

| 단계 | 송신자(S)                        | 수신자(R)           | 설명              |
| -- | ----------------------------- | ---------------- | --------------- |
| ①  | `seq=0` 데이터 전송                |                  | 첫 번째 패킷 보냄      |
| ②  |                               | 정상 수신 → `ACK(0)` | 데이터 정상 → ACK 보냄 |
| ③  | `ACK(0)` 수신 → `seq=1` 전송 준비   |                  | 다음 데이터 준비       |
| ④  | `seq=1` 전송                    |                  | 다음 패킷 전송        |
| ⑤  | 오류 발생 → 수신자가 NAK 또는 이전 ACK 전송 |                  | 재전송 요청          |
| ⑥  | 송신자는 `seq=1` 패킷을 다시 보냄        |                  | 데이터 복구 완료       |

&ensp;Sender FSM 동작 (송신자)<br/>
&ensp;FSM을 보면 상태가 두 배로 늘었다. 이제 송신자는 0번 데이터 전송 중인지 1번 데이터 전송 중인지 기억해야 한다.<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-20.png" width="500"></p>

&ensp;상태별 요약<br/>

| 상태                             | 이벤트                | 행동                      |
| ------------------------------ | ------------------ | ----------------------- |
| **Wait for call 0 from above** | `rdt_send(data)`   | `make_pkt(seq=0)` → 전송  |
| **Wait for ACK or NAK 0**      | ACK 수신             | 다음으로 이동 (→ state 1)     |
|                                | NAK 또는 손상된 ACK/NAK | `udt_send(이전 패킷)` (재전송) |
| **Wait for call 1 from above** | `rdt_send(data)`   | `make_pkt(seq=1)` → 전송  |
| **Wait for ACK or NAK 1**      | ACK 수신             | 다음으로 이동 (→ state 0)     |
|                                | NAK 또는 손상된 ACK/NAK | `udt_send(이전 패킷)` (재전송) |


&ensp;Receiver FSM 동작 (수신자)<br/>
&ensp;수신자 역시 어떤 시퀀스 번호의 패킷을 기다리고 있는가를 기억해야 한다.<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-21.png" width="500"></p>

&ensp;상태별 요약<br/>

| 상태                        | 이벤트               | 행동                                  |
| ------------------------- | ----------------- | ----------------------------------- |
| **Wait for 0 from below** | 올바른 `seq=0` 패킷 수신 | 데이터 전달 + `ACK(0)` 송신 + 다음 state로 이동 |
|                           | 손상된 패킷            | `NAK` 송신                            |
|                           | 중복 `seq=1` 패킷 수신  | 이전 ACK 재전송                          |
| **Wait for 1 from below** | 올바른 `seq=1` 패킷 수신 | 데이터 전달 + `ACK(1)` 송신 + 다음 state로 이동 |
|                           | 손상된 패킷            | `NAK` 송신                            |
|                           | 중복 `seq=0` 패킷 수신  | 이전 ACK 재전송                          |

&ensp;수신자는 자신이 기대하는 seq 번호(0 or 1)와 일치할 때만 데이터를 상위 계층에 넘긴다.<br/>

&ensp;동작 플로우<br/>

```bash
Sender: [send seq=0] → [wait ACK/NAK 0]
Receiver: [expect 0] → ACK(0)
Sender: [send seq=1] → [wait ACK/NAK 1]
Receiver: [expect 1] → ACK(1)
반복…
```

&ensp;만약 ACK이나 NAK가 깨지면?<br/>
&ensp;→ 송신자는 같은 seq# 패킷을 재전송<br/>
&ensp;→ 수신자는 "중복"으로 인식하고 그냥 ACK을 다시 보냄<br/>
&ensp;데이터 중복은 방지된다.<br/>

&ensp;Sender와 Receiver의 주요 변화 요약<br/>

| 구분    | RDT 2.0   | RDT 2.1                         |
| ----- | --------- | ------------------------------- |
| 오류 감지 | Checksum  | Checksum                        |
| 오류 복구 | ACK / NAK | ACK / NAK + **Sequence Number** |
| 중복 처리 | 불가능       | 중복 구분 가능                        |
| 상태 수  | 2개        | 4개 (0/1 기억 필요)                  |
| 장점    | 단순        | **ACK/NAK 손상 복구 가능**            |

&ensp;포인트<br/>
&ensp;송신자(Sender)<br/>
* 각 패킷에 seq# 추가
* 두 개의 번호 (0, 1)로 충분(번갈아 전송)
* ACK/NAK 손상 여부 검사 필요
* 상태 수 2배 (각 seq별로 기다림)

&ensp;수신자(Receiver)<br/>
* 중복 패킷 검사 필요
    - 동일 seq 번호의 패킷은 무시하고 ACK만 재전송
* 수신자는 송신자가 자기 ACK을 잘 받았는지 확신할 수 없다 → 그래서 “ACK을 반복 전송” 가능하게 설계됨

&ensp;핵심 문장 요약<br/>

| 구문                                      | 의미                  |
| --------------------------------------- | ------------------- |
| **RDT 2.1 = RDT 2.0 + Sequence Number** | ACK/NAK 손상 문제 해결    |
| **2 seq# (0,1)**                        | Stop-and-Wait에서 충분  |
| **송신자**는 “현재 보낸 seq” 기억                 | ACK이 손상되면 같은 번호 재전송 |
| **수신자**는 “기대하는 seq” 기억                  | 중복이면 무시하고 ACK만 보냄   |
| **상태 수 2배 증가**                          | 각 seq별로 별도 FSM 필요   |

&ensp;RDT 2.1은 시퀀스 번호(0, 1)를 도입해 ACK/NAK 손상 문제를 해결한 Stop-and-Wait 프로토콜이다. 송신자는 현재 seq#, 수신자는 기대 seq# 을 기억하며 손상 시 중복을 구분해 재전송을 안전하게 처리한다.<br/>

# RDT2.2 - A NAK-free Protocol

&ensp;등장 배경: RDT 2.1의 한계<br/>
&ensp;이전 버전인 RDT 2.1은 잘 동작하지만 NAK(Negative ACK) 메시지가 별도로 존재해서 구조가 조금 복잡했다.<br/>
&ensp;RDT 2.1에서는<br/>
* 오류 → NAK 보냄
* 올바름 → ACK 보냄

&ensp;문제는<br/>
* NAK 메시지도 손상될 수 있고
* 프로토콜 설계가 ACK/NAK를 둘 다 처리해야 해서 복잡하다.

&ensp;그래서 RDT2.2는 NAK을 없애고 ACK만으로 오류 복구하도록 단순화했다.<br/>

&ensp;핵심 아이디어: Duplicate ACK<br/>
&ensp;수신자(receiver)가 NAK 대신 중복 ACK(Duplicate ACK)을 보냄으로써 오류를 알려줄 수 있다는 개념이다.<br/>

&ensp;작동 방식 요약<br/>

| 상황       | 수신자 행동                    | 송신자 반응     |
| -------- | ------------------------- | ---------- |
| 정상 수신    | 현재 데이터의 **ACK(seq)** 전송   | 다음 데이터 전송  |
| 패킷 오류 발생 | **직전 패킷의 ACK(seq-1)** 재전송 | 같은 데이터 재전송 |


&ensp;NAK 대신 이전 데이터 잘 받았어(ACK for last good packet)라고 보내는 것이다.<br/>
&ensp;송신자는 중복 ACK이 오면 → 내 마지막 전송이 손상됐구나 하고 자동으로 재전송을 수행한다.<br/>

&ensp;구조적 변화<br/>

| 구분       | RDT 2.1      | RDT 2.2            |
| -------- | ------------ | ------------------ |
| 제어 메시지   | ACK, NAK 둘 다 | **ACK만 사용**        |
| 오류 알림 방식 | NAK 전송       | **중복 ACK 전송**      |
| 복잡도      | 조금 높음        | **단순화됨**           |
| TCP와 유사도 | 중간 수준        | **TCP와 거의 동일한 방식** |

&ensp;RDT 2.2 FSM 개요<br/>
&ensp;Sender FSM(송신자)<br/>

| 상태                         | 이벤트 → 행동                                              |
| -------------------------- | ---------------------------------------------------- | 
| Wait for call 0 from above | `rdt_send(data)` → 패킷(seq=0) 생성 및 전송                 |
| Wait for ACK 0             | `ACK(0)` 수신 → 다음 데이터(seq=1) 전송                       |
|                            | **손상된 ACK** 또는 **ACK(1)** 수신 → 이전 데이터(seq=0) **재전송** |
| Wait for call 1 from above | `rdt_send(data)` → 패킷(seq=1) 전송                      |
| Wait for ACK 1             | `ACK(1)` 수신 → 다음 데이터(seq=0) 전송                       |
|                            | **손상된 ACK** 또는 **ACK(0)** 수신 → 이전 데이터(seq=1) **재전송** |

&ensp;송신자는 올바른 ACK인지 중복 ACK인지 검사하여 중복이면 → 재전송, 올바르면 → 다음 단계로 넘어감<br/>

&ensp;Receiver FSM (수신자)<br/>

| 상태                    | 이벤트 → 행동                                 |
| --------------------- | ---------------------------------------- |
| Wait for 0 from below | 올바른 `seq=0` 수신 → 데이터 전달, `ACK(0)` 보냄     |
|                       | 손상되었거나, `seq=1` (중복) → **이전 ACK(1)** 재전송 |
| Wait for 1 from below | 올바른 `seq=1` 수신 → 데이터 전달, `ACK(1)` 보냄     |
|                       | 손상되었거나, `seq=0` (중복) → **이전 ACK(0)** 재전송 |

&ensp;수신자는 기대하지 않은 번호나 오류 패킷이 오면 NAK 대신 이전 ACK을 재전송한다.<br/>

&ensp;FSM 요약 그림 해석<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-22.png" width="500"></p>

&ensp;이 FSM은 RDT 2.1과 거의 동일하지만 NAK 관련 transition이 사라지고 그 자리에 중복 ACK 전송 로직이 들어가 있다.<br/>

&ensp;예를 들어<br/>
```text
rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq1(rcvpkt))
   → udt_send(ACK0)
```

&ensp;수신한 패킷이 손상됐거나 예상한 seq와 다르면 이전에 받은 seq(=마지막 정상 데이터)의 ACK을 재전송한다.<br/>

&ensp;RDT 2.2의 장점<br/>
* NAK 없이 오류 처리 가능 → 제어 메시지 하나만 써서 단순해짐
* ACK이 손상되어도 재전송 가능 → 송신자는 중복 ACK으로 문제 감지 가능
* TCP의 설계 기반 → 실제 TCP에서도 NAK은 존재하지 않음 → 손상이나 손실을 **“중복 ACK”과 “타임아웃”**으로 해결

&ensp;전체 동작 시나리오 예시<br/>
```makefile
송신자: send seq=0
수신자: (오류) → 이전 ACK(1) 전송
송신자: duplicate ACK → seq=0 재전송
수신자: 정상 수신 → ACK(0)
송신자: ACK(0) 수신 → seq=1 준비
반복...
```

&ensp;요약<br>

| 항목           | 내용                                                |
| ------------ | ------------------------------------------------- |
| **핵심 차이점**   | RDT 2.1의 NAK 제거, ACK만 사용                          |
| **에러 복구 방식** | “중복 ACK”이 NAK 역할 수행                               |
| **시퀀스 번호**   | 여전히 0, 1 번갈아 사용                                   |
| **송신자 동작**   | 올바른 ACK → 다음 전송 / 중복 ACK → 재전송                    |
| **수신자 동작**   | 손상 or 잘못된 seq → 이전 ACK 재전송                        |
| **TCP 관련성**  | TCP는 NAK 없이 **ACK만으로 신뢰성 보장** (Fast Retransmit 등) |

# RDT 3.0 — Channels with Errors and Loss

&ensp;RDT 2.2는 NAK 없는(NAK-free) Stop-and-Wait 프로토콜이다. 수신자는 오류가 발생하면 이전 패킷의 ACK을 중복 전송하여 송신자가 이를 감지하고 재전송하도록 만든다. 이 방식이 TCP의 기본 신뢰성 매커니즘이다.<br/>

&ensp;등장 배경-손실(loss)까지 생긴다.<br/>
&ensp;이전까지의 RDT 2.x는 비트 오류(bit errors)는 처리했지만 패킷이 아예 사라지는(loss)상황은 고려하지 않았다.<br/>
&ensp;RDT 2.x는 손상된 패킷만 복구할 수 있었고 패킷이 유실되면 그대로 통신이 멈춰버린다.<br/>

&ensp;새로운 가정<br/>
&ensp;Underlying channel can lose packets (both data and ACKs)<br/>
&ensp;즉 전송 중 다음이 사라질 수 있다.<br/>
* 송신자의 데이터(data packet)
* 수신자의 ACK(응답 메시지)

&ensp;핵심 아이디어-Timeout 기반 재전송<br/>
&ensp;Approach: 송신자는 데이터를 보낸 뒤 일정 시간 동안(타이머) ACK이 오길 기다린다.<br/>

| 상황                    | 송신자 행동                        |
| --------------------- | ----------------------------- |
| ACK이 도착함              | 타이머 중지(stop timer), 다음 데이터 전송 |
| ACK이 일정 시간 내에 도착하지 않음 | **Timeout 발생 → 재전송**          |

&ensp;Timeout 메커니즘 요약<br/>

| 항목                      | 설명                                                      |
| ----------------------- | ------------------------------------------------------- |
| **타이머 시작(start_timer)** | 패킷을 보낼 때 함께 시작                                          |
| **타이머 정지(stop_timer)**  | ACK을 정상 수신하면 중지                                         |
| **타임아웃 발생(timeout)**    | 일정 시간 경과 → **재전송(udt_send)** 수행                         |
| **타임아웃 시간 설정**          | “reasonable amount of time” — 너무 짧으면 불필요한 재전송, 너무 길면 느림 |

&ensp;왜 시퀀스 번호(seq#)가 여전히 필요한가?<br/>
&ensp;패킷 손실 외에도 전송 지연(delay)으로 인해 ACK이 늦게 도착할 수도 있다. 이때 재전송이 이미 되었기 때문에 중복 데이터가 발생할 수 있다.<br/>
&ensp;그래서 여전히 시퀀스 번호(0, 1)로 구분해야 한다.<br/>

| 상황           | 해결 방법                |
| ------------ | -------------------- |
| ACK이 지연되어 도착 | 송신자는 중복 ACK으로 인식, 무시 |
| 데이터 재전송      | 수신자는 중복 데이터 확인 후 무시  |

&ensp;시퀀스 번호 + 타이머 의 조합이 핵심<br/>

&ensp;FSM (송신자 기준) 분석<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-23.png" width="500"></p>

&ensp;동작 요약<br/>
&ensp;송신자는 다음 두 단계로 번갈아가며 동작한다.<br/>

| 상태                             | 행동                                     |
| ------------------------------ | -------------------------------------- |
| **Wait for call 0 from above** | 새 데이터 수신 시 전송 → `start_timer()`        |
| **Wait for ACK0**              | ACK(0) 수신 시 → `stop_timer()`, 다음 단계 이동 |
| **Timeout 발생 시**               | 같은 데이터 재전송 → `start_timer()` 다시 시작     |
| **Wait for call 1 from above** | 다음 데이터(seq=1) 전송 → `start_timer()`     |
| **Wait for ACK1**              | ACK(1) 수신 시 → `stop_timer()`, 다음 단계 이동 |
| **Timeout 발생 시**               | 동일하게 재전송 반복                            |

&ensp;FSM 해석<br/>
* `start_timer`: 패킷 보낼 때마다 타이머 작동
* `stop_timer`: ACK 수신 시 타이머 종료
* `timeout`: 타이머 만료 → 재전송 (udt_send(sndpkt))

&ensp;송신자는 타임아웃을 통해 손실된 패킷을 복귀하고 시퀀스 번호를 통해 중복 패킷을 구분한다.<br/>

&ensp;RDT 3.0 의 실제 동작 예시<br/>

&ensp;1. No Loss - 완벽한 환경(정상 통신)<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-24.png" width="500"></p>

&ensp;위 그림은 패킷이 전혀 손실되지 않았을 때의 이상적인 상황이다.<br/>
```scss
Sender                Receiver
-----------------------------------
send pkt0   ─────────▶ rcv pkt0
                     send ack0 ───▶
rcv ack0
send pkt1   ─────────▶ rcv pkt1
                     send ack1 ───▶
rcv ack1
send pkt0   ─────────▶ rcv pkt0
                     send ack0 ───▶
```

&ensp;정상 흐름<br/>
* 송신자는 한 번에 하나의 패킷만 보냄
* 수신자는 매번 ACK을 보냄
* 모든 ACK을 제대로 받으면 타임아웃 없이 연속 진행

&ensp;핵심 개념<br/>
&ensp;→ "Stop and Wait": 한 번 보내고, 응답이 올 때까지 기다림<Br/>

&ensp;2. Packet Loss - 데이터 패킷 손실<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-25.png" width="500"></p>

&ensp;위 그림에서는 pkt1이 손실되는 상황이다.<br/>

```scss
Sender                Receiver
-----------------------------------
send pkt0   ─────────▶ rcv pkt0
                     send ack0 ───▶
rcv ack0
send pkt1   ─────────X (loss)
(timeout) ⏰
resend pkt1 ─────────▶ rcv pkt1
                     send ack1 ───▶
rcv ack1
```

&ensp;동작 요약<br/>
* 송신자는 ACK1을 못 받음 → 타이머 만료(timeout)
* pkt1 재전송
* 수신자는 중복 패킷을 인식하지 않음 (seq#으로 구분됨)

&ensp;핵심 개념<br/>
&ensp;→ 손실이 발생하면 timeout으로 복구한다.<br/>
&ensp;→ seq 번호로 중복 전송 구분 가능<br/>

&ensp;ACK Loss-ACK 손실<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-26.png" width="500"></p>

&ensp;이제는 ACK이 손실되는 상황이다.<br/>
```scss
Sender                Receiver
-----------------------------------
send pkt0 ─────────▶ rcv pkt0
                   send ack0 ───▶
rcv ack0
send pkt1 ─────────▶ rcv pkt1
                   send ack1 ───▶ X (loss)
(timeout) ⏰
resend pkt1 ───────▶ rcv pkt1 (중복 감지)
                   send ack1 ───▶
rcv ack1
```

&ensp;동작 요약<br/>
* 수신자는 ACK을 보냈지만 송신자가 받지 못함
* 송신자는 timeout으로 pkt1을 재전송
* 수신자는 중복 데이터임을 인식(`detect duplicate`)
* 하지만 여전히 ACK을 다시 보냄

&ensp;중복 ACK이 손상된 ACK 복구 역할을 수행한다. 데이터 중복은 seq 번호 덕부넹 안전하게 처리된다.<br/>

&ensp;Premauture Timeout / Delay ACK - ACK 지연<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-27.png" width="500"></p>

&ensp;동작 요약<br/>
* ACK이 늦게 도착 → 송신자는 timeout으로 중복 전송
* 수신자는 중복 데이터 감지 → ACK만 재전송
* 송신자는 나중에 도착한 ACK1을 무시(이미 처리 완료)

&ensp;핵심 포인트<br/>
&ensp;Timeout은 손실뿐 아니라 지연(delay)도 처리 가능하게 하지만 지연 ACK 시엔 불필요한 중복 전송이 생긴다.(비효율성 발생)<br/>

&ensp;Performance of RDT 3.0 (Stop-and-Wait)<br/>
&ensp;송신자 활용도(Utilization)<br/>
&ensp;U_sender = fraction of time sender is busy sending<br/>
&ensp;→ 송신자가 실제로 “데이터를 보내는 중”인 시간의 비율을 의미한다.<br/>

&ensp;예제 계산<br/>
&ensp;예시 조건<br/>
* 링크 속도 (R): 1 Gbps
* 전송 지연 (Propagation delay): 15 ms
* 패킷 크기 (L): 8000 bits

&ensp;패킷 전송 시간 (Transmission time)<br/>
&ensp;송신자가 데이터를 링크로 내보내는 데 걸리는 시간: <br/>

&ensp;$D_{trans} = \frac{L}{R} = \frac{8000bits}{10^9bits/sec} = 8μs$ <br/>


&ensp;핵심 포인트 정리표<br/>

| 기능                   | 설명                     |
| -------------------- | ---------------------- |
| **오류 검출 (checksum)** | 비트 손상 감지               |
| **시퀀스 번호 (seq#)**    | 중복 전송 구분               |
| **ACK**              | 성공 응답                  |
| **Timeout**          | 패킷 손실 감지 및 재전송         |
| **Stop-and-Wait 구조** | 하나 보내고, 응답 기다린 후 다음 전송 |

&ensp;TCP와의 연결<br/>
&ensp;RDT 3.0은 TCP의 기초 모델이다. TCP도 동일하게 손실 복귀를 위해 다음 메커니즘을 사용한다.<br/>

| TCP 요소      | RDT 3.0 대응                               |
| ----------- | ---------------------------------------- |
| 타이머 기반 재전송  | Timeout                                  |
| 시퀀스 번호      | seq# (0,1 대신 실제 바이트 번호 사용)               |
| 누적 ACK      | 중복 ACK = NAK 역할                          |
| 손실 탐지 후 재전송 | Fast Retransmit / Timeout Retransmission |

&ensp;핵심 문장 요약<br/>

| 포인트                             | 한 줄 설명               |
| ------------------------------- | -------------------- |
| **RDT 3.0 = RDT 2.2 + Timeout** | 오류 + 손실 모두 처리 가능     |
| **타이머 추가**                      | 일정 시간 내 ACK 없으면 재전송  |
| **seq# 유지**                     | 중복 데이터 구분            |
| **완전한 신뢰적 전송 보장**               | Stop-and-Wait 방식     |
| **TCP의 근간**                     | TCP는 RDT 3.0을 확장한 버전 |

&ensp;RDT 3.0 비트 오류 + 패킷 손실까지 처리하는 완전한 Stop-and-Wait 신뢰적 전송 프로토콜이다. 송신자는 타이머(timeout)를 이용해 손실된 패킷을 감지하고 재전송, 수신자는 시퀀스 번호(seq#)로 중복 패킷을 구분하여 정확한 데이터 전달을 보장한다.<br/>

# RDT 3.0: Stop-and-Wait Operation

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-28.png" width="500"></p>

&ensp;과정 요약<br/>
1. t = 0 → 송신자가 첫 번째 패킷 전송 시작
* 패킷의 비트들이 하나씩 전송되어 채널을 통해 이동함
* 이 파란색 대각선 영역은 패킷이 전송 중(transmitting) 임을 의미
2. first packet bit arrives → 수신자 쪽에 첫 번째 비트 도착
3. last packet bit arrives → send ACK
* 수신자가 모든 비트를 다 받으면 ACK(응답)을 전송
4. ACK arrives → send next packet
* 송신자는 ACK이 도착해야만 다음 패킷을 전송함

&ensp;시간 계산식<br/>
&ensp;송신자는 다음 패킷을 보내기까지 걸리는 총 시간을 이렇게 계산한다.<br/>

&ensp;$t = RTT + \frac{L}{R}$ <br/>

* RTT (Round Trip Time) : 왕복 지연 (데이터 + ACK 왕복 시간)
* L/R : 하나의 패킷을 전송하는 데 걸리는 시간

&ensp;Stop-and-Wait에서는 송신자가 ACK을 받을 때까지 기다리기 때문에 한 번의 전송 주기 동안 하나의 패킷만 전송할 수 있다.<br/>

&ensp;Sender Utilization (송신자 활용도)<br/>
&ensp;이제 송신자가 얼마나 바쁠게 일하는가를 비율로 나타낸 게 이 식이다.<br/>

&ensp;$U_{sender} = \frac{L/R}{RTT + L/R}$ <br/>

&ensp;데이터를 실제로 보내는 시간 / 전체 주기 시간이다.<br/>

&ensp;예제 계산<br/>
* L = 8000 bits
* R = 1 Gbps → L/R = 8 μs (0.008 ms)
* RTT = 30 ms

&ensp;$U_{sender} = \frac{0.008}{30.008} ≈0.00027$ <br/>

&ensp;송신자가 0.027%의 시간만 실제로 데이터를 보내고 나머지 99.973%는 ACK을 기다리는 중!<br/>

&ensp;RDT 3.0’s performance stinks → 아무리 빠른 링크(1Gbps)라도 Stop-and-Wait 구조 때문에 낭비가 심함.<br/>

# Pipelined Protocols: 효율 향상 아이디어

&ensp;Pipelining: 송신자가 여러 개의 패킷을 동시에 보낼 수 있도록 허용하는 것<br/>
&ensp;ACK을 기다리지 않고 여러 패킷을 연속으로 보냄<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-29.png" width="500"></p>

&ensp;필요 조건<br/>

1. 시퀀스 번호 범위 확장
* 여러 패킷이 동시에 존재하므로 seq 번호도 더 커져야 함 (0,1만으로 부족 → 0~N까지 확장)
2.  버퍼링(Buffering)
* 송신자: 아직 ACK을 못 받은 패킷들을 임시 저장
* 수신자: 순서가 꼬인 패킷(out-of-order)을 잠시 저장

&ensp;즉 Pipelining은 Stop-and-Wait의 ‘하나씩 보내기’ 제약을 없앤 개선판이다.<br/>

&ensp;Pipelining의 효과: Utilization 향상<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-30.png" width="500"></p>

&ensp;과정:<br/>
* 첫 번째 패킷 전송 → 이동 중에
* 두 번째 패킷 전송 시작 → 이동 중에
* 세 번째 패킷 전송 시작

&ensp;ACK이 도착할 때쯤에는 이미 다음 데이터들도 전송되고 있다.<br/>

&ensp;계산식<br/>

&ensp;$U_{sender} = \frac{3L/R}{RTT + L/R}$ <br/>

&ensp;(즉 한 번에 3개 보내면 3배 향상)<br/>

&ensp;$U_{sender} = \frac{0.0024}{30.008} = 0.000081$ <br/>

&ensp;이건 여전히 낮지만, Stop-and-Wait보다 3배 향상된 수치<br/>

&ensp;일반화 식<br/>
&ensp;만약 한 번에 N개의 패킷을 보낼 수 있다면<br/>

&ensp;$U_{sender} = \frac{N⋅L/R​}{RTT + L/R}$ <br/>

&ensp;요약<br/>

| 구분                          | 내용                              |
| --------------------------- | ------------------------------- |
| **Stop-and-Wait (RDT 3.0)** | 한 번에 하나의 패킷만 전송                 |
| **Pipelining**              | 여러 패킷을 연속으로 전송 (ACK 기다리지 않음)    |
| **필요 요소**                   | 시퀀스 번호 확장, 버퍼링                  |
| **효율 (Utilization)**        | Stop-and-Wait보다 훨씬 높음           |
| **단점**                      | 손실 시 복구 복잡 (→ Go-Back-N, SR 등장) |


Go-Back-N (GBN) 프로토콜
-----

&ensp;Sender 동작 원리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-31.png" width="500"></p>

&ensp;송신자는 다음 세 구간으로 나뉜 “윈도우(window)”를 가진다:<br/>

| 색상     | 의미                     |
| ------ | ---------------------- |
| 🟩 초록색 | 이미 ACK을 받은 패킷들 (전송 완료) |
| 🟨 노란색 | 전송했지만 아직 ACK을 못 받은 패킷들 |
| 🟦 파란색 | 아직 보낼 수 있는(전송 가능) 패킷들  |
| ⬜ 회색   | 현재 윈도우 범위 밖이라 전송 불가    |


&ensp;send_base → 가장 오래된 전송된(아직 ACK 안 받은) 패킷의 번호<br/>
&ensp;nextseqnum → 다음에 전송할 패킷의 번호<br/>
&ensp;window size (N) → 한 번에 비행 중일 수 있는 패킷의 개수<br/>

&ensp;송신자 동작 단계<br/>
1. 데이터 생성 시
* `nextseqnum < send_base + N` 이면 전송 가능
* 그렇지 않으면 (즉, 윈도우 꽉 찼다면) 대기
2. ACK 수신 시
* 누적 ACK(`ACK(n)`)은 n 이하의 모든 패킷이 도착함을 의미
* 윈도우를 앞으로 이동(슬라이드)하여 다음 패킷들 전송 가능
3. Timeout 발생 시
* 가장 오래된 패킷(send_base) 부터 모든 전송된 패킷 재전송

&ensp;Go-Back-N이라는 이름은 하나라도 손실되면 N개 전부 돌다가서 재전송한다는 뜻이다.<br/>

&ensp;Receiver 동작 원리<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-32.png" width="500"></p>

&ensp;기본 동작<br/>
&ensp;수신자는 항상 순서대로(in-order) 패킷만 처리한다.<br/>

1. 패킷이 순서대로 도착하면:
* ACK을 보냄
* 다음 순번(`rcv_base`)으로 이동
2. 패킷이 순서 밖(out-of-order) 으로 도착하면:
* 버퍼에 저장하지 않거나 버퍼링할 수 있음 (구현 선택 사항)
* 하지만 ACK은 마지막으로 순서대로 받은 패킷 번호로 보냄

&ensp;예<br/>
* 0,1은 정상 수신
* 2번 패킷이 손실
* 3,4가 도착해도 ACK 1만 계속 보냄 (중복 ACK)

&ensp;Receiver 변수<br/>

| 변수         | 설명                             |
| ---------- | ------------------------------ |
| `rcv_base` | 다음에 받을 것으로 기대되는 패킷 번호          |
| **ACK(n)** | “패킷 n까지 정상적으로 받았어” 의미          |
| **중복 ACK** | 순서가 깨졌음을 송신자에게 알림 (손실 신호로 활용됨) |

&ensp;Go-Back-N in Action<br/>

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-33.png" width="500"></p>

&ensp;예시 상황<br/>
* 윈도우 크기 N = 4
* 송신자는 0~3번 패킷을 연속으로 전송

&ensp;1단계-정상 전송<br/>
```makefile
Sender: send pkt0, pkt1, pkt2, pkt3
Receiver: rcv pkt0 → ACK0
           rcv pkt1 → ACK1
           rcv pkt2 ❌ (loss)
```

&ensp;→ pkt2 손실 발생!<br/>

&ensp;2단계-손실 이후 상황<br/>
* 송신자는 ACK2를 기다리지만 오지 않음
* meantime: pkt3은 전송되었으나 수신자는 pkt2가 없으므로 discard
    - → "out-of-order packet" 버림
    - → ACK1을 반복 전송 (중복 ACK)

&ensp;3단계 - Timeout 발생<br/>
```bash
timeout(pkt2)
```

&ensp;→ 송신자는 pkt2부터 윈도우 내 모든 패킷 재전송<br/>

```bash
pkt2, pkt3, pkt4, pkt5 ...
```

&ensp;모두 다시 전송함<br/>

&ensp;4단계 - 복구<br/>
&ensp;수신자는 재전송된 pkt2를 받고 나서 이후 순서대로 도착하는 패킷을 정상적으로 ACK:<br/>
```bash
rcv pkt2 → deliver, send ACK2
rcv pkt3 → deliver, send ACK3
rcv pkt4 → deliver, send ACK4
rcv pkt5 → deliver, send ACK5
```

&ensp;최종적으로 정상 복구 완료!<br/>

| 항목               | 내용                          |
| ---------------- | --------------------------- |
| **윈도우 크기 N**     | 최대 N개의 패킷을 연속 전송 가능         |
| **ACK 방식**       | 누적 ACK (Cumulative ACK)     |
| **수신자 특징**       | 순서대로만 ACK, out-of-order는 무시 |
| **송신자 타이머**      | 가장 오래된 패킷만 타이머 설정           |
| **Timeout 시 행동** | 손실된 패킷 포함 이후 모든 패킷 재전송      |
| **효율성**          | Stop-and-Wait보다 훨씬 빠름       |
| **단점**           | 한 패킷 손실로 인해 불필요한 재전송 다수 발생  |

&ensp;장단점 요약<br/>

| 장점                    | 단점                        |
| --------------------- | ------------------------- |
| ✅ 높은 전송 효율 (파이프라인 구조) | ❌ 한 개 손실로 여러 패킷 재전송 (비효율) |
| ✅ 간단한 구현              | ❌ 대역폭 낭비 가능               |
| ✅ TCP 기본 모델 기반        | ❌ 수신자 버퍼링 부족              |

&ensp;Go-Back-N은 손실이 발생하면 뒤로 돌아가서 다시 전송하는 파이프라인 프로토콜이다. 효율은 높지만 작은 손실에도 많은 재전송이 발생하는 게 단점이다.<br/>

Selective Repeat
-----

&ensp;Selective Repeat(SR)는 Go-Back-N 의 비효율성을 개선한 방식이다.<br/>
&ensp;핵심 아이디어: 손실된 패킷만 개별적으로 재전송한다는 것<br/>

&ensp;특징 요약<br/>
1. Receiver (수신자)
* 각 패킷마다 개별적으로 ACK를 보냄 (Go-Back-N은 누적 ACK 사용)
* 순서가 뒤섞여 도착한 패킷(out-of-order)도 **버퍼(buffer)**에 저장 → 나중에 순서가 맞춰지면 상위 계층에 전달
2. Sender (송신자)
* 각 패킷마다 타이머를 따로 둠 (패킷마다 재전송 관리)
3. Sender Window
* 한 번에 보낼 수 있는 패킷의 최대 개수(N)
* 이 범위를 벗어나면 ACK를 기다려야 함

&ensp;Sender/Receiver 윈도우 구조<br/>
* 송신자(sender)는 window size = N 만큼의 연속된 시퀀스 번호를 사용할 수 있음

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-34.png" width="500"></p>

&ensp;각 색의 의미:<br/>
* 🟩 이미 ACK 받은 패킷
* 🟨 보냈지만 아직 ACK 받지 못한 패킷
* 🟦 전송 가능하지만 아직 안 보낸 패킷
* ⬛ 전송 불가능한 패킷

&ensp;송신자는 이 윈도우(window) 안에서만 데이터를 보낼 수 있고, ACK가 오면 윈도우가 앞으로 밀려 감.<br/>

&ensp;송신자/수신자 동작 방식<br/>
&ensp;Sender 동작<br/>
* 새 데이터가 위에서 오면: 다음 sequence 번호가 윈도우 안이면 바로 전송 
* Timeout(n): 패킷 n이 일정 시간 내에 ACK를 못 받으면 → 해당 패킷 다시 보냄
* ACK(n) 수신 시: n번 패킷이 수신됨을 표시하고 가장 작은 미수신 패킷 번호까지 윈도우를 앞으로 이동

&ensp;Receiver 동작<br/>
* 수신한 패킷 n이 [rcvbase, rcvbase+N-1] 범위에 있으면:
    - ACK(n) 전송
    - 순서가 맞으면 상위 계층으로 전달
    - 순서가 안 맞으면 버퍼에 저장
* 이미 받은 패킷(n < rcvbase):
    - 중복 ACK 전송 (ACK(n))
* 그 외 번호:
    - 무시

&ensp;실제 동작 예시<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-35.png" width="500"></p>

&ensp;윈도우 크기 N=4일 때의 예시<br/>
&ensp;송신자와 수신자 사이에서 pkt2 손실(loss) 발생<br/>

&ensp;과정요약<br/>
1. 송신자는 pkt0~pkt3까지 보냄
2. 수신자는 pkt0, pkt1을 정상 수신 → ACK0, ACK1 보냄
pkt2 손실됨, pkt3, pkt4, pkt5는 버퍼에 저장만 하고 ACK3, ACK4, ACK5 보냄
3. 송신자는 ack3이 온 것을 기록하지만 pkt2의 타임아웃 발생 → pkt2 재전송
4. 수신자는 pkt2를 받자마자 순서대로 pkt2~pkt5까지 모두 상위 계층으로 전달

&ensp;SR은 손실된 패킷만 다시 보내고, 나머지는 그대로 유지!<br/>

&ensp;Selective Repeat의 딜레마<br/>
&ensp;문제 상황<br/>
* 시퀀스 번호가 0,1,2,3이고 (4개만 있음)
* 윈도우 크기가 3이라면…?

&ensp;수신자는 보낸 쪽이 새로운 pkt0을 보낸 건지, 이전의 재전송 pkt0인지 구분 불가<br/>

&ensp;예를 들어<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-36.png" width="500"></p>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-37.png" width="500"></p>

&ensp;(a) 정상적으로 전송된 경우는 괜찮지만 (b) 재전송 타임아웃이 발생해 옛날 pkt0이 다시 오면, 수신자는 그것을 새로운 pkt0으로 착각함 → 데이터 중복 전송 또는 순서 오류 발생 가능<br/>

&ensp;해결 방법
&ensp;Sequence number 공간은 window size의 2배 이상이어야 한다.<br/>
&ensp;Sequence number space size ≥ 2 × Window size<br/>
&ensp;이 관계를 지키면 중복 혼동을 방지<br/>

&ensp;정리 요약<br/>

| 항목     | Go-Back-N      | Selective Repeat         |
| ------ | -------------- | ------------------------ |
| ACK 방식 | 누적 ACK         | 개별 ACK                   |
| 버퍼링    | 불가능 (discard)  | 가능 (out-of-order buffer) |
| 재전송 단위 | 손실된 이후 모든 패킷   | 손실된 패킷만                  |
| 타이머    | 하나 (가장 오래된 패킷) | 각 패킷별 타이머                |
| 효율성    | 낮음             | 높음                       |
| 복잡도    | 낮음             | 높음                       |

Connection-oriented transport: TCP
====

&ensp;TCP Overview<br/>

| 개념                                 | 설명                                                   |
| ---------------------------------- | ---------------------------------------------------- |
| **point-to-point**                 | 한 번의 TCP 연결은 정확히 **1:1 (sender ↔ receiver)** 통신만 지원  |
| **reliable, in-order byte stream** | 데이터 손실 없이, 순서대로 전달 (메시지 경계가 없음 — 스트림 형태)             |
| **full duplex**                    | 양방향 전송 (A↔B 동시에 가능)                                  |
| **cumulative ACKs**                | 여러 세그먼트를 한 번에 ACK (누적 확인 응답)                         |
| **pipelining**                     | 여러 패킷을 동시에 전송 가능 (Go-Back-N/Selective Repeat 개념과 유사) |
| **connection-oriented**            | 연결 수립 (3-way handshake) 후 전송 시작                      |
| **flow controlled**                | 수신자의 처리 속도를 고려해서 전송량 조절                              |

&ensp;TCP는 신뢰적이고 순서가 보장된 양방향 바이트 스트림 전송을 제공하는 프로토콜이다.<br/>

&ensp;TCP Segment Structure<br/>
&ensp;TCP는 IP 위에서 동작하며, 데이터 단위를 세그먼트(segment) 라고 부른다.<br/>

&ensp;주요 필드 정리<br/>

| 필드                                     | 설명                                                                                   |
| -------------------------------------- | ------------------------------------------------------------------------------------ |
| **Source Port # / Destination Port #** | 송신자와 수신자 애플리케이션 식별                                                                   |
| **Sequence Number**                    | 세그먼트 내 **첫 번째 바이트의 번호**                                                              |
| **Acknowledgement Number**             | 상대방으로부터 다음에 기대하는 바이트 번호                                                              |
| **Header Length**                      | TCP 헤더의 길이                                                                           |
| **Flags (C, E, U, A, P, R, S, F)**     | 제어 비트들<br>**SYN**: 연결 요청<br>**FIN**: 연결 종료<br>**ACK**: 응답 확인<br>**RST**: 비정상 연결 종료 등 |
| **Receive Window (rwnd)**              | 수신자가 한 번에 받을 수 있는 **버퍼 크기** (→ 흐름 제어)                                                |
| **Checksum**                           | 오류 검출용                                                                               |
| **Options**                            | MSS(Max Segment Size), Timestamp 등 부가 정보                                             |
| **Data**                               | 실제 전송되는 애플리케이션 데이터                                                                   |

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-38.png" width="500"></p>

&ensp;TCP는 세그먼트 단위로 데이터를 주고받지만 각 세그먼트의 sequence number는 바이트 단위로 번호를 매긴다.<br/>

&ensp;TCP Sequence Numbers & ACKs<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-39.png" width="500"></p>

&ensp;Sequence Number<br/>
* 세그먼트 내 첫 번째 데이터 바이트의 번호
* 예를 들어 1000~1999바이트를 보냈다면 다음 세그먼트의 시퀀스 번호는 2000이 됨

&ensp;ACK Number<br/>
* 다음에 기대하는 바이트 번호
    - 이전까지의 모든 데이터를 받았으니 다음 번호부터 보내라는 의미
* TCP는 누적 ACK(cumulative ACK) 방식 사용 → 연속된 데이터가 모두 수신되면 한 번에 ACK 보냄

&ensp;Out-of-order 처리<br/>
* TCP 표준에서는 순서가 뒤바뀐 세그먼트 처리 방식을 명시하지 않음 → OS나 구현 방식에 따라 다름 (ex. 버퍼링 가능 or 무시)

&ensp;Simple Tenlnet Scenario<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-40.png" width="500"></p>

&ensp;흐름 설명<br/>

| 단계 | 송신자 (Host A)             | 수신자 (Host B)                        |
| -- | ------------------------ | ----------------------------------- |
| ①  | 사용자 입력 ‘C’               |                                     |
| ②  | Seq=42, ACK=79, data=‘C’ | ‘C’ 수신 후 ACK=43 응답 및 ‘C’ 반사(echo)   |
| ③  | Seq=79, ACK=43, data=‘C’ | Host A가 ‘C’를 받았다는 것을 다시 ACK=80으로 회신 |

&ensp;결과적으로 TCP는 양방향 통신이기 때문에 각 방향마다 별도의 시퀀스/ACK 번호 흐름이 유지된다.<br/>

&ensp;정리 요약<br/>

| 개념            | 설명                                                   |
| ------------- | ---------------------------------------------------- |
| **TCP의 목적**   | 신뢰적, 순서보장, 양방향 전송                                    |
| **핵심 기능**     | 오류검출, 흐름제어, 혼잡제어, 연결관리                               |
| **데이터 단위**    | 세그먼트 (segment)                                       |
| **시퀀스 번호 단위** | 바이트 단위 (byte-based numbering)                        |
| **ACK 방식**    | 누적 ACK (Cumulative)                                  |
| **연결 특성**     | 1:1 연결, 양방향(Full Duplex), 연결지향형(Connection-Oriented) |

# TCP RTT와 Timeout 개념

&ensp;RTT(Round Trip Time)<br/>
* 송신자가 세그먼트를 보낸 뒤 ACK(응답)을 받기까지 걸리는 왕복 시간
* 네트워크 상태(혼잡, 거리, 라우팅 등)에 따라 계속 변함

&ensp;Timeout이란?<br/>
* 송신자가 보낸 세그먼트의 ACK이 일정 시간 내에 안 오면 재전송하기 위한 기준 시간
* 네트워크 상태(혼잡, 거리, 라우팅 등)에 따라 계속 변함

&ensp;Timeout이란?
* 송신자가 보낸 세그먼트의 AKC이 일정 시간 내에 안 오면 재전송하기 위한 기준 시간

&ensp;그럼 Timeout 값을 어떻게 설정해야 할까?<br/>

| 경우               | 문제점                                                |
| ---------------- | -------------------------------------------------- |
| ⏱️ **너무 짧게 설정**  | 실제 세그먼트가 도착하기 전에 재전송 시작 → **불필요한 재전송 증가 (중복 트래픽)** |
| 🕰️ **너무 길게 설정** | 손실된 세그먼트에 대한 **대응이 너무 늦어짐** → 성능 저하                |

&ensp;따라서 TCP는 RTT보다 약간 긴 시간으로 timeout을 잡되 RTT가 변동하는 것을 고려해서 동적으로 조정해야 한다.<br/>

&ensp;RTT 측정 방법<br/>

&ensp;SampleRTT<br/>
* 실제 한 세그먼트 전송 → ACK 수신까지의 시간
* 재전송된 세그먼트는 무시(왜냐면 어떤 세그먼트의 ACK인지 헥살릴 수 있으니까)

&ensp;Estimated RTT<br/>
* RTT는 매번 다르기 때문에 최근 측정값 여러 개를 평균 내어 부드럽게 추정

&ensp;Estimated RTT 계산식<br/>
&ensp;EstimatedRTT = (1 - α) × EstimatedRTT + α × SampleRTT<br/>

* α(알파) : 최근 측정값에 얼마나 가중치를 둘지 결정
    - 일반적으로 α = 0.125 (1/8)
* 과거 값의 영향은 지수적으로 감소(Exponential Weighted Moving Average, EWMA)

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-41.png" width="500"></p>

* 파란색: 실제 SampleRTT(불안정, 들쭉날쭉)
* 분홍색: EstimateRTT(평균된 안정적 추세)

&ensp;TCP는 RTT를 실시간으로 학습하고 네트워크 상태에 따라 timeout을 조정하는 적응형 프로토콜이다.<br/>

&ensp;Timeout Interval 계산<br/>
&ensp;TimeoutInterval = EstimatedRTT + 4 × DevRTT<br/>

&ensp;구성 요소 설명<br/>
* EstimatedRTT : RTT의 평균값
* DevRTT (Deviation RTT) : RTT가 얼마나 변동되는지를 나타내는 표준편차
    - RTT의 "흔들림"이 크면 timeout에 더 여유를 둠

&ensp;DevRTT 계산식<br/>
&ensp;DevRTT = (1 - β) × DevRTT + β × |SampleRTT - EstimatedRTT|<br/>
* β(베타) : 보통 0.25 (1/4)
* SampleRTT가 예측보다 너무 높거나 낮을수록 DevRTT가 커짐 → 즉, RTT의 불안정성이 커진다는 뜻

&ensp;TimeoutInterval 의미<br/>

| 상황                   | 결과                                |
| -------------------- | --------------------------------- |
| RTT가 안정적 (DevRTT 작음) | TimeoutInterval이 작아짐 → 빠른 재전송 가능  |
| RTT가 불안정 (DevRTT 큼)  | TimeoutInterval이 커짐 → 불필요한 재전송 방지 |

&ensp;TCP는 RTT의 평균(EstimatedRTT)과 변동폭(DevRTT)을 함께 고려해 유연한 TimeoutInterval 을 설정함으로써 빠른 복구와 불필요한 방지를 동시에 달성한다.<br/>

# TCP Sender 동작

&ensp;TCP 송신자(sender)는 3가지 이벤트(event)에 반응한다.<br/>

| 이벤트                              | 동작                                                                                                                                                |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| 📩 **데이터 수신 (from application)** | - 애플리케이션이 보낸 데이터를 TCP 세그먼트로 만듦<br>- 세그먼트에 **시퀀스 번호(seq #)** 부여 (바이트 단위)<br>- **타이머 시작** (만약 아직 안 돌고 있으면)<br> → 타이머는 “가장 오래된 unACKed(미확인) 세그먼트” 기준 |
| ⏰ **타임아웃 발생 (timeout)**          | - 해당 세그먼트를 **재전송(retransmit)**<br>- 타이머 **재시작** (TimeoutInterval 기준으로)                                                                            |
| ✅ **ACK 수신 (acknowledgement)**   | - 이전에 보내서 아직 확인 안 된 세그먼트 중, ACK가 도착한 부분은 “확인됨”으로 표시<br>- 아직 남아있는 unACKed 세그먼트가 있으면 타이머 유지                                                         |

&ensp;TCP는 타이머와 ACK를 함께 이용해 손실 감지 + 재전송 관리를 자동으로 수행한다.<br/>

# TCP Receiver 동작

&ensp;수신자는 세그먼트 도착 상태에 따라 ACK 생성 방법이 달라진다.<br/>

| 이벤트                                           | 수신자의 동작                                                                                                 |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| ✅ **순서대로(in-order)** 세그먼트 도착, 모든 데이터는 이미 ACK됨 | - **지연 ACK (Delayed ACK)**: 최대 500ms 동안 다음 세그먼트를 기다림<br>- 다음 세그먼트가 오면 한 번에 ACK<br>- 안 오면 500ms 뒤 ACK 전송 |
| ✅ **순서대로(in-order)** 세그먼트 도착, 하나의 ACK가 대기 중   | - **즉시 ACK 전송 (immediate cumulative ACK)**<br>- 이전 세그먼트 + 이번 세그먼트를 한 번에 ACK                             |
| ⚠️ **순서가 어긋난(out-of-order)** 세그먼트 도착 (Gap 발생) | - **즉시 duplicate ACK 전송**<br>- “다음에 기대하는 시퀀스 번호”를 명시 (즉, 아직 빠진 세그먼트를 요청하는 의미)                           |

&ensp;수신자는 누락된 부분을 즉시 알리기 위해 duplicate ACK를 보낸다.<br/>

# TCP 재전송 시나리오 (Retransmission Scenarios)

&ensp;(1) Lost ACK Scenario<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-42.png" width="500"></p>

* ACK 손실: 송신자는 ACK을 못 받았다고 생각해 타임아웃 → 같은 데이터 재전송
* 하지만 수신자는 이미 데이터 받았음 → 중복 ACK 발생 가능

&ensp;결국 중복 전송이 일어나지만 TCP는 데이터 중복 수신 시 자동으로 제거함<br/>

&ensp;(2) Premature Timeout (조기 타임아웃)<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-43.png" width="500"></p>

* 실제 데이터는 잘 도착했지만 ACK이 조금 늦게 옴 → 송신자는 timeout이 너무 짧아서 "손실로 오판"하고 재전송함
* 수신자는 중복된 데이터지만 또 ACK 보냄 → 나중에 누적 ACK(cumulative ACK)가 중복 ACK 문제를 해결함

&ensp;(3) Cumulative ACK<br/>
<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-44.png" width="500"></p>

* 여러 세그먼트를 받았을 때 중간 ACK이 손실돼도 누적 ACK(cumulative ACK)이 그 이전 모든 데이터를 포함함 → 손실된 ACK은 자연스럽게 복구됨

# TCP Fast Retransmit (빠른 재전송)

<p align="center"><img src="/assets/img/Computer Network/chapter3. Transport-layer services/3-45.png" width="500"></p>

&ensp;동작 원리<br/>
* 송신자가 같은 데이터에 대한 duplicate ACK 3개를 연속으로 받으면 → "이건 타임아웃 기다릴 필요 없이 세그먼트가 진짜 손실된 것 같다"고 판단
* 즉시 가장 작은 시퀀스 번호의 세그먼트를 재전송

&ensp;예시<br/>
* 송신자가 Seq=100 세그먼트를 보냄(중간에 손실)
* 이후 세그먼트(Seq=120, 140...)들은 잘 도착
* 수신자는 빠진 부분(Seq=100)을 계속 요구하며 ACK=100을 3번 이상 연속 보냄 → "Triple Duplicate ACKs"

&ensp;송신자는 timeout 없이 즉시 Seq=100 재전송.<br/>

| 개념                  | 설명                                             |
| ------------------- | ---------------------------------------------- |
| **Timer 기반 재전송**    | ACK이 안 오면 timeout → 세그먼트 재전송                   |
| **ACK 기반 업데이트**     | ACK 도착 시, 수신된 데이터 범위 업데이트                      |
| **Duplicate ACK**   | 순서 어긋남 감지 → 빠진 세그먼트 재요청                        |
| **Cumulative ACK**  | 누락된 ACK 자동 복구                                  |
| **Fast Retransmit** | 3회 duplicate ACK 감지 시 즉시 재전송 (timeout 기다리지 않음) |
