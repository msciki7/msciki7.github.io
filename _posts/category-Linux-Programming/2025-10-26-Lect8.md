---
title: "Lect8. Singal"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-10-26
last_modified_at: 2025-10-26
---

Singal
====

&ensp;개념 정리<br/>
&ensp;시그널은 **프로세스 간 통신(IPC)** 의 한 형태로 운영체제가 **프로세스에게 어떤 사건(event)이 발생했음을 알려주는 메시지** 이다.<br/>
&ensp;쉽게 말해: 프로세스야 지금 이런 일이 일어났어 하고 운영체제(kernel)가 알려주는 일종의 알림<br/>

&ensp;시그널의 역할<br/>
* 비정상적이거나 예외적인 상황을 알림 (예: Ctrl + C 입력, 잘못된 메모리 접근, 0으로 나누기, 타이머 종료 등)
* 프로세스 제어: 프로세스를 중지하거나 종료, 혹은 특정 동작을 수행하도록 함
* 프로세스 간 통신: 한 프로세스가 다른 프로세스에 메시지를 전달할 수 있음

&ensp;시그널의 전달 경로<br/>
&ensp;시그널은 두 가지 방식으로 전달된다.<br/>
&ensp;1. 커널 → 프로세스<br/>
&ensp;예: 사용자가 Ctrl + C를 눌러 SIGINT 신호 발생 → 커널이 해당 세션의 모든 프로세스에 시그널 전달<br/>
&ensp;2. 프로세스 → 프로세스<br/>
&ensp;예: 한 프로세스가 kill(pid, SIGTERM)을 호출해 다른 프로세스 종료<br/>

* 예시: Ctrl + C (Interrupt Key)를 누르면
    - 커널이 이 입력을 감지하고,
    - 현재 session에 있는 모든 프로세스에게 "SIGINT" 시그널을 보냄
    - 대부분의 프로세스는 종료됨
    - 하지만 shell 프로세스는 무시! (shell이 종료되면 터미널 전체가 닫히니까 예외적으로 처리)

&ensp;모든 시그널은 <signal.h> 헤더 파일에 정의되어 있음<br/>

&ensp;시그널 처리 방법(Signal Handling)<br/>
&ensp;1. 기본 동작(Default Action)<br/>
&ensp;각 시그널에는 기본 동작이 정해져 있음 → 종료, 무시, 중지, 코어 덤프 등<br/>
&ensp;2. 무시(Ignore)<br/>
&ensp;특정 시그널을 무시할 수도 있음 (e.g. shell이 SIGINT 무시)<br/>
&ensp;3. 지정된 함수 호출(Handler 등록)<br/>
&ensp;프로그래머가 직접 이 시그널이 오면 어떤 함수 실행할지 정의 가능<br/>
```c
signal(SIGINT, handler_function);
```

&ensp;4. 시그널 블록(Block)<br/>
&ensp;특정 구간 동안 시그널을 임시로 차단할 수도 있음 (중요 작업 중 시그널로 방해받지 않기 위해)<br/>

| 구분         | 설명                     | 예시                          |
| ---------- | ---------------------- | --------------------------- |
| **Signal** | 비정상 상황을 알리는 소프트웨어 인터럽트 | SIGINT, SIGTERM, SIGKILL    |
| **발신자**    | 커널 or 다른 프로세스          | Ctrl+C (커널), kill 명령 (프로세스) |
| **기본 동작**  | 종료 / 무시 / 중지 / 코어덤프    | SIGINT → 종료                 |
| **사용 목적**  | 비정상 이벤트 전달, 프로세스 제어    | 프로그램 중단, 프로세스 종료 등          |

&ensp;시그널의 기본 구조<br/>
&ensp;시그널은 “운영체제가 프로세스에게 보내는 이벤트 알림” 이다. 즉, 시그널은 프로세스 간의 간단한 통신(IPC) 방법이며, 프로세스는 받은 시그널에 따라 행동을 결정한다.<br/>
&ensp;시그널이 발생하면<br/>
&ensp;1. 커널이 해당 프로세스의 PCB(Process Control Block) 에 "시그널이 도착했다"는 플래그를 남긴다.<br/>
&ensp;2. 프로세스가 CPU를 얻으면, 커널은 해당 프로세스에게 등록된 시그널 핸들러(handler) 를 실행하거나 기본 동작(default action) 을 수행시킨다.<br/>

child process의 종료 상태 확인
=====

&ensp;프로세스가 종료되면 부모 프로세스는 wait()또는 waitpid()를 호출해서 자식의 종료 상태를 받아볼 수 있다.<br/>

&ensp;코드 구조<br/>
```c
pid = wait(&status);

if (WIFEXITED(status)) { // 정상 종료인 경우
    printf("정상 종료, exit code = %d\n", WEXITSTATUS(status));
}

if (WIFSIGNALED(status)) { // 시그널로 인해 종료된 경우
    printf("signal에 의해 종료됨, signal 번호 = %d\n", WTERMSIG(status));
}
```

&ensp;흐름 요약<br/>

| 단계 | 동작                          | 설명                     |
| -- | --------------------------- | ---------------------- |
| 1  | 자식 프로세스 종료                  | exit() 또는 signal로 종료됨  |
| 2  | 커널이 종료 상태 저장                | 부모의 PCB에 자식 종료 상태 기록   |
| 3  | 부모의 wait() 호출               | 종료된 자식의 상태(status) 가져옴 |
| 4  | WIFEXITED / WIFSIGNALED로 구분 | 정상 종료인지, 시그널 종료인지 확인   |

&ensp;자식이 어떻게 죽었는지(정상 / 시그널) 를 알 수 있는 함수들이 WIFEXITED, WIFSIGNALED 이다.<br/>

signal 보내기
=====

&ensp;`kill()` 함수<br/>
&ensp;`kill()` 은 프로세스에게 시그널을 보내고 시스템 콜이다. (이름 때문에 죽이는 함수로 오해하지만 실제로는 시그널을 보내는 함수이다.)<br/>

```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

&ensp;매개변수 설명<br/>
* `pid` : 시그널을 받을 프로세스의 PID
* `sig` : 보낼 시그널 번호 (예: SIGINT, SIGKILL, SIGUSR1 등)

&ensp;예시<br/>
```c
kill(1234, SIGINT);   // PID 1234에게 SIGINT (Ctrl+C와 동일) 전송
kill(getpid(), SIGSTOP); // 자기 자신을 일시정지
```

&ensp;pid 값에 따른 전달 범위<br/>
&ensp;시그널을 보낼 대상을 더 유연하게 지정할 수 있다.<br/>

| pid 값                  | 의미                                             |
| ---------------------- | ---------------------------------------------- |
| **pid > 0**            | 해당 pid의 프로세스에게만 signal 전달                      |
| **pid = 0**            | 현재 프로세스와 같은 process group의 모든 프로세스에게 signal 전달  (sender 자신 포함) |
| **pid = -1**           | sender의 euid(파일 소유자의 권한이 있는)와 같은 모든 process에게 signal 전달 (sender 자신 포함) |
| **pid < 0 (단, != -1)** | 절댓값이 pid인 **process group**에 signal 전달         |


&ensp;권한 주의<br/>
&ensp;다른 사용자(user)의 프로세스에 시그널을 보내면 kill()은 -1을 반환하고 에러가 발생한다.(권한 없음)<br/>

&ensp;`raise()` <br/>
&ensp;`raise()` 함수는 자기 자신에게 시그널을 보내는 함수이다. 즉 `kill(getpid(), sig)` 와 동일한 효과를 가진다.<br/>

```c
#include <signal.h>

int raise(int sig);
```

&ensp;동작<br/>
* 현재 프로세스에게 sig 시그널을 보냄
* 핸들러가 등록되어 있으면 핸들러 실행
* 등록되어 있지 않으면 기본 동작 수행

&ensp;예시<br/>
```c
#include <stdio.h>
#include <signal.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    signal(SIGUSR1, handler); // SIGUSR1 핸들러 등록
    raise(SIGUSR1);           // 자기 자신에게 보냄
    printf("프로그램 종료\n");
}
```

&ensp;실행결과<br/>
```scss
시그널 10 받음!   ← raise() 호출 시 핸들러 실행됨
프로그램 종료
```

&ensp;전체 흐름 정리<br/>
```css
[1] 시그널 발생 (Ctrl+C, kill(), raise(), 타이머 등)
        ↓
[2] 커널이 해당 프로세스의 PCB에 시그널 플래그 설정
        ↓
[3] 프로세스가 CPU를 얻으면
        ↓
    (a) 등록된 handler가 있으면 → handler 함수 실행
    (b) 없으면 → 기본 동작(default action) 수행
        - 종료 / 무시 / 중지 / 코어덤프
        ↓
[4] 자식 프로세스 종료 시 → 부모가 wait()으로 종료 상태 확인
```

Signal Handling (시그널 처리)
=====

&ensp;개념 정리<br/>
&ensp;시그널이란 커널이 프로세스에게 보내는 알림(이벤트)이고 시그널 핸들링(signal handling)은 그 알림을 프로세스가 어떻게 처리할지 정희하는 과정이다.<br/>

&ensp;signal handling 기본 구조<br/>

| 처리 방식                  | 설명                      | 예시                         |
| ---------------------- | ----------------------- | -------------------------- |
| **1️⃣ Default action** | 시스템이 미리 정의한 기본 동작 수행    | `SIGINT` → 프로세스 종료         |
| **2️⃣ 무시 (ignore)**    | 시그널을 무시하고 아무 일도 하지 않음   | `signal(SIGINT, SIG_IGN);` |
| **3️⃣ 사용자 정의 함수 호출**   | 특정 시그널이 오면 직접 작성한 함수 실행 | `signal(SIGINT, handler);` |

&ensp;예시: signal() 함수로 핸들러 설정<br/>
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    signal(SIGINT, handler); // Ctrl + C 입력 시 handler 실행
    while (1) {
        printf("실행 중...\n");
        sleep(1);
    }
    return 0;
}
```

&ensp;실행결과<br/>
&ensp;Ctrl + C를 누르면 종료되지 않고 다음처럼 출력됨:<br/>
```scss
실행 중...
실행 중...
^C시그널 2 받음!
실행 중...
```

&ensp;➡ 기본 동작(종료)을 덮어쓰고, 사용자가 정의한 행동(handler)을 수행함.<br/>

&ensp;`signal()` 함수는 간단하지만 시스템에 따라 동작이 다르고 불안정한 경우가 있다. 그래서 실제 리눅스 프로그래밍에서는 sigaction()을 사용한다.<br/>

&ensp;sigaction의 역할<br/>
&ensp;시그널이 발생했을 때 원하는 행동을 세밀하게 지정할 수 있도록 함<br/>
* `SIGSTOP` (일시 중지)과 `SIGKILL` (강제 종료)은 예외 → 이 두 시그널은 어떤 방법으로도 잡거나 무시할 수 없음.

&ensp;함수 원형<br/>
```c
#include <signal.h>

int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact);
```

| 인자       | 설명                                     |
| -------- | -------------------------------------- |
| `signo`  | 지정할 시그널 번호 (예: SIGINT, SIGUSR1 등)      |
| `act`    | 시그널이 왔을 때 수행할 행동(struct sigaction 구조체) |
| `oldact` | 기존 시그널 처리를 저장하고 싶을 때 사용 (NULL 가능)      |

&ensp;struct sigaction 구조<br/>
&ensp;sigaction 함수는 이 구조체를 사용해 동작을 지정한다.<br/>
```c
struct sigaction {
    void (*sa_handler)(int);           // 간단한 핸들러 함수
    sigset_t sa_mask;                  // 블록할 시그널 집합
    int sa_flags;                      // 동작 옵션
    void (*sa_sigaction)(int, siginfo_t *, void *); // 확장형 핸들러
};
```

&ensp;각 멤버 설명<br/>
| 멤버             | 설명                                              |
| -------------- | ----------------------------------------------- |
| `sa_handler`   | 기본적인 시그널 핸들러 함수 포인터. ex) `handler(int sig)`     |
| `sa_mask`      | 핸들러가 실행되는 동안 **임시로 차단할 시그널 집합**                 |
| `sa_flags`     | 동작 옵션 (예: SA_RESTART, SA_SIGINFO 등)             |
| `sa_sigaction` | 고급형 핸들러. 시그널 번호, 시그널 정보, 프로세스 context까지 받을 수 있음 |

&ensp;예시 코드<br/>
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    struct sigaction act;

    act.sa_handler = handler;   // 실행할 함수 지정
    sigemptyset(&act.sa_mask);  // 블록할 시그널 없음
    act.sa_flags = 0;           // 기본 설정

    sigaction(SIGINT, &act, NULL); // Ctrl + C 시 handler 실행

    while (1) {
        printf("실행 중...\n");
        sleep(1);
    }
    return 0;
}
```

&ensp;실행 결과<br/>
```scss
실행 중...
^C시그널 2 받음!
실행 중...
```

&ensp;handler vs sigaction 비교 정리<br/>
| 구분     | signal() | sigaction()             |
| ------ | -------- | ----------------------- |
| 사용 난이도 | 쉬움       | 약간 복잡함                  |
| 설정 안정성 | 시스템마다 다름 | POSIX 표준, 안전            |
| 추가 기능  | 없음       | 마스크/플래그 등 다양한 설정 가능     |
| 확장성    | 제한적      | sa_sigaction으로 상세 정보 제공 |

&ensp;전체 흐름 요약<br/>
```markdown
1. 프로세스가 시그널을 받음
        ↓
2. 커널이 해당 시그널의 처리 방식 확인
        ↓
3. 등록된 핸들러가 있으면 → 핸들러 실행
   없으면 → 기본 동작 수행 (종료/중지/무시)
        ↓
4. sigaction을 사용하면 블록, 옵션 등 세밀한 제어 가능
```

sigaction
=====

&ensp;`sa_handler` - 시그널이 왔을 때 실행할 행동 지정<br/>
&ensp;`sa_handler` 는 시그널을 받았을 때 어떤 행동을 취할지 지정하는 포인터이다. 즉 이 시그널이 오면 이 함수를 실행하라 라는 의미이다.<br/>

```c
void (*sa_handler)(int);
```

| 구분        | 설명                                | 예시                 |
| --------- | --------------------------------- | ------------------ |
| `SIG_DFL` | Default Action — 시스템이 정한 기본 동작 수행 | `SIGINT` → 종료      |
| `SIG_IGN` | Ignore — 시그널 무시                   | Ctrl+C 눌러도 종료 안 됨  |
| 사용자 정의 함수 | 시그널이 오면 직접 만든 함수 실행               | `handler(int sig)` |

&ensp;기본 동작(Default)<br/>
```c
act.sa_handler = SIG_DFL; // 시스템 기본 동작 수행 (보통 종료)
```

&ensp;무시(Ignore)<br/>
```c
act.sa_handler = SIG_IGN; // 시그널 무시
```

&ensp;사용자 정의 핸들러<br/>
```c
void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

act.sa_handler = handler;
```

&ensp;동작 순서<br/>
&ensp;시그널 발생 → 커널이 sa_handler 확인 → 해당 함수로 제어 이동 → 함수 실행 완료 후 원래 코드로 복귀 (return)<br/>

&ensp;sigset_t sa_mask, int sa_flags<br/>
&ensp;`sigaction` 구조체에는 `sa_mask`와 `sa_flags`라는 중요한 멤버도 있다. 이 둘은 시그널이 처리되는 동안 다른 시그널을 일시적으로 막거나 특정 옵션을 지정할 때 사용된다.<br/>

&ensp;1. `sigset_t sa_mask` <br/>
&ensp;시그널 핸들러가 실행되는 동안 차단(blocking)할 시그널 집합을 정의한다.<br/>
```c
sigset_t sa_mask;
```

* `sigemptyset(&act.sa_mask);` → 차단할 시그널 없음
* `sigaddset(&act.sa_mask, SIGINT);` → handler 실행 중에는 SIGINT를 차단 (중복 호출 방지)

&ensp;예시<br/>
&ensp;만약 SIGUSR1을 처리 중인데 같은 시그널이 계속 들어오면?<br/>
&ensp;→ sa_mask에 SIGUSR1이 포함되어 있으면 handler가 끝날 때까지 차단됨.<br/>

&ensp;2. `int sa_flags` <br/>
&ensp;시그널 처리의 동작 옵션을 지정하는 플래그<br/>

| 플래그            | 설명                                                     |
| -------------- | ------------------------------------------------------ |
| `SA_RESETHAND` | 핸들러가 한 번 실행된 뒤 자동으로 기본 동작(SIG_DFL)으로 복귀함               |
| `SA_SIGINFO`   | `sa_handler` 대신 `sa_sigaction`을 사용 (시그널 정보까지 받는 고급 버전) |

&ensp;`SA_RESETHAND` 예시<br/>
```c
act.sa_handler = handler;
act.sa_flags = SA_RESETHAND;
```

&ensp;➡ 한 번만 사용자 함수 실행, 그 이후에는 기본 동작 수행 (보통 종료)<br/>

&ensp;`SA_SIGINFO` 예시
```c
void handler(int sig, siginfo_t *info, void *context) {
    printf("Signal %d from PID %d\n", sig, info->si_pid);
}

act.sa_sigaction = handler;
act.sa_flags = SA_SIGINFO;
```

&ensp;➡ 시그널 번호뿐 아니라, 누가 보냈는지(pid), 어떤 이유로 발생했는지 등의 정보까지 받을 수 있음.<br/>

&ensp;전체 구조요약<br/>
```c
struct sigaction {
    void     (*sa_handler)(int);           // 시그널 핸들러 함수
    sigset_t  sa_mask;                     // 핸들러 실행 중 차단할 시그널
    int       sa_flags;                    // 플래그 옵션
    void     (*sa_sigaction)(int, siginfo_t *, void *); // 확장형 핸들러
};
```

&ensp;전체 동작 흐름<br/>
```bash
1️⃣ 시그널 발생 (kill(), Ctrl+C 등)
       ↓
2️⃣ 커널이 프로세스의 sigaction 테이블 확인
       ↓
3️⃣ sa_handler 또는 sa_sigaction에 따라 처리
       ↓
   - sa_mask에 지정된 시그널은 잠시 차단됨
   - sa_flags 옵션에 따라 추가 동작 수행
       ↓
4️⃣ handler 실행 후 원래 프로그램 복귀
```

&ensp;signal 사용 예제 완전 정리<br/>

&ensp;기본 예제-SIGINT<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

main() {
    static struct sigaction act;
    void catchint(int);  // 시그널 처리 함수 선언

    act.sa_handler = catchint;          // SIGINT 수신 시 실행할 함수 지정
    sigaction(SIGINT, &act, NULL);      // SIGINT에 대한 동작 등록

    printf("sleep call1\n");
    sleep(1);
    printf("sleep call2\n");
    sleep(1);
    printf("exiting\n");
    exit(0);
}

void catchint(int signo) {
    printf("\nCATCHINT: signo=%d\n", signo);
}
```

&ensp;코드 동작 흐름<br/>

| 단계  | 동작                                                              |
| --- | --------------------------------------------------------------- |
| 1️⃣ | `sigaction(SIGINT, &act, NULL);` → SIGINT에 대해 catchint() 함수를 등록 |
| 2️⃣ | 프로그램이 실행 중에 `Ctrl + C` 입력                                       |
| 3️⃣ | 커널이 해당 프로세스에게 SIGINT 시그널 전송                                     |
| 4️⃣ | 기본 동작(종료) 대신 `catchint()` 함수 실행                                 |
| 5️⃣ | `printf("\nCATCHINT: signo=2\n")` 출력 후 계속 실행                    |

&ensp;실행 예시<br/>
```bash
$ ./a.out
sleep call1
^C
CATCHINT: signo=2
sleep call2
exiting
```

&ensp;➡ Ctrl+C를 눌러도 프로그램이 종료되지 않고 사용자가 정의한 핸들러(`catchint`)가 실행됨.<br/>

* SIGINT는 보통 Ctrl+C 입력 시 발생
* sigaction()을 사용하면 이 시그널을 직접 처리하거나 무시할 수 있음
* sa_handler에 등록한 함수는 시그널이 도착하면 호출되는 일종의 인터럽트 핸들러 역할을 함

&ensp;SIGINT 무시 / 기본동작 복귀<br/>
1. 사용자 정의 함수 호출
2. 무시(`SIG_IGN`)
3. 기본 동작(`SIG_DEL`)

&ensp;SIGINT 무시<br/>
```c
act.sa_handler = SIG_IGN;     // SIGINT 무시 설정
sigaction(SIGINT, &act, NULL);
```

&ensp;➡ Ctrl+C를 눌러도 프로그램이 종료되지도 않고, 핸들러도 실행되지 않음. 커널이 SIGINT를 보냈지만 프로세스가 “난 이 신호 안 받을래!”라고 한 것.<br/>

&ensp;SIGINT 기본 동작 복귀<br/>
```c
act.sa_handler = SIG_DFL;     // SIGINT 기본 동작 수행
sigaction(SIGINT, &act, NULL);
```

&ensp;➡ Ctrl+C 입력 시 다시 원래처럼 프로세스가 종료됨.<br/>

| 설정값       | 의미              | 결과                 |
| --------- | --------------- | ------------------ |
| `SIG_DFL` | Default (기본 동작) | SIGINT → 종료        |
| `SIG_IGN` | Ignore (무시)     | SIGINT → 무시        |
| 사용자 함수    | Custom Handler  | SIGINT → 지정한 함수 실행 |


&ensp;여러 시그널 처리 및 exec()의 특성<br/>
&ensp;여러 시그널 무시하기<br/>
```c
act.sa_handler = SIG_IGN;  // 무시 설정
sigaction(SIGINT, &act, NULL);   // Ctrl+C 무시
sigaction(SIGQUIT, &act, NULL);  // Ctrl+\ 무시
```

&ensp;➡ SIGINT와 SIGQUIT 모두 무시됨. (SIGQUIT은 일반적으로 Ctrl+\ 입력 시 발생) <br/>

&ensp;`exec()` 이후에도 무시 상태 유지<br/>
&ensp;한 프로세스에서 무시된 시그널은 `exec()` 호출 후에도 계속 무시된다.<br/>
&ensp;`exec()`는 새로운 프로그램을 시핼하지만 "무시" 설정된 시그널은 그대로 유지된다.<br/>
&ensp;반면 사용자 정의 핸들러(`sa_handler = hander`)는 `exec()` 후에 사라지고 기본 동작으로 초기화된다.<br/>

| 동작 유형          | exec() 후 유지 여부      | 비고              |
| -------------- | ------------------- | --------------- |
| `SIG_IGN` (무시) | ✅ 유지됨               | 예: SIGINT 무시 지속 |
| 사용자 핸들러        | ❌ 리셋됨 (SIG_DFL로 복귀) | 안전성 이유          |
| `SIG_DFL` (기본) | ✅ 그대로 유지            | 시스템 기본 동작 유지    |

&ensp;전체 요약표<br/>

| 목적         | 설정 코드                                                            | 결과               |
| ---------- | ---------------------------------------------------------------- | ---------------- |
| 사용자 함수로 처리 | `act.sa_handler = handler;`                                      | 시그널 발생 시 함수 실행   |
| 시그널 무시     | `act.sa_handler = SIG_IGN;`                                      | 아무 반응 없음         |
| 기본 동작 수행   | `act.sa_handler = SIG_DFL;`                                      | 기본 동작(종료 등) 수행   |
| 여러 시그널 처리  | `sigaction(SIGINT, &act, NULL); sigaction(SIGQUIT, &act, NULL);` | 여러 시그널 동시에 제어 가능 |

* `sigaction()`은 시그널의 행동(핸들러, 무시, 기본동작)을 지정하는 함수
* `SIGINT` 은 Ctrl+C 입력 시 발생
* `SIGQUIT` 은 Ctrl+\ 입력 시 발생
* `SIG_IGN` 은 exec() 후에도 유지되지만 사용자 핸들러는 exec() 후 사라짐 
* 실습 시 `sleep()` 을 사용하면 시그널을 보낼 타이밍을 확보할 수 있음



&ensp;내부 매커니즘 이해<br/>
&ensp;리눅스에서는 터미널 입력을 담당하는 커널 드라이브가 있다. 이 드라이버는 사용자가 특수 키를 누르면 자동으로 특정 시그널을 보낸다.<br/>

| 키 입력         | 발생하는 시그널  | 설명                                |
| ------------ | --------- | --------------------------------- |
| **Ctrl + C** | `SIGINT`  | Interrupt 시그널 (프로세스 중단 요청)        |
| **Ctrl + \** | `SIGQUIT` | Quit 시그널 (프로세스 종료 + core dump 생성) |
| **Ctrl + Z** | `SIGTSTP` | Stop 시그널 (일시정지 — background로 보내기) |


Signal 집합 지정(sigset_t)
====

&ensp;시그널을 하나씩 처리할 수도 있지만 때로는 여러 개의 시그널ㅇ르 묶어서 관리해야 할 때가 있다. 이때 사용하는 자료형이 바로 sigset_t 이다.<br/>

&ensp;용도<br/>
&ensp;`sigset_t` 는 시그널들의 집합(세트)을 표현하는 자료형이다.<br/>
&ensp;예를 들어<br/>
* SIGINT와 SIGQUIT을 동시에 차단(block)
* SIGCHLD는 제외하고 나머지 모두 포함

&ensp;이런 경우 sigset_t를 이용해서 지정한다.<br/>

&ensp;주요 함수 목록<br/>
```c
#include <signal.h>

int sigemptyset(sigset_t *set);    // 집합 비우기 (초기화)
int sigfillset(sigset_t *set);     // 모든 시그널 추가
int sigaddset(sigset_t *set, int signo);   // 특정 시그널 추가
int sigdelset(sigset_t *set, int signo);   // 특정 시그널 제거
int sigismember(const sigset_t *set, int signo); // 포함 여부 확인
```

&ensp;사용 흐름<br/>
1. `sigemptyset()`으로 집합 초기화
2. `sigaddset()`으로 필요한 시그널 추가
3. 필요하면 `sigdelset()`으로 제외
4. `sigismember()`로 확인 가능

&ensp;이렇게 정의한 시그널 집합은 `sigaction` 구조체의 `sa_mask` 나 `phread_sigmask()` 같은 곳에 전달되어 시그널 블록 동작에 사용된다.<br/>

&ensp;예시 코드<br/>
```c
sigset_t mask;

sigemptyset(&mask);              // 비어있는 집합 생성
sigaddset(&mask, SIGINT);        // SIGINT 추가
sigaddset(&mask, SIGQUIT);       // SIGQUIT 추가
```

&ensp;이렇게 하면 mask에는 두 개의 시그널(SIGINT, SIGQUIT)이 들어 있다. 핸들러 실행 중 mask를 지정하면 이 두 시그널은 잠시 차단된다.<br/>

&ensp;실제 예시<br/>
```c
sigset_t mask1, mask2;

sigemptyset(&mask1);           // 비어있는 집합
sigaddset(&mask1, SIGINT);     // SIGINT 추가
sigaddset(&mask1, SIGQUIT);    // SIGQUIT 추가

sigfillset(&mask2);            // 모든 시그널 추가
sigdelset(&mask2, SIGCHLD);    // SIGCHLD만 제거
```

&ensp;실행 결과 개념<br/>

| 변수        | 의미                            |
| --------- | ----------------------------- |
| **mask1** | SIGINT, SIGQUIT만 포함된 집합       |
| **mask2** | 모든 시그널 포함 but SIGCHLD는 제외된 집합 |

&ensp;이렇게 만들어진 시그널 집합은 어디에 쓰일까?<br/>
&ensp;➡ 보통 sigaction의 sa_mask에 넣어서 핸들러가 실행되는 동안 특정 시그널을 자동으로 block하도록 한다.<br/>

&ensp;예시<br/>
```c
act.sa_mask = mask1; // handler 실행 중 SIGINT, SIGQUIT 차단
```

&ensp;즉 handler가 실행 중일 때 같은 시그널이 반복해서 들어오지 않게 막는 기능이다.<br/>

&ensp;sa_sigaction()에 의한 고급 signal handling<br/>

&ensp;`sa_sigaction()` 은 기존의 `sa_handler` 보다 더 자세한 시그널 정보를 제공하는 고급 핸들러이다.<br/>

&ensp;코드 예시<br/>
```c
int main(void) {
    static struct sigaction act;
    act.sa_flags = SA_SIGINFO;           // 고급 핸들러 사용 플래그
    act.sa_sigaction = handler;          // handler 등록
    sigaction(SIGUSR1, &act, NULL);      // SIGUSR1 처리 설정
    ...
}

void handler(int signo, siginfo_t *sf, ucontext_t *uc) {
    psiginfo(sf, "...!");                // 시그널 정보 출력
    printf("%d\n", sf->si_code);         // 발생 원인 코드 출력
}
```

&ensp;핵심 포인트<br/>

| 요소                                  | 설명                                      |
| ----------------------------------- | --------------------------------------- |
| `sa_flags = SA_SIGINFO`             | 이 설정을 해야 `sa_sigaction`이 작동             |
| `handler(int, siginfo_t *, void *)` | 3개의 인자 사용                               |
| `siginfo_t` 구조체                     | 시그널 관련 상세 정보 저장                         |
| `psiginfo()`                        | siginfo_t 내용을 보기 쉽게 출력하는 함수             |
| `sf->si_code`                       | 시그널 발생 원인 코드 (예: 커널, kill(), 하드웨어 예외 등) |

&ensp;`siginfo_t` 구조체 예시<br/>
```c
typedef struct siginfo {
    int si_signo;    // 시그널 번호
    int si_errno;    // 관련 오류 번호 (없으면 0)
    int si_code;     // 시그널 발생 원인
    pid_t si_pid;    // 시그널을 보낸 프로세스 PID
    uid_t si_uid;    // 보낸 프로세스의 사용자 ID
    void *si_addr;   // 메모리 접근 예외 주소
} siginfo_t;
```

&ensp;이 정보를 통해 누가 시그널을 보냈는지 어떤 이유로 발생했는지 등을 세밀하게 알 수 있다.<br/>

&ensp;예시 실행 흐름<br/>
1. 부모 프로세스가 kill(child_pid, SIGUSR1);
2. 자식 프로세스가 sa_sigaction으로 등록된 handler 실행
3. handler 내부에서 sf->si_pid로 “시그널을 보낸 부모 PID” 출력 가능

&ensp;예시 출력<br/>
```yaml
Signal: SIGUSR1
Sent by PID: 1234
Reason: user
Code: SI_USER
```

&ensp;전체 요약표<br/>
| 개념            | 주요 함수 / 구조                               | 설명                           |
| ------------- | ---------------------------------------- | ---------------------------- |
| **시그널 집합 지정** | `sigset_t`, `sigemptyset`, `sigaddset` 등 | 시그널들을 묶어서 관리                 |
| **시그널 블록 기능** | `sa_mask`                                | handler 실행 중 특정 시그널 임시 차단    |
| **기본 핸들러**    | `sa_handler(int)`                        | 간단한 처리 (시그널 번호만)             |
| **고급 핸들러**    | `sa_sigaction(int, siginfo_t*, void*)`   | 시그널 원인, 보낸 PID 등 세부 정보 확인 가능 |
| **활성화 조건**    | `sa_flags = SA_SIGINFO`                  | sa_sigaction 사용을 위한 설정       |


이전의 설정 복원하기 (sigaction 복원)
====

&ensp;`sigaction()`은 새 시그널 동작을 설정할 때 기존에 설정되어 있던 시그널 동작을 백업해 둘 수 있다.<br/>

&ensp;코드 예시<br/>
```c
struct sigaction act, oact;

// 과거 설정 저장
sigaction(SIGTERM, NULL, &oact);

// 현재 동작을 무시로 변경
act.sa_handler = SIG_IGN;
sigaction(SIGTERM, &act, NULL);

// ... 중간에 원하는 코드 실행 ...
printf("SIGTERM 무시 중...\n");

// 과거 설정 복원
sigaction(SIGTERM, &oact, NULL);
```

&ensp;흐름 요약<br/>

| 단계                                  | 설명                        |
| ----------------------------------- | ------------------------- |
| ① `sigaction(SIGTERM, NULL, &oact)` | 기존 SIGTERM 설정을 `oact`에 저장 |
| ② `act.sa_handler = SIG_IGN`        | 시그널 무시로 변경                |
| ③ `sigaction(SIGTERM, &act, NULL)`  | 무시 설정 적용                  |
| ④ `sigaction(SIGTERM, &oact, NULL)` | 이전 설정 복원                  |

alarm signal 설정
=====

&ensp;alarm()은 일정 시간이 지나면 SIGALRM 시그널을 발생시켜주는 타이머이다.<br/>

&ensp;사용법<br/>
```c
#include <signal.h>

unsigned int alarm(unsigned int seconds);
```

* seconds: 초 단위 타이머
* 지정된 시간이 지나면 프로세스에 `SIGALRM` 시그널 전달

&ensp;주요 특징<br/>

| 항목                 | 설명                           |
| ------------------ | ---------------------------- |
| `alarm(5)`         | 5초 후 SIGALRM 시그널 발생          |
| `alarm(0)`         | 현재 설정된 alarm 취소              |
| `alarm()`은 누적되지 않음 | 새 alarm이 기존 alarm을 덮어씀       |
| `exec()` 후에도 유지    | 하지만 `fork()` 후 자식에게는 적용되지 않음 |
| `alarm()`의 반환값     | 이전 alarm이 남아있던 잔여 시간(초 단위)   |

&ensp;예시코드<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void handler(int sig) {
    printf("시간이 끝났습니다! SIGALRM 발생!\n");
}

int main() {
    signal(SIGALRM, handler);
    alarm(3); // 3초 후 시그널 발생

    printf("3초 기다리는 중...\n");
    pause(); // 시그널이 올 때까지 대기
    return 0;
}
```

&ensp;출력예시<br/>
```bash
3초 기다리는 중...
시간이 끝났습니다! SIGALRM 발생!
```

signal blocking (시그널 차단)
=====

&ensp;프로세스가 시그널을 받을 때 특정 시그널을 일시적으로 차단(block)하고 싶을 수 있다. 이때 사용하는 함수가 sigprocmask()이다.<br/>

&ensp;함수 원형<br/>
```c
#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
```

&ensp;매개변수 설정<br/>

| 인자     | 설명                       |
| ------ | ------------------------ |
| `how`  | 어떤 동작을 할지 지정             |
| `set`  | 추가/삭제할 시그널 집합            |
| `oset` | 현재 시그널 마스크 저장용 (NULL 가능) |

&ensp;how 옵션<br/>

| 상수            | 의미                     |
| ------------- | ---------------------- |
| `SIG_BLOCK`   | `set`에 포함된 시그널을 추가로 차단 |
| `SIG_UNBLOCK` | `set`에 포함된 시그널 차단 해제   |
| `SIG_SETMASK` | 현재 마스크를 `set`으로 완전히 교체 |


&ensp;예시 코드<br/>
```c
sigset_t mask;
sigemptyset(&mask);
sigaddset(&mask, SIGINT);

// SIGINT 차단
sigprocmask(SIG_BLOCK, &mask, NULL);
printf("Ctrl+C 무시 (차단 중)...\n");
sleep(5);

// SIGINT 차단 해제
sigprocmask(SIG_UNBLOCK, &mask, NULL);
printf("Ctrl+C 다시 활성화됨!\n");
```

&ensp;실행 흐름<br/>
1. SIG_BLOCK → SIGINT를 임시 차단
2. sleep 중에 Ctrl+C 눌러도 반응 없음
3. SIG_UNBLOCK → 다시 활성화

pause() 시스템 호출
====

&ensp;pause()는 프로세스 실행을 시그널이 도착할 때까지 일시 정지시키는 함수이다.<br/>

&ensp;사용법<br/>
```c
#include <unistd.h>

int pause(void);
```

&ensp;동작 원리<br/>

| 단계  | 설명                                   |
| --- | ------------------------------------ |
| 1️⃣ | 프로세스가 `pause()` 호출 시 실행을 멈춤          |
| 2️⃣ | 커널이 “시그널이 도착할 때까지” 기다림               |
| 3️⃣ | 시그널이 도착하면 handler 실행                 |
| 4️⃣ | handler 종료 후 `pause()`가 `-1` 반환하고 복귀 |

&ensp;예시 코드<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    signal(SIGINT, handler);
    printf("Ctrl+C 기다리는 중...\n");
    pause();   // 시그널이 오기 전까지 CPU 사용 안 함
    printf("pause() 종료됨\n");
    return 0;
}
```

&ensp;실행 예시<br/>
```scss
Ctrl+C 기다리는 중...
^C시그널 2 받음!
pause() 종료됨
```

&ensp;정리<br/>

| 함수                    | 역할                      |
| --------------------- | ----------------------- |
| `pause()`             | 시그널이 도착할 때까지 프로그램 일시 정지 |
| `SIGALRM`             | 일정 시간 후 자동으로 시그널 보내기    |
| `sigprocmask()`       | 특정 시그널을 블록하거나 해제        |
| `sigaction()`         | 시그널의 처리 동작 지정           |
| `alarm()` + `pause()` | 타이머 기반 동작 구현 시 자주 함께 사용 |

&ensp;실제 예시: alarm + pause 함께 사용<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void alarm_handler(int sig) {
    printf("3초 타이머 종료!\n");
}

int main() {
    signal(SIGALRM, alarm_handler);
    alarm(3); // 3초 뒤 SIGALRM 발생

    printf("3초 동안 대기 중...\n");
    pause(); // 시그널 올 때까지 대기
    printf("종료!\n");
}
```

&ensp;결과<br/>
```bash
3초 동안 대기 중...
3초 타이머 종료!
종료!
```
