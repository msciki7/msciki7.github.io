---
title: "Lect8. Singal"
excerpt: ""

writer: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-10-26
last_modified_at: 2025-10-26
---

Singal
====

&ensp;개념 정리<br/>
&ensp;시그널은 **프로세스 간 통신(IPC)** 의 한 형태로 운영체제가 **프로세스에게 어떤 사건(event)이 발생했음을 알려주는 메시지** 이다.<br/>
&ensp;쉽게 말해: 프로세스야 지금 이런 일이 일어났어 하고 운영체제(kernel)가 알려주는 일종의 알림<br/>

&ensp;시그널의 역할<br/>
* 비정상적이거나 예외적인 상황을 알림 (예: Ctrl + C 입력, 잘못된 메모리 접근, 0으로 나누기, 타이머 종료 등)
* 프로세스 제어: 프로세스를 중지하거나 종료, 혹은 특정 동작을 수행하도록 함
* 프로세스 간 통신: 한 프로세스가 다른 프로세스에 메시지를 전달할 수 있음

&ensp;시그널의 전달 경로<br/>
&ensp;시그널은 두 가지 방식으로 전달된다.<br/>
&ensp;1. 커널 → 프로세스<br/>
&ensp;예: 사용자가 Ctrl + C를 눌러 SIGINT 신호 발생 → 커널이 해당 세션의 모든 프로세스에 시그널 전달<br/>
&ensp;2. 프로세스 → 프로세스<br/>
&ensp;예: 한 프로세스가 kill(pid, SIGTERM)을 호출해 다른 프로세스 종료<br/>

* 예시: Ctrl + C (Interrupt Key)를 누르면
    - 커널이 이 입력을 감지하고,
    - 현재 session에 있는 모든 프로세스에게 "SIGINT" 시그널을 보냄
    - 대부분의 프로세스는 종료됨
    - 하지만 shell 프로세스는 무시! (shell이 종료되면 터미널 전체가 닫히니까 예외적으로 처리)

&ensp;모든 시그널은 <signal.h> 헤더 파일에 정의되어 있음<br/>

&ensp;시그널 처리 방법(Signal Handling)<br/>
&ensp;1. 기본 동작(Default Action)<br/>
&ensp;각 시그널에는 기본 동작이 정해져 있음 → 종료, 무시, 중지, 코어 덤프 등<br/>
&ensp;2. 무시(Ignore)<br/>
&ensp;특정 시그널을 무시할 수도 있음 (e.g. shell이 SIGINT 무시)<br/>
&ensp;3. 지정된 함수 호출(Handler 등록)<br/>
&ensp;프로그래머가 직접 이 시그널이 오면 어떤 함수 실행할지 정의 가능<br/>
```c
signal(SIGINT, handler_function);
```

&ensp;4. 시그널 블록(Block)<br/>
&ensp;특정 구간 동안 시그널을 임시로 차단할 수도 있음 (중요 작업 중 시그널로 방해받지 않기 위해)<br/>

| 구분         | 설명                     | 예시                          |
| ---------- | ---------------------- | --------------------------- |
| **Signal** | 비정상 상황을 알리는 소프트웨어 인터럽트 | SIGINT, SIGTERM, SIGKILL    |
| **발신자**    | 커널 or 다른 프로세스          | Ctrl+C (커널), kill 명령 (프로세스) |
| **기본 동작**  | 종료 / 무시 / 중지 / 코어덤프    | SIGINT → 종료                 |
| **사용 목적**  | 비정상 이벤트 전달, 프로세스 제어    | 프로그램 중단, 프로세스 종료 등          |

&ensp;시그널의 기본 구조<br/>
&ensp;시그널은 “운영체제가 프로세스에게 보내는 이벤트 알림” 이다. 즉, 시그널은 프로세스 간의 간단한 통신(IPC) 방법이며, 프로세스는 받은 시그널에 따라 행동을 결정한다.<br/>
&ensp;시그널이 발생하면<br/>
&ensp;1. 커널이 해당 프로세스의 PCB(Process Control Block) 에 "시그널이 도착했다"는 플래그를 남긴다.<br/>
&ensp;2. 프로세스가 CPU를 얻으면, 커널은 해당 프로세스에게 등록된 시그널 핸들러(handler) 를 실행하거나 기본 동작(default action) 을 수행시킨다.<br/>

child process의 종료 상태 확인
=====

&ensp;프로세스가 종료되면 부모 프로세스는 wait()또는 waitpid()를 호출해서 자식의 종료 상태를 받아볼 수 있다.<br/>

&ensp;코드 구조<br/>
```c
pid = wait(&status);

if (WIFEXITED(status)) { // 정상 종료인 경우
    printf("정상 종료, exit code = %d\n", WEXITSTATUS(status));
}

if (WIFSIGNALED(status)) { // 시그널로 인해 종료된 경우
    printf("signal에 의해 종료됨, signal 번호 = %d\n", WTERMSIG(status));
}
```

&ensp;흐름 요약<br/>

| 단계 | 동작                          | 설명                     |
| -- | --------------------------- | ---------------------- |
| 1  | 자식 프로세스 종료                  | exit() 또는 signal로 종료됨  |
| 2  | 커널이 종료 상태 저장                | 부모의 PCB에 자식 종료 상태 기록   |
| 3  | 부모의 wait() 호출               | 종료된 자식의 상태(status) 가져옴 |
| 4  | WIFEXITED / WIFSIGNALED로 구분 | 정상 종료인지, 시그널 종료인지 확인   |

&ensp;자식이 어떻게 죽었는지(정상 / 시그널) 를 알 수 있는 함수들이 WIFEXITED, WIFSIGNALED 이다.<br/>

signal 보내기
=====

&ensp;`kill()` 함수<br/>
&ensp;`kill()` 은 프로세스에게 시그널을 보내고 시스템 콜이다. (이름 때문에 죽이는 함수로 오해하지만 실제로는 시그널을 보내는 함수이다.)<br/>

```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

&ensp;매개변수 설명<br/>
* `pid` : 시그널을 받을 프로세스의 PID
* `sig` : 보낼 시그널 번호 (예: SIGINT, SIGKILL, SIGUSR1 등)

&ensp;예시<br/>
```c
kill(1234, SIGINT);   // PID 1234에게 SIGINT (Ctrl+C와 동일) 전송
kill(getpid(), SIGSTOP); // 자기 자신을 일시정지
```

&ensp;pid 값에 따른 전달 범위<br/>
&ensp;시그널을 보낼 대상을 더 유연하게 지정할 수 있다.<br/>

| pid 값                  | 의미                                             |
| ---------------------- | ---------------------------------------------- |
| **pid > 0**            | 해당 pid의 프로세스에게만 signal 전달                      |
| **pid = 0**            | 현재 프로세스와 같은 process group의 모든 프로세스에게 signal 전달  (sender 자신 포함) |
| **pid = -1**           | sender의 euid(파일 소유자의 권한이 있는)와 같은 모든 process에게 signal 전달 (sender 자신 포함) |
| **pid < 0 (단, != -1)** | 절댓값이 pid인 **process group**에 signal 전달         |


&ensp;권한 주의<br/>
&ensp;다른 사용자(user)의 프로세스에 시그널을 보내면 kill()은 -1을 반환하고 에러가 발생한다.(권한 없음)<br/>

&ensp;`raise()` <br/>
&ensp;`raise()` 함수는 자기 자신에게 시그널을 보내는 함수이다. 즉 `kill(getpid(), sig)` 와 동일한 효과를 가진다.<br/>

```c
#include <signal.h>

int raise(int sig);
```

&ensp;동작<br/>
* 현재 프로세스에게 sig 시그널을 보냄
* 핸들러가 등록되어 있으면 핸들러 실행
* 등록되어 있지 않으면 기본 동작 수행

&ensp;예시<br/>
```c
#include <stdio.h>
#include <signal.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    signal(SIGUSR1, handler); // SIGUSR1 핸들러 등록
    raise(SIGUSR1);           // 자기 자신에게 보냄
    printf("프로그램 종료\n");
}
```

&ensp;실행결과<br/>
```scss
시그널 10 받음!   ← raise() 호출 시 핸들러 실행됨
프로그램 종료
```

&ensp;전체 흐름 정리<br/>
```css
[1] 시그널 발생 (Ctrl+C, kill(), raise(), 타이머 등)
        ↓
[2] 커널이 해당 프로세스의 PCB에 시그널 플래그 설정
        ↓
[3] 프로세스가 CPU를 얻으면
        ↓
    (a) 등록된 handler가 있으면 → handler 함수 실행
    (b) 없으면 → 기본 동작(default action) 수행
        - 종료 / 무시 / 중지 / 코어덤프
        ↓
[4] 자식 프로세스 종료 시 → 부모가 wait()으로 종료 상태 확인
```

Signal Handling (시그널 처리)
=====

&ensp;개념 정리<br/>
&ensp;시그널이란 커널이 프로세스에게 보내는 알림(이벤트)이고 시그널 핸들링(signal handling)은 그 알림을 프로세스가 어떻게 처리할지 정희하는 과정이다.<br/>

&ensp;signal handling 기본 구조<br/>

| 처리 방식                  | 설명                      | 예시                         |
| ---------------------- | ----------------------- | -------------------------- |
| **1️⃣ Default action** | 시스템이 미리 정의한 기본 동작 수행    | `SIGINT` → 프로세스 종료         |
| **2️⃣ 무시 (ignore)**    | 시그널을 무시하고 아무 일도 하지 않음   | `signal(SIGINT, SIG_IGN);` |
| **3️⃣ 사용자 정의 함수 호출**   | 특정 시그널이 오면 직접 작성한 함수 실행 | `signal(SIGINT, handler);` |

&ensp;예시: signal() 함수로 핸들러 설정<br/>
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    signal(SIGINT, handler); // Ctrl + C 입력 시 handler 실행
    while (1) {
        printf("실행 중...\n");
        sleep(1);
    }
    return 0;
}
```

&ensp;실행결과<br/>
&ensp;Ctrl + C를 누르면 종료되지 않고 다음처럼 출력됨:<br/>
```scss
실행 중...
실행 중...
^C시그널 2 받음!
실행 중...
```

&ensp;➡ 기본 동작(종료)을 덮어쓰고, 사용자가 정의한 행동(handler)을 수행함.<br/>

&ensp;`signal()` 함수는 간단하지만 시스템에 따라 동작이 다르고 불안정한 경우가 있다. 그래서 실제 리눅스 프로그래밍에서는 sigaction()을 사용한다.<br/>

&ensp;sigaction의 역할<br/>
&ensp;시그널이 발생했을 때 원하는 행동을 세밀하게 지정할 수 있도록 함<br/>
* `SIGSTOP` (일시 중지)과 `SIGKILL` (강제 종료)은 예외 → 이 두 시그널은 어떤 방법으로도 잡거나 무시할 수 없음.

&ensp;함수 원형<br/>
```c
#include <signal.h>

int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact);
```

| 인자       | 설명                                     |
| -------- | -------------------------------------- |
| `signo`  | 지정할 시그널 번호 (예: SIGINT, SIGUSR1 등)      |
| `act`    | 시그널이 왔을 때 수행할 행동(struct sigaction 구조체) |
| `oldact` | 기존 시그널 처리를 저장하고 싶을 때 사용 (NULL 가능)      |

&ensp;struct sigaction 구조<br/>
&ensp;sigaction 함수는 이 구조체를 사용해 동작을 지정한다.<br/>
```c
struct sigaction {
    void (*sa_handler)(int);           // 간단한 핸들러 함수
    sigset_t sa_mask;                  // 블록할 시그널 집합
    int sa_flags;                      // 동작 옵션
    void (*sa_sigaction)(int, siginfo_t *, void *); // 확장형 핸들러
};
```

&ensp;각 멤버 설명<br/>

| 멤버             | 설명                                              |
| -------------- | ----------------------------------------------- |
| `sa_handler`   | 기본적인 시그널 핸들러 함수 포인터. ex) `handler(int sig)`     |
| `sa_mask`      | 핸들러가 실행되는 동안 **임시로 차단할 시그널 집합**                 |
| `sa_flags`     | 동작 옵션 (예: SA_RESTART, SA_SIGINFO 등)             |
| `sa_sigaction` | 고급형 핸들러. 시그널 번호, 시그널 정보, 프로세스 context까지 받을 수 있음 |

&ensp;예시 코드<br/>
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    struct sigaction act;

    act.sa_handler = handler;   // 실행할 함수 지정
    sigemptyset(&act.sa_mask);  // 블록할 시그널 없음
    act.sa_flags = 0;           // 기본 설정

    sigaction(SIGINT, &act, NULL); // Ctrl + C 시 handler 실행

    while (1) {
        printf("실행 중...\n");
        sleep(1);
    }
    return 0;
}
```

&ensp;실행 결과<br/>
```scss
실행 중...
^C시그널 2 받음!
실행 중...
```

&ensp;handler vs sigaction 비교 정리<br/>

| 구분     | signal() | sigaction()             |
| ------ | -------- | ----------------------- |
| 사용 난이도 | 쉬움       | 약간 복잡함                  |
| 설정 안정성 | 시스템마다 다름 | POSIX 표준, 안전            |
| 추가 기능  | 없음       | 마스크/플래그 등 다양한 설정 가능     |
| 확장성    | 제한적      | sa_sigaction으로 상세 정보 제공 |

&ensp;전체 흐름 요약<br/>
```markdown
1. 프로세스가 시그널을 받음
        ↓
2. 커널이 해당 시그널의 처리 방식 확인
        ↓
3. 등록된 핸들러가 있으면 → 핸들러 실행
   없으면 → 기본 동작 수행 (종료/중지/무시)
        ↓
4. sigaction을 사용하면 블록, 옵션 등 세밀한 제어 가능
```

sigaction
=====

&ensp;`sa_handler` - 시그널이 왔을 때 실행할 행동 지정<br/>
&ensp;`sa_handler` 는 시그널을 받았을 때 어떤 행동을 취할지 지정하는 포인터이다. 즉 이 시그널이 오면 이 함수를 실행하라 라는 의미이다.<br/>

```c
void (*sa_handler)(int);
```

| 구분        | 설명                                | 예시                 |
| --------- | --------------------------------- | ------------------ |
| `SIG_DFL` | Default Action — 시스템이 정한 기본 동작 수행 | `SIGINT` → 종료      |
| `SIG_IGN` | Ignore — 시그널 무시                   | Ctrl+C 눌러도 종료 안 됨  |
| 사용자 정의 함수 | 시그널이 오면 직접 만든 함수 실행               | `handler(int sig)` |

&ensp;기본 동작(Default)<br/>
```c
act.sa_handler = SIG_DFL; // 시스템 기본 동작 수행 (보통 종료)
```

&ensp;무시(Ignore)<br/>
```c
act.sa_handler = SIG_IGN; // 시그널 무시
```

&ensp;사용자 정의 핸들러<br/>
```c
void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

act.sa_handler = handler;
```

&ensp;동작 순서<br/>
&ensp;시그널 발생 → 커널이 sa_handler 확인 → 해당 함수로 제어 이동 → 함수 실행 완료 후 원래 코드로 복귀 (return)<br/>

&ensp;sigset_t sa_mask, int sa_flags<br/>
&ensp;`sigaction` 구조체에는 `sa_mask`와 `sa_flags`라는 중요한 멤버도 있다. 이 둘은 시그널이 처리되는 동안 다른 시그널을 일시적으로 막거나 특정 옵션을 지정할 때 사용된다.<br/>

&ensp;1. `sigset_t sa_mask` <br/>
&ensp;시그널 핸들러가 실행되는 동안 차단(blocking)할 시그널 집합을 정의한다.<br/>
```c
sigset_t sa_mask;
```

* `sigemptyset(&act.sa_mask);` → 차단할 시그널 없음
* `sigaddset(&act.sa_mask, SIGINT);` → handler 실행 중에는 SIGINT를 차단 (중복 호출 방지)

&ensp;예시<br/>
&ensp;만약 SIGUSR1을 처리 중인데 같은 시그널이 계속 들어오면?<br/>
&ensp;→ sa_mask에 SIGUSR1이 포함되어 있으면 handler가 끝날 때까지 차단됨.<br/>

&ensp;2. `int sa_flags` <br/>
&ensp;시그널 처리의 동작 옵션을 지정하는 플래그<br/>

| 플래그            | 설명                                                     |
| -------------- | ------------------------------------------------------ |
| `SA_RESETHAND` | 핸들러가 한 번 실행된 뒤 자동으로 기본 동작(SIG_DFL)으로 복귀함               |
| `SA_SIGINFO`   | `sa_handler` 대신 `sa_sigaction`을 사용 (시그널 정보까지 받는 고급 버전) |

&ensp;`SA_RESETHAND` 예시<br/>
```c
act.sa_handler = handler;
act.sa_flags = SA_RESETHAND;
```

&ensp;➡ 한 번만 사용자 함수 실행, 그 이후에는 기본 동작 수행 (보통 종료)<br/>

&ensp;`SA_SIGINFO` 예시
```c
void handler(int sig, siginfo_t *info, void *context) {
    printf("Signal %d from PID %d\n", sig, info->si_pid);
}

act.sa_sigaction = handler;
act.sa_flags = SA_SIGINFO;
```

&ensp;➡ 시그널 번호뿐 아니라, 누가 보냈는지(pid), 어떤 이유로 발생했는지 등의 정보까지 받을 수 있음.<br/>

&ensp;전체 구조요약<br/>
```c
struct sigaction {
    void     (*sa_handler)(int);           // 시그널 핸들러 함수
    sigset_t  sa_mask;                     // 핸들러 실행 중 차단할 시그널
    int       sa_flags;                    // 플래그 옵션
    void     (*sa_sigaction)(int, siginfo_t *, void *); // 확장형 핸들러
};
```

&ensp;전체 동작 흐름<br/>
```bash
1️⃣ 시그널 발생 (kill(), Ctrl+C 등)
       ↓
2️⃣ 커널이 프로세스의 sigaction 테이블 확인
       ↓
3️⃣ sa_handler 또는 sa_sigaction에 따라 처리
       ↓
   - sa_mask에 지정된 시그널은 잠시 차단됨
   - sa_flags 옵션에 따라 추가 동작 수행
       ↓
4️⃣ handler 실행 후 원래 프로그램 복귀
```

&ensp;signal 사용 예제 완전 정리<br/>

&ensp;기본 예제-SIGINT<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

main() {
    static struct sigaction act;
    void catchint(int);  // 시그널 처리 함수 선언

    act.sa_handler = catchint;          // SIGINT 수신 시 실행할 함수 지정
    sigaction(SIGINT, &act, NULL);      // SIGINT에 대한 동작 등록

    printf("sleep call1\n");
    sleep(1);
    printf("sleep call2\n");
    sleep(1);
    printf("exiting\n");
    exit(0);
}

void catchint(int signo) {
    printf("\nCATCHINT: signo=%d\n", signo);
}
```

&ensp;코드 동작 흐름<br/>

| 단계  | 동작                                                              |
| --- | --------------------------------------------------------------- |
| 1️⃣ | `sigaction(SIGINT, &act, NULL);` → SIGINT에 대해 catchint() 함수를 등록 |
| 2️⃣ | 프로그램이 실행 중에 `Ctrl + C` 입력                                       |
| 3️⃣ | 커널이 해당 프로세스에게 SIGINT 시그널 전송                                     |
| 4️⃣ | 기본 동작(종료) 대신 `catchint()` 함수 실행                                 |
| 5️⃣ | `printf("\nCATCHINT: signo=2\n")` 출력 후 계속 실행                    |

&ensp;실행 예시<br/>
```bash
$ ./a.out
sleep call1
^C
CATCHINT: signo=2
sleep call2
exiting
```

&ensp;➡ Ctrl+C를 눌러도 프로그램이 종료되지 않고 사용자가 정의한 핸들러(`catchint`)가 실행됨.<br/>

* SIGINT는 보통 Ctrl+C 입력 시 발생
* sigaction()을 사용하면 이 시그널을 직접 처리하거나 무시할 수 있음
* sa_handler에 등록한 함수는 시그널이 도착하면 호출되는 일종의 인터럽트 핸들러 역할을 함

&ensp;SIGINT 무시 / 기본동작 복귀<br/>
1. 사용자 정의 함수 호출
2. 무시(`SIG_IGN`)
3. 기본 동작(`SIG_DEL`)

&ensp;SIGINT 무시<br/>
```c
act.sa_handler = SIG_IGN;     // SIGINT 무시 설정
sigaction(SIGINT, &act, NULL);
```

&ensp;➡ Ctrl+C를 눌러도 프로그램이 종료되지도 않고, 핸들러도 실행되지 않음. 커널이 SIGINT를 보냈지만 프로세스가 “난 이 신호 안 받을래!”라고 한 것.<br/>

&ensp;SIGINT 기본 동작 복귀<br/>
```c
act.sa_handler = SIG_DFL;     // SIGINT 기본 동작 수행
sigaction(SIGINT, &act, NULL);
```

&ensp;➡ Ctrl+C 입력 시 다시 원래처럼 프로세스가 종료됨.<br/>

| 설정값       | 의미              | 결과                 |
| --------- | --------------- | ------------------ |
| `SIG_DFL` | Default (기본 동작) | SIGINT → 종료        |
| `SIG_IGN` | Ignore (무시)     | SIGINT → 무시        |
| 사용자 함수    | Custom Handler  | SIGINT → 지정한 함수 실행 |


&ensp;여러 시그널 처리 및 exec()의 특성<br/>
&ensp;여러 시그널 무시하기<br/>
```c
act.sa_handler = SIG_IGN;  // 무시 설정
sigaction(SIGINT, &act, NULL);   // Ctrl+C 무시
sigaction(SIGQUIT, &act, NULL);  // Ctrl+\ 무시
```

&ensp;➡ SIGINT와 SIGQUIT 모두 무시됨. (SIGQUIT은 일반적으로 Ctrl+\ 입력 시 발생) <br/>

&ensp;`exec()` 이후에도 무시 상태 유지<br/>
&ensp;한 프로세스에서 무시된 시그널은 `exec()` 호출 후에도 계속 무시된다.<br/>
&ensp;`exec()`는 새로운 프로그램을 실행하지만 "무시" 설정된 시그널은 그대로 유지된다.<br/>
&ensp;반면 사용자 정의 핸들러(`sa_handler = hander`)는 `exec()` 후에 사라지고 기본 동작으로 초기화된다.<br/>

| 동작 유형          | exec() 후 유지 여부      | 비고              |
| -------------- | ------------------- | --------------- |
| `SIG_IGN` (무시) | ✅ 유지됨               | 예: SIGINT 무시 지속 |
| 사용자 핸들러        | ❌ 리셋됨 (SIG_DFL로 복귀) | 안전성 이유          |
| `SIG_DFL` (기본) | ✅ 그대로 유지            | 시스템 기본 동작 유지    |

&ensp;전체 요약표<br/>

| 목적         | 설정 코드                                                            | 결과               |
| ---------- | ---------------------------------------------------------------- | ---------------- |
| 사용자 함수로 처리 | `act.sa_handler = handler;`                                      | 시그널 발생 시 함수 실행   |
| 시그널 무시     | `act.sa_handler = SIG_IGN;`                                      | 아무 반응 없음         |
| 기본 동작 수행   | `act.sa_handler = SIG_DFL;`                                      | 기본 동작(종료 등) 수행   |
| 여러 시그널 처리  | `sigaction(SIGINT, &act, NULL); sigaction(SIGQUIT, &act, NULL);` | 여러 시그널 동시에 제어 가능 |

* `sigaction()`은 시그널의 행동(핸들러, 무시, 기본동작)을 지정하는 함수
* `SIGINT` 은 Ctrl+C 입력 시 발생
* `SIGQUIT` 은 Ctrl+\ 입력 시 발생
* `SIG_IGN` 은 exec() 후에도 유지되지만 사용자 핸들러는 exec() 후 사라짐 
* 실습 시 `sleep()` 을 사용하면 시그널을 보낼 타이밍을 확보할 수 있음



&ensp;내부 매커니즘 이해<br/>
&ensp;리눅스에서는 터미널 입력을 담당하는 커널 드라이브가 있다. 이 드라이버는 사용자가 특수 키를 누르면 자동으로 특정 시그널을 보낸다.<br/>

| 키 입력         | 발생하는 시그널  | 설명                                |
| ------------ | --------- | --------------------------------- |
| **Ctrl + C** | `SIGINT`  | Interrupt 시그널 (프로세스 중단 요청)        |
| **Ctrl + \** | `SIGQUIT` | Quit 시그널 (프로세스 종료 + core dump 생성) |
| **Ctrl + Z** | `SIGTSTP` | Stop 시그널 (일시정지 — background로 보내기) |


Signal 집합 지정(sigset_t)
====

&ensp;시그널을 하나씩 처리할 수도 있지만 때로는 여러 개의 시그널을 묶어서 관리해야 할 때가 있다. 이때 사용하는 자료형이 바로 sigset_t 이다.<br/>

&ensp;용도<br/>
&ensp;`sigset_t` 는 시그널들의 집합(세트)을 표현하는 자료형이다.<br/>
&ensp;예를 들어<br/>
* SIGINT와 SIGQUIT을 동시에 차단(block)
* SIGCHLD는 제외하고 나머지 모두 포함

&ensp;이런 경우 sigset_t를 이용해서 지정한다.<br/>

&ensp;주요 함수 목록<br/>
```c
#include <signal.h>

int sigemptyset(sigset_t *set);    // 집합 비우기 (초기화)
int sigfillset(sigset_t *set);     // 모든 시그널 추가
int sigaddset(sigset_t *set, int signo);   // 특정 시그널 추가
int sigdelset(sigset_t *set, int signo);   // 특정 시그널 제거
int sigismember(const sigset_t *set, int signo); // 포함 여부 확인
```

&ensp;사용 흐름<br/>
1. `sigemptyset()`으로 집합 초기화
2. `sigaddset()`으로 필요한 시그널 추가
3. 필요하면 `sigdelset()`으로 제외
4. `sigismember()`로 확인 가능

&ensp;이렇게 정의한 시그널 집합은 `sigaction` 구조체의 `sa_mask` 나 `phread_sigmask()` 같은 곳에 전달되어 시그널 블록 동작에 사용된다.<br/>

&ensp;예시 코드<br/>
```c
sigset_t mask;

sigemptyset(&mask);              // 비어있는 집합 생성
sigaddset(&mask, SIGINT);        // SIGINT 추가
sigaddset(&mask, SIGQUIT);       // SIGQUIT 추가
```

&ensp;이렇게 하면 mask에는 두 개의 시그널(SIGINT, SIGQUIT)이 들어 있다. 핸들러 실행 중 mask를 지정하면 이 두 시그널은 잠시 차단된다.<br/>

&ensp;실제 예시<br/>
```c
sigset_t mask1, mask2;

sigemptyset(&mask1);           // 비어있는 집합
sigaddset(&mask1, SIGINT);     // SIGINT 추가
sigaddset(&mask1, SIGQUIT);    // SIGQUIT 추가

sigfillset(&mask2);            // 모든 시그널 추가
sigdelset(&mask2, SIGCHLD);    // SIGCHLD만 제거
```

&ensp;실행 결과 개념<br/>

| 변수        | 의미                            |
| --------- | ----------------------------- |
| **mask1** | SIGINT, SIGQUIT만 포함된 집합       |
| **mask2** | 모든 시그널 포함 but SIGCHLD는 제외된 집합 |

&ensp;이렇게 만들어진 시그널 집합은 어디에 쓰일까?<br/>
&ensp;➡ 보통 sigaction의 sa_mask에 넣어서 핸들러가 실행되는 동안 특정 시그널을 자동으로 block하도록 한다.<br/>

&ensp;예시<br/>
```c
act.sa_mask = mask1; // handler 실행 중 SIGINT, SIGQUIT 차단
```

&ensp;즉 handler가 실행 중일 때 같은 시그널이 반복해서 들어오지 않게 막는 기능이다.<br/>

&ensp;sa_sigaction()에 의한 고급 signal handling<br/>

&ensp;`sa_sigaction()` 은 기존의 `sa_handler` 보다 더 자세한 시그널 정보를 제공하는 고급 핸들러이다.<br/>

&ensp;코드 예시<br/>
```c
int main(void) {
    static struct sigaction act;
    act.sa_flags = SA_SIGINFO;           // 고급 핸들러 사용 플래그
    act.sa_sigaction = handler;          // handler 등록
    sigaction(SIGUSR1, &act, NULL);      // SIGUSR1 처리 설정
    ...
}

void handler(int signo, siginfo_t *sf, ucontext_t *uc) {
    psiginfo(sf, "...!");                // 시그널 정보 출력
    printf("%d\n", sf->si_code);         // 발생 원인 코드 출력
}
```

&ensp;핵심 포인트<br/>

| 요소                                  | 설명                                      |
| ----------------------------------- | --------------------------------------- |
| `sa_flags = SA_SIGINFO`             | 이 설정을 해야 `sa_sigaction`이 작동             |
| `handler(int, siginfo_t *, void *)` | 3개의 인자 사용                               |
| `siginfo_t` 구조체                     | 시그널 관련 상세 정보 저장                         |
| `psiginfo()`                        | siginfo_t 내용을 보기 쉽게 출력하는 함수             |
| `sf->si_code`                       | 시그널 발생 원인 코드 (예: 커널, kill(), 하드웨어 예외 등) |

&ensp;`siginfo_t` 구조체 예시<br/>
```c
typedef struct siginfo {
    int si_signo;    // 시그널 번호
    int si_errno;    // 관련 오류 번호 (없으면 0)
    int si_code;     // 시그널 발생 원인
    pid_t si_pid;    // 시그널을 보낸 프로세스 PID
    uid_t si_uid;    // 보낸 프로세스의 사용자 ID
    void *si_addr;   // 메모리 접근 예외 주소
} siginfo_t;
```

&ensp;이 정보를 통해 누가 시그널을 보냈는지 어떤 이유로 발생했는지 등을 세밀하게 알 수 있다.<br/>

&ensp;예시 실행 흐름<br/>
1. 부모 프로세스가 kill(child_pid, SIGUSR1);
2. 자식 프로세스가 sa_sigaction으로 등록된 handler 실행
3. handler 내부에서 sf->si_pid로 “시그널을 보낸 부모 PID” 출력 가능

&ensp;예시 출력<br/>
```yaml
Signal: SIGUSR1
Sent by PID: 1234
Reason: user
Code: SI_USER
```

&ensp;전체 요약표<br/>

| 개념            | 주요 함수 / 구조                               | 설명                           |
| ------------- | ---------------------------------------- | ---------------------------- |
| **시그널 집합 지정** | `sigset_t`, `sigemptyset`, `sigaddset` 등 | 시그널들을 묶어서 관리                 |
| **시그널 블록 기능** | `sa_mask`                                | handler 실행 중 특정 시그널 임시 차단    |
| **기본 핸들러**    | `sa_handler(int)`                        | 간단한 처리 (시그널 번호만)             |
| **고급 핸들러**    | `sa_sigaction(int, siginfo_t*, void*)`   | 시그널 원인, 보낸 PID 등 세부 정보 확인 가능 |
| **활성화 조건**    | `sa_flags = SA_SIGINFO`                  | sa_sigaction 사용을 위한 설정       |


이전의 설정 복원하기 (sigaction 복원)
====

&ensp;`sigaction()`은 새 시그널 동작을 설정할 때 기존에 설정되어 있던 시그널 동작을 백업해 둘 수 있다.<br/>

&ensp;코드 예시<br/>
```c
struct sigaction act, oact;

// 과거 설정 저장
sigaction(SIGTERM, NULL, &oact);

// 현재 동작을 무시로 변경
act.sa_handler = SIG_IGN;
sigaction(SIGTERM, &act, NULL);

// ... 중간에 원하는 코드 실행 ...
printf("SIGTERM 무시 중...\n");

// 과거 설정 복원
sigaction(SIGTERM, &oact, NULL);
```

&ensp;흐름 요약<br/>

| 단계                                  | 설명                        |
| ----------------------------------- | ------------------------- |
| ① `sigaction(SIGTERM, NULL, &oact)` | 기존 SIGTERM 설정을 `oact`에 저장 |
| ② `act.sa_handler = SIG_IGN`        | 시그널 무시로 변경                |
| ③ `sigaction(SIGTERM, &act, NULL)`  | 무시 설정 적용                  |
| ④ `sigaction(SIGTERM, &oact, NULL)` | 이전 설정 복원                  |

alarm signal 설정
=====

&ensp;alarm()은 일정 시간이 지나면 SIGALRM 시그널을 발생시켜주는 타이머이다.<br/>

&ensp;사용법<br/>
```c
#include <signal.h>

unsigned int alarm(unsigned int seconds);
```

* seconds: 초 단위 타이머
* 지정된 시간이 지나면 프로세스에 `SIGALRM` 시그널 전달

&ensp;주요 특징<br/>

| 항목                 | 설명                           |
| ------------------ | ---------------------------- |
| `alarm(5)`         | 5초 후 SIGALRM 시그널 발생          |
| `alarm(0)`         | 현재 설정된 alarm 취소              |
| `alarm()`은 누적되지 않음 | 새 alarm이 기존 alarm을 덮어씀       |
| `exec()` 후에도 유지    | 하지만 `fork()` 후 자식에게는 적용되지 않음 |
| `alarm()`의 반환값     | 이전 alarm이 남아있던 잔여 시간(초 단위)   |

&ensp;예시코드<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void handler(int sig) {
    printf("시간이 끝났습니다! SIGALRM 발생!\n");
}

int main() {
    signal(SIGALRM, handler);
    alarm(3); // 3초 후 시그널 발생

    printf("3초 기다리는 중...\n");
    pause(); // 시그널이 올 때까지 대기
    return 0;
}
```

&ensp;출력예시<br/>
```bash
3초 기다리는 중...
시간이 끝났습니다! SIGALRM 발생!
```

signal blocking (시그널 차단)
=====

&ensp;프로세스가 시그널을 받을 때 특정 시그널을 일시적으로 차단(block)하고 싶을 수 있다. 이때 사용하는 함수가 sigprocmask()이다.<br/>

&ensp;함수 원형<br/>
```c
#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
```

&ensp;매개변수 설정<br/>

| 인자     | 설명                       |
| ------ | ------------------------ |
| `how`  | 어떤 동작을 할지 지정             |
| `set`  | 추가/삭제할 시그널 집합            |
| `oset` | 현재 시그널 마스크 저장용 (NULL 가능) |

&ensp;how 옵션<br/>

| 상수            | 의미                     |
| ------------- | ---------------------- |
| `SIG_BLOCK`   | `set`에 포함된 시그널을 추가로 차단 |
| `SIG_UNBLOCK` | `set`에 포함된 시그널 차단 해제   |
| `SIG_SETMASK` | 현재 마스크를 `set`으로 완전히 교체 |


&ensp;예시 코드<br/>
```c
sigset_t mask;
sigemptyset(&mask);
sigaddset(&mask, SIGINT);

// SIGINT 차단
sigprocmask(SIG_BLOCK, &mask, NULL);
printf("Ctrl+C 무시 (차단 중)...\n");
sleep(5);

// SIGINT 차단 해제
sigprocmask(SIG_UNBLOCK, &mask, NULL);
printf("Ctrl+C 다시 활성화됨!\n");
```

&ensp;실행 흐름<br/>
1. SIG_BLOCK → SIGINT를 임시 차단
2. sleep 중에 Ctrl+C 눌러도 반응 없음
3. SIG_UNBLOCK → 다시 활성화

pause() 시스템 호출
====

&ensp;pause()는 프로세스 실행을 시그널이 도착할 때까지 일시 정지시키는 함수이다.<br/>

&ensp;사용법<br/>
```c
#include <unistd.h>

int pause(void);
```

&ensp;동작 원리<br/>

| 단계  | 설명                                   |
| --- | ------------------------------------ |
| 1️⃣ | 프로세스가 `pause()` 호출 시 실행을 멈춤          |
| 2️⃣ | 커널이 “시그널이 도착할 때까지” 기다림               |
| 3️⃣ | 시그널이 도착하면 handler 실행                 |
| 4️⃣ | handler 종료 후 `pause()`가 `-1` 반환하고 복귀 |

&ensp;예시 코드<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void handler(int sig) {
    printf("시그널 %d 받음!\n", sig);
}

int main() {
    signal(SIGINT, handler);
    printf("Ctrl+C 기다리는 중...\n");
    pause();   // 시그널이 오기 전까지 CPU 사용 안 함
    printf("pause() 종료됨\n");
    return 0;
}
```

&ensp;실행 예시<br/>
```scss
Ctrl+C 기다리는 중...
^C시그널 2 받음!
pause() 종료됨
```

&ensp;정리<br/>

| 함수                    | 역할                      |
| --------------------- | ----------------------- |
| `pause()`             | 시그널이 도착할 때까지 프로그램 일시 정지 |
| `SIGALRM`             | 일정 시간 후 자동으로 시그널 보내기    |
| `sigprocmask()`       | 특정 시그널을 블록하거나 해제        |
| `sigaction()`         | 시그널의 처리 동작 지정           |
| `alarm()` + `pause()` | 타이머 기반 동작 구현 시 자주 함께 사용 |

&ensp;실제 예시: alarm + pause 함께 사용<br/>
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void alarm_handler(int sig) {
    printf("3초 타이머 종료!\n");
}

int main() {
    signal(SIGALRM, alarm_handler);
    alarm(3); // 3초 뒤 SIGALRM 발생

    printf("3초 동안 대기 중...\n");
    pause(); // 시그널 올 때까지 대기
    printf("종료!\n");
}
```

&ensp;결과<br/>
```bash
3초 동안 대기 중...
3초 타이머 종료!
종료!
```

실습
=====

`문제 1.`
&ensp; Parent process는 세 개의 child process를 만들고 1초 간격으로 각 child process에게 SIGUSR1 signal을 보낸 후, child process들이 종료할 때까지 대기하였다가, 종료한 child process의 id와 exit status를 출력 후 종료 합니다. 각 child process는 생성 후 parent로부터 signal이 올 때까지 대기하였다가 (pause() 사용), signal을 받으면 자신의 process id를 세 번 출력한 후 종료 합니다. 이와 같이 동작하는 프로그램을 아래 코드를 사용하여 작성하시오.<br/>

```c
void do_child(int i){
    int i, pid;
    static struct sigaction act;

    // SIGUSR1 signal 처리가 가능 하도록 설정
    printf("%d-th child is created...\n", i);
    pause(); // signal이 올때까지 멈춰 있음

    // signal을 받으면, process id 세 번 출력 하도록 설정 (?)
    exit(i);
}

int main(void) {
    int i, cid, status;
    pid_t pid[3];

    for (i=0;i<3;i++){
        pid[i]=fork();
        if (pid[i]==0) {
            do_child(i);
        }
    }

    // 1초씩 sleep()하면서, child들에게 SIGUSR1 signal 보내기
    for(i=0;i<3;i++){
        cid=wait(&status);
        printf("child id=%d, exit status=%d\n", cid, WEXITSTATUS(status));
    }

    exit(0);
}
```


```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <signal.h>

void catchusr(int signo) {
    // 시그널을 받았을 때 호출됨
    printf("Signal is caught: %d\n", signo);
}

void do_child(int n){
    pid_t pid;
    static struct sigaction act;

    act.sa_handler = catchusr;
    sigaction(SIGUSR1, &act, NULL);

    printf("%d-th child is created...\n", n);

    pause(); // 부모 시그널 받을 때까지 대기

    pid = getpid();
    for (int i = 0; i < 3; i++) {
        printf("child %d\n", pid);
        sleep(1);
    }

    exit(n);
}

int main(void){
    int i, cid, status;
    pid_t pid[3];

    for (i = 0; i < 3; i++){
        pid[i] = fork();
        if (pid[i] == 0)
            do_child(i);
    }

    for (i = 0; i < 3; i++){
        sleep(1);
        kill(pid[i], SIGUSR1);
    }

    for (i = 0; i < 3; i++){
        cid = wait(&status);
        printf("child id=%d, exit status=%d\n", cid, WEXITSTATUS(status));
    }

    exit(0);
}

```

&ensp;결과<br/>
```bash
0-th child is created... 
1-th child is created... 
2-th child is created... 
Signal is caught: 10 
child 25819 
child 25819 
child 25819 
Signal is caught: 10 
child 25820 
child 25820 
child 25820 
Signal is caught: 10 
child id=25819, exit status=0 
child 25821 
child 25821 
child id=25820, exit status=1 
child 25821 
child id=25821, exit status=2
```

&ensp;1. `fork(i=0; i<3; i++) fork();` <br/>
```c
for(i=0; i < 3; i++){
    pid[i] = fork();
    if(pid[i] == 0){
        do_child(i);
    }
}
```

&ensp;동작 과정<br/>

| 단계  | 설명                     |
| --- | ---------------------- |
| i=0 | 첫 번째 `fork()` → 자식1 생성 |
| i=1 | 두 번째 `fork()` → 자식2 생성 |
| i=2 | 세 번째 `fork()` → 자식3 생성 |

&ensp;→ 부모 프로세스는 총 3개의 자식 프로세스를 만든다.<br/>
&ensp;`pid[0]`, `pid[1]`, `pid[2]` 배열에 각각 자식들의 PID가 저장된다.<br/>

&ensp;2. 자식 프로세스는 `do_child(i)` 진입<br/>
&ensp;각 자식은 아래 함수로 들어간다.<br/>
```c
void do_child(int i){
    pid_t pid;
    static struct sigaction act;

    act.sa_handler = catchusr;        // SIGUSR1 시그널 핸들러 설정
    sigaction(SIGUSR1, &act, NULL);   // 커널에게 “이 시그널 오면 catchusr 실행해라” 등록

    printf("%d-th child is created...\n", i);
    pause();   // 시그널 올 때까지 멈춤
```

&ensp;동작 요약<br/>

| 동작            | 설명                                          |
| ------------- | ------------------------------------------- |
| `sigaction()` | 이 프로세스가 SIGUSR1을 받으면 `catchusr()`를 실행하도록 설정 |
| `printf()`    | “0-th child is created…” 이런 메시지를 출력         |
| `pause()`     | 여기서 **CPU를 양보하고 잠에 듦** (커널이 시그널이 오기 전까지 멈춤) |


&ensp;3. 부모 프로세스는 시그널 전송 시작<br/>
```c
for(i=0; i < 3; i++){
    sleep(1);
    kill(pid[i], SIGUSR1);
}
```

&ensp;핵심<br/>

| 순서  | 1초 대기 후                              | 동작                   |
| --- | ------------------------------------ | -------------------- |
| i=0 | `sleep(1)` → `kill(pid[0], SIGUSR1)` | 첫 번째 자식에게 SIGUSR1 보냄 |
| i=1 | `sleep(1)` → `kill(pid[1], SIGUSR1)` | 두 번째 자식에게 SIGUSR1 보냄 |
| i=2 | `sleep(1)` → `kill(pid[2], SIGUSR1)` | 세 번째 자식에게 SIGUSR1 보냄 |

&ensp;부모는 1초 간격으로 자식에게 순서대로 시그널을 보낸다.<br/>

&ensp;4. 자식이 시그널 받음 → 커널이 catchusr() 호출<br/>
&ensp;자식 프로세스는 `pause()` 상태였는데 부모가 `kill()` 을 커널이 다음을 수행한다.<br/>

1. SIGUSR1 시그널을 해당 자식 프로세스에게 전달
2. 프로세스가 "pause 상태"라면 바로 깨움
3. `sigaction`으로 등록된 함수(`catchusr()`)를 호출

```c
void catchusr(int signo) {
    printf("Signal is caught: %d\n", signo);
}
```

&ensp;그래서 화면에 이렇게 뜬다.<br/>
```bash
Signal is caught: 10
```

&ensp;(`SIGUSR1` 은 시그널 번호가 10번이다.)<br/>

&ensp;5. `pause()` 이후 코드 재개<br/>
&ensp;`pause()` 는 시그널을 하나 받고 나면 리턴한다. 이제 자식은 `pause()` 다음 줄부터 실행을 이어간다.<br/>
```c
pid = getpid();
for(i=0;i<3;i++){
    printf("child %d\n", pid);
    sleep(1);
}
```

| 동작                           | 설명                          |
| ---------------------------- | --------------------------- |
| `getpid()`                   | 현재 자신의 PID 가져옴              |
| `printf("child %d\n", pid);` | 자신의 PID를 3번 출력              |
| `sleep(1)`                   | 출력 간격 1초 줌 (안 줘도 되지만 보기 좋음) |

&ensp;그래서 예를 들어 자식 PID가 25819면<br/>
```bash
child 25819
child 25819
child 25819
```

&ensp;이렇게 나온다.<br/>

&ensp;6. 자식 프로세스 종료<br/>
&ensp;마지막 줄:<br/>
```c
exit(i);
```

&ensp;자식이 종료 코드(i)를 반환하면 종료한다. 예를 들어 0-th child는 exit(0), 1-th child는 exit(1)<br/>

&ensp;부모는 wait()로 종료 감시<br/>
```c
for(i=0; i < 3; i++){
    cid = wait(&status);
    printf("child id=%d, exit status=%d\n", cid, WEXITSTATUS(status));
}
```

| 동작                    | 설명                  |
| --------------------- | ------------------- |
| `wait()`              | 자식이 하나 종료될 때까지 대기   |
| `cid`                 | 종료된 자식의 PID         |
| `WEXITSTATUS(status)` | 자식이 `exit()`로 전달한 값 |
| `printf()`            | 종료된 자식의 ID와 상태를 출력  |

&ensp;8. 실행 흐름 정리 (전체 타임라인)<br/>

| 시간(sec) | 부모 동작                  | 자식 동작                                        |
| ------- | ---------------------- | -------------------------------------------- |
| 0초      | 자식 3명 생성 (`fork`)      | 각 자식 “~th child is created” 출력 후 `pause()`   |
| 1초      | 부모 → 첫 번째 자식 `SIGUSR1` | 자식1 깨어남 → `Signal is caught: 10` + PID 3번 출력 |
| 2초      | 부모 → 두 번째 자식 `SIGUSR1` | 자식2 깨어남 → 동일 동작                              |
| 3초      | 부모 → 세 번째 자식 `SIGUSR1` | 자식3 깨어남 → 동일 동작                              |
| 이후      | 각 자식 종료                | 부모가 `wait()`로 종료 감시 후 결과 출력                  |

&ensp;출력이 뒤섞인 이유<br/>
```bash
Signal is caught: 10
child id=25819, exit status=0
child 25821
...
```

&ensp;처럼 섞여 보이는 이유는 각 프로세스가 동시에 실행되고 출력이 비동기적으로 터미널로 섞인다. (자식3이 PID를 출력하는 중에, 부모가 wait()출력을 할 수도 있다.)<br/>

&ensp;부모는 `fork` 로 3명 생성 → 자식은 `pause()` 로 대기 → 부모가 1초 간격으로 `SIGUSR1` 시그널 보냄 → 자식이 `catchusr()` 실행 후 PID 3번 출력 → 종료 시 부모가 wait()로 결과 출력<br/>

`문제 2`
&ensp;2. Parent process는 다섯 개의 child process들을 만들고, 대기하였다가 child process가 모두 종료한 후 종료 합니다. 각 child process는 자신의 순서가 될 때까지 대기하였다가, 1초씩 쉬면서 (sleep (1); 사용) 자신의 process id(getpid(); 사용)를 5회 출력하는 작업을 한 후 종료 합니다. child process의 id 츨력 순서는 생성순서의 역순이며, 이와 같은 순서 동기화 작업은 signal을 보내서 진행합니다. 단, parent process는 동기화 작업에 참여하지 않습니다.<br/>

```c
void do_child(int i, int *cid){
    // SIGUSR1 signal 처리가 가능 하도록 설정
    // 자신의 출력 순서가 될 때까지 대기

    pid=getpid();
    for (j=0;j<5;j++){
        printf("child %d .... \n", pid);
        sleep(1);
    }
    // 출력 완료 후 다음 출력 순서의 child에게 출력 시작을 알림
    exit(0);
}

int main(void) {
    int i, status;
    pid_t pid[5];

    for (i=0;i<5;i++){
        pid[i]=fork();
        if (pid[i]==0) {
            do_child(i, pid);
        }
    }

    for (i=0;i<5;i++){
        wait(&status);
    }
    exit(0);
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void catchusr(int signo);

void do_child(int i, pid_t *cid){
	pid_t pid;
	static struct sigaction act;
	int j;
	
	act.sa_handler=catchusr;
	sigaction(SIGUSR1, &act, NULL);

	if(i < 4){
		pause();
	}
	
	pid = getpid();
	for(j = 0; j < 5; j++){
		printf("child %d...\n", pid);
		sleep(1);
	}
	
	if(i>0){
		kill(cid[i-1], SIGUSR1);
	}
	exit(0);
}

int main(void){
	int i, cid, status;
	pid_t pid[5];
	
	for(i=0; i < 5; i++){
		pid[i] = fork();
		if(pid[i]==0){
			do_child(i, pid);
		}
	}
	for(i=0; i < 5; i++){
		cid=wait(&status);
		printf("child id=%d, exit staus=%d\n", cid, WEXITSTATUS(status));
	}
	exit(0);
	
}

void catchusr(int signo){
        printf("SIGUSR1 is caught! signo = %d\n", signo);
}
```

&ensp;결과<br/>
```bash
child 2823...
child 2823...
child 2823...
child 2823...
child 2823...
SIGUSR1 is caught! signo = 10
child 2822...
child id=2823, exit staus=0
child 2822...
child 2822...
child 2822...
child 2822...
SIGUSR1 is caught! signo = 10
child 2821...
child id=2822, exit staus=0
child 2821...
child 2821...
child 2821...
child 2821...
SIGUSR1 is caught! signo = 10
child 2820...
child id=2821, exit staus=0
child 2820...
child 2820...
child 2820...
child 2820...
SIGUSR1 is caught! signo = 10
child 2819...
child id=2820, exit staus=0
child 2819...
child 2819...
child 2819...
child 2819...
child id=2819, exit staus=0
```

&ensp;핵심 메커니즘(요약)<br/>
* 초기 상태
    - 자식 0~3: `pause()` 로 Sleep(SIGUSR1 기다림)
    - 자식 4: `pause()` 안 하고 바로 시작 → PID 5번 출력 후 `kill(pid[3], SIGUSR1)`
* 릴레이
    - 4가 끝나면 → 3에게 SIGUSR1 → 3이 깨어나서 5번 출력 → 2에게 SIGUSR1 → 2 출력 → 1에게 → 0에게 …
    - 각 자식은 끝나면서 이전 인덱스(i-1)에게만 시그널을 넘김.
* 출력 섞임(정상)
    - 여러 프로세스가 동시에 Running으로 스케줄링됨 → printf들이 시간 순서대로만 보장되지 않음.
    - 특히 부모의 `child id=..., exit staus=...` 줄은, 해당 자식이 종료하는 그 타이밍에 부모가 깨어나며 끼어든다.

&ensp;코드 핵심 요약<br/>

| 구분        | 역할                                                                         |
| --------- | -------------------------------------------------------------------------- |
| **부모**    | 자식 5명을 fork() 후, 모든 자식 종료를 wait()로 기다림. 동기화엔 참여하지 않음.                      |
| **자식**    | SIGUSR1 받을 때까지 pause()로 대기. 자신의 차례가 되면 PID 5번 출력 후, 바로 이전 자식에게 SIGUSR1 보냄. |
| **시작 조건** | i=4 (마지막으로 생성된 자식)은 pause() 안 하고 바로 시작 → 그 뒤 역순으로 이어짐.                     |


&ensp;코드 흐름 + 결과 해석<br/>

&ensp;1. 부모가 fork() 5번 실행<br/>
```c
for(i=0; i < 5; i++){
    pid[i] = fork();
    if(pid[i]==0){
        do_child(i, pid);
    }
}
```

&ensp;이 시점에서 프로세스 트리가 이렇게 됨<br/>
```css
Parent
 ├── Child[0]
 ├── Child[1]
 ├── Child[2]
 ├── Child[3]
 └── Child[4]
```

* 각 자식은 do_child(i, pid)로 들어감.
* i 값은 각자 다름 (0~4)

&ensp;2. 자식 내부: 시그널 핸들러 등록<br/>
```c
void do_child(int i, pid_t *cid){
    pid_t pid;
    static struct sigaction act;
    int j;

    act.sa_handler=catchusr;
    sigaction(SIGUSR1, &act, NULL);
```

* i는 생성 순서 인덱스(0~4). 부모의 for 루프에서 fork될 때의 i 값이 복사됨.
* cid는 형제들의 PID 배열 주소. 다음 차례를 kill()하려고 필요
* static struct sigaction act;
    - 초기값이 0으로 클리어됨(정적 저장영역). 그래서 sa_mask/sa_flags가 0으로 시작

&ensp;각 자식은 "SIGUSR1 오면 catchusr() 실행해라" 설정을 등록함<br/>
&ensp;act.sa_handler=catchusr; → 이 줄이 있어야 pause()가 SIGUSR1로 깨어남. (핸들러 없으면 pause()는 못 깬다.)

&ensp;3. 마지막 자식(i==4)만 바로 시작, 나머지는 pause()<br/>
```c
if (i < 4) 
    pause();
```

* i=0~3 → pause() 진입 (잠듦)
* i=4 → 즉시 다음 줄 실행 (Running)

&ensp;4. 자식4(i=4): 출력 시작<br/>
```c
pid = getpid();
for(j = 0; j < 5; j++){
    printf("child %d...\n", pid);
    sleep(1);
}
```

&ensp;실제 결과<br/>
```bash
child 2823...
child 2823...
child 2823...
child 2823...
child 2823...
```

&ensp;**자식 4번(프로세스 2823)**이 pause() 안 했기 때문에 바로 실행됨. 1초 간격으로 5번 출력.<br/>

&ensp;5. 자식4 종료 직전: 다음 자식 깨우기<br/>
```c
if (i > 0){
    kill(cid[i-1], SIGUSR1);
}
```

&ensp;i=4니까 kill(pid[3], SIGUSR1) 실행 → 즉 **자식 3번(2822)**에게 SIGUSR1 보냄.<br/>

&ensp;6. 자식3(2822): SIGUSR1을 받음 → catchusr 실행<br/>
```c
void catchusr(int signo){
    printf("SIGUSR1 is caught! signo = %d\n", signo);
}
```

&ensp;결과<br/>
```bash
SIGUSR1 is caught! signo = 10
```

&ensp;시그널 번호 10은 SIGUSR1. 이 메시지가 바로 “자식3이 깨어났다”는 뜻<br/>

&ensp;7. 자식3은 pause()에서 깨어나 출력 시작<br/>
```c
pid = getpid();
for(j=0; j<5; j++){
    printf("child %d...\n", pid);
    sleep(1);
}
```

&ensp;결과<br/>
```bash
child 2822...
child id=2823, exit staus=0
child 2822...
child 2822...
child 2822...
child 2822...
```

&ensp;중요한 점<br/>
* `child id=2823, exit staus=0` 은 부모가 2823의 종료를 wait()로 수거하며 찍은 줄. → 2822가 출력 중이지만 CPU를 잠깐 부모가 가져갔다가 한 줄 찍고 다시 넘긴 것. (정상)
* 즉 자식 4가 막 끝난 순간에 부모가 Running 상태가 됨.

&ensp;8. 자식3 종료 후, 자식2에게 시그널 보냄<br/>
```c
kill(cid[i-1], SIGUSR1);  // i=3 → pid[2]
```

&ensp;이제 자식2(2821) 깨어남 → catchusr 실행<br/>

&ensp;결과<br/>
```bash
SIGUSR1 is caught! signo = 10
child 2821...
child id=2822, exit staus=0
child 2821...
child 2821...
child 2821...
child 2821...
```

&ensp;패턴 동일:<br/>
* "SIGUSR1…" : 다음 자식이 깨어남
* "child id=2822…" : 직전 자식의 종료를 부모가 출력

&ensp;9. 자식2 종료 → 자식1에게 시그널 → 자식1 깨어남<br/>
```bash
SIGUSR1 is caught! signo = 10
child 2820...
child id=2821, exit staus=0
child 2820...
child 2820...
child 2820...
child 2820...
```

&ensp;10. 자식1 종료 → 자식0에게 시그널 → 자식0 깨어남<br/>
&ensp;결과<br/>
```bash
SIGUSR1 is caught! signo = 10
child 2819...
child id=2820, exit staus=0
child 2819...
child 2819...
child 2819...
child 2819...
child id=2819, exit staus=0
```

&ensp;최종 전체 흐름 요약표<br/>

| 단계 | 실행 프로세스   | 상태 변화      | 실제 출력                         |
| -- | --------- | ---------- | ----------------------------- |
| 1  | 부모        | fork() 5회  | (출력 없음)                       |
| 2  | 자식4(2823) | Running    | child 2823... (5회)            |
| 3  | 자식4 → 자식3 | SIGUSR1 전달 | SIGUSR1 is caught! (2822 깨어남) |
| 4  | 자식4 종료    | wait() 깸   | child id=2823...              |
| 5  | 자식3(2822) | Running    | child 2822... (5회)            |
| 6  | 자식3 → 자식2 | SIGUSR1 전달 | SIGUSR1 is caught! (2821 깨어남) |
| 7  | 자식3 종료    | wait() 깸   | child id=2822...              |
| 8  | 자식2(2821) | Running    | child 2821...                 |
| 9  | 자식2 → 자식1 | SIGUSR1 전달 | SIGUSR1 is caught! (2820 깨어남) |
| 10 | 자식2 종료    | wait() 깸   | child id=2821...              |
| 11 | 자식1(2820) | Running    | child 2820...                 |
| 12 | 자식1 → 자식0 | SIGUSR1 전달 | SIGUSR1 is caught! (2819 깨어남) |
| 13 | 자식1 종료    | wait() 깸   | child id=2820...              |
| 14 | 자식0(2819) | Running    | child 2819... (5회)            |
| 15 | 자식0 종료    | wait() 깸   | child id=2819...              |

&ensp;운영체제 상태 관점<br/>

| 상태                                    | 의미                                     |
| ------------------------------------- | -------------------------------------- |
| **pause() → Sleep**                   | SIGUSR1 오기 전까지 CPU를 완전히 양보             |
| **SIGUSR1 → Ready → Running**         | 커널이 깨움 → CPU 잡음 → catchusr() → for문 수행 |
| **exit() → Zombie → wait() → Reaped** | 종료 후 부모가 wait()로 수거                    |
| **출력 섞임 원인**                          | 여러 프로세스가 동시에 터미널(stdout)을 공유하기 때문      |

&ensp;시험 대비 “빈칸 포인트” 모음<br/>
* 시그널 등록: sigaction(SIGUSR1, &act, NULL);
* 핸들러 시그니처: void catchusr(int signo)
* 대기: pause(); (또는 심화 sigsuspend)
* PID 얻기: getpid();
* 시그널 보내기: kill( pid_t, SIGUSR1 );
* 1초 쉬기: sleep(1);
* 종료 대기: wait(&status);
* 종료 코드: WEXITSTATUS(status)
* 형식: pid_t pid[5]; (배열/형 변환)

&ensp;리눅스 기본 시그널 테이블<br/>

| 시그널 이름    | 번호     | 기본 동작            | 설명             |
| --------- | ------ | ---------------- | -------------- |
| `SIGHUP`  | 1      | 종료               | 터미널 끊김         |
| `SIGINT`  | **2**  | 종료               | Ctrl + C       |
| `SIGQUIT` | 3      | Core Dump 후 종료   | Ctrl + \       |
| `SIGILL`  | 4      | Core Dump 후 종료   | 잘못된 명령어        |
| `SIGABRT` | 6      | Core Dump 후 종료   | abort() 호출     |
| `SIGFPE`  | 8      | Core Dump 후 종료   | 0으로 나눔         |
| `SIGKILL` | **9**  | 즉시 종료 (catch 불가) | 강제 종료          |
| `SIGUSR1` | **10** | 사용자 정의           | 사용자가 임의로 사용    |
| `SIGSEGV` | 11     | Core Dump 후 종료   | 잘못된 메모리 접근     |
| `SIGUSR2` | **12** | 사용자 정의           | 사용자가 임의로 사용    |
| `SIGPIPE` | 13     | 종료               | 파이프 오류         |
| `SIGALRM` | 14     | 종료               | alarm() 타이머 만료 |
| `SIGTERM` | 15     | 종료               | 기본 종료 시그널      |
| `SIGCHLD` | 17     | 무시               | 자식 종료 알림       |
| `SIGSTOP` | 19     | 정지 (catch 불가)    | 프로세스 일시중지      |
| `SIGCONT` | 18     | 계속 실행            | 정지된 프로세스 재개    |

실습 2
====

`문제 1`
&ensp;10개의 정수를 입력으로 받아 그 합을 출력하는 프로그램을 작성합니다.<br/>
&ensp;(1) 단, 10초간 사용자로부터의 입력이 없으면, 경고 메시지를 출력하고 다시 입력을 기다립니다. <br/>
&ensp;(2) 또한, 입력을 기다리는 동안 받는 SIGINT 시그널은 blocking 시킨 후, 입력을 성공적으로 받은 후, SIGINT 처리를 합니다.<br/>

```c
void catchalarm(int);
void catchint(int);

int main(void){
    int i, num, sum=0;
    sigset_t mask;
    static struct sigaction act1, act2;

    // SIGALRM signal 처리가 가능하도록 설정
    // SIGINT signal 처리가 가능하도록 설정
    // SIGINT signal blocking을 위한 준비

    for (i=0; i<10; i++){
    // SIGINT signal block
    // 10초간 입력이 없으면, SIGALRM이 오도록 설정
    // 입력받기
    // SIGINT signal unblock
    // 입력을 받으면, 알람 꺼두기
    sum+=num;
    printf("sum=%d\n", sum);
    }
    exit(0);
}

void catchalarm(int signo){
    printf("input !!! input !!! input !!!\n");
}

void catchint(int signo){
    printf("Do not interrupt !!!\n");
}
```

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

void catchalarm(int signo);
void catchint(int signo);

int main(void){
	int i, num, sum = 0;
   	sigset_t mask;
    	static struct sigaction act1, act2;
	
	act1.sa_handler=catchalarm;
	sigaction(SIGALRM, &act1, NULL);
	
	act2.sa_handler=catchint;
	sigaction(SIGINT, &act2, NULL);
	
	sigemptyset(&mask);
    	sigaddset(&mask, SIGINT);
	
	for(i=0; i <10; i++){
		sigprocmask(SIG_SETMASK, &mask, NULL);
		do{
			alarm(10);
		}while(scanf("%d", &num) < 0);
		sigprocmask(SIG_UNBLOCK, &mask, NULL);
		alarm(0);
		sum+=num;
		printf("sum=%d\n", sum);
	}
	exit(0);
}

void catchalarm(int signo){
	printf("input !!! input !!! input !!!\n");
}

void catchint(int signo){
	printf("DO not interrup !!!\n");
} 
```

&ensp;주요 시그널 핸들러 등록<br/>
```c
act1.sa_handler = catchalarm;
sigaction(SIGALRM, &act1, NULL);

act2.sa_handler = catchint;
sigaction(SIGINT, &act2, NULL);
```

* `SIGALRM` → `catchalarm()` 실행
* `SIGINT` → `catchint()` 실행
* sigaction()으로 시그널 처리기를 등록한 뒤에는 해당 시그널이 발생할 때마다 지정한 함수가 실행된다.

&ensp;시그널 블록 준비<br/>
```c
sigemptyset(&mask);
sigaddset(&mask, SIGINT);
```

&ensp;→ `mask`라는 시그널 집합에 SIGINT를 추가<br/>
&ensp;→ 즉, 이 mask는 "SIGINT만 막겠다"는 의미이다.<br/>

&ensp;메인 반복문 핵심 부분<br/>
```c
for (i = 0; i < 10; i++) {
    sigprocmask(SIG_SETMASK, &mask, NULL);   // (1) SIGINT 차단
    do {
        alarm(10);                           // (2) 10초 타이머 설정
    } while (scanf("%d", &num) < 0);         // (3) 입력 시도
    sigprocmask(SIG_UNBLOCK, &mask, NULL);   // (4) SIGINT 허용
    alarm(0);                                // (5) 타이머 해제
    sum += num;
    printf("sum=%d\n", sum);
}
```

&ensp;이 루프를 10번 반복해서 정수 10개를 입력받는다.<br/>

&ensp;동작 단계 상세 분석<br/>

&ensp;(1) `sigprocmask(SIG_SETMASK, &mask, NULL);` <br/>
* SIGINT(즉 Ctrl+C)를 차단(block) 한다.
* 이 시점부터 사용자가 Ctrl+C를 눌러도 프로세스는 신호를 받지 않는다.
* 시그널은 대기 상태(pending) 로만 저장된다.

&ensp;입력 도중에 Ctrl+C를 눌러도 프로그램이 중단되지 않는다.<br/>

&ensp;(2) `alarm(10);` <br/>
* 10초 타이머를 설정합니다.
* 10초가 지나면 커널이 자동으로 `SIGALRM` 시그널을 이 프로세스에 보낸다.
* 그때 실행되는 함수가 `catchalarm()` 이다.

&ensp;→10초 동안 아무 입력이 없으면<br/>
```css
input !!! input !!! input !!!
```

&ensp;이 출력됩니다.(그리고 다시 `scanf` 는 계속 입력을 기다립니다.)<br/>

&ensp;(3) `scanf("%d", &num)` <br/>
* 사용자의 숫자 입력을 기다린다.
* 입력이 있을 때까지 블록(blocked) 상태로 머문다.
* 만약 사용자가 10초 안에 입력하면:
    - SIGALRM이 발생하기 전에 `scanf()` 가 값을 읽고 진행
    - 이후 `alarm(0)` 으로 타이머 해제
* 만약 사용자가 10초 이상 입력하지 않으면:
    - SIGALRM 발생 → `catchalarm()` 실행
    - `"input !!! input !!! input !!!"` 출력
    - 다시 `scanf()` 로 입력을 기다림 (프로그램 계속 진행)

&ensp;10초마다 "input !!!" 경고가 뜨지만 입력은 계속 대기 상태<br/>

&ensp;(4) `sigprocmask(SIG_UNBLOCK, &mask, NULL);` <br/>
* 입력이 완료되면 `SIGINT` 를 다시 허용(Unblock).
* 이 시점 이후에는 Ctrl+C를 누르면 `catchint()` 실행됨

```bash
Do not interrup !!!
```

&ensp;이 메시지만 뜨고, 프로그램은 종료되지 않는다.<br/>

&ensp;(5) `alarm(0);` <br/>
* alarm(0)은 기존에 걸어둔 타이머를 해제(cancel) 하는 명령이다.
* 정상적으로 입력을 받았다면 더 이상 SIGALRM이 올 필요가 없으므로 제거한다.

&ensp;결과 예시<br/>
```bash
Enter integer 1: (10초간 아무것도 입력 안 함)
input !!! input !!! input !!!
Enter integer 1: 10
sum=10
Enter integer 2: ^C
Do not interrup !!!
Enter integer 2: 20
sum=30
Enter integer 3: (입력 없음)
input !!! input !!! input !!!
input !!! input !!! input !!!
Enter integer 3: 5
sum=35
...
```

&ensp;코드의 핵심 매커니즘<br/>

| 기능                  | 설명                                        |
| ------------------- | ----------------------------------------- |
| **SIGALRM (alarm)** | 10초 동안 입력이 없을 때 경고 메시지 출력                 |
| **SIGINT (Ctrl+C)** | 입력 중에는 차단, 입력 끝나면 핸들러 출력만 함               |
| **sigprocmask**     | SIGINT를 block/unblock 하여 입력 중간에 방해되지 않게 함 |
| **alarm(0)**        | 입력이 완료되면 알람 해제                            |
| **scanf**           | 사용자 입력을 기다림. 블록 중에 SIGALRM 발생 가능          |

&ensp;시그널 타이밍 다이어그램<br/>
```scss
시간 흐름  ───────────────────────────────────────────────────────────→

[1] SIGINT Block 시작
│
│ sigprocmask(SIG_SETMASK, &mask, NULL)
│ → Ctrl+C 눌러도 무시됨 (SIGINT 대기 상태)
│
│───────────────────────────────────────────────────────────────
│
│ [2] alarm(10) 설정
│ → 10초 후 SIGALRM 예정
│
│───────────────────────────────────────────────────────────────
│
│ [3] scanf()로 입력 대기 상태
│   사용자가 입력할 때까지 블록됨
│
│   ├──(a) 사용자가 10초 안에 입력하면:
│   │      • SIGALRM 발생 안 함
│   │      • alarm(0)으로 타이머 해제
│   │      • 입력된 값 합산, 출력
│   │      • SIGINT Unblock (Ctrl+C 다시 동작 가능)
│   │
│   └──(b) 사용자가 10초 동안 입력 안 하면:
│          • SIGALRM 발생 → catchalarm() 실행
│          • "input !!! input !!! input !!!" 출력
│          • 다시 scanf() 대기 (반복)
│
│───────────────────────────────────────────────────────────────
│
│ [4] 입력 성공 시
│   alarm(0);              → 타이머 해제
│   sigprocmask(SIG_UNBLOCK, &mask, NULL);  → SIGINT 허용
│
│───────────────────────────────────────────────────────────────
│
│ [5] SIGINT 발생 (예: Ctrl+C)
│   → catchint() 실행
│   → "Do not interrup !!!" 출력
│   (하지만 프로그램은 종료되지 않음)
│
│───────────────────────────────────────────────────────────────
│
│ [6] 다음 입력 단계로 이동 (다시 SIGINT Block)
│───────────────────────────────────────────────────────────────
```

&ensp;핵심 흐름 요약<br/>

| 단계 | 이벤트              | 설명                                    |
| -- | ---------------- | ------------------------------------- |
| ①  | `SIGINT Block`   | Ctrl+C 일시적으로 차단                       |
| ②  | `alarm(10)`      | 10초 타이머 설정                            |
| ③  | `scanf()`        | 사용자 입력 대기 (입력 없으면 SIGALRM 발생)         |
| ④  | `SIGALRM`        | 10초 후 "input !!! input !!!" 출력        |
| ⑤  | `alarm(0)`       | 입력 성공 시 타이머 해제                        |
| ⑥  | `SIGINT Unblock` | 입력 후 Ctrl+C 다시 허용                     |
| ⑦  | `SIGINT 발생`      | "Do not interrup !!!" 출력 (프로세스는 종료 X) |
| ⑧  | `반복`             | 다음 숫자 입력 위해 다시 block~unblock 반복       |
