---
title: "Lect11-3. Locking"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-12-01
last_modified_at: 2025-12-01
---

리눅스 세마포 핵심 복습
=====

&ensp;리눅스 세마포는 카운팅 세마포 + 바이너리 세마포가 합쳐진 형태이다. → 값은 0 또는 양의 정수만 가능, 음수 없음<br/>

&ensp;**Wait(k)**<br/>
* 세마포 값 ≥ k → k만큼 뺌
* 세마포 값 < k → block(대기)

&ensp;**Signal(k)**<br/>
* 세마포 값 += k
* 이때 깨어날 수 있는 프로세스는 세마포 값이 0이상이 되었을 때만 깨어남

&ensp;리눅스의 세마포는 카운팅 세마포보다 훨씬 강력한 여러 프로세스를 한 번에 깨우거나 작업 순서를 강제로 1→2→3으로 만들 수도 있다.<br/>

Record Locking
=====

> 파일 안의 일부 구간만 잠그는 기능

&ensp;필요한 이유<br/>
&ensp;파일 x = 100이 있다.<br/>
&ensp;P1<br/>
* Read x → 100
* x + 100 → 200
* Write x → 200

&ensp;P2<br/>
* Read x → 100
* x + 200 → 300
* Write x → 300

&ensp;두 프로세스가 동시에 작업하면?<br/>
&ensp;결과는 <br/>
* 200, 300, 400 모두 가능 

&ensp;왜 문제?<br/>
&ensp;P1과 P2가 동시에 read, 각자 계산 후 overwrite하기 때문 → 이 문제를 막는 것이 record locking<br/>

## Record Locking 개념

&ensp;락 종류<br/>
&ensp;**Read lock (F_RDLCK)**<br/>
* 여러 프로세스가 동시에 읽기 가능
* 하지만 쓰기(lock)는 허용 안 됨

&ensp;**Write lock (F_WRLCK)**<br/>
* 읽기/쓰기 모두 금지
* 하나의 프로세스만 접근 가능

&ensp;**Unlock (F_UNLCK)**<br/>
* 락 해제

| 현재 작업 | 필요한 락      |
| ----- | ---------- |
| 읽기만   | read lock  |
| 쓰기 포함 | write lock |
| 락 풀기  | unlock     |


## Record Locking 사용법

```c
#include <fcntl.h>

fcntl(int fd, int cmd, struct flock *lockinfo);
```

&ensp;struct flock<br/>
```c
struct flock {
    short l_type;    // F_RDLCK, F_WRLCK, F_UNLCK
    short l_whence;  // SEEK_SET, SEEK_CUR, SEEK_END
    off_t l_start;   // 기준점으로부터 락을 걸 시작 위치
    off_t l_len;     // 락을 걸 범위 길이
    pid_t l_pid;     // F_GETLK에서만 사용 (누가 락 걸었는지)
};
```

## cmd 의 의미

&ensp;;**F_GETLK**<br/>
&ensp;현재 어떤 락이 걸렸는지 확인<br/>

&ensp;**F_SETLK**<br/>
&ensp;non-blocking lock/unlock<br/>
* 누가 락 걸고 있으면 → 바로 실패(return -1)
* 기다리지 않음

&ensp;**F_SETLKW**<br/>
* 락이 풀릴 때까지 기다림
* 일반적으로 우리가 쓰는 방식

## 레코드 범위 지정

&ensp;락은 파일 전체가 아니라 특정 구간에만 걸 수 있다.<br/>
```css
seek_cur
a b c d e f g h i j k ...
        ^-------^
      l_start   l_len
```

* l_whence = SEEK_CUR
* l_start = 현재 위치로부터 + 2
* l_len = 4바이트 락

&ensp;이런 식으로 정확히 필요한 데이터만 잠근다.<br/>

&ensp;락킹의 특징<br/>
&ensp;**fork() 해도 락은 자식에게 상속되지 않음**<br/>
* 부모가 락 걸어도
* 자식은 락 없음

&ensp;**프로세스 종료 시 모든 락 자동 해제**<br/>
* 강제 종료돼도 락은 풀림
* 파일이 영구적으로 잠기는 일 없음

&ensp;실제 예제 분석<br/>
&ensp;두 프로세스가 파일의 10개 정수에 차례로 +10을 하는 상황<br/>

&ensp;락 없이 실행하면?<br/>
* 데이터 꼬임 발생
* 결과 = +20 되어야 하는데 +10만 반영되는 경우 발생(중간 계산이 덮어씌워짐)

&ensp;락 사용 시<br/>
&ensp;각 정수에 대해<br/>
```text
1) write lock 걸기  
2) 읽기  
3) 계산  
4) 쓰기  
5) unlock  
```

&ensp;이 순서를 지키므로 항상 정확한 결과 보장<br/>
&ensp;여러 프로세스가 동시에 돌려도 항상 최종 결과 = +20 정상 출력됨<br/>

Deadlock (교착 상태)
====

&ensp;락에서 데드락이 생기는 경우<br/>

&ensp;P1<br/>
1. A lock
2. B lock(대기)

&ensp;p2<br/>
1. B lock
2. A lock(대기)

&ensp;→ 서로 상대방이 락 풀기 전까지 영원히 기다림<br/>

&ensp;리눅스 record locking은 Deadlock detection 있음<br/>
* F_SETLKW(블로킹 락)를 사용했는데 OS가 보기에 데드락 위험이면 즉시 실패시킴
* errno = `EDEADLK` 로 설정됨

&ensp;세마포/파이프는 OS가 데드락 감지 안 하지만 파일 record locking은 자동 감지해줌<br/>

