---
title: "Lect11-3. Locking"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-12-01
last_modified_at: 2025-12-01
---

리눅스 세마포 핵심 복습
=====

&ensp;리눅스 세마포는 카운팅 세마포 + 바이너리 세마포가 합쳐진 형태이다. → 값은 0 또는 양의 정수만 가능, 음수 없음<br/>

&ensp;**Wait(k)**<br/>
* 세마포 값 ≥ k → k만큼 뺌
* 세마포 값 < k → block(대기)

&ensp;**Signal(k)**<br/>
* 세마포 값 += k
* 이때 깨어날 수 있는 프로세스는 세마포 값이 0이상이 되었을 때만 깨어남

&ensp;리눅스의 세마포는 카운팅 세마포보다 훨씬 강력한 여러 프로세스를 한 번에 깨우거나 작업 순서를 강제로 1→2→3으로 만들 수도 있다.<br/>

Record Locking
=====

> 파일 안의 일부 구간만 잠그는 기능

&ensp;필요한 이유<br/>
&ensp;파일 x = 100이 있다.<br/>
&ensp;P1<br/>
* Read x → 100
* x + 100 → 200
* Write x → 200

&ensp;P2<br/>
* Read x → 100
* x + 200 → 300
* Write x → 300

&ensp;두 프로세스가 동시에 작업하면?<br/>
&ensp;결과는 <br/>
* 200, 300, 400 모두 가능 

&ensp;왜 문제?<br/>
&ensp;P1과 P2가 동시에 read, 각자 계산 후 overwrite하기 때문 → 이 문제를 막는 것이 record locking<br/>

## Record Locking 개념

&ensp;락 종류<br/>
&ensp;**Read lock (F_RDLCK)**<br/>
* 여러 프로세스가 동시에 읽기 가능
* 하지만 쓰기(lock)는 허용 안 됨

&ensp;**Write lock (F_WRLCK)**<br/>
* 읽기/쓰기 모두 금지
* 하나의 프로세스만 접근 가능

&ensp;**Unlock (F_UNLCK)**<br/>
* 락 해제

| 현재 작업 | 필요한 락      |
| ----- | ---------- |
| 읽기만   | read lock  |
| 쓰기 포함 | write lock |
| 락 풀기  | unlock     |


## Record Locking 사용법

```c
#include <fcntl.h>

fcntl(int fd, int cmd, struct flock *lockinfo);
```

&ensp;struct flock<br/>
```c
struct flock {
    short l_type;    // F_RDLCK, F_WRLCK, F_UNLCK
    short l_whence;  // SEEK_SET, SEEK_CUR, SEEK_END
    off_t l_start;   // 기준점으로부터 락을 걸 시작 위치
    off_t l_len;     // 락을 걸 범위 길이
    pid_t l_pid;     // F_GETLK에서만 사용 (누가 락 걸었는지)
};
```

## cmd 의 의미

&ensp;;**F_GETLK**<br/>
&ensp;현재 어떤 락이 걸렸는지 확인<br/>

&ensp;**F_SETLK**<br/>
&ensp;non-blocking lock/unlock<br/>
* 누가 락 걸고 있으면 → 바로 실패(return -1)
* 기다리지 않음

&ensp;**F_SETLKW**<br/>
* 락이 풀릴 때까지 기다림
* 일반적으로 우리가 쓰는 방식

## 레코드 범위 지정

&ensp;락은 파일 전체가 아니라 특정 구간에만 걸 수 있다.<br/>
```css
seek_cur
a b c d e f g h i j k ...
        ^-------^
      l_start   l_len
```

* l_whence = SEEK_CUR
* l_start = 현재 위치로부터 + 2
* l_len = 4바이트 락

&ensp;이런 식으로 정확히 필요한 데이터만 잠근다.<br/>

&ensp;락킹의 특징<br/>
&ensp;**fork() 해도 락은 자식에게 상속되지 않음**<br/>
* 부모가 락 걸어도
* 자식은 락 없음

&ensp;**프로세스 종료 시 모든 락 자동 해제**<br/>
* 강제 종료돼도 락은 풀림
* 파일이 영구적으로 잠기는 일 없음

&ensp;실제 예제 분석<br/>
&ensp;두 프로세스가 파일의 10개 정수에 차례로 +10을 하는 상황<br/>

&ensp;락 없이 실행하면?<br/>
* 데이터 꼬임 발생
* 결과 = +20 되어야 하는데 +10만 반영되는 경우 발생(중간 계산이 덮어씌워짐)

&ensp;락 사용 시<br/>
&ensp;각 정수에 대해<br/>
```text
1) write lock 걸기  
2) 읽기  
3) 계산  
4) 쓰기  
5) unlock  
```

&ensp;이 순서를 지키므로 항상 정확한 결과 보장<br/>
&ensp;여러 프로세스가 동시에 돌려도 항상 최종 결과 = +20 정상 출력됨<br/>

Deadlock (교착 상태)
====

&ensp;락에서 데드락이 생기는 경우<br/>

&ensp;P1<br/>
1. A lock
2. B lock(대기)

&ensp;p2<br/>
1. B lock
2. A lock(대기)

&ensp;→ 서로 상대방이 락 풀기 전까지 영원히 기다림<br/>

&ensp;리눅스 record locking은 Deadlock detection 있음<br/>
* F_SETLKW(블로킹 락)를 사용했는데 OS가 보기에 데드락 위험이면 즉시 실패시킴
* errno = `EDEADLK` 로 설정됨

&ensp;세마포/파이프는 OS가 데드락 감지 안 하지만 파일 record locking은 자동 감지해줌<br/>

실습
====

문제1
----

&ensp;1. Parent process는 표준입력으로 정수를 하나 입력받아, “data" 파일에 쓴 후, 세 개의 child process들을 만듭니다. 각 child process는 "data" 파일의 정수값을 읽고 5초간 기다렸다 +10 한 값을 씁니다. 세 child의 덧셈이 정확히 되도록 file locking을 써서 동기화를 합니다. <br/>

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ipc.h>

void do_child(int fd){
    int in;
    pid_t pid = getpid();
    struct flock lock;

    // record locking    
    lock.l_type = F_WRLCK;
    lock.l_whence = SEEK_SET;
    lock.l_start=0;
    lock.l_len=sizeof(int);
    fcntl(fd, F_SETLKW, &lock);

    lseek(fd, 0, SEEK_SET);
    read(fd, &in, sizeof(int));
    printf("%ld reads %d ... \n", pid, in);
    sleep(5);


    in=in+10;
    // 정수 다시 쓰기
    lseek(fd, 0, SEEK_SET);
    write(fd, &in, sizeof(int));
    printf("%ld writes %d ... \n", pid,  in);

    // record unlocking
    lock.l_type=F_UNLCK;
    // lock.l_whence = SEEK_SET;
    // lock.l_start= 0;
    // lock.l_len=sizeof(int);
    fcntl(fd, F_SETLK, &lock);

    exit(0);
    
}

int main(void){
    int i, in, fd;
    pid_t pid;

    fd=open("data1", O_RDWR | O_CREAT, 0600);
    scanf("%d", &in);
    write(fd, &in, sizeof(int));

    for(i=0;i<3;i++){
        pid=fork();
        if(pid==0){
            do_child(fd);
        }
    }

    for(i=0;i<3;i++){
        wait(0);
    }

    // 정수 읽기
    lseek(fd, 0, SEEK_SET);   
    read(fd, &in, sizeof(int));
    printf("%d\n", in);

    exit(0);
}
```

## 메커니즘

&ensp;1. Parent가 하는 일<br/>
```c
fd = open("data1", O_RDWR | O_CREAT, 0600);
scanf("%d", &in);
write(fd, &in, sizeof(int));
```

&ensp;설명<br/>
1. `data1` 파일을 열어서 fd를 얻는다.
2. Parent는 정수를 입력받아 파일 맨 앞에 저장한다.
3. 이 fd는 곧 fork를 통해 child에게 그대로 복사되어 공유된다.

&ensp;2. fork() 후의 상황<br/>
```c
for(i=0;i<3;i++){
    pid=fork();
    if(pid==0){
        do_child(fd);
    }
}
```

&ensp;Parent와 Child는 같은 파일을 공유한다.<br/>
* 각각의 child는 같은 fd를 가진다.
* 같은 fd는 같은 파일 테이블 entry를 공유하므로 → 파일 오프셋(file offset) 도 공유됨, 레코드 락도 서로 영향을 주고 받는다. 

&ensp;Child 프로세스의 행동(do_child)<br/>
&ensp;(1) 파일 잠금: Critical section 입장 준비<br/>
```c
lock.l_type = F_WRLCK;
lock.l_whence = SEEK_SET;
lock.l_start=0;
lock.l_len=sizeof(int);
fcntl(fd, F_SETLKW, &lock);
```

&ensp;의미<br/>
* 파일의 처음부터 `sizeof(int)` 바이트 구간을 쓰기 락(F_WRLCK)으로 잠근다.
* `F_SETLKW` 는 락이 풀릴 때까지 기다리는(blocking) 함수이다. 

&ensp;핵심<br/>
* child 3개가 동시에 do_child를 실행하지만 락을 걸 수 있는 child는 단 1개 뿐
* 나머지 child 2개는 여기에서 잠금 상태로 block된다.

```pgsql
child1: lock 성공 → read → sleep → write → unlock
child2: lock 시도 → block(커널이 잠금중이라고 판단)
child3: lock 시도 → block

child1 unlock → child2 깨움
child2 unlock → child3 깨움
child3 unlock → 종료
```

&ensp;이 모든 과정이 커널 내부에서 자동을 일어난다.<br/>

&ensp;(2) 값 읽기<br/>
```c
lseek(fd, 0, SEEK_SET);
read(fd, &in, sizeof(int));
```

&ensp;파일 오프셋을 처음으로 이동<br/>
&ensp;정수 하나 읽어오기<br/>
&ensp;이때 이미 다른 child는 들어올 수 없으므로 읽는 값은 항상 최신값이다.<br/>

&ensp;(3) 5초 대기 (동시성 문제를 유발시키는 명령)<br/>
```c
sleep(5);
```

&ensp;원래 sleep은 race codition을 유발할 수 있다. 하지만 지금은 record lock으로 보호받으므로 문제가 없다.<br/>

&ensp;(4) 값 읽기<br/>
```c
in = in + 10;
lseek(fd, 0, SEEK_SET);
write(fd, &in, sizeof(int));
```

&ensp;다시 파일 처음에 값을 덮어쓴다.<br/>
&ensp;;Child → +10<br/>
&ensp;child2 → +10<br/>
&ensp;child3 → +10<br/>
&ensp;이 순서의 보장은 락을 통해 이루어진다.<br/>

&ensp;(5) Lock 해제<br/>
```c
lock.l_type=F_UNLCK;
fcntl(fd, F_SETLK, &lock);
```

&ensp;이제 critical section을 빠져나감<br/>
&ensp;다음 child에게 lock이 넘어가서 실행된다.<br/>

```perl
child1 → lock → read → sleep → write → unlock
child2 → lock → read → sleep → write → unlock
child3 → lock → read → sleep → write → unlock
```

| 왜 가능한가?                   | 이유                                                |
| ------------------------- | ------------------------------------------------- |
| child들이 자동으로 줄 선다         | fcntl의 record locking은 커널이 관리하는 ‘락 테이블’을 이용하기 때문에 |
| 하나의 child만 lock을 획득한다     | 동일 구간에 대해 쓰기 락은 배타적이기 때문(WRLCK)                   |
| 나머지 child는 block 상태로 기다린다 | `F_SETLKW`가 lock이 풀릴 때까지 커널이 block 시킴             |
| unlock하면 다음 child가 이어서 실행 | 커널이 block queue에서 프로세스를 깨워줌                       |


&ensp;이 흐름으로 정확히 동작함<br/>

&ensp;4. Parent가 최종 결과 확인<br/>
```c
lseek(fd, 0, SEEK_SET);
read(fd, &in, sizeof(int));   
printf("%d\n", in);
```

&ensp;child 3명 모두 완료(wait) 후 최종 값 읽음<br/>

&ensp;예를 들어 입력이 100이면:<br/>
```nginx
child1 → 110
child2 → 120
child3 → 130
```

&ensp;최종 출력: 130<br/>

&ensp;전체 메커니즘 도식화<br/>
```perl
Parent
 ├─ write(초기값)
 ├─ fork child1
 ├─ fork child2
 └─ fork child3

Child1            Child2           Child3
----------------------------------------------------
lock(wait-free)   lock(wait)       lock(wait)
read 값 100
+10 → 110
write 110
unlock → Child2가 실행됨

                  read 값 110
                  +10 → 120
                  write 120
                  unlock → Child3 실행됨

                                   read 120
                                   +10 → 130
                                   write 130
                                   unlock
```

문제 2
----

&ensp;2. 네 개의 프로세스가 동기화를 하며 자신의 프로세스 id를 5회 출력하는 프로그램을 작성합니다. 네 개의 프로세스는 "turn1" file을 이용하여 동기화에 참여하는 전체 프로세스 중 자신의 출력 순서를 결정합니다. 둘 이상의 프로세스가 동시에 자신의 id를 출력하지 않도록 하는 동기화 작업은 file locking을 사용합니다. 네 프로세스의 출력 순서가 정해져 있지 않습니다. 동시에 출력을 하지 않도록만 하면 됩니다.<br/>

&ensp;문제 요구사항<br/>
1. 프로세스 4개가 생성된다.
2. 각 프로세스는 자기 pid를 5번 출력한다.
3. 출력 순서는 정해져 있지 않다. → 즉, "1번이 먼저, 2번이 다음" 같은 특정 순서 필요 없음.
4. 단, 동시에 두 개 이상 프로세스가 출력하면 안 된다. → 즉, “critical section”을 보호해야 한다.
5. 동기화를 위해 파일 locking만 사용한다.
6. turn1 파일은 “전체 프로세스가 공유하는 잠금용 파일” 역할.

&ensp;결론: 각 프로세스는 출력할 때마다 lock → print(pid) → unlock 해야 한다.<br/>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

int main(void){
    int i, fd;
    pid_t pid;
    struct flock lock;

    fd = open("turn1", O_RDWR | O_CREAT, 0600);

    for (i = 0; i < 3; i++) {
        pid = fork();
        if (pid == 0)
            break;
    }

    lock.l_type   = F_WRLCK;
    lock.l_whence = SEEK_SET;
    lock.l_start  = 0;
    lock.l_len    = sizeof(pid_t);
    fcntl(fd, F_SETLKW, &lock);

    pid = getpid();
    for (i = 0; i < 5; i++) {
        sleep(1);
        printf("%ld\n", pid);
    }

    lock.l_type = F_UNLCK;
    fcntl(fd, F_SETLK, &lock);

    /* 부모만 자식 대기 */
    if (pid > 0) {
        for (i = 0; i < 3; i++)
            wait(NULL);
    }

    exit(0);
}

```


## 매커니즘

&ensp;1. 프로세스 생성 매커니즘 (fork 단계)<br/>
```c
for (i = 0; i < 3; i++) {
    pid = fork();
    if (pid == 0)
        break;
}
```

&ensp;실행 흐름<br/>
* 최초 1개 프로세스(부모)
* `fork()` 3번 호출

&ensp;결과:<br/>
```
부모 1개
자식 3개
총 4개 프로세스
```

* 모든 프로세스는 같은 코드 실행
* 하지만 각각 다른 PID 보유
* 모두 동일한 `"turn1"` 파일을 공유

&ensp;2. 공용 자원: turn1 파일<br/>
```c
fd = open("turn1", O_RDWR | O_CREAT, 0600);
```

&ensp;역할<br/>
* 프로세스 간 동기화 대상
* 커널이 관리하는 전역 자원
* 메모리 공유 없이도 동기화 가능

&ensp;3. Lock 설정 의미<br/>
```c
lock.l_type   = F_WRLCK;
lock.l_whence = SEEK_SET;
lock.l_start  = 0;
lock.l_len    = sizeof(pid_t);
```

&ensp;의미 해석<br/>

| 항목                      | 의미          |
| ----------------------- | ----------- |
| `F_WRLCK`               | 배타적 쓰기 lock |
| `SEEK_SET`              | 파일 시작 기준    |
| `l_start = 0`           | 0바이트부터      |
| `l_len = sizeof(pid_t)` | pid 크기 영역   |

&ensp;4. Lock 획득 (핵심 동기화)<br/>
```c
fcntl(fd, F_SETLKW, &lock);
```

&ensp;커널에서 벌어지는 일<br/>
* lock이 비어있으면 → 즉시 획득
* 다른 프로세스가 lock 중이면 → sleep 상태로 대기
* busy waiting X

&ensp;항상 단 하나의 프로세스만 통과<br/>

&ensp;5. 임계 구역 (Critical Section)<br/>
```c
pid = getpid();
for (i = 0; i < 5; i++) {
    sleep(1);
    printf("%ld\n", pid);
}
```

&ensp;의미<br/>
* lock을 가진 프로세스만 실행 가능
* 자신의 PID를 연속으로 5회 출력
* 이 동안 다른 3개 프로세스는 완전히 차단

&ensp;동시에 출력 불가 보장<br/>

&ensp;6. Unlock → 다음 프로세스로 턴 전달<br/>
```c
lock.l_type = F_UNLCK;
fcntl(fd, F_SETLK, &lock);
```

&ensp;동작<br/>
* 현재 프로세스 lock 해제
* 커널이 대기 중이던 프로세스 하나를 깨움
* 다음 프로세스가 lock 획득

&ensp;7. 부모 프로세스의 역할 (wait 매커니즘)<bt/>
```c
if (pid > 0) {
    for (i = 0; i < 3; i++)
        wait(NULL);
}
```

&ensp;왜 필요한가<br/>
* 부모가 먼저 종료되면 쉘이 프롬프트를 띄움
* 자식 출력이 프롬프트 뒤에 섞이는 문제 발생

&ensp;해결<br/>
* 부모는 자식 3개가 끝날 때까지 대기
* 프로그램 종료 시점이 완전히 정리됨

&ensp;8. 전체 실행 타임라인 (개념도)<br/>
```bash
P1: lock ── print x5 ── unlock ── exit
P2:      wait ── lock ── print x5 ── unlock ── exit
P3:             wait ── lock ── print x5 ── unlock ── exit
P4:                    wait ── lock ── print x5 ── unlock ── exit
```

&ensp;출력 순서는 랜덤하지만 절대 동시에 두 개 이상 출력되지 않는다.<br/>

&ensp;출력 예시 (실제로는 매 실행마다 순서 바뀜)<br/>
```shell
4002
4001
4003
4004
4001
4003
4002
4004
4003
4001
...
(각자 5번씩)
```