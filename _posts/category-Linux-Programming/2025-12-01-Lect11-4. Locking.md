---
title: "Lect11-3. Locking"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-12-01
last_modified_at: 2025-12-01
---

리눅스 세마포 핵심 복습
=====

&ensp;리눅스 세마포는 카운팅 세마포 + 바이너리 세마포가 합쳐진 형태이다. → 값은 0 또는 양의 정수만 가능, 음수 없음<br/>

&ensp;**Wait(k)**<br/>
* 세마포 값 ≥ k → k만큼 뺌
* 세마포 값 < k → block(대기)

&ensp;**Signal(k)**<br/>
* 세마포 값 += k
* 이때 깨어날 수 있는 프로세스는 세마포 값이 0이상이 되었을 때만 깨어남

&ensp;리눅스의 세마포는 카운팅 세마포보다 훨씬 강력한 여러 프로세스를 한 번에 깨우거나 작업 순서를 강제로 1→2→3으로 만들 수도 있다.<br/>

Record Locking
=====

> 파일 안의 일부 구간만 잠그는 기능

&ensp;필요한 이유<br/>
&ensp;파일 x = 100이 있다.<br/>
&ensp;P1<br/>
* Read x → 100
* x + 100 → 200
* Write x → 200

&ensp;P2<br/>
* Read x → 100
* x + 200 → 300
* Write x → 300

&ensp;두 프로세스가 동시에 작업하면?<br/>
&ensp;결과는 <br/>
* 200, 300, 400 모두 가능 

&ensp;왜 문제?<br/>
&ensp;P1과 P2가 동시에 read, 각자 계산 후 overwrite하기 때문 → 이 문제를 막는 것이 record locking<br/>

## Record Locking 개념

&ensp;락 종류<br/>
&ensp;**Read lock (F_RDLCK)**<br/>
* 여러 프로세스가 동시에 읽기 가능
* 하지만 쓰기(lock)는 허용 안 됨

&ensp;**Write lock (F_WRLCK)**<br/>
* 읽기/쓰기 모두 금지
* 하나의 프로세스만 접근 가능

&ensp;**Unlock (F_UNLCK)**<br/>
* 락 해제

| 현재 작업 | 필요한 락      |
| ----- | ---------- |
| 읽기만   | read lock  |
| 쓰기 포함 | write lock |
| 락 풀기  | unlock     |


## Record Locking 사용법

```c
#include <fcntl.h>

fcntl(int fd, int cmd, struct flock *lockinfo);
```

&ensp;struct flock<br/>
```c
struct flock {
    short l_type;    // F_RDLCK, F_WRLCK, F_UNLCK
    short l_whence;  // SEEK_SET, SEEK_CUR, SEEK_END
    off_t l_start;   // 기준점으로부터 락을 걸 시작 위치
    off_t l_len;     // 락을 걸 범위 길이
    pid_t l_pid;     // F_GETLK에서만 사용 (누가 락 걸었는지)
};
```

## cmd 의 의미

&ensp;;**F_GETLK**<br/>
&ensp;현재 어떤 락이 걸렸는지 확인<br/>

&ensp;**F_SETLK**<br/>
&ensp;non-blocking lock/unlock<br/>
* 누가 락 걸고 있으면 → 바로 실패(return -1)
* 기다리지 않음

&ensp;**F_SETLKW**<br/>
* 락이 풀릴 때까지 기다림
* 일반적으로 우리가 쓰는 방식

## 레코드 범위 지정

&ensp;락은 파일 전체가 아니라 특정 구간에만 걸 수 있다.<br/>
```css
seek_cur
a b c d e f g h i j k ...
        ^-------^
      l_start   l_len
```

* l_whence = SEEK_CUR
* l_start = 현재 위치로부터 + 2
* l_len = 4바이트 락

&ensp;이런 식으로 정확히 필요한 데이터만 잠근다.<br/>

&ensp;락킹의 특징<br/>
&ensp;**fork() 해도 락은 자식에게 상속되지 않음**<br/>
* 부모가 락 걸어도
* 자식은 락 없음

&ensp;**프로세스 종료 시 모든 락 자동 해제**<br/>
* 강제 종료돼도 락은 풀림
* 파일이 영구적으로 잠기는 일 없음

&ensp;실제 예제 분석<br/>
&ensp;두 프로세스가 파일의 10개 정수에 차례로 +10을 하는 상황<br/>

&ensp;락 없이 실행하면?<br/>
* 데이터 꼬임 발생
* 결과 = +20 되어야 하는데 +10만 반영되는 경우 발생(중간 계산이 덮어씌워짐)

&ensp;락 사용 시<br/>
&ensp;각 정수에 대해<br/>
```text
1) write lock 걸기  
2) 읽기  
3) 계산  
4) 쓰기  
5) unlock  
```

&ensp;이 순서를 지키므로 항상 정확한 결과 보장<br/>
&ensp;여러 프로세스가 동시에 돌려도 항상 최종 결과 = +20 정상 출력됨<br/>

Deadlock (교착 상태)
====

&ensp;락에서 데드락이 생기는 경우<br/>

&ensp;P1<br/>
1. A lock
2. B lock(대기)

&ensp;p2<br/>
1. B lock
2. A lock(대기)

&ensp;→ 서로 상대방이 락 풀기 전까지 영원히 기다림<br/>

&ensp;리눅스 record locking은 Deadlock detection 있음<br/>
* F_SETLKW(블로킹 락)를 사용했는데 OS가 보기에 데드락 위험이면 즉시 실패시킴
* errno = `EDEADLK` 로 설정됨

&ensp;세마포/파이프는 OS가 데드락 감지 안 하지만 파일 record locking은 자동 감지해줌<br/>

실습
====

문제1
----

&ensp;1. Parent process는 표준입력으로 정수를 하나 입력받아, “data" 파일에 쓴 후, 세 개의 child process들을 만듭니다. 각 child process는 "data" 파일의 정수값을 읽고 5초간 기다렸다 +10 한 값을 씁니다. 세 child의 덧셈이 정확히 되도록 file locking을 써서 동기화를 합니다. <br/>

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ipc.h>

void do_child(int fd){
    int in;
    pid_t pid = getpid();
    struct flock lock;

    // record locking    
    lock.l_type = F_WRLCK;
    lock.l_whence = SEEK_SET;
    lock.l_start=0;
    lock.l_len=sizeof(int);
    fcntl(fd, F_SETLKW, &lock);

    lseek(fd, 0, SEEK_SET);
    read(fd, &in, sizeof(int));
    printf("%ld reads %d ... \n", pid, in);
    sleep(5);


    in=in+10;
    // 정수 다시 쓰기
    lseek(fd, 0, SEEK_SET);
    write(fd, &in, sizeof(int));
    printf("%ld writes %d ... \n", pid,  in);

    // record unlocking
    lock.l_type=F_UNLCK;
    // lock.l_whence = SEEK_SET;
    // lock.l_start= 0;
    // lock.l_len=sizeof(int);
    fcntl(fd, F_SETLK, &lock);

    exit(0);
    
}

int main(void){
    int i, in, fd;
    pid_t pid;

    fd=open("data1", O_RDWR | O_CREAT, 0600);
    scanf("%d", &in);
    write(fd, &in, sizeof(int));

    for(i=0;i<3;i++){
        pid=fork();
        if(pid==0){
            do_child(fd);
        }
    }

    for(i=0;i<3;i++){
        wait(0);
    }

    // 정수 읽기
    lseek(fd, 0, SEEK_SET);   
    read(fd, &in, sizeof(int));
    printf("%d\n", in);

    exit(0);
}
```

## 메커니즘

&ensp;1. Parent가 하는 일<br/>
```c
fd = open("data1", O_RDWR | O_CREAT, 0600);
scanf("%d", &in);
write(fd, &in, sizeof(int));
```

&ensp;설명<br/>
1. `data1` 파일을 열어서 fd를 얻는다.
2. Parent는 정수를 입력받아 파일 맨 앞에 저장한다.
3. 이 fd는 곧 fork를 통해 child에게 그대로 복사되어 공유된다.

&ensp;2. fork() 후의 상황<br/>
```c
for(i=0;i<3;i++){
    pid=fork();
    if(pid==0){
        do_child(fd);
    }
}
```

&ensp;Parent와 Child는 같은 파일을 공유한다.<br/>
* 각각의 child는 같은 fd를 가진다.
* 같은 fd는 같은 파일 테이블 entry를 공유하므로 → 파일 오프셋(file offset) 도 공유됨, 레코드 락도 서로 영향을 주고 받는다. 

&ensp;Child 프로세스의 행동(do_child)<br/>
&ensp;(1) 파일 잠금: Critical section 입장 준비<br/>
```c
lock.l_type = F_WRLCK;
lock.l_whence = SEEK_SET;
lock.l_start=0;
lock.l_len=sizeof(int);
fcntl(fd, F_SETLKW, &lock);
```

&ensp;의미<br/>
* 파일의 처음부터 `sizeof(int)` 바이트 구간을 쓰기 락(F_WRLCK)으로 잠근다.
* `F_SETLKW` 는 락이 풀릴 때까지 기다리는(blocking) 함수이다. 

&ensp;핵심<br/>
* child 3개가 동시에 do_child를 실행하지만 락을 걸 수 있는 child는 단 1개 뿐
* 나머지 child 2개는 여기에서 잠금 상태로 block된다.

```pgsql
child1: lock 성공 → read → sleep → write → unlock
child2: lock 시도 → block(커널이 잠금중이라고 판단)
child3: lock 시도 → block

child1 unlock → child2 깨움
child2 unlock → child3 깨움
child3 unlock → 종료
```

&ensp;이 모든 과정이 커널 내부에서 자동을 일어난다.<br/>

&ensp;(2) 값 읽기<br/>
```c
lseek(fd, 0, SEEK_SET);
read(fd, &in, sizeof(int));
```

&ensp;파일 오프셋을 처음으로 이동<br/>
&ensp;정수 하나 읽어오기<br/>
&ensp;이때 이미 다른 child는 들어올 수 없으므로 읽는 값은 항상 최신값이다.<br/>

&ensp;(3) 5초 대기 (동시성 문제를 유발시키는 명령)<br/>
```c
sleep(5);
```

&ensp;원래 sleep은 race codition을 유발할 수 있다. 하지만 지금은 record lock으로 보호받으므로 문제가 없다.<br/>

&ensp;(4) 값 읽기<br/>
```c
in = in + 10;
lseek(fd, 0, SEEK_SET);
write(fd, &in, sizeof(int));
```

&ensp;다시 파일 처음에 값을 덮어쓴다.<br/>
&ensp;;Child → +10<br/>
&ensp;child2 → +10<br/>
&ensp;child3 → +10<br/>
&ensp;이 순서의 보장은 락을 통해 이루어진다.<br/>

&ensp;(5) Lock 해제<br/>
```c
lock.l_type=F_UNLCK;
fcntl(fd, F_SETLK, &lock);
```

&ensp;이제 critical section을 빠져나감<br/>
&ensp;다음 child에게 lock이 넘어가서 실행된다.<br/>

```perl
child1 → lock → read → sleep → write → unlock
child2 → lock → read → sleep → write → unlock
child3 → lock → read → sleep → write → unlock
```

| 왜 가능한가?                   | 이유                                                |
| ------------------------- | ------------------------------------------------- |
| child들이 자동으로 줄 선다         | fcntl의 record locking은 커널이 관리하는 ‘락 테이블’을 이용하기 때문에 |
| 하나의 child만 lock을 획득한다     | 동일 구간에 대해 쓰기 락은 배타적이기 때문(WRLCK)                   |
| 나머지 child는 block 상태로 기다린다 | `F_SETLKW`가 lock이 풀릴 때까지 커널이 block 시킴             |
| unlock하면 다음 child가 이어서 실행 | 커널이 block queue에서 프로세스를 깨워줌                       |


&ensp;이 흐름으로 정확히 동작함<br/>

&ensp;4. Parent가 최종 결과 확인<br/>
```c
lseek(fd, 0, SEEK_SET);
read(fd, &in, sizeof(int));   
printf("%d\n", in);
```

&ensp;child 3명 모두 완료(wait) 후 최종 값 읽음<br/>

&ensp;예를 들어 입력이 100이면:<br/>
```nginx
child1 → 110
child2 → 120
child3 → 130
```

&ensp;최종 출력: 130<br/>

&ensp;전체 메커니즘 도식화<br/>
```perl
Parent
 ├─ write(초기값)
 ├─ fork child1
 ├─ fork child2
 └─ fork child3

Child1            Child2           Child3
----------------------------------------------------
lock(wait-free)   lock(wait)       lock(wait)
read 값 100
+10 → 110
write 110
unlock → Child2가 실행됨

                  read 값 110
                  +10 → 120
                  write 120
                  unlock → Child3 실행됨

                                   read 120
                                   +10 → 130
                                   write 130
                                   unlock
```

문제 2
----

&ensp;2. 네 개의 프로세스가 동기화를 하며 자신의 프로세스 id를 5회 출력하는 프로그램을 작성합니다. 네 개의 프로세스는 "turn1" file을 이용하여 동기화에 참여하는 전체 프로세스 중 자신의 출력 순서를 결정합니다. 둘 이상의 프로세스가 동시에 자신의 id를 출력하지 않도록 하는 동기화 작업은 file locking을 사용합니다. 네 프로세스의 출력 순서가 정해져 있지 않습니다. 동시에 출력을 하지 않도록만 하면 됩니다.<br/>

&ensp;문제 요구사항<br/>
1. 프로세스 4개가 생성된다.
2. 각 프로세스는 자기 pid를 5번 출력한다.
3. 출력 순서는 정해져 있지 않다. → 즉, "1번이 먼저, 2번이 다음" 같은 특정 순서 필요 없음.
4. 단, 동시에 두 개 이상 프로세스가 출력하면 안 된다. → 즉, “critical section”을 보호해야 한다.
5. 동기화를 위해 파일 locking만 사용한다.
6. turn1 파일은 “전체 프로세스가 공유하는 잠금용 파일” 역할.

&ensp;결론: 각 프로세스는 출력할 때마다 lock → print(pid) → unlock 해야 한다.<br/>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

void do_child(int fd) {
    pid_t pid = getpid();
    struct flock lock;
    int i;

    for (i = 0; i < 5; i++) {

        // --- Lock ---
        lock.l_type = F_WRLCK;
        lock.l_whence = SEEK_SET;
        lock.l_start = 0;
        lock.l_len = 0;     // 파일 전체 잠금
        fcntl(fd, F_SETLKW, &lock);

        // --- Critical Section ---
        printf("%ld\n", (long)pid);
        fflush(stdout);
        sleep(1);

        // --- Unlock ---
        lock.l_type = F_UNLCK;
        fcntl(fd, F_SETLK, &lock);
    }

    exit(0);
}

int main(void) {
    int fd, i;
    pid_t pid;

    fd = open("turn1", O_RDWR | O_CREAT, 0600);

    for (i = 0; i < 4; i++) {
        pid = fork();
        if (pid == 0) {
            do_child(fd);
        }
    }

    for (i = 0; i < 4; i++)
        wait(0);

    exit(0);
}
```

&ensp;왜 이게 가능한지 (기본 원리 요약)<br/>
1. 4개 프로세스는 모두 같은 lock 파일(fd)을 공유한다.
2. 커널은 같은 파일에 대한 WRLOCK 요청이 들어오면:
* 하나만 lock 허용
* 나머지는 block queue에 넣어 기다리게 한다.
3. unlock 호출 시 커널이 다음 프로세스를 깨운다.
4. 그래서 자동으로 상호배제(mutual exclusion) 가 만들어진다.

## 매커니즘

&ensp;1. Parent가 turn1 파일을 open → fd 생성<br/>
```c
fd = open("turn1", O_RDWR | O_CREAT, 0600);
```

&ensp;여기서 만들어진 fd는 커널 내부의 open file table entry를 가리킨다. 이 fd는 fork 후 child에게 복사되지만 open file table entry는 공유된다.<br/>

```arduino
Parent fd=3 → same open file description
Child1 fd=3 → same
Child2 fd=3 → same
Child3 fd=3 → same
Child4 fd=3 → same
```

&ensp;모두 같은 파일을 가리키고 locking은 이 같은 파일에 대해 적용된다. 그래서 서로 영향을 줄 수 있다.<br/>

&ensp;2. fork()로 4개의 child 생성<br/>
```c
for(i=0;i<4;i++){
    pid=fork();
    if(pid==0) do_child(fd);
}
```

&ensp;fork는 다음을 그대로 복사한다.<br/>
* 파일 디스크립터 테이블(fd)
* 파일 오프셋
* 파일 잠금 정보가 적용될 동일한 파일

&ensp;네 개 child는 모두 같은 fd를 통해 같은 커널 파일 객체를 사용한다.<br/>

&ensp;3. 각 child는 5번 반복하며 lock → print → unlock<br/>
```c
lock.l_type = F_WRLCK;
fcntl(fd, F_SETLKW, &lock);
```

&ensp;F_SETLKW 는 “락이 걸려 있으면 기다려(block)” 라는 뜻이다.<br/>

&ensp;프로세스 A가 lock을 획득하면 → 프로세스 B, C, D는 이 구간을 lock하려고 할 때 커널이 block queue에 넣고 재움<br/>
&ensp;프로그램에서 sleep(1)을 쓰지 않아도 커널이 프로세스를 automatcially sleep 시킴<br/>

&ensp;4. 커널 내부에서 일어나는 진짜 동작<br/>
&ensp;step 1) child1 실행 → fcntl() 호출<br/>
&ensp;커널의 record lock table 확인<br/>
```css
turn1 파일: 아무도 lock 안함
```

&ensp;child1에게 WRLOCK 부여<br/>
&ensp;record lock table 업데이트<br/>

&ensp;step 2) child2 실행 → fcntl(F_SETLKW) 호출<br/>
&ensp;커널 확인<br/>
```css
turn1 파일: child1이 WRLOCK 중
```

&ensp;WRLOCK은 배타적(exclusive)이므로 → child2는 lock을 얻을 수 없음, 커널이 child2를 "blocked" 상태로 만듦, CPU 스케줄에서 제외됨(실행 멈춤)<br/>

&ensp;step 3) child3, child4도 동일하게 block 상태<br/>
```scss
child3 → block
child4 → block
```

&ensp;5. child1이 printf 실행 중일 때 누군가 방해할 수 없는 이유<br/>
```c
printf("%ld\n", pid);
```

&ensp;이 부분은 critical section이다.<br/>
&ensp;WRLOCK이 걸려 있으므로 child2는 실행 중이 아님(block), child3도 block, child4도 block.<br/>
&ensp;출력을 섞어 버리는 경우가 발생할 수 없다.<br/>

&ensp;6. child1이 unlock → 다음 대기 프로세스 자동 깨우기<br/>
```c
lock.l_type = F_UNLCK;
fcntl(fd, F_SETLK, &lock);
```

&ensp;이 순간 커널이 다음을 수행한다.<br/>
1. record lock table에서 child1의 lock 삭제
2. block queue를 확인
3. queue의 맨 앞(process waiting 가장 오래된 애) 깨움
4. 예: child2가 wakeup되고 lock 획득
5. 나머지 child3, child4는 여전히 block 상태

&ensp;7. 이어서 child2가 print → unlock → child3 → child4…<br/>
&ensp;결국 순서는 매번 달라질 수 있지만 항상 아래 규칙을 지킨다.<br/>
* 한 순간에 하나의 프로세스만 print()
* print() 끝날 때 unlock
* unlock되면 kernel이 자동으로 다음 프로세스를 깨움
* 절대 두 프로세스가 동시에 print할 수 없음

&ensp;8. 왜 파일을 잠그는 방식으로 가능한가?<br/>
&ensp;이유 1: record lock은 OS 커널에서 관리한다.<br/>
&ensp;사용자 수준이 아니라 커널 내부에서 queue + 상태관리를 한다.<br/>

&ensp;이유 2. WRLOCK은 배타적(exclusive) 락이다.<br/>
&ensp;한 프로세스만 critical section에 들어간다.<br/>

&ensp;이유 3. F_SETLKW 는 "다른 프로세스가 unlock할 때까지 block" 기능<br/>
&ensp;busy waiting 없이 효율적으로 대기<br/>

&ensp;이유 4. fork 후 모든 child가 동일한 파일을 공유하기 때문에<br/>
&ensp;lock의 영향이 모든 child에 적용된다.<br/>

&ensp;전체 그림 요약<br/>
```scss
Child1: lock → print → unlock
Child2: (block) → lock → print → unlock
Child3: (block) → lock → print → unlock
Child4: (block) → lock → print → unlock
```

&ensp;출력 순서는 랜덤하지만 절대 동시에 두 개 이상 출력되지 않는다.<br/>

&ensp;출력 예시 (실제로는 매 실행마다 순서 바뀜)<br/>
```shell
4002
4001
4003
4004
4001
4003
4002
4004
4003
4001
...
(각자 5번씩)
```