---
title: "Lect9. 메모리 매핑"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-10-29
last_modified_at: 2025-10-29
---

메모리 매핑(Memory Mapping) 기본 개념
=====

&ensp;메모리 매핑(memeory mapping)이란 파일이나 장치의 내용을 프로세스의 가상 메모리 공간에 직접 연결하는 기법을 말한다.<br/>

&ensp;즉 디스크에 있는 파일 데이터를 read(), write() 시스템 콜 없이 바로 메모리 주소를 통해 접근할 수 있게 만드는 것이다.<br/>

&ensp;**동작 원리** <br/>
&ensp;운영체제는 프로세스마다 가상 메모리 공간을 갖고 있다. `mmap()` 함수를 사용하면 파일의 특정 부분을 이 가상 메모리에 매핑시켜 해당 영역을 읽거나 쓰면 자동으로 파일의 내용이 변경된다.<br/>

&ensp;**파일 <-> 메모리 간의 연결고리를 만들어주는 함수가 mmap()입니다.**<br/>

&ensp;**장점**<br/>

| 구분        | 설명                                       |
| --------- | ---------------------------------------- |
| 성능 향상     | read(), write() 시스템 콜 없이 파일을 메모리에서 직접 접근 |
| 간결한 코드    | 파일 I/O를 포인터 연산처럼 간단히 다룰 수 있음             |
| 프로세스 간 공유 | 동일한 파일을 여러 프로세스가 같은 물리 메모리로 공유 가능        |

관련 시스템 콜
=====

# mmap()

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
```

&ensp;mmap() 함수 인자 설명<br/>
&ensp;`mmap()`은 다음과 같이 동작한다.<br/>
&ensp;fd가 가리키는 파일의 offset부터 len만큼의 데이터를 addr이 가리키는 메모리 공간에 매핑한다.<br/>

&ensp;주요 인자 정리<br/>

| 인자         | 설명                                |
| ---------- | --------------------------------- |
| **addr**   | 매핑할 메모리 주소 (NULL로 지정 시 커널이 자동 배정) |
| **len**    | 매핑할 메모리 크기 (byte 단위)              |
| **prot**   | 보호 모드 (읽기, 쓰기 권한 설정)              |
| **flags**  | 매핑된 데이터의 공유 방법 지정                 |
| **fd**     | 파일 디스크립터 (open으로 얻음)              |
| **offset** | 파일 내 매핑 시작 위치 (페이지 크기 단위)         |

&ensp;prot, flag 인자 & 주의사항<br/>
&ensp;prot 인자<br/>

| 상수           | 의미    |
| ------------ | ----- |
| `PROT_READ`  | 읽기 허용 |
| `PROT_WRITE` | 쓰기 허용 |

&ensp;flag 인자<br/>

| 상수            | 의미                                 |
| ------------- | ---------------------------------- |
| `MAP_SHARED`  | 다른 프로세스와 변경 내용 공유                  |
| `MAP_PRIVATE` | 변경 내용 비공유 (복사 후 쓰기, copy-on-write) |

* 메모리 매핑은 페이지 단위(보통 4KB)로 이루어진다.
    - 페이지 크기 = 4KB = 4096바이트
    - offset은 반드시 4096의 배수여야 한다.
* 매핑된 영역을 벗어나 접근하면 → SIGBUS 또는 SIGSEGV 시그널이 발생한다 (Segmentation fault)

# munmap() - memory mapping 해제

&ensp;`mmap()` 으로 매핑한 메모리 영역을 해제할 때 사용하는 함수이다. 즉 파일과 메모리의 연결을 끊는 역할을 한다.<br/>

```c
#include <sys/mman.h>

int munmap(void *addr, size_t len);
```

| 인자     | 설명                                   |
| ------ | ------------------------------------ |
| `addr` | `mmap()`이 반환한 시작 주소                  |
| `len`  | 매핑된 메모리의 크기 (mmap에서 지정한 len과 동일해야 함) |

&ensp;동작원리<br/>
* 매핑을 해제하면 해당 영역의 접근 권한이 사라진다.
* 해제된 영역을 접근하면 SIGSEGV (Segmentation fault) 발생
* 일반적으로 `munmap()`은 파일 닫기(`close(fd)`) 전에 호출한다.

&ensp;예시<br/>
```c
munmap(addr, length);
close(fd);
```

# mprotect() - 보호 모드 변경

&ensp;이미 매핑된 메모리 영역의 읽기/쓰기 권한(protection mode)을 동적으로 변경할 수 있게 해준다.<br/>

```c
#include <sys/mman.h>

int mprotect(void *addr, size_t len, int prot);
```

| 인자     | 설명                                               |
| ------ | ------------------------------------------------ |
| `addr` | 권한을 변경할 메모리 시작 주소                                |
| `len`  | 변경할 메모리 크기                                       |
| `prot` | 새로운 보호 모드 (ex: PROT_READ, PROT_WRITE, PROT_NONE) |

&ensp;예시<br/>
```c
mprotect(addr, 4096, PROT_READ);      // 읽기만 가능하게 변경
mprotect(addr, 4096, PROT_WRITE);     // 쓰기 권한 추가
```

* `mprotect()` 도 페이지 단위(4KB)로 적용됨
* 쓰기 금지된 영역에 접근하면 SIGSEGV 발생

# truncate(), ftruncate() - 파일 크기 변경

&ensp;파일의 크기를 변경하는 함수이다. 파일이 매핑된 상태에서 크기를 조절할 때 사용한다.<br/>

```c
#include <unistd.h>

// 파일 경로로 변경
int truncate(const char *path, off_t len);

// 파일 디스크립터로 변경
int ftruncate(int fd, off_t len);
```

| 인자            | 설명                |
| ------------- | ----------------- |
| `path` / `fd` | 변경할 파일            |
| `len`         | 새 파일 크기 (byte 단위) |

&ensp;동작 원리<br/>
* 지정한 크기보다 작으면 → 파일을 잘라냄(데이터 손실)
* 지정한 크기보다 크면 → 0으로 채워서 확장됨

&ensp;예시<br/>
```c
ftruncate(fd, 8192);   // 파일을 8KB 크기로 조정
```

&ensp;주의<br/>
* `mmap()` 된 메모리의 크기보다 파일의 더 작게 자르면 이후 접근 시 SIGBUS 오류 발생 (잘린 영역 접근 때문)

# msync() - 매핑된 메모리 동기화

&ensp;`mmap()`으로 매핑된 메모리에 변경사항이 있을 때 그 내용을 파일에 동기화(write-back)하는 함수이다.<br/>

&ensp;사용 방법<br/>
```c
#include <sys/mman.h>

int msync(void *addr, size_t len, int flags);
```

| 인자      | 설명          |
| ------- | ----------- |
| `addr`  | 동기화할 메모리 주소 |
| `len`   | 동기화할 길이     |
| `flags` | 동기화 방식 지정   |

&ensp;flags 인자<br/>

| 인자      | 설명          |
| ------- | ----------- |
| `addr`  | 동기화할 메모리 주소 |
| `len`   | 동기화할 길이     |
| `flags` | 동기화 방식 지정   |

&ensp;예시<br/>
```c
msync(addr, length, MS_SYNC);  // 즉시 파일과 동기화
```

&ensp;활용 예<br/>
* 여러 프로세스가 같은 파일을 공유 매핑할 때 하나의 프로세스가 수정한 내용이 파일에 바로 반영되도록 할 수 있음

실습
====

`문제 1`
&ensp;메모리 매핑을 이용하는 reader와 writer 프로그램을 아래 코드를 사용하여 작성하시오.<br/>
&ensp;(a) reader 프로그램은 “temp" 파일을 메모리 매핑 한 후, scanf()로 10개의 정수를 읽어서 매핑된 파일에 저장하는 작업을 10회 실행합니다.<br/>
&ensp;(b) writer 프로그램은 “temp" 파일을 메모리 매핑 한 후, 매핑 된 파일에 있는 정수를 출력하는 작업을 10회 실행합니다(printf() 사용). 단. 출력 프로그램은 5초간 sleep() 한 후 5회의 출력 작업을 연속 진행하고, 다시 5초간 sleep() 한 후 5회의 출력 작업을 진행합니다.<br/>
&ensp;(c) 두 프로그램이 모두 종료한 후 ”temp" 파일의 크기를 확인합니다.<br/>

| 구분           | 역할              | 동작 요약                                                    |
| ------------ | --------------- | -------------------------------------------------------- |
| **reader.c** | 작성자(Writer 역할)  | `"temp"` 파일을 메모리에 매핑 후 `scanf()`로 입력받은 정수를 그 매핑된 메모리에 저장 |
| **writer.c** | 읽는 쪽(Reader 역할) | `"temp"` 파일을 메모리에 매핑 후 거기 저장된 정수를 읽어 `printf()`로 출력      |

&ensp;Memory Mapping(mmap)<br/>
&ensp;mmap()은 파일을 메모리 주소 공간에 직접 연결한다. 그래서 addr[i]에 값을 쓰면 → 바로 파일 내용이 바뀌고 다른 프로세스가 같은 파일을 mmap하면 → 그 메모리 변화가 즉시 반영된다.<br/>

&ensp;reader<br/>
```c
int main(void){
  int fd, i;
  int *addr;  

  fd=// 파일을 읽기, 쓰기 가능하게 open
  addr=// memory mapping

  //
  for (i=0; i<10; i++){
    scanf("%d", addr+i);
  }
  exit(0);
}
```

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
    int fd, i;
    int *addr;

    // 1. temp 파일을 읽기/쓰기 모드로 연다. 없으면 새로 만든다.
    fd = open("temp", O_RDWR | O_CREAT, 0666);

    // 2. 파일을 메모리에 매핑한다.(길이: 10개의 int 크기)
    addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);

    // 3. 파일 크기를 미리 10개의 int 크기
    ftruncate(fd, sizeof(int) * 10);

    // 4. 사용자로부터 정수 10개를 입력받아 메모리에 저장 
    for(i=0; i < 10; i++){
      scanf("%d", addr+i);  // 입력값이 바로 매핑된 메모리 → 파일에 반영됨
    }

    exit(0);
}
```

&ensp;동작 과정 단계별 설명<br/>
&ensp;1. open()<br/>
```c
fd = open("temp", O_RDWR | O_CREAT, 0666);
```

* "temp" 파일을 읽기/쓰기 가능하게 연다.
* 없으면 새로 만들고 권한은 `rw-rw-rw-` 로 설정된다.
* 이 파일이 공유될 공간의 기반이 된다.

&ensp;2. mmap()<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
```

* 파일을 프로세스의 가상 메모리에 연결한다.
* `PROT_WRITE`: 쓰기 가능한 메모리
* `MAP_SHARED`: 파일과 메모리를 공유 모드로 연결 → 다른 프로세스도 변경 내용을 볼 수 있음
* 반환값 addr은 파일의 0번 오프셋(시작 지점)을 가리키는 포인터

&ensp;3. ftruncate()<br/>
```c
ftruncate(fd, sizeof(int) * 10);
```

* 파일 크기를 10개의 int(40바이트)로 맞춘다.
* 안 하면 파일 크기가 0이라 mmap 접근 시 segmentation fault 발생 가능

&ensp;4. 입력 저장<br/>
```c
for (i = 0; i < 10; i++)
    scanf("%d", addr + i);
```

* 사용자가 입력하는 10개의 정수를 메모리에 차례로 저장
* 사실상 addr[i] = 입력값; 과 같다.
* 이 순간 메모리 내용이 자동으로 temp 파일에 기록됨

&ensp;5. exit(0)<br/>
&ensp;프로그램 종료. 메모리 매핑은 OS가 자동 해제<br/>


&ensp;writer<br/>
```c
int main(void){
  int fd, i;  
  int *addr;

  fd=// 파일을 읽기 가능하게 open
  addr=// memory mapping

  sleep(5);
  for (i=0; i<5; i++){
    printf("%d\n", *(addr+i));
  }
  sleep(5);

  for (i=5; i<10; i++){
    printf("%d\n", *(addr+i));
  }
  exit(0);
}
```

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
        int fd, i;
        int *addr;

        // 1. temp 파일을 "읽기 전용"으로 연다.
        fd = open("temp", O_RDONLY | O_CREAT, 0600);

        // 2. temp 파일을 읽기 전용으로 메모리에 매핑한다.
        addr = mmap(NULL, 10 * sizeof(int), PROT_READ, MAP_SHARED, fd, 0);

        // 3. 처음엔 5초 기다린다 (reader가 입력할 시간 확보)
        sleep(5);

        // 4. 앞의 5개 값 출력
        for(i=0; i < 5; i++){
                printf("%d\n", *(addr+i));
        }

        // 5. 다시 5초 쉬고 뒤의 5개 값 출력
        sleep(5);
        for(i=5; i < 10;i++){
                printf("%d\n", *(addr+i));
        }
        exit(0);
}
```

&ensp;동작 과정 단계별 설명<br/>
&ensp;1. open()<br/>
* `"temp"` 파일을 읽기전용으로 연다
* 권한 `0600` : 오직 소유자만 읽기/쓰기 가능

&ensp;2. mmap()<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_READ, MAP_SHARED, fd, 0);
```

* 파일을 읽기 전용으로 메모리에 매핑한다.
* reader가 쓴 데이터가 그대로 이 메모리에 반영된다.
* `*(addr + i)` 를 읽으면 reader가 입력한 값이 나옴

&ensp;3. sleep(5)<br/>
* reader가 scanf로 데이터를 다 입력할 시간을 주기 위해 5초 대기

&ensp;4. 출력 루프(앞 5개)<br/>
```c
for(i=0; i<5; i++)
    printf("%d\n", *(addr+i));
```

* 메모리에서 0~4번째 int를 읽어 출력

&ensp;5. sleep(5)<br/>
* 잠깐 쉬었다가 다시 출력

&ensp;6. 출력 루프 (뒤 5개)<br/>
```c
for(i=5; i<10; i++)
  printf("%d\n", *(addr+i));
```

* 나머지 5개 출력


&ensp;실행 순서 예시<br/>

&ensp;터미널 1 (reader 실행)<br/>
```shell
$ ./reader
1 2 3 4 5 6 7 8 9 10
```

&ensp;터미널 2 (writer 실행)<br/>
```shell
$ ./writer
```

&ensp;결과 출력<br/>
```shell
(5초 후)
1
2
3
4
5
(5초 후)
6
7
8
9
10
```

&ensp;temp파일 크기 확인<br/>
```shall
$ ls -l temp
-rw-rw-rw- 1 user user 40 Nov 2 18:20 temp
```

* 파일 크기 40바이트 = 10 * sizeof(int) (리틀엔디언 환경 기준)
* reader에서 ftruncate(fd, 40) 했기 때문

&ensp;전체 원리 정리<br/>

| 항목                         | 설명                                    |
| -------------------------- | ------------------------------------- |
| **mmap()**                 | 파일을 가상 메모리에 매핑해, read/write 없이도 접근 가능 |
| **MAP_SHARED**             | 파일에 실제로 반영되고, 다른 프로세스와 공유됨            |
| **PROT_WRITE / PROT_READ** | 매핑된 메모리의 접근 권한 설정                     |
| **ftruncate()**            | 파일의 물리적 크기 지정 (매핑 영역보다 작으면 오류)        |
| **addr + i**               | i번째 정수의 메모리 주소 (배열처럼 접근 가능)           |
| **동기화 방식**                 | OS 커널이 페이지 캐시를 통해 자동으로 동기화함           |


&ensp;요약 암기 포인트<br/>

| 항목       | 기억할 것                                          |                |
| -------- | ---------------------------------------------- | -------------- |
| 파일 열기    | open("temp", O_RDWR                            | O_CREAT, 0666) |
| mmap 기본형 | `mmap(NULL, length, prot, flags, fd, 0)`       |                |
| 공유 설정    | MAP_SHARED (다른 프로세스와 공유됨)                      |                |
| 파일 크기 확장 | ftruncate(fd, N * sizeof(int))                 |                |
| 접근 방법    | addr[i] = 값 → 파일에 바로 기록됨                       |                |
| 결과       | temp 파일 크기 = 40바이트, writer는 reader 입력값을 그대로 읽음 |                |

&ensp;mmap()과 ftruncate() 순서가 바뀌었을 때 생기는 문제<br/>
```c
fd = open("temp", O_RDWR | O_CREAT, 0666);
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
ftruncate(fd, sizeof(int) * 10);
```

&ensp;원래는 ftruncate() → mmap() 순으로 하는 게 더 안전하다. 이 순서 차이가 **메모리 접근 가능한 영역 크기** 에 직접적인 영향을 주기 때문이다.<br/>

&ensp;원리부터 간단히 정리<br/>
&ensp;`mmap()`은 파일의 내용을 물리적 디스크 영역과 프로세스의 가상 메모리 공간에 연결한다. 이때 커널은 현재 크기(`st_size`)를 기준으로 매핑을 설정한다. "mmap은 open된 파일의 현재 크기만큼만 접근 가능한 메모리로 인식한다.`<br/>

&ensp;문제 상황: ftruncate()를 나중에 호출하면?<br/>
&ensp;잘못된 순서 예시<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
ftruncate(fd, sizeof(int) * 10);
```

* mmap()이 호출될 때, temp 파일 크기가 0바이트라면 → 커널은 **빈 파일(크기 0)**을 메모리에 매핑하려 함 → "접근 가능한 영역 없음"으로 설정됨
* 그다음 ftruncate(fd, 40)으로 파일 크기를 늘려도 이미 매핑된 메모리(addr)의 영역은 커널 내부 테이블에 0바이트로 등록되어 있음
* 따라서 addr[i] = ...로 접근할 때 → 실제로는 "존재하지 않는 페이지"에 접근 → SIGBUS (Bus Error) 발생

&ensp;SIGBUS 에러 예시<br/>
```bash
Bus error (core dumped)
```

* 이 에러는 sefmentation fault(`SIGSEGV`)랑 비슷하지만 원인이 존재하지 않은 파일 매핑 영역 접근일 때 발생함
* mmap이 인식한 파일 크기보다 뒤쪽 메모리를 건드렸다는 뜻이다.

&ensp;올바른 순서<br/>
```c
fd = open("temp", O_RDWR | O_CREAT, 0666);
ftruncate(fd, sizeof(int) * 10);  // 파일 크기 먼저 확보
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
```

1. ftruncate() 가 파일 크기를 40바이트로 확장 → 커널이 해당 크기만큼 실제 파일 페이지를 준비함
2. mmap() 은 그 40바이트 파일을 기준으로 정상적인 매핑 관계를 설정 → addr[0]~addr[9] 접근 가능
3. 이후 addr[i] = 값 쓰기 시도 → 정상적으로 temp 파일에 기록됨

&ensp;순서가 중요한 이유 요약<br/>

| 순서                     | 결과                                      |
| ---------------------- | --------------------------------------- |
| `mmap() → ftruncate()` | 매핑 시점에 파일이 0바이트 → 매핑된 영역 없음 → SIGBUS 발생 |
| `ftruncate() → mmap()` | 매핑 전에 크기 확보 → 접근 가능 영역 존재 → 정상 동작       |

&ensp;교수님 코드가 작동하는 이유<br/>
&ensp;그건 운 좋게 OS의 lazy allocation 특성 덕분이다.<br/>
&ensp;리눅스는 mmap()을 호출할 때 실제로 파일 페이지를 곧바로 매핑하지 않고 처음 접근할 때(page fault 발생 시) 파일 크기를 다시 확인하는 경우가 있다. 그래서 아래 상황이면 우연히 동작한다.<br/>
* ftruncate()가 scanf()보다 먼저 호출되므로 (사용자 입력 전에 실행됨) 커널이 첫 접근 시점에 이미 파일 크기를 인식함

&ensp;메모리 매핑 시 안전한 코드 작성 순서<br/>

| 단계 | 함수                      | 설명                              |
| -- | ----------------------- | ------------------------------- |
| 1  | `open()`                | 파일 디스크립터 열기                     |
| 2  | `ftruncate()`           | 파일 크기 미리 확보 (mmap 길이보다 작으면 안 됨) |
| 3  | `mmap()`                | 파일을 메모리에 매핑                     |
| 4  | `scanf()` or `printf()` | 매핑된 메모리 접근                      |
| 5  | `munmap()`              | (선택) 매핑 해제                      |
| 6  | `close(fd)`             | 파일 닫기                           |

&ensp;Bus Error vs Segmentation Fault<br/>

| 구분                               | 의미                         | 원인                   |
| -------------------------------- | -------------------------- | -------------------- |
| **SIGSEGV (Segmentation Fault)** | 잘못된 메모리 주소 접근              | ex. NULL 포인터 접근      |
| **SIGBUS (Bus Error)**           | 유효하지만 실제 존재하지 않는 물리 페이지 접근 | ex. mmap 크기 초과 영역 접근 |

&ensp;mmap()은 매핑 시점의 파일 크기만큼만 접근 가능하므로, 반드시 ftruncate()로 파일 크기를 먼저 늘린 후 mmap() 해야 한다.<br/>


&ensp;안전한 표준 코드 (수정 버전)<br/>
```c
// ✅ reader_safe.c (안전한 표준 버전)
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
    int fd, i;
    int *addr;

    // (1) 파일을 읽기/쓰기 모드로 엶
    fd = open("temp", O_RDWR | O_CREAT, 0666);

    // (2) mmap 전에 파일 크기를 미리 확보해야 함
    // 파일 크기를 10개의 int 만큼 확장 (40바이트)
    ftruncate(fd, sizeof(int) * 10);

    // (3) 이제 파일을 mmap
    addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);

    // (4) 10개의 정수를 입력받아 파일(매핑된 메모리)에 저장
    for (i = 0; i < 10; i++) {
        scanf("%d", addr + i);
    }

    // (5) 프로그램 종료 → OS가 자동으로 파일에 flush
    exit(0);
}
```

&ensp;안전한 코드 동작 구조<br/>

| 단계 | 동작              | 설명                             |
| -- | --------------- | ------------------------------ |
| 1  | open("temp")    | temp 파일 열기                     |
| 2  | ftruncate()     | 파일을 미리 40바이트 확보                |
| 3  | mmap(fd, 40바이트) | 커널이 정확한 파일 크기만큼 메모리 매핑         |
| 4  | scanf()         | 입력값을 addr[i]에 저장 → 파일 내용 자동 반영 |
| ✅  | 결과              | 완전한 안전 동작, 어떤 OS에서도 SIGBUS 없음  |

&ensp;두 버전 비교표<br/>

| 비교 항목                 | 교수님 버전             | 안전한 표준 버전          |
| --------------------- | ------------------ | ------------------ |
| **ftruncate() 호출 시점** | mmap() 이후          | mmap() 이전          |
| **파일 크기**             | mmap 시점에 0바이트      | mmap 시점에 40바이트     |
| **mmap 유효 범위**        | 0바이트 (위험)          | 40바이트 (안전)         |
| **SIGBUS 가능성**        | 있음 (운에 따라 다름)      | 없음                 |
| **운영체제 호환성**          | 제한적 (일부 Linux만 가능) | 모든 Unix/Linux에서 안전 |
| **표준 준수 여부**          | ❌ POSIX 권장 위배      | ✅ POSIX 표준 준수      |
| **시험/과제에서 권장**        | ❌ 피해야 함            | ✅ 반드시 이렇게 작성       |

&ensp;올바른 순서 (ftruncate → mmap)<br/>
```scss
파일(temp): 40바이트 확보
↓
mmap() 호출 → 메모리 40바이트 매핑
↓
addr[0] ~ addr[9] 안전하게 접근 가능
↓
reader 입력 → writer가 그대로 읽음
```