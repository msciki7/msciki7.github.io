---
title: "Lect9. 메모리 매핑"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-10-29
last_modified_at: 2025-10-29
---

메모리 매핑(Memory Mapping) 기본 개념
=====

&ensp;메모리 매핑(memeory mapping)이란 파일이나 장치의 내용을 프로세스의 가상 메모리 공간에 직접 연결하는 기법을 말한다.<br/>

&ensp;즉 디스크에 있는 파일 데이터를 read(), write() 시스템 콜 없이 바로 메모리 주소를 통해 접근할 수 있게 만드는 것이다.<br/>

&ensp;**동작 원리** <br/>
&ensp;운영체제는 프로세스마다 가상 메모리 공간을 갖고 있다. `mmap()` 함수를 사용하면 파일의 특정 부분을 이 가상 메모리에 매핑시켜 해당 영역을 읽거나 쓰면 자동으로 파일의 내용이 변경된다.<br/>

&ensp;**파일 <-> 메모리 간의 연결고리를 만들어주는 함수가 mmap()입니다.**<br/>

&ensp;**장점**<br/>

| 구분        | 설명                                       |
| --------- | ---------------------------------------- |
| 성능 향상     | read(), write() 시스템 콜 없이 파일을 메모리에서 직접 접근 |
| 간결한 코드    | 파일 I/O를 포인터 연산처럼 간단히 다룰 수 있음             |
| 프로세스 간 공유 | 동일한 파일을 여러 프로세스가 같은 물리 메모리로 공유 가능        |

관련 시스템 콜
=====

# mmap()

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
```

&ensp;mmap() 함수 인자 설명<br/>
&ensp;`mmap()`은 다음과 같이 동작한다.<br/>
&ensp;fd가 가리키는 파일의 offset부터 len만큼의 데이터를 addr이 가리키는 메모리 공간에 매핑한다.<br/>

&ensp;주요 인자 정리<br/>

| 인자         | 설명                                |
| ---------- | --------------------------------- |
| **addr**   | 매핑할 메모리 주소 (NULL로 지정 시 커널이 자동 배정) |
| **len**    | 매핑할 메모리 크기 (byte 단위)              |
| **prot**   | 보호 모드 (읽기, 쓰기 권한 설정)              |
| **flags**  | 매핑된 데이터의 공유 방법 지정                 |
| **fd**     | 파일 디스크립터 (open으로 얻음)              |
| **offset** | 파일 내 매핑 시작 위치 (페이지 크기 단위)         |

&ensp;prot, flag 인자 & 주의사항<br/>
&ensp;prot 인자<br/>

| 상수           | 의미    |
| ------------ | ----- |
| `PROT_READ`  | 읽기 허용 |
| `PROT_WRITE` | 쓰기 허용 |

&ensp;flag 인자<br/>

| 상수            | 의미                                 |
| ------------- | ---------------------------------- |
| `MAP_SHARED`  | 다른 프로세스와 변경 내용 공유                  |
| `MAP_PRIVATE` | 변경 내용 비공유 (복사 후 쓰기, copy-on-write) |

* 메모리 매핑은 페이지 단위(보통 4KB)로 이루어진다.
    - 페이지 크기 = 4KB = 4096바이트
    - offset은 반드시 4096의 배수여야 한다.
* 매핑된 영역을 벗어나 접근하면 → SIGBUS 또는 SIGSEGV 시그널이 발생한다 (Segmentation fault)

# munmap() - memory mapping 해제

&ensp;`mmap()` 으로 매핑한 메모리 영역을 해제할 때 사용하는 함수이다. 즉 파일과 메모리의 연결을 끊는 역할을 한다.<br/>

```c
#include <sys/mman.h>

int munmap(void *addr, size_t len);
```

| 인자     | 설명                                   |
| ------ | ------------------------------------ |
| `addr` | `mmap()`이 반환한 시작 주소                  |
| `len`  | 매핑된 메모리의 크기 (mmap에서 지정한 len과 동일해야 함) |

&ensp;동작원리<br/>
* 매핑을 해제하면 해당 영역의 접근 권한이 사라진다.
* 해제된 영역을 접근하면 SIGSEGV (Segmentation fault) 발생
* 일반적으로 `munmap()`은 파일 닫기(`close(fd)`) 전에 호출한다.

&ensp;예시<br/>
```c
munmap(addr, length);
close(fd);
```

# mprotect() - 보호 모드 변경

&ensp;이미 매핑된 메모리 영역의 읽기/쓰기 권한(protection mode)을 동적으로 변경할 수 있게 해준다.<br/>

```c
#include <sys/mman.h>

int mprotect(void *addr, size_t len, int prot);
```

| 인자     | 설명                                               |
| ------ | ------------------------------------------------ |
| `addr` | 권한을 변경할 메모리 시작 주소                                |
| `len`  | 변경할 메모리 크기                                       |
| `prot` | 새로운 보호 모드 (ex: PROT_READ, PROT_WRITE, PROT_NONE) |

&ensp;예시<br/>
```c
mprotect(addr, 4096, PROT_READ);      // 읽기만 가능하게 변경
mprotect(addr, 4096, PROT_WRITE);     // 쓰기 권한 추가
```

* `mprotect()` 도 페이지 단위(4KB)로 적용됨
* 쓰기 금지된 영역에 접근하면 SIGSEGV 발생

# truncate(), ftruncate() - 파일 크기 변경

&ensp;파일의 크기를 변경하는 함수이다. 파일이 매핑된 상태에서 크기를 조절할 때 사용한다.<br/>

```c
#include <unistd.h>

// 파일 경로로 변경
int truncate(const char *path, off_t len);

// 파일 디스크립터로 변경
int ftruncate(int fd, off_t len);
```

| 인자            | 설명                |
| ------------- | ----------------- |
| `path` / `fd` | 변경할 파일            |
| `len`         | 새 파일 크기 (byte 단위) |

&ensp;동작 원리<br/>
* 지정한 크기보다 작으면 → 파일을 잘라냄(데이터 손실)
* 지정한 크기보다 크면 → 0으로 채워서 확장됨

&ensp;예시<br/>
```c
ftruncate(fd, 8192);   // 파일을 8KB 크기로 조정
```

&ensp;주의<br/>
* `mmap()` 된 메모리의 크기보다 파일의 더 작게 자르면 이후 접근 시 SIGBUS 오류 발생 (잘린 영역 접근 때문)

# msync() - 매핑된 메모리 동기화

&ensp;`mmap()`으로 매핑된 메모리에 변경사항이 있을 때 그 내용을 파일에 동기화(write-back)하는 함수이다.<br/>

&ensp;사용 방법<br/>
```c
#include <sys/mman.h>

int msync(void *addr, size_t len, int flags);
```

| 인자      | 설명          |
| ------- | ----------- |
| `addr`  | 동기화할 메모리 주소 |
| `len`   | 동기화할 길이     |
| `flags` | 동기화 방식 지정   |

&ensp;flags 인자<br/>

| 인자      | 설명          |
| ------- | ----------- |
| `addr`  | 동기화할 메모리 주소 |
| `len`   | 동기화할 길이     |
| `flags` | 동기화 방식 지정   |

&ensp;예시<br/>
```c
msync(addr, length, MS_SYNC);  // 즉시 파일과 동기화
```

&ensp;활용 예<br/>
* 여러 프로세스가 같은 파일을 공유 매핑할 때 하나의 프로세스가 수정한 내용이 파일에 바로 반영되도록 할 수 있음

실습
====

`문제 1`
&ensp;메모리 매핑을 이용하는 reader와 writer 프로그램을 아래 코드를 사용하여 작성하시오.<br/>
&ensp;(a) reader 프로그램은 “temp" 파일을 메모리 매핑 한 후, scanf()로 10개의 정수를 읽어서 매핑된 파일에 저장하는 작업을 10회 실행합니다.<br/>
&ensp;(b) writer 프로그램은 “temp" 파일을 메모리 매핑 한 후, 매핑 된 파일에 있는 정수를 출력하는 작업을 10회 실행합니다(printf() 사용). 단. 출력 프로그램은 5초간 sleep() 한 후 5회의 출력 작업을 연속 진행하고, 다시 5초간 sleep() 한 후 5회의 출력 작업을 진행합니다.<br/>
&ensp;(c) 두 프로그램이 모두 종료한 후 ”temp" 파일의 크기를 확인합니다.<br/>

| 구분           | 역할              | 동작 요약                                                    |
| ------------ | --------------- | -------------------------------------------------------- |
| **reader.c** | 작성자(Writer 역할)  | `"temp"` 파일을 메모리에 매핑 후 `scanf()`로 입력받은 정수를 그 매핑된 메모리에 저장 |
| **writer.c** | 읽는 쪽(Reader 역할) | `"temp"` 파일을 메모리에 매핑 후 거기 저장된 정수를 읽어 `printf()`로 출력      |

&ensp;Memory Mapping(mmap)<br/>
&ensp;mmap()은 파일을 메모리 주소 공간에 직접 연결한다. 그래서 addr[i]에 값을 쓰면 → 바로 파일 내용이 바뀌고 다른 프로세스가 같은 파일을 mmap하면 → 그 메모리 변화가 즉시 반영된다.<br/>

&ensp;reader<br/>
```c
int main(void){
  int fd, i;
  int *addr;  

  fd=// 파일을 읽기, 쓰기 가능하게 open
  addr=// memory mapping

  //
  for (i=0; i<10; i++){
    scanf("%d", addr+i);
  }
  exit(0);
}
```

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
    int fd, i;
    int *addr;

    // 1. temp 파일을 읽기/쓰기 모드로 연다. 없으면 새로 만든다.
    fd = open("temp", O_RDWR | O_CREAT, 0666);

    // 2. 파일을 메모리에 매핑한다.(길이: 10개의 int 크기)
    addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);

    // 3. 파일 크기를 미리 10개의 int 크기
    ftruncate(fd, sizeof(int) * 10);

    // 4. 사용자로부터 정수 10개를 입력받아 메모리에 저장 
    for(i=0; i < 10; i++){
      scanf("%d", addr+i);  // 입력값이 바로 매핑된 메모리 → 파일에 반영됨
    }

    exit(0);
}
```

&ensp;동작 과정 단계별 설명<br/>
&ensp;1. open()<br/>
```c
fd = open("temp", O_RDWR | O_CREAT, 0666);
```

* "temp" 파일을 읽기/쓰기 가능하게 연다.
* 없으면 새로 만들고 권한은 `rw-rw-rw-` 로 설정된다.
* 이 파일이 공유될 공간의 기반이 된다.

&ensp;2. mmap()<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
```

* 파일을 프로세스의 가상 메모리에 연결한다.
* `PROT_WRITE`: 쓰기 가능한 메모리
* `MAP_SHARED`: 파일과 메모리를 공유 모드로 연결 → 다른 프로세스도 변경 내용을 볼 수 있음
* 반환값 addr은 파일의 0번 오프셋(시작 지점)을 가리키는 포인터

&ensp;3. ftruncate()<br/>
```c
ftruncate(fd, sizeof(int) * 10);
```

* 파일 크기를 10개의 int(40바이트)로 맞춘다.
* 안 하면 파일 크기가 0이라 mmap 접근 시 segmentation fault 발생 가능

&ensp;4. 입력 저장<br/>
```c
for (i = 0; i < 10; i++)
    scanf("%d", addr + i);
```

* 사용자가 입력하는 10개의 정수를 메모리에 차례로 저장
* 사실상 addr[i] = 입력값; 과 같다.
* 이 순간 메모리 내용이 자동으로 temp 파일에 기록됨

&ensp;5. exit(0)<br/>
&ensp;프로그램 종료. 메모리 매핑은 OS가 자동 해제<br/>


&ensp;writer<br/>
```c
int main(void){
  int fd, i;  
  int *addr;

  fd=// 파일을 읽기 가능하게 open
  addr=// memory mapping

  sleep(5);
  for (i=0; i<5; i++){
    printf("%d\n", *(addr+i));
  }
  sleep(5);

  for (i=5; i<10; i++){
    printf("%d\n", *(addr+i));
  }
  exit(0);
}
```

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
        int fd, i;
        int *addr;

        // 1. temp 파일을 "읽기 전용"으로 연다.
        fd = open("temp", O_RDONLY | O_CREAT, 0600);

        // 2. temp 파일을 읽기 전용으로 메모리에 매핑한다.
        addr = mmap(NULL, 10 * sizeof(int), PROT_READ, MAP_SHARED, fd, 0);

        // 3. 처음엔 5초 기다린다 (reader가 입력할 시간 확보)
        sleep(5);

        // 4. 앞의 5개 값 출력
        for(i=0; i < 5; i++){
                printf("%d\n", *(addr+i));
        }

        // 5. 다시 5초 쉬고 뒤의 5개 값 출력
        sleep(5);
        for(i=5; i < 10;i++){
                printf("%d\n", *(addr+i));
        }
        exit(0);
}
```

&ensp;동작 과정 단계별 설명<br/>
&ensp;1. open()<br/>
* `"temp"` 파일을 읽기전용으로 연다
* 권한 `0600` : 오직 소유자만 읽기/쓰기 가능

&ensp;2. mmap()<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_READ, MAP_SHARED, fd, 0);
```

* 파일을 읽기 전용으로 메모리에 매핑한다.
* reader가 쓴 데이터가 그대로 이 메모리에 반영된다.
* `*(addr + i)` 를 읽으면 reader가 입력한 값이 나옴

&ensp;3. sleep(5)<br/>
* reader가 scanf로 데이터를 다 입력할 시간을 주기 위해 5초 대기

&ensp;4. 출력 루프(앞 5개)<br/>
```c
for(i=0; i<5; i++)
    printf("%d\n", *(addr+i));
```

* 메모리에서 0~4번째 int를 읽어 출력

&ensp;5. sleep(5)<br/>
* 잠깐 쉬었다가 다시 출력

&ensp;6. 출력 루프 (뒤 5개)<br/>
```c
for(i=5; i<10; i++)
  printf("%d\n", *(addr+i));
```

* 나머지 5개 출력


&ensp;실행 순서 예시<br/>

&ensp;터미널 1 (reader 실행)<br/>
```shell
$ ./reader
1 2 3 4 5 6 7 8 9 10
```

&ensp;터미널 2 (writer 실행)<br/>
```shell
$ ./writer
```

&ensp;결과 출력<br/>
```shell
(5초 후)
1
2
3
4
5
(5초 후)
6
7
8
9
10
```

&ensp;temp파일 크기 확인<br/>
```shall
$ ls -l temp
-rw-rw-rw- 1 user user 40 Nov 2 18:20 temp
```

* 파일 크기 40바이트 = 10 * sizeof(int) (리틀엔디언 환경 기준)
* reader에서 ftruncate(fd, 40) 했기 때문

&ensp;전체 원리 정리<br/>

| 항목                         | 설명                                    |
| -------------------------- | ------------------------------------- |
| **mmap()**                 | 파일을 가상 메모리에 매핑해, read/write 없이도 접근 가능 |
| **MAP_SHARED**             | 파일에 실제로 반영되고, 다른 프로세스와 공유됨            |
| **PROT_WRITE / PROT_READ** | 매핑된 메모리의 접근 권한 설정                     |
| **ftruncate()**            | 파일의 물리적 크기 지정 (매핑 영역보다 작으면 오류)        |
| **addr + i**               | i번째 정수의 메모리 주소 (배열처럼 접근 가능)           |
| **동기화 방식**                 | OS 커널이 페이지 캐시를 통해 자동으로 동기화함           |


&ensp;요약 암기 포인트<br/>

| 항목       | 기억할 것                                          |                |
| -------- | ---------------------------------------------- | -------------- |
| 파일 열기    | open("temp", O_RDWR                            | O_CREAT, 0666) |
| mmap 기본형 | `mmap(NULL, length, prot, flags, fd, 0)`       |                |
| 공유 설정    | MAP_SHARED (다른 프로세스와 공유됨)                      |                |
| 파일 크기 확장 | ftruncate(fd, N * sizeof(int))                 |                |
| 접근 방법    | addr[i] = 값 → 파일에 바로 기록됨                       |                |
| 결과       | temp 파일 크기 = 40바이트, writer는 reader 입력값을 그대로 읽음 |                |
