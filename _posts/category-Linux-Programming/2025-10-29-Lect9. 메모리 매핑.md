---
title: "Lect9. 메모리 매핑"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-10-29
last_modified_at: 2025-10-29
---

메모리 매핑(Memory Mapping) 기본 개념
=====

&ensp;메모리 매핑(memeory mapping)이란 파일이나 장치의 내용을 프로세스의 가상 메모리 공간에 직접 연결하는 기법을 말한다.<br/>

&ensp;즉 디스크에 있는 파일 데이터를 read(), write() 시스템 콜 없이 바로 메모리 주소를 통해 접근할 수 있게 만드는 것이다.<br/>

&ensp;**동작 원리** <br/>
&ensp;운영체제는 프로세스마다 가상 메모리 공간을 갖고 있다. `mmap()` 함수를 사용하면 파일의 특정 부분을 이 가상 메모리에 매핑시켜 해당 영역을 읽거나 쓰면 자동으로 파일의 내용이 변경된다.<br/>

&ensp;**파일 <-> 메모리 간의 연결고리를 만들어주는 함수가 mmap()입니다.**<br/>

&ensp;**장점**<br/>

| 구분        | 설명                                       |
| --------- | ---------------------------------------- |
| 성능 향상     | read(), write() 시스템 콜 없이 파일을 메모리에서 직접 접근 |
| 간결한 코드    | 파일 I/O를 포인터 연산처럼 간단히 다룰 수 있음             |
| 프로세스 간 공유 | 동일한 파일을 여러 프로세스가 같은 물리 메모리로 공유 가능        |

관련 시스템 콜
=====

# mmap()

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
```

&ensp;mmap() 함수 인자 설명<br/>
&ensp;`mmap()`은 다음과 같이 동작한다.<br/>
&ensp;fd가 가리키는 파일의 offset부터 len만큼의 데이터를 addr이 가리키는 메모리 공간에 매핑한다.<br/>

&ensp;주요 인자 정리<br/>

| 인자         | 설명                                |
| ---------- | --------------------------------- |
| **addr**   | 매핑할 메모리 주소 (NULL로 지정 시 커널이 자동 배정) |
| **len**    | 매핑할 메모리 크기 (byte 단위)              |
| **prot**   | 보호 모드 (읽기, 쓰기 권한 설정)              |
| **flags**  | 매핑된 데이터의 공유 방법 지정                 |
| **fd**     | 파일 디스크립터 (open으로 얻음)              |
| **offset** | 파일 내 매핑 시작 위치 (페이지 크기 단위)         |

&ensp;prot, flag 인자 & 주의사항<br/>
&ensp;prot 인자<br/>

| 상수           | 의미    |
| ------------ | ----- |
| `PROT_READ`  | 읽기 허용 |
| `PROT_WRITE` | 쓰기 허용 |

&ensp;flag 인자<br/>

| 상수            | 의미                                 |
| ------------- | ---------------------------------- |
| `MAP_SHARED`  | 다른 프로세스와 변경 내용 공유                  |
| `MAP_PRIVATE` | 변경 내용 비공유 (복사 후 쓰기, copy-on-write) |

* 메모리 매핑은 페이지 단위(보통 4KB)로 이루어진다.
    - 페이지 크기 = 4KB = 4096바이트
    - offset은 반드시 4096의 배수여야 한다.
* 매핑된 영역을 벗어나 접근하면 → SIGBUS 또는 SIGSEGV 시그널이 발생한다 (Segmentation fault)

# munmap() - memory mapping 해제

&ensp;`mmap()` 으로 매핑한 메모리 영역을 해제할 때 사용하는 함수이다. 즉 파일과 메모리의 연결을 끊는 역할을 한다.<br/>

```c
#include <sys/mman.h>

int munmap(void *addr, size_t len);
```

| 인자     | 설명                                   |
| ------ | ------------------------------------ |
| `addr` | `mmap()`이 반환한 시작 주소                  |
| `len`  | 매핑된 메모리의 크기 (mmap에서 지정한 len과 동일해야 함) |

&ensp;동작원리<br/>
* 매핑을 해제하면 해당 영역의 접근 권한이 사라진다.
* 해제된 영역을 접근하면 SIGSEGV (Segmentation fault) 발생
* 일반적으로 `munmap()`은 파일 닫기(`close(fd)`) 전에 호출한다.

&ensp;예시<br/>
```c
munmap(addr, length);
close(fd);
```

# mprotect() - 보호 모드 변경

&ensp;이미 매핑된 메모리 영역의 읽기/쓰기 권한(protection mode)을 동적으로 변경할 수 있게 해준다.<br/>

```c
#include <sys/mman.h>

int mprotect(void *addr, size_t len, int prot);
```

| 인자     | 설명                                               |
| ------ | ------------------------------------------------ |
| `addr` | 권한을 변경할 메모리 시작 주소                                |
| `len`  | 변경할 메모리 크기                                       |
| `prot` | 새로운 보호 모드 (ex: PROT_READ, PROT_WRITE, PROT_NONE) |

&ensp;예시<br/>
```c
mprotect(addr, 4096, PROT_READ);      // 읽기만 가능하게 변경
mprotect(addr, 4096, PROT_WRITE);     // 쓰기 권한 추가
```

* `mprotect()` 도 페이지 단위(4KB)로 적용됨
* 쓰기 금지된 영역에 접근하면 SIGSEGV 발생

# truncate(), ftruncate() - 파일 크기 변경

&ensp;파일의 크기를 변경하는 함수이다. 파일이 매핑된 상태에서 크기를 조절할 때 사용한다.<br/>

```c
#include <unistd.h>

// 파일 경로로 변경
int truncate(const char *path, off_t len);

// 파일 디스크립터로 변경
int ftruncate(int fd, off_t len);
```

| 인자            | 설명                |
| ------------- | ----------------- |
| `path` / `fd` | 변경할 파일            |
| `len`         | 새 파일 크기 (byte 단위) |

&ensp;동작 원리<br/>
* 지정한 크기보다 작으면 → 파일을 잘라냄(데이터 손실)
* 지정한 크기보다 크면 → 0으로 채워서 확장됨

&ensp;예시<br/>
```c
ftruncate(fd, 8192);   // 파일을 8KB 크기로 조정
```

&ensp;주의<br/>
* `mmap()` 된 메모리의 크기보다 파일의 더 작게 자르면 이후 접근 시 SIGBUS 오류 발생 (잘린 영역 접근 때문)

# msync() - 매핑된 메모리 동기화

&ensp;`mmap()`으로 매핑된 메모리에 변경사항이 있을 때 그 내용을 파일에 동기화(write-back)하는 함수이다.<br/>

&ensp;사용 방법<br/>
```c
#include <sys/mman.h>

int msync(void *addr, size_t len, int flags);
```

| 인자      | 설명          |
| ------- | ----------- |
| `addr`  | 동기화할 메모리 주소 |
| `len`   | 동기화할 길이     |
| `flags` | 동기화 방식 지정   |

&ensp;flags 인자<br/>

| 인자      | 설명          |
| ------- | ----------- |
| `addr`  | 동기화할 메모리 주소 |
| `len`   | 동기화할 길이     |
| `flags` | 동기화 방식 지정   |

&ensp;예시<br/>
```c
msync(addr, length, MS_SYNC);  // 즉시 파일과 동기화
```

&ensp;활용 예<br/>
* 여러 프로세스가 같은 파일을 공유 매핑할 때 하나의 프로세스가 수정한 내용이 파일에 바로 반영되도록 할 수 있음

실습
====

`문제 1`
&ensp;메모리 매핑을 이용하는 reader와 writer 프로그램을 아래 코드를 사용하여 작성하시오.<br/>
&ensp;(a) reader 프로그램은 “temp" 파일을 메모리 매핑 한 후, scanf()로 10개의 정수를 읽어서 매핑된 파일에 저장하는 작업을 10회 실행합니다.<br/>
&ensp;(b) writer 프로그램은 “temp" 파일을 메모리 매핑 한 후, 매핑 된 파일에 있는 정수를 출력하는 작업을 10회 실행합니다(printf() 사용). 단. 출력 프로그램은 5초간 sleep() 한 후 5회의 출력 작업을 연속 진행하고, 다시 5초간 sleep() 한 후 5회의 출력 작업을 진행합니다.<br/>
&ensp;(c) 두 프로그램이 모두 종료한 후 ”temp" 파일의 크기를 확인합니다.<br/>

| 구분           | 역할              | 동작 요약                                                    |
| ------------ | --------------- | -------------------------------------------------------- |
| **reader.c** | 작성자(Writer 역할)  | `"temp"` 파일을 메모리에 매핑 후 `scanf()`로 입력받은 정수를 그 매핑된 메모리에 저장 |
| **writer.c** | 읽는 쪽(Reader 역할) | `"temp"` 파일을 메모리에 매핑 후 거기 저장된 정수를 읽어 `printf()`로 출력      |

&ensp;Memory Mapping(mmap)<br/>
&ensp;mmap()은 파일을 메모리 주소 공간에 직접 연결한다. 그래서 addr[i]에 값을 쓰면 → 바로 파일 내용이 바뀌고 다른 프로세스가 같은 파일을 mmap하면 → 그 메모리 변화가 즉시 반영된다.<br/>

&ensp;reader<br/>
```c
int main(void){
  int fd, i;
  int *addr;  

  fd=// 파일을 읽기, 쓰기 가능하게 open
  addr=// memory mapping

  //
  for (i=0; i<10; i++){
    scanf("%d", addr+i);
  }
  exit(0);
}
```

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
    int fd, i;
    int *addr;

    // 1. temp 파일을 읽기/쓰기 모드로 연다. 없으면 새로 만든다.
    fd = open("temp", O_RDWR | O_CREAT, 0666);

    // 2. 파일을 메모리에 매핑한다.(길이: 10개의 int 크기)
    addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);

    // 3. 파일 크기를 미리 10개의 int 크기
    ftruncate(fd, sizeof(int) * 10);

    // 4. 사용자로부터 정수 10개를 입력받아 메모리에 저장 
    for(i=0; i < 10; i++){
      scanf("%d", addr+i);  // 입력값이 바로 매핑된 메모리 → 파일에 반영됨
    }

    exit(0);
}
```

&ensp;동작 과정 단계별 설명<br/>
&ensp;1. open()<br/>
```c
fd = open("temp", O_RDWR | O_CREAT, 0666);
```

* "temp" 파일을 읽기/쓰기 가능하게 연다.
* 없으면 새로 만들고 권한은 `rw-rw-rw-` 로 설정된다.
* 이 파일이 공유될 공간의 기반이 된다.

&ensp;2. mmap()<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
```

* 파일을 프로세스의 가상 메모리에 연결한다.
* `PROT_WRITE`: 쓰기 가능한 메모리
* `MAP_SHARED`: 파일과 메모리를 공유 모드로 연결 → 다른 프로세스도 변경 내용을 볼 수 있음
* 반환값 addr은 파일의 0번 오프셋(시작 지점)을 가리키는 포인터

&ensp;3. ftruncate()<br/>
```c
ftruncate(fd, sizeof(int) * 10);
```

* 파일 크기를 10개의 int(40바이트)로 맞춘다.
* 안 하면 파일 크기가 0이라 mmap 접근 시 segmentation fault 발생 가능

&ensp;4. 입력 저장<br/>
```c
for (i = 0; i < 10; i++)
    scanf("%d", addr + i);
```

* 사용자가 입력하는 10개의 정수를 메모리에 차례로 저장
* 사실상 addr[i] = 입력값; 과 같다.
* 이 순간 메모리 내용이 자동으로 temp 파일에 기록됨

&ensp;5. exit(0)<br/>
&ensp;프로그램 종료. 메모리 매핑은 OS가 자동 해제<br/>


&ensp;writer<br/>
```c
int main(void){
  int fd, i;  
  int *addr;

  fd=// 파일을 읽기 가능하게 open
  addr=// memory mapping

  sleep(5);
  for (i=0; i<5; i++){
    printf("%d\n", *(addr+i));
  }
  sleep(5);

  for (i=5; i<10; i++){
    printf("%d\n", *(addr+i));
  }
  exit(0);
}
```

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
        int fd, i;
        int *addr;

        // 1. temp 파일을 "읽기 전용"으로 연다.
        fd = open("temp", O_RDONLY | O_CREAT, 0600);

        // 2. temp 파일을 읽기 전용으로 메모리에 매핑한다.
        addr = mmap(NULL, 10 * sizeof(int), PROT_READ, MAP_SHARED, fd, 0);

        // 3. 처음엔 5초 기다린다 (reader가 입력할 시간 확보)
        sleep(5);

        // 4. 앞의 5개 값 출력
        for(i=0; i < 5; i++){
                printf("%d\n", *(addr+i));
        }

        // 5. 다시 5초 쉬고 뒤의 5개 값 출력
        sleep(5);
        for(i=5; i < 10;i++){
                printf("%d\n", *(addr+i));
        }
        exit(0);
}
```

&ensp;동작 과정 단계별 설명<br/>
&ensp;1. open()<br/>
* `"temp"` 파일을 읽기전용으로 연다
* 권한 `0600` : 오직 소유자만 읽기/쓰기 가능

&ensp;2. mmap()<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_READ, MAP_SHARED, fd, 0);
```

* 파일을 읽기 전용으로 메모리에 매핑한다.
* reader가 쓴 데이터가 그대로 이 메모리에 반영된다.
* `*(addr + i)` 를 읽으면 reader가 입력한 값이 나옴

&ensp;3. sleep(5)<br/>
* reader가 scanf로 데이터를 다 입력할 시간을 주기 위해 5초 대기

&ensp;4. 출력 루프(앞 5개)<br/>
```c
for(i=0; i<5; i++)
    printf("%d\n", *(addr+i));
```

* 메모리에서 0~4번째 int를 읽어 출력

&ensp;5. sleep(5)<br/>
* 잠깐 쉬었다가 다시 출력

&ensp;6. 출력 루프 (뒤 5개)<br/>
```c
for(i=5; i<10; i++)
  printf("%d\n", *(addr+i));
```

* 나머지 5개 출력


&ensp;실행 순서 예시<br/>

&ensp;터미널 1 (reader 실행)<br/>
```shell
$ ./reader
1 2 3 4 5 6 7 8 9 10
```

&ensp;터미널 2 (writer 실행)<br/>
```shell
$ ./writer
```

&ensp;결과 출력<br/>
```shell
(5초 후)
1
2
3
4
5
(5초 후)
6
7
8
9
10
```

&ensp;temp파일 크기 확인<br/>
```shall
$ ls -l temp
-rw-rw-rw- 1 user user 40 Nov 2 18:20 temp
```

* 파일 크기 40바이트 = 10 * sizeof(int) (리틀엔디언 환경 기준)
* reader에서 ftruncate(fd, 40) 했기 때문

&ensp;전체 원리 정리<br/>

| 항목                         | 설명                                    |
| -------------------------- | ------------------------------------- |
| **mmap()**                 | 파일을 가상 메모리에 매핑해, read/write 없이도 접근 가능 |
| **MAP_SHARED**             | 파일에 실제로 반영되고, 다른 프로세스와 공유됨            |
| **PROT_WRITE / PROT_READ** | 매핑된 메모리의 접근 권한 설정                     |
| **ftruncate()**            | 파일의 물리적 크기 지정 (매핑 영역보다 작으면 오류)        |
| **addr + i**               | i번째 정수의 메모리 주소 (배열처럼 접근 가능)           |
| **동기화 방식**                 | OS 커널이 페이지 캐시를 통해 자동으로 동기화함           |


&ensp;요약 암기 포인트<br/>

| 항목       | 기억할 것                                          |                |
| -------- | ---------------------------------------------- | -------------- |
| 파일 열기    | open("temp", O_RDWR                            | O_CREAT, 0666) |
| mmap 기본형 | `mmap(NULL, length, prot, flags, fd, 0)`       |                |
| 공유 설정    | MAP_SHARED (다른 프로세스와 공유됨)                      |                |
| 파일 크기 확장 | ftruncate(fd, N * sizeof(int))                 |                |
| 접근 방법    | addr[i] = 값 → 파일에 바로 기록됨                       |                |
| 결과       | temp 파일 크기 = 40바이트, writer는 reader 입력값을 그대로 읽음 |                |

&ensp;mmap()과 ftruncate() 순서가 바뀌었을 때 생기는 문제<br/>
```c
fd = open("temp", O_RDWR | O_CREAT, 0666);
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
ftruncate(fd, sizeof(int) * 10);
```

&ensp;원래는 ftruncate() → mmap() 순으로 하는 게 더 안전하다. 이 순서 차이가 **메모리 접근 가능한 영역 크기** 에 직접적인 영향을 주기 때문이다.<br/>

&ensp;원리부터 간단히 정리<br/>
&ensp;`mmap()`은 파일의 내용을 물리적 디스크 영역과 프로세스의 가상 메모리 공간에 연결한다. 이때 커널은 현재 크기(`st_size`)를 기준으로 매핑을 설정한다. "mmap은 open된 파일의 현재 크기만큼만 접근 가능한 메모리로 인식한다.`<br/>

&ensp;문제 상황: ftruncate()를 나중에 호출하면?<br/>
&ensp;잘못된 순서 예시<br/>
```c
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
ftruncate(fd, sizeof(int) * 10);
```

* mmap()이 호출될 때, temp 파일 크기가 0바이트라면 → 커널은 **빈 파일(크기 0)**을 메모리에 매핑하려 함 → "접근 가능한 영역 없음"으로 설정됨
* 그다음 ftruncate(fd, 40)으로 파일 크기를 늘려도 이미 매핑된 메모리(addr)의 영역은 커널 내부 테이블에 0바이트로 등록되어 있음
* 따라서 addr[i] = ...로 접근할 때 → 실제로는 "존재하지 않는 페이지"에 접근 → SIGBUS (Bus Error) 발생

&ensp;SIGBUS 에러 예시<br/>
```bash
Bus error (core dumped)
```

* 이 에러는 sefmentation fault(`SIGSEGV`)랑 비슷하지만 원인이 존재하지 않은 파일 매핑 영역 접근일 때 발생함
* mmap이 인식한 파일 크기보다 뒤쪽 메모리를 건드렸다는 뜻이다.

&ensp;올바른 순서<br/>
```c
fd = open("temp", O_RDWR | O_CREAT, 0666);
ftruncate(fd, sizeof(int) * 10);  // 파일 크기 먼저 확보
addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);
```

1. ftruncate() 가 파일 크기를 40바이트로 확장 → 커널이 해당 크기만큼 실제 파일 페이지를 준비함
2. mmap() 은 그 40바이트 파일을 기준으로 정상적인 매핑 관계를 설정 → addr[0]~addr[9] 접근 가능
3. 이후 addr[i] = 값 쓰기 시도 → 정상적으로 temp 파일에 기록됨

&ensp;순서가 중요한 이유 요약<br/>

| 순서                     | 결과                                      |
| ---------------------- | --------------------------------------- |
| `mmap() → ftruncate()` | 매핑 시점에 파일이 0바이트 → 매핑된 영역 없음 → SIGBUS 발생 |
| `ftruncate() → mmap()` | 매핑 전에 크기 확보 → 접근 가능 영역 존재 → 정상 동작       |

&ensp;교수님 코드가 작동하는 이유<br/>
&ensp;그건 운 좋게 OS의 lazy allocation 특성 덕분이다.<br/>
&ensp;리눅스는 mmap()을 호출할 때 실제로 파일 페이지를 곧바로 매핑하지 않고 처음 접근할 때(page fault 발생 시) 파일 크기를 다시 확인하는 경우가 있다. 그래서 아래 상황이면 우연히 동작한다.<br/>
* ftruncate()가 scanf()보다 먼저 호출되므로 (사용자 입력 전에 실행됨) 커널이 첫 접근 시점에 이미 파일 크기를 인식함

&ensp;메모리 매핑 시 안전한 코드 작성 순서<br/>

| 단계 | 함수                      | 설명                              |
| -- | ----------------------- | ------------------------------- |
| 1  | `open()`                | 파일 디스크립터 열기                     |
| 2  | `ftruncate()`           | 파일 크기 미리 확보 (mmap 길이보다 작으면 안 됨) |
| 3  | `mmap()`                | 파일을 메모리에 매핑                     |
| 4  | `scanf()` or `printf()` | 매핑된 메모리 접근                      |
| 5  | `munmap()`              | (선택) 매핑 해제                      |
| 6  | `close(fd)`             | 파일 닫기                           |

&ensp;Bus Error vs Segmentation Fault<br/>

| 구분                               | 의미                         | 원인                   |
| -------------------------------- | -------------------------- | -------------------- |
| **SIGSEGV (Segmentation Fault)** | 잘못된 메모리 주소 접근              | ex. NULL 포인터 접근      |
| **SIGBUS (Bus Error)**           | 유효하지만 실제 존재하지 않는 물리 페이지 접근 | ex. mmap 크기 초과 영역 접근 |

&ensp;mmap()은 매핑 시점의 파일 크기만큼만 접근 가능하므로, 반드시 ftruncate()로 파일 크기를 먼저 늘린 후 mmap() 해야 한다.<br/>


&ensp;안전한 표준 코드 (수정 버전)<br/>
```c
// ✅ reader_safe.c (안전한 표준 버전)
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(void){
    int fd, i;
    int *addr;

    // (1) 파일을 읽기/쓰기 모드로 엶
    fd = open("temp", O_RDWR | O_CREAT, 0666);

    // (2) mmap 전에 파일 크기를 미리 확보해야 함
    // 파일 크기를 10개의 int 만큼 확장 (40바이트)
    ftruncate(fd, sizeof(int) * 10);

    // (3) 이제 파일을 mmap
    addr = mmap(NULL, 10 * sizeof(int), PROT_WRITE, MAP_SHARED, fd, 0);

    // (4) 10개의 정수를 입력받아 파일(매핑된 메모리)에 저장
    for (i = 0; i < 10; i++) {
        scanf("%d", addr + i);
    }

    // (5) 프로그램 종료 → OS가 자동으로 파일에 flush
    exit(0);
}
```

&ensp;안전한 코드 동작 구조<br/>

| 단계 | 동작              | 설명                             |
| -- | --------------- | ------------------------------ |
| 1  | open("temp")    | temp 파일 열기                     |
| 2  | ftruncate()     | 파일을 미리 40바이트 확보                |
| 3  | mmap(fd, 40바이트) | 커널이 정확한 파일 크기만큼 메모리 매핑         |
| 4  | scanf()         | 입력값을 addr[i]에 저장 → 파일 내용 자동 반영 |
| ✅  | 결과              | 완전한 안전 동작, 어떤 OS에서도 SIGBUS 없음  |

&ensp;두 버전 비교표<br/>

| 비교 항목                 | 교수님 버전             | 안전한 표준 버전          |
| --------------------- | ------------------ | ------------------ |
| **ftruncate() 호출 시점** | mmap() 이후          | mmap() 이전          |
| **파일 크기**             | mmap 시점에 0바이트      | mmap 시점에 40바이트     |
| **mmap 유효 범위**        | 0바이트 (위험)          | 40바이트 (안전)         |
| **SIGBUS 가능성**        | 있음 (운에 따라 다름)      | 없음                 |
| **운영체제 호환성**          | 제한적 (일부 Linux만 가능) | 모든 Unix/Linux에서 안전 |
| **표준 준수 여부**          | ❌ POSIX 권장 위배      | ✅ POSIX 표준 준수      |
| **시험/과제에서 권장**        | ❌ 피해야 함            | ✅ 반드시 이렇게 작성       |

&ensp;올바른 순서 (ftruncate → mmap)<br/>
```scss
파일(temp): 40바이트 확보
↓
mmap() 호출 → 메모리 40바이트 매핑
↓
addr[0] ~ addr[9] 안전하게 접근 가능
↓
reader 입력 → writer가 그대로 읽음
```

실습 2
=====

&ensp;1. 메모리 매핑을 이용하는 reader와 writer 프로그램을 아래 코드를 사용하여 작성하시오. <br/>

&ensp;(a) reader 프로그램은 “data" 파일을 메모리 매핑 한 후, 외부 입력을 읽어서 (read() 시스템 콜 사용) 매핑된 메모리에 저장하는 작업을 3회 실행합니다.<br/>
&ensp;(b) writer 프로그램은 “data" 파일을 메모리 매핑 한 후, 매핑된 메모리의 내용을 출력하는 작업을 3회 실행합니다 (write() 시스템 콜 사용).<br/>
&ensp;(c) 읽기-쓰기의 동기화를 위해 signal을 사용합니다.<br/>

&ensp;프로그램 요약<br/>
* writer: 자신의 PID를 공유 파일(data)에 써서 알리고, SIGUSR1 시그널을 받을 때마다 temp에 메모리 매핑된 내용을 표준출력으로 내보냅니다(3회)
* reader: writer의 PID를 **메모리 매핑된 data**에서 읽어온 다음, 표준입력에서 받은 데이터를 **메모리 매핑된 temp**에 써 놓고, 그때그때 writer에게 SIGUSR1을 보냅니다(3회)

&ensp;공유 파일 + mmap + 시그널로 두 프로세스가 “입력 → 신호 → 출력”을 3번 왕복하는 구조이다.<br/>


&ensp;**reader**<br/>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <signal.h>

int main(void){
        int fd1, fd2, len = 0, n, i;
        pid_t *pid;
        char *addr;

        fd1 = open("data", O_RDWR | O_CREAT, 0600);  // 파일을 읽기, 쓰기 가능하게 open
        fd2 = open("temp", O_RDWR | O_CREAT | O_TRUNC, 0600);  // 파일을 읽기, 쓰기 가능하게 open

        pid = mmap(NULL, sizeof(pid_t), PROT_READ, MAP_SHARED, fd1, 0);   // memory mapping
        addr = mmap(NULL, 512, PROT_WRITE, MAP_SHARED, fd2, 0);   // memory mapping

        ftruncate(fd1, sizeof(pid_t));
        ftruncate(fd2, 512);

        while (*pid == 0);  
        printf("writer id = %d\n", *pid);

        for (i = 0; i < 3; i++) {
                n = read(0, addr+len, 512-len);  // read로 입력받은 내용을 file에 저장
                len=len+n;
                if (n >= 512) 
                         break;
                kill(*pid, SIGUSR1);  // writer에게 signal 보내기
    }

    exit(0);
}
```

&ensp;**writer**<br/>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <signal.h>

void catchsig(int signo);

int main(void){
 	char *addr;
	int fd1, fd2, i, n, len = 0;
    	pid_t *pid;
    	static struct sigaction act;

    	act.sa_handler = catchsig;
    	sigaction(SIGUSR1, &act, NULL);

      // signal handler 설정
    	fd1 = open("data", O_RDWR | O_CREAT, 0600);   // 파일을 읽기, 쓰기 가능하게 open
    	fd2 = open("temp", O_RDONLY | O_CREAT, 0600);  // 파일을 읽기, 쓰기 가능하게 open

    	pid = mmap(NULL, sizeof(pid_t), PROT_WRITE, MAP_SHARED, fd1, 0);  // memory mapping
    	addr = mmap(NULL, 512, PROT_READ, MAP_SHARED, fd2, 0);  // memory mapping
	
	ftruncate(fd1, sizeof(pid_t));
    	*pid = getpid(); 

    	for (i = 0; i < 3; i++){
		    pause();
		    write(1, addr+len, 512);  // 읽은 내용을 write로 화면 출력
		    len=strlen(addr);
		    if(len>512){
			    break;
		}
	}

    unlink("data");
}

void catchsig(int signo){
}
```

&ensp;전체 동작 타임라인

1. writer 시작
* data 파일을 `mmap(PROT_WRITE | MAP_SHARED)` 히여 `pid` 위치를 공유 메모리처럼 쓴다.
* 자신의 PID를 `*pid` 에 기록한다.
* `SIGUSR1` 핸들러 등록 후 `pause()` 로 신호를 기다린다.
2. reader 시작
* data 파일을 `mmap(PROT_READ|MAP_SHARED)` 해서 `*pid`를 볼 수 있게 한다.
* temp 파일을 `mmap(PROT_WRITE|MAP_SHARED)` 해서 실제 데이터(입력값)가 들어갈 512바이트 버퍼를 만든다.
* **while(*pid==0);**로 busy-wait 하며 writer가 PID를 써 주기를 기다린다.
* *pid 가 0이 아니면(=writer 준비 완료) 표준입력에서 읽은 바이트를 `temp` 매핑에 써 두고 (누적) 곧바로 `kil(*pid, SIGUSR1)` 로 writer를 깨운다. 이 과정을 3회 반복
3. writer 쪽 반은
* `SIGUSR1` 을 받으면 `pause()` 에서 깨어나 temp 매핑에서 내용을 읽어 표준 출력으로 쓴다.
* 다시 `pause()` 로 들어가 다음 신호를 기다린다. 총 3회 수행 후 종료(마지막에 `unlink("data")` 로 data 삭제)



&ensp;reader 코드 해설<br/>
```c
fd1 = open("data", O_RDWR | O_CREAT, 0600);
fd2 = open("temp", O_RDWR | O_CREAT | O_TRUNC, 0600);

pid  = mmap(NULL, sizeof(pid_t), PROT_READ,  MAP_SHARED, fd1, 0);
addr = mmap(NULL, 512,           PROT_WRITE, MAP_SHARED, fd2, 0);

ftruncate(fd1, sizeof(pid_t));
ftruncate(fd2, 512);
```

* data는 writer의 PID 1개만 공유하면 되므로 `sizeof(pid_t)` 로 temp는 데이터 버퍼 512바이트로 사용
* `mmap` 직후에 `ftruncate` 를 하고 있다.(일반적으로는 파일 크기를 먼저 맞추고 `mmap` 하는 게 안전하다.)
* `pid` 매핑은 읽기 전용(`PROT_READ`)이면 충분(여기는 reader라 쓰지 않음)
* `addr` 매핑은 쓰기 전용(`PROT_WRITE`)으로 표준입력에서 받은 데이터를 여기에 적재

```c
while (*pid == 0);  // writer가 pid를 기록할 때까지 바쁜 대기
printf("writer id = %d\n", *pid);
```

* writer가 *pid를 설정할 때까지 busy-wait.

```c
for (i = 0; i < 3; i++) {
    n = read(0, addr+len, 512-len); // 표준입력 → 매핑 메모리
    len = len + n;
    if (n >= 512) break;            // (의도) 버퍼 초과 방지
    kill(*pid, SIGUSR1);            // writer를 깨움
}
```

* read()는 널문자 '\0'를 넣어주지 않는다. 즉 addr은 단순 바이트 버퍼이다.
* 한 번 읽을 때 `512-len` 만큼만 덜어 읽고 누적한다.
* 매번 입력 후 writer에게 시그널을 보내 읽을 준비 됨을 알린다.


&ensp;writer 코드 해설<br/>
```c
act.sa_handler = catchsig;
sigaction(SIGUSR1, &act, NULL);   // SIGUSR1 핸들러 등록
...
pid  = mmap(NULL, sizeof(pid_t), PROT_WRITE, MAP_SHARED, fd1, 0);
addr = mmap(NULL, 512,           PROT_READ,  MAP_SHARED, fd2, 0);

ftruncate(fd1, sizeof(pid_t));
*pid = getpid();                  // 자신의 PID를 공유 메모리에 씀
```

* writer는 `pid` 매핑을 쓰기 가능으로 열고 자신의 PID를 쓴다. reader는 이를 감지하고 진행한다.
* `addr` 는 읽기 전용으로 매핑하여 temp의 내용을 그대로 읽는다.

```c
for (i = 0; i < 3; i++){
    pause();                      // reader가 SIGUSR1 보낼 때까지 대기
    write(1, addr+len, 512);      // (문제 포인트) 매번 512바이트를 출력
    len = strlen(addr);           // (문제 포인트) 널문자 없는 버퍼에 strlen()
    if (len > 512) break;
}
```

* `pause()`로 시그널 기반 동기화: reader가 쓸 때마다 정확히 1번씩 깨어난다.
* 하지만 출력 부분에 중요한 함정이 2개 있다.
  - 매번 고정 길이 512바이트를 `write()` 한다. 실제로 reader가 이번에 추가로 쓴 길이(n)만큼만 출력해야 의미가 또렷하다. 지금은 버퍼의 앞부분을 반복 출력하거나 덜/더 출력하는 상황이 생길 수 있다.
  - `len=strlen(addr);` 는 널문자 종료 문자열에만 유효하다. `read()` 는 널문자를 붙이지 않기 때문에 `addr` 에는 '\0' 이 없을 수 있고 심지어 이전 쓰레기값을 따라가며 out-of-bounds가 될 위험이 있다.

&ensp;전체 개요<br/>
* 두 개의 프로세스(reader, writer)가 서로 다른 실행 파일로 동시에 실행됨
* 공유 매체: 두 개의 파일
  1. data → writer의 PID를 저장하는 파일
  2. temp → 실제 문자열 데이터를 저장하는 버퍼 파일
* 통신 방식:
  - 파일을 mmap() 으로 메모리에 매핑해서, 마치 같은 메모리를 공유하듯이 접근
  - 시그널(SIGUSR1) 로 "데이터 준비됨" 신호를 주고받음

&ensp;reader는 데이터를 써 주는 역할, writer는 데이터를 읽고 출력하는 역할을 수행함<br/>

&ensp;1단계. writer 실행<br/>
&ensp;코드 동작 순서<br/>
```c
fd1 = open("data", O_RDWR | O_CREAT, 0600);
fd2 = open("temp", O_RDONLY | O_CREAT, 0600);
```

* writer는 두 파일으 ㄹ모두 엶
* data: PID 공유용, O_RDWR로 열기
* temp: 실제 데이터 읽기용, O_RDONLY로 열기

```c
pid = mmap(NULL, sizeof(pid_t), PROT_WRITE, MAP_SHARED, fd1, 0);
addr = mmap(NULL, 512, PROT_READ, MAP_SHARED, fd2, 0);
```

* `mmap()`은 파일을 가상 메모리에 직접 연결하는 시스템 콜
* writer는 pid를 쓰기 가능(PROT_WRITE)으로 매핑, addr은 읽기 전용(PROT_READ)
* `MAP_SHARED` 덕분에 다른 프로세스(reader)도 이 영역의 변화를 볼 수 있음

```c
ftruncate(fd1, sizeof(pid_t));
*pid = getpid();
```

* ftruncate는 파일 크기를 조정하는 함수. data 파일의 크기를 `sizeof(pid_t)`로 딱 맞춰줌.
* writer의 PID를 *pid에 저장하면 파일 data의 내용이 writer의 PID로 채워짐 -> 이제 reader가 이 PID를 읽어서 kill(pid, SIGUSR1)로 writer를 깨울 수 있음.

&ensp;ftruncate(fd2, 512) 생략 이유

&ensp;writer도 temp파일(fd2)에 대해 `ftruncate(fd2, 512)` 을 해주는 것이 정석<br/>
&ensp;하지만 `writer`가 `ftruncate(fd2)`를 실행하지 않은 이유는:<br/>
* reader가 이미 temp파일을 O_TRUNC로 열고 ftruncate(fd2, 512)를 실행하기 때문
* writer  `temp`를 읽기만 하기 때문에 reader가 먼저 크기를 딱 512로 설정한다"는 전제를 깔고 있음
* writer는 temp의 크기가 이미 준비되었다고 가정한다.

&ensp;실제 코드에서 파일 크기를 설정하는 곳<br/>
&ensp;reader(정확히 설정함)<br/>
```c
fd2 = open("temp", O_RDWR | O_CREAT | O_TRUNC, 0600);
addr = mmap(NULL, 512, PROT_WRITE, MAP_SHARED, fd2, 0);
ftruncate(fd2, 512);
```

* `O_TRUNC` 로 파일 내용 초기화
* `ftruncate(fd2, 512)` 로 파일 크기 명확히 설정
* temp파일을 쓸 준비를 reader가 끝냄

&ensp;writer(temp를 읽기만 함)<br/>
```c
fd2 = open("temp", O_RDONLY | O_CREAT, 0600);
addr = mmap(NULL, 512, PROT_READ, MAP_SHARED, fd2, 0);
```

&ensp;writer는 temp에 읽기만 하기 때문에 reader가 파일 크기를 만들어놓아다고 믿고 그대로 읽는 구조이다.<br/>



```c
act.sa_handler = catchsig;
sigaction(SIGUSR1, &act, NULL);
```

* SIGUSR1 시그널이 오면 실행될 함수를 등록 (catchsig)

```c
for (i = 0; i < 3; i++) {
    pause();
    write(1, addr+len, 512);
    len = strlen(addr);
}
```

* pause()는 시그널이 올 때까지 프로세스를 멈춤(block)
* 처음엔 reader가 아직 실행되지 않았으므로 여기서 writer는 멈춰 있음.
* writer는 "reader가 나를 깨워줄 때까지 잠자고 있는 상태"

&ensp;2단계. reader 실행<br/>
&ensp;코드 동작 순서<br/>
```c
fd1 = open("data", O_RDWR | O_CREAT, 0600);
fd2 = open("temp", O_RDWR | O_CREAT | O_TRUNC, 0600);
```

* 같은 파일들을 엶
* data: writer의 PID를 읽을 것이므로 O_RDWR
* temp: 데이터를 쓸 것이므로 O_RDWR + O_TRUNC(기존 내용 비움)

```c
pid  = mmap(NULL, sizeof(pid_t), PROT_READ,  MAP_SHARED, fd1, 0);
addr = mmap(NULL, 512,           PROT_WRITE, MAP_SHARED, fd2, 0);
```

* reader는 pid를 읽기 전용으로, addr을 쓰기 전용으로 매핑함.
* writer와 같은 파일을 매핑했기 때문에, 파일의 내용 변화가 메모리에서 바로 보임

```c
ftruncate(fd1, sizeof(pid_t));
ftruncate(fd2, 512);
```

* 두 파일의 크기를 미리 확보해둠
* 이제 data는 pid크기만큼 temp는 512바이트 크기 확보

```c
while (*pid == 0);
printf("writer id = %d\n", *pid);
```

* writer가 PID를 쓸 때까지 기다림. (while(*pid==0)은 busy-wait)
* writer가 이미 실행 중이므로 *pid 값이 들어오면 루프 탈출.
* PID를 출력함 → "writer id = 12345"

&ensp;3단계. reader가 데이터 입력받고 시그널 전송<br/>
```c
for (i = 0; i < 3; i++) {
    n = read(0, addr+len, 512-len);  // 표준입력에서 문자열 입력
    len = len + n;
    kill(*pid, SIGUSR1);             // writer에게 신호 보냄
}
```

* 사용자가 콘솔에서 입력한 문자열을 temp의 매핑된 메모리에 그대로 써둠
* addr는 바로 temp의 파일 데이터이기 때문에 writer 쪽에서도 같은 내용이 즉시 반영됨
* `kill(*pid, SIGUSR1)` 로 writer를 깨움
* 총 3번 반복

&ensp;4단계. writer가 시그널 받고 출력<br/>
&ensp;이제 reader가 보낸 `SIGUSR1` 시그널이 writer에게 도달함<br/>
```c
void catchsig(int signo) { }
```

* 이 함수는 실제로 아무 동작을 하지 않지만 시그널을 받으면 `pause()` 가 즉시 종료되어 깨어남

&ensp;이후 반복문 본문으로 복귀:<br/>
```c
write(1, addr+len, 512);
len = strlen(addr);
```

* writer는 temp의 매핑된 데이터를 읽어서 표준출력(터미널)에 씀
* 실제로는 512바이트를 통째로 출력하기 때문에 입력 내용 뒤로 공백(널 문자)이 많이 찍힐 수 있음
* strlen(addr)로 길이를 새로 계산(비효율적이지만 교수님이 “중요 포인트”로 강조하신 부분).

&ensp;5단계. 3회 반복<br/>
&ensp;이 과정을 총 3번 반복한다.<br/>

| 순서  | reader 동작                        | writer 반응                                    |
| --- | -------------------------------- | -------------------------------------------- |
| 1회차 | "Hello" 입력 후 `kill()`            | SIGUSR1 수신 → "Hello" 출력                      |
| 2회차 | "Nice to meet you" 입력 후 `kill()` | SIGUSR1 수신 → "HelloNice to meet you" 출력 (누적) |
| 3회차 | "Bye" 입력 후 `kill()`              | SIGUSR1 수신 → "HelloNice to meet youBye" 출력   |


&ensp;6단계. 종료 처리<br/>
* reader는 for문 3회 후 exit(0)로 종료
* writer는 3회 pause()를 모두 끝내면 unlink("data")로 data 파일 삭제하고 종료

&ensp;이로써 두 프로세스는 종료되고 파일 temp에는 마지막 입력 데이터가 남아 있다.<br/>

&ensp;7단계. 실행 결과 요약<br/>

| 구분            | 내용                                                      |
| ------------- | ------------------------------------------------------- |
| **공유 파일**     | `data` (pid 저장) / `temp` (데이터 버퍼)                       |
| **공유 방식**     | `mmap(..., MAP_SHARED, ...)` 로 메모리 공유                   |
| **동기화 방식**    | `kill(SIGUSR1)` + `pause()`                             |
| **입력 방향**     | reader → temp                                           |
| **출력 방향**     | writer → stdout                                         |
| **실행 순서**     | writer 실행 → reader 실행 → 3회 입력/출력 반복 → 종료                |
| **출력 형태**     | 입력한 문자열이 writer 터미널에 3회에 걸쳐 누적 출력됨                      |
| **핵심 학습 포인트** | 메모리 매핑(`mmap`) + 시그널(`SIGUSR1`)을 이용한 **프로세스 간 통신(IPC)** |

&ensp;8단계. 간단한 흐름도<br/>
```scss
┌────────────────────┐       ┌────────────────────┐
│     reader 프로세스 │       │     writer 프로세스 │
└────────┬───────────┘       └────────┬───────────┘
         │                              │
   open/mmap(data,temp)           open/mmap(data,temp)
         │                              │
 while(*pid==0);  ←─────── *pid=getpid()│
         │                              │
 printf("writer id")                    │
         │                              │
read(stdin→addr)──────────────SIGUSR1───▶│
         │                       pause() 해제
         │                              │
         │                    write(stdout, addr)
         │                              │
   (3회 반복)                   (3회 반복)
         ▼                              ▼
      exit(0)                        unlink("data"), exit(0)
```


&ensp;실제 실행 시 관찰될 동작<br/>
&ensp;의도<br/>
* reader가 3번에 걸쳐 입력(예: 세 줄) → 매번 SIGUSR1 전송 → writer는 그때그때 temp의 현재 누적 데이터를 읽어 표준출력에 3번 보여줌

&ensp;현실<br/>
* writer는 매번 512바이트를 통째로 출력한다. 사람이 친 입력이 10바이트여도 512바이트가 나가며(나머지는 \0 또는 쓰레기), 터미널엔 긴 공백/널이 섞여 보일 수 있다.
* strlen(addr) 때문에 len 계산이 부정확하다. 버퍼에 우연히 \0가 있으면 그 전까지만 길이가 잡히고 없으면 엉뚱한 곳까지 훑다가 이상한 값이 될 수 있다.
* 그 결과 2, 3번째 출력의 오프셋(addr + len)이 틀어지고 같은 내용이 반복되거나 중복/누락되는 출력이 나올 수 있다.

&ensp;메모리 매핑 + 시그널 기반 IPC 프로그램 동작 흐름도<br/>
&ensp;전체 구조 개요<br/>
```scss
 ┌──────────────────────────────────────────────┐
 │                공유 파일 2개                │
 │                                              │
 │  data → writer의 PID 저장용 (sizeof(pid_t)) │
 │  temp → 실제 문자열 데이터 공유용 (512 bytes)│
 └──────────────────────────────────────────────┘

     ▲                                 ▲
     │                                 │
     │                                 │
┌────┴─────┐                     ┌─────┴────┐
│  reader  │                     │  writer  │
└──────────┘                     └──────────┘

```

&ensp;동작 순서 (Flowchart + 주석)<br/>
```scss
   ┌──────────────────────────────────────────────┐
   │               [1] writer 실행                │
   └──────────────────────────────────────────────┘
          │
          ▼
   open("data"), open("temp")
          │
          ▼
   mmap data → pid(공유)
   mmap temp → addr(공유)
          │
          ▼
   ftruncate(fd1, sizeof(pid_t))
   *pid = getpid()           ← 자신의 PID를 공유 파일에 기록
          │
          ▼
   sigaction(SIGUSR1, catchsig)
   for (i=0; i<3; i++) {
       pause();               ← 시그널 오기 전까지 대기
       write(1, addr+len, 512);
       len = strlen(addr);
   }
          │
          ▼
   unlink("data"), 종료


──────────────────────────────────────────────

   ┌──────────────────────────────────────────────┐
   │               [2] reader 실행                │
   └──────────────────────────────────────────────┘
          │
          ▼
   open("data"), open("temp")
          │
          ▼
   mmap data → pid(공유)
   mmap temp → addr(공유)
          │
          ▼
   while(*pid == 0);          ← writer의 PID 올 때까지 대기
   printf("writer id = %d\n", *pid);
          │
          ▼
   for (i=0; i<3; i++) {
       read(0, addr+len, 512-len);  ← 표준입력에서 읽어 temp에 저장
       len += n;
       kill(*pid, SIGUSR1);         ← writer 깨움
   }
          │
          ▼
   exit(0)

──────────────────────────────────────────────
```

&ensp;프로세스 간 상호작용(시간 순서)<br/>

| 순서 | reader 동작                                | writer 반응                     |
| -- | ---------------------------------------- | ----------------------------- |
| ①  | 실행 후 writer의 PID를 기다림 (`while(*pid==0)`) | writer 실행되어 PID 기록            |
| ②  | “writer id = 12345” 출력                   |                               |
| ③  | 사용자가 입력(`read()`)                        |                               |
| ④  | 입력을 temp에 저장 후 `kill(SIGUSR1)`           | `pause()` 해제 후 temp 내용을 읽어 출력 |
| ⑤  | 3회 반복 후 종료                               | 3회 출력 후 종료 (`unlink("data")`) |


&ensp;결과<br/>
1. 먼저 writer 실행<br/>
* 아직 reader가 시작 안 해서 pause() 상태로 대기한다.
* 내부적으로 data 파일을 만들고, 여기에 *pid = getpid()를 저장함. → 예: writer의 PID가 12345면 data 파일에 12345가 들어간다.
2. 다음 reader 실행
* reader는 data 파일을 mmap해서 pid를 읽습니다.
* while (*pid == 0); 조건을 통과한 뒤 → "writer id = 12345" 를 출력합니다.
* 이제 표준입력(stdin)에서 데이터를 3번 읽을 준비가 됨.

&ensp;단계별 입출력 시뮬레이션<br/>
&ensp;(1) writer 실행<br/>
```shell
$ ./writer
```

&ensp;→ 아무것도 안 뜸 (pause() 대기 중)<br/>
&ensp;(2) reader 실행<br/>
```shell
$ ./reader
writer id = 12345
```

&ensp;이후 reader는 표준입력을 기다림 (직접 입력하는 부분입니다 ↓)<br/>
```bash
Hello
```

&ensp;→ reader가 addr에 "Hello\n"을 저장하고 writer에게 `SIGUSR1` 전송<br/>
&ensp;→ writer 깨어나서 표준출력으로 temp 내용(512바이트)을 출력<br/>

&ensp;writer 쪽 출력:<br/>
```bash
Hello
```

&ensp;(단, 실제 터미널에서는 512바이트가 고정으로 찍혀서 보통 아래처럼 보입니다 ↓)<br/>
```bash
Hello
[이후 수많은 공백 또는 널문자들]
```

&ensp;(3) reader 두 번째 입력<br/>
```bash
Nice to meet you
```

&ensp;→ reader가 addr+len에 이어서 저장하고 SIGUSR1 전송<br/>

&ensp;writer 쪽 출력:<br/>
```bash
Hello
Nice to meet you
[이후 공백들...]
```

&ensp;(4) reader 세 번째 입력<br/>
```bash
Bye
```

&ensp;writer 쪽 출력:<br/>
```bash
Hello
Nice to meet you
Bye
[공백들...]
```

&ensp;reader는 3회 입력 후 종료, writer는 3번 pause() 끝나면 종료하면서 unlink("data")<br/>

| 구분  | reader 동작                  | writer 출력                                |
| --- | -------------------------- | ---------------------------------------- |
| 1회차 | “Hello” 입력 → `SIGUSR1` 전송  | Hello (이후 공백)                            |
| 2회차 | “Nice to meet you” 입력 → 신호 | Hello + Nice to meet you (누적된 전체 내용 출력됨) |
| 3회차 | “Bye” 입력 → 신호              | Hello + Nice to meet you + Bye (전체 출력)   |

