---
title: "설계과제2"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-12
last_modified_at: 2025-11-12
---

설계과제 #2-1 
=====

체크 포인트 & 복구 가능한 프로그램 구조 설계
------

&ensp;이 과제는 프로그램 실행 도중에 비정상 종료가 발생해도 다시 실행했을 대 이전 작업을 이어서 수행할 수 있는 복구 가능한 프로그램(recoverable program)을 만드는 것이 목표이다. 이를 위해 복구 함수를 작성하고 로컬 파일을 체크 포인트처럼 활용해 프로그램의 진행 상태를 저장한다.<br/>


&ensp;1. 문제 요구사항 정리<br/>

&ensp;(a) 복구 가능한 프로그램의 동작 방식<br/>
&ensp;1) 실행 중 잘못된 입력 발생 → 사용자가 Ctrl-C(SIGINT)로 프로그램 일시 중단<br/>
* 잘못된 입력이 들어오면 프로그램은 정상적으로 처리할 수 없으므로 사용자가 `Ctrl + C` 를 눌러 실행을 잠시 멈춘다.
* 프로그램은 완전히 종료되지 않고 일시 중단 상태로 들어간다는 점이 중요

&ensp;2) 프로그램 중단 시, 복구 기능 실행 → 마지막 입력 번호 출력<br/>
* 프로그램은 현재까지 처리된 입력 번호를 사용자에게 보여준다.

&ensp;예<br/>
```text
마지막으로 완료된 입력 번호: 5
```

* 이후 사용자에게 어디까지 복구할 것인지 번호를 입력받는다.

```text
복구를 원하는 입력 번호를 입력하세요: 
```

&ensp;3) 사용자가 입력한 번호까지 복구 진행<br/>
* 여기서 핵심은 사용자의 선택에 따라 원하는 위치까지의 복구만 수행하는 것
* 예를 들어 마지막 완료 입력번호가 5인데 사용자가 3을 입력한다면:
  - 1 → 2 → 3 까지의 처리 결과를 재생성하여 복구
* 복구가 완료되면:

```text
복구 완료되었습니다.
```

&ensp;4) 복구가 끝나면 프로그램은 정상 실행을 재개<br/>
* 복구 이후에는 일반 모드로 돌아가 이전과 동일하게 프로그램을 계속 수행한다.
* 복구는 중간 회복 기능이며 실행의 흐름은 유지된다.

&ensp;(b) 복구 기능을 사용할 테스트 프로그램의 제약조건<br/>
&ensp;테스트 프로그램은 아래 조건을 모두 충족해야 한다.<br/>

&ensp;1) 정수, 실수, 문자 등의 표준 입출력을 포함할 것<br/>
&ensp;다음과 같은 입력이 모두 존재해야 한다.<br/>
* int
* float(또는 double)
* char

&ensp;2) 문자열 (string) 표준입출력은 사용하지 않는다<br/>
* `"hello world"` 같은 문자열 입력은 사용 불가
* `scanf("%s")`, `fgets()` 등 문자열 처리 금지

&ensp;3) 파일 입출력 사용 금지<br/>
* `fopen` , `fwrite`, `fread` 등 파일 입출력 함수 절대 금지
* 체크포인트는 파일이 아닌 메모리 기반(예: 배열, 구조체)으로 관리

&ensp;4) 프로세스 간 통신(IPC) 및 시그널 동기화 금지<br/>
* 메모리 매핑(mmap)
* 파이프(pipe)
* 메시지 큐(msgget, msgrcv 등)
* 공유 메모리(shmget, shmat)
* 시그널을 이용한 IPC 동기화 (sigwait 등)

&ensp;이 모든 것 사용 금지<br/>
&ensp;단, `Ctrl-C(SIGINT)` 핸들링을 위한 기본 시그널 사용은 허용<br/>

&ensp;교수님 제공 예시 프로그램 전체 설명<br/>
```c
#include <stdio.h>
#include "myio3.h"

int main(void){
    char ch;
    int N, i, num, sum=0, cnt=0;
    float f[20], max=0;

    r_init();

    r_scanf("%d", &N);
    for (i=0; i<N; i++){
        r_scanf("%d", &num);
        sum += num;
	r_printf("sum=%d\n", sum);
    }
    

    r_scanf("%d", &N);
    for (i=0; i<N; i++){
        r_scanf("%f", &f[i]);
    }

    for (i=0; i<N; i++){
          if (f[i] > max) max = f[i];
	  r_printf("max=%2.2f\n", max);
    }
    

    r_scanf("%d", &N);
    for (i=0; i<N; i++){
        r_scanf("%c", &ch);
        if (ch>='a' && ch<='z') cnt++;
	r_printf("cnt=%d\n", cnt);
    }
    

    r_cleanup();
    return 0;
}
```

```c
#include <stdio.h>
#include "myio3.h"
```

* `myio3.h` 안에는 `r_init()`, `r_scanf()`, `r_printf()`, `r_cleanup()` 함수가 들어있다. 
* 이 함수들이 입력/추력 진행 상태를 저장하고 복구하는 핵심 기능을 담당한다.

&ensp;main 변수 정의<br/>
```c
char ch;
int N, i, num, sum=0, cnt=0;
float f[20], max=0;
```

* 정수 입력용: `N`, `num`, `sum`
* 실수 입력용: `f[]`, `max` 
* 문자 입력용: `ch`, `cnt`
* 이 영역들은 프로그램 재실행 시 복구되지 않는다. 복구되는 것은 "입력/출력 진행 상태" 이다.

&ensp;r_init() – 복구 준비<br/>
```c
r_init();
```

* 프로그램 시작 시 이전 실행의 체크포인터 파일이 존재하는지 검사한다.
* 있었다면:
  - 몇 번째 입력까지 r_scanf 가 실행되었는지
  - 몇 번째 출력까지 r_printf가 실행되었는지 를 잃어와 이전 진행 상태를 복구한다.
* 없으면 새로 체크포인터 파일을 생성한다.

&ensp;r_init()은 이번 실행을 복구 모드로 할지 새 실행으로 할지 결정하는 단계<br/>

&ensp;\[ 1단계 \] 정수 입력 → 합계 출력<br/>
&ensp;1) N 입력<br/>
```c
r_scanf("%d", &N);
```

* 정수의 개수 N을 입력받는다.
* 복구 모드일 경우 이미 N이 입력 완료 상태라면 → 다시 입력받지 않고 저장된 값을 사용한다.

&ensp;2) N개의 정수 입력 + 합계 계산 + 매 입력마다 출력<br/>
```c
for (i=0; i<N; i++){
    r_scanf("%d", &num);
    sum += num;
    r_printf("sum=%d\n", sum);
}
```

&ensp;포인트 1) 정수 입력(r_scanf) 은 입력 진행 상태 기록<br/>
* num 입력 시마다 r_scanf는 입력 번호 i를 체크포인트에 저장한다.
* 실행 도중 Ctrl+C로 끊기면 다음 실행에서 i번째부터 계속 입력받는다.

&ensp;포인트 2) 출력(r_printf) 은 출력 진행 상태 기록<br/>
* sum을 출력할 때마다 r_printf는 출력번호를 체크포인트에 기록한다.
* 복구 모드에서 이미 출력된 부분은 절대로 다시 출력되지 않는다.

&ensp;포인트 3) 매 입력마다 출력하는 이유<br/>
&ensp;이 구조는 입력마다 출력이 이어지는 형태이므로 
* 3번째 입력에서 Ctrl+C로 끊기면 → sum이 3번만 출력된 상태로 저장됨
* 다음 실행에서는 → 4번째 입력부터 계속 진행 → sum 출력도 3번째 이후부터 계속 이어짐

&ensp;중복 출력 방지 + 입력 진행 이어서 진행 두 가지를 동시에 만족시키는 구조<br/>

&ensp;\[ 2단계 \] 실수 입력 → 최대값 출력<br/>
&ensp;1) 실수 개수 입력<br/>
```c
r_scanf("%d", &N);
```

* 실수의 개수 입력
* 복구 모드일 경우 저장된 N을 사용하기도 함

&ensp;2) 실수 배열 입력<br/>
```c
for (i=0; i<N; i++){
    r_scanf("%f", &f[i]);
}
```

* 역시 r_scanf가 입력 위치를 저장함
* 만약 i = 7에서 중단되면 다음 실행은 i=7부터 재개됨
* 실수 배열 f[] 자체는 static 저장 안 되지만 입력마다 checkpoint가 저장되므로 다시 계산 가능

&ensp;3) 최대값 찾기 + 매 단계 출력<br/>
```c
for (i=0; i<N; i++){
    if (f[i] > max) max = f[i];
    r_printf("max=%2.2f\n", max);
}
```

&ensp;이 부분도 핵심이 2개 있음<br/>
&ensp;포인트 1) 계산 자체는 복구되지 않음<br/>
* max 계산은 항상 처음부터 다시 수행됨
* 이는 정상적임
* 복구되는 것은 출력 위치이다. → 즉 max 출력을 어디까지 했는지 기억한다

&ensp;포인트 2) 출력이 매 루프마다 들어가는 이유<br/>
* 5번째까지 출력했을 때 Ctrl+C로 중단되면
* 복구 후에는 → 출력은 6번째부터 계속 실행됨
* 1~5 번째 출력은 다시 하지 않음

&ensp;중복 계산은 가능하지만 중복 출력은 방지함<br/>

&ensp;\[ 3단계 \] 문자 입력 → 소문자 개수 출력<br/>
&ensp;1) 문자 개수 N 입력<br/>
```c
r_scanf("%d", &N);
```

&ensp;2) 문자를 하나씩 입력받아 소문자면 cnt 증가<br/>
```c
for (i=0; i<N; i++){
    r_scanf("%c", &ch);
    if (ch>='a' && ch<='z') cnt++;
    r_printf("cnt=%d\n", cnt);
}
```

&ensp;여기도 완전히 동일한 복구 방식<br/>

&ensp;r_scanf → 입력 위치 저장<br/>
&ensp;r_printf → 출력 위치 저장<br/>
&ensp;cnt는 로컬 변수지만, 입력한 문자 순서가 보존되므로 다시 계산 가능<br/>

&ensp;종료 처리: r_cleanup()<br/>
```c
r_cleanup();
```

* 정상 종료 시 체크포인트 파일 삭제
* 다음 실행은 완전히 새로운 실행으로 동작
* 복구 기능은 종료됨


1차 계획서
-----

&ensp;(1) 복구 기능을 구현하기 위해 memory mapping, pipe, message queue, shared memory segment 중 어느 매체를 이용하려고 하는지 쓰고, 해당 매체를 선택한 이유를 설명하시오.<br/>
&ensp;선택 매체: Memory Mapping (메모리 매핑)<br/>
&ensp;선택 이유<br/>
* memory mapping은 파일을 프로세스의 주소 공간에 직접 매핑하여, 메모리에 접근하듯 파일에 읽고 쓸 수 있는 기능을 제공한다.
* 이를 이용하면 프로그램이 입력받은 데이터나 진행 상태를 파일 형태로 실시간 저장할 수 있다.
* 프로그램이 비정상 종료되더라도 매핑된 파일(`data1`, `data2`)에 데이터가 남아 있으므로 재실행 시 이전 상태를 그대로 복구할 수 있다.
* 또한 `msync()` 를 사용하면 메모리 변경 내용을 즉시 디스크에 반영할 수 있어 별도의 파일 입출력 함수를 사용하지 않고도 빠르고 안정적인 복구 시스템을 구현할 수 있다.
* pipe나 message queue는 데이터의 일시적 전달에 적합하고, shared memory는 프로세스 간 통신에 효과적이지만 영속성이 없으므로 복구용으로는 적절하지 않다. 반면 memory mapping은 파일 기반으로 하여 프로세스 종료 후에도 데이터가 유지된다.

&ensp;(2) r_init() 함수에 포함되어야 한다고 생각하는 기능을 설명하시오.<br/>
&ensp;memory mapping 복구 구조 흐름<br/>
&ensp;1단계: 프로그램 시작 시 (`r_init()`)<br/>
```scss
┌─────────────────────────────┐
│ 프로그램 시작               │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ backup.dat 파일 open       │
     │ O_RDWR | O_CREAT 모드      │
     │ 파일 크기 = 구조체 크기로     │
     │ ftruncate()로 미리 확보     │
     └────────────────────────────┘
             ↓
     ┌────────────────────────────┐
     │ mmap()으로 구조체 연결       │
     │ ex) state = mmap(NULL,     │
     │ sizeof(union state), ...) │
     └────────────────────────────┘
             ↓
     ┌────────────────────────────┐
     │ 파일 안에 저장된 값 확인      │
     │ - stage==0 → 새 실행        │
     │ - stage>0  → 복구 실행      │
     └────────────────────────────┘
```

* 프로그램 시작 시 복구용 파일을 열고(`open()`) 지정된 크기만큼 확장(`ftruncate()`)한다.
* `mmap()` 을 사용하여 두 개의 파일을 각각 메모리에 매핑한다.
  - data1: 입력 데이터(`DataUnion` 배열) 저장용
  - data2: 진행 상태(`입력 개수`, `출력 개수`)저장용
* 기존 파일에 저장된 데이터가 있으면 프로그램이 중단되었던 지점(`nscanf`, `nprint`)을 읽어 복구 모드(`mode=1`)로 전환한다.
* 복구 모드일 경우 사용자가 원하는 복구 지점을 선택할 수도 있다.
* 새로 실행되는 경우(`mode=0`)에는 매핑된 영역을 0으로 초기화한다.

&ensp;핵심 역할<br/>
&ensp;프로그램 시작 시 복구 파일을 연결하고 기존 데이터 존재 여부에 따라 복구/초기화를 결정하는 초기화 루틴이다.<br/>

&ensp;(3) `r_scanf()` 함수에 포함되어야 한다고 생각하는 기능을 설명하시오.<br/>
```scss
┌─────────────────────────────┐
│ scanf()로 입력받음            │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ 입력값을 state->arr[i] 에 저장│
     │ state->stage = 현재 단계 기록 │
     └────────────────────────────┘
             ↓
     ┌────────────────────────────┐
     │ msync(state, sizeof(...))  │
     │ → 파일에 즉시 반영           │
     └────────────────────────────┘
```

&ensp;이 과정이 핵심: `msync()` 를 해줘야 비정상 종료에도 `backup.dat` 에 최신 상태가 남아 복구할 수 있다.<br/>

* 일반적인 `scanf()`와 동일하게 입력을 받아 변수에 저장하되 입력값을 `data1` 의 메모리 매핑 영역에 함께 저장한다.
* 매 입력마다 입력 카운트(`cnt`)를 증가시키고 그 값을 `data2[0]`(`nscanf`)에 기록한다.
* `msync()` 를 호출하여 변경된 데이터를 즉시 파일에 반영하여 프로그램이 갑자기 종료되더라도 최신 입력 상태가 유지되도록 한다. 
* 복구 모드(`mode==1`)에서는 사용자 입력을 받지 않고 이전 실행에서 저장된 값을 addr1에서 읽어 변수에 복원한다.
  - 복구가 완료되면 mode를 0으로 돌려 정상 모드로 전환한다.

&ensp;핵심 역할<br/>
&ensp;입력값을 단순히 받는 것이 아니라 입력 데이터와 입력 진행 상태룰 파일에 백업하여 복구 가능하게 하는 함수이다.<br/>

&ensp;(4) `r_printf()` 함수에 포함되어야 한다고 생각하는 기능을 설명하시오.<br/>
```scss
┌─────────────────────────────┐
│ printf()로 결과 출력        │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ state->stage++ 업데이트     │
     │ (출력 단계 진행)            │
     │ msync() 호출로 저장         │
     └────────────────────────────┘
```

* 일반적인 `printf()` 기능을 수행하면서 출력 단계 진행 상황(`nprint`)을 `data2[1]`에 기록한다.
* 매 출력마다 현재 출력 인덱스(`out_cnt`)를 증가시키고 이를 `msync` 로 동기화하여 어디까지 출력했는지 상태를 저장한다.
* 복구 모드에서는 이미 출력이 완료된 부분(`out_cnt < nprint`)은 건너뛰고 아직 출력되지 않은 부분만 새로 출력하도록 제어한다.
* 이를 통해 비정상 종료 후 재실행 시 이전에 출력이 완료된 부분을 중복 출력하지 않고 이어서 출력할 수 있다.

&ensp;핵심 역할<br/>
&ensp;출력 내용을 단순히 표시하는 것이 아니라, 출력 진행 상태를 저장하여 재출력 위치를 제어하는 복구 출력 함수이다.<br/>

```c
┌─────────────────────────────┐
│ 프로그램 종료                │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ munmap(state)              │
     │ close(fd)                  │
     └────────────────────────────┘
```

