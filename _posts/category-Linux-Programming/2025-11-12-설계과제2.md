---
title: "설계과제2"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-12
last_modified_at: 2025-11-14
---

설계과제 #2-1 
=====

체크 포인트 & 복구 가능한 프로그램 구조 설계
------

&ensp;이 과제는 프로그램 실행 도중에 비정상 종료가 발생해도 다시 실행했을 대 이전 작업을 이어서 수행할 수 있는 복구 가능한 프로그램(recoverable program)을 만드는 것이 목표이다. 이를 위해 복구 함수를 작성하고 로컬 파일을 체크 포인트처럼 활용해 프로그램의 진행 상태를 저장한다.<br/>


&ensp;1. 문제 요구사항 정리<br/>

&ensp;(a) 복구 가능한 프로그램의 동작 방식<br/>
&ensp;1) 실행 중 잘못된 입력 발생 → 사용자가 Ctrl-C(SIGINT)로 프로그램 일시 중단<br/>
* 잘못된 입력이 들어오면 프로그램은 정상적으로 처리할 수 없으므로 사용자가 `Ctrl + C` 를 눌러 실행을 잠시 멈춘다.
* 프로그램은 완전히 종료되지 않고 일시 중단 상태로 들어간다는 점이 중요

&ensp;2) 프로그램 중단 시, 복구 기능 실행 → 마지막 입력 번호 출력<br/>
* 프로그램은 현재까지 처리된 입력 번호를 사용자에게 보여준다.

&ensp;예<br/>
```text
마지막으로 완료된 입력 번호: 5
```

* 이후 사용자에게 어디까지 복구할 것인지 번호를 입력받는다.

```text
복구를 원하는 입력 번호를 입력하세요: 
```

&ensp;3) 사용자가 입력한 번호까지 복구 진행<br/>
* 여기서 핵심은 사용자의 선택에 따라 원하는 위치까지의 복구만 수행하는 것
* 예를 들어 마지막 완료 입력번호가 5인데 사용자가 3을 입력한다면:
  - 1 → 2 → 3 까지의 처리 결과를 재생성하여 복구
* 복구가 완료되면:

```text
복구 완료되었습니다.
```

&ensp;4) 복구가 끝나면 프로그램은 정상 실행을 재개<br/>
* 복구 이후에는 일반 모드로 돌아가 이전과 동일하게 프로그램을 계속 수행한다.
* 복구는 중간 회복 기능이며 실행의 흐름은 유지된다.

&ensp;(b) 복구 기능을 사용할 테스트 프로그램의 제약조건<br/>
&ensp;테스트 프로그램은 아래 조건을 모두 충족해야 한다.<br/>

&ensp;1) 정수, 실수, 문자 등의 표준 입출력을 포함할 것<br/>
&ensp;다음과 같은 입력이 모두 존재해야 한다.<br/>
* int
* float(또는 double)
* char

&ensp;2) 문자열 (string) 표준입출력은 사용하지 않는다<br/>
* `"hello world"` 같은 문자열 입력은 사용 불가
* `scanf("%s")`, `fgets()` 등 문자열 처리 금지

&ensp;3) 파일 입출력 사용 금지<br/>
* `fopen` , `fwrite`, `fread` 등 파일 입출력 함수 절대 금지
* 체크포인트는 파일이 아닌 메모리 기반(예: 배열, 구조체)으로 관리

&ensp;4) 프로세스 간 통신(IPC) 및 시그널 동기화 금지<br/>
* 메모리 매핑(mmap)
* 파이프(pipe)
* 메시지 큐(msgget, msgrcv 등)
* 공유 메모리(shmget, shmat)
* 시그널을 이용한 IPC 동기화 (sigwait 등)

&ensp;이 모든 것 사용 금지<br/>
&ensp;단, `Ctrl-C(SIGINT)` 핸들링을 위한 기본 시그널 사용은 허용<br/>

&ensp;교수님 제공 예시 프로그램 전체 설명<br/>
```c
#include <stdio.h>
#include "myio3.h"

int main(void){
    char ch;
    int N, i, num, sum=0, cnt=0;
    float f[20], max=0;

    r_init();

    r_scanf("%d", &N);
    for (i=0; i<N; i++){
        r_scanf("%d", &num);
        sum += num;
	r_printf("sum=%d\n", sum);
    }
    

    r_scanf("%d", &N);
    for (i=0; i<N; i++){
        r_scanf("%f", &f[i]);
    }

    for (i=0; i<N; i++){
          if (f[i] > max) max = f[i];
	  r_printf("max=%2.2f\n", max);
    }
    

    r_scanf("%d", &N);
    for (i=0; i<N; i++){
        r_scanf("%c", &ch);
        if (ch>='a' && ch<='z') cnt++;
	r_printf("cnt=%d\n", cnt);
    }
    

    r_cleanup();
    return 0;
}
```

```c
#include <stdio.h>
#include "myio3.h"
```

* `myio3.h` 안에는 `r_init()`, `r_scanf()`, `r_printf()`, `r_cleanup()` 함수가 들어있다. 
* 이 함수들이 입력/추력 진행 상태를 저장하고 복구하는 핵심 기능을 담당한다.

&ensp;main 변수 정의<br/>
```c
char ch;
int N, i, num, sum=0, cnt=0;
float f[20], max=0;
```

* 정수 입력용: `N`, `num`, `sum`
* 실수 입력용: `f[]`, `max` 
* 문자 입력용: `ch`, `cnt`
* 이 영역들은 프로그램 재실행 시 복구되지 않는다. 복구되는 것은 "입력/출력 진행 상태" 이다.

&ensp;r_init() – 복구 준비<br/>
```c
r_init();
```

* 프로그램 시작 시 이전 실행의 체크포인터 파일이 존재하는지 검사한다.
* 있었다면:
  - 몇 번째 입력까지 r_scanf 가 실행되었는지
  - 몇 번째 출력까지 r_printf가 실행되었는지 를 잃어와 이전 진행 상태를 복구한다.
* 없으면 새로 체크포인터 파일을 생성한다.

&ensp;r_init()은 이번 실행을 복구 모드로 할지 새 실행으로 할지 결정하는 단계<br/>

&ensp;\[ 1단계 \] 정수 입력 → 합계 출력<br/>
&ensp;1) N 입력<br/>
```c
r_scanf("%d", &N);
```

* 정수의 개수 N을 입력받는다.
* 복구 모드일 경우 이미 N이 입력 완료 상태라면 → 다시 입력받지 않고 저장된 값을 사용한다.

&ensp;2) N개의 정수 입력 + 합계 계산 + 매 입력마다 출력<br/>
```c
for (i=0; i<N; i++){
    r_scanf("%d", &num);
    sum += num;
    r_printf("sum=%d\n", sum);
}
```

&ensp;포인트 1) 정수 입력(r_scanf) 은 입력 진행 상태 기록<br/>
* num 입력 시마다 r_scanf는 입력 번호 i를 체크포인트에 저장한다.
* 실행 도중 Ctrl+C로 끊기면 다음 실행에서 i번째부터 계속 입력받는다.

&ensp;포인트 2) 출력(r_printf) 은 출력 진행 상태 기록<br/>
* sum을 출력할 때마다 r_printf는 출력번호를 체크포인트에 기록한다.
* 복구 모드에서 이미 출력된 부분은 절대로 다시 출력되지 않는다.

&ensp;포인트 3) 매 입력마다 출력하는 이유<br/>
&ensp;이 구조는 입력마다 출력이 이어지는 형태이므로 
* 3번째 입력에서 Ctrl+C로 끊기면 → sum이 3번만 출력된 상태로 저장됨
* 다음 실행에서는 → 4번째 입력부터 계속 진행 → sum 출력도 3번째 이후부터 계속 이어짐

&ensp;중복 출력 방지 + 입력 진행 이어서 진행 두 가지를 동시에 만족시키는 구조<br/>

&ensp;\[ 2단계 \] 실수 입력 → 최대값 출력<br/>
&ensp;1) 실수 개수 입력<br/>
```c
r_scanf("%d", &N);
```

* 실수의 개수 입력
* 복구 모드일 경우 저장된 N을 사용하기도 함

&ensp;2) 실수 배열 입력<br/>
```c
for (i=0; i<N; i++){
    r_scanf("%f", &f[i]);
}
```

* 역시 r_scanf가 입력 위치를 저장함
* 만약 i = 7에서 중단되면 다음 실행은 i=7부터 재개됨
* 실수 배열 f[] 자체는 static 저장 안 되지만 입력마다 checkpoint가 저장되므로 다시 계산 가능

&ensp;3) 최대값 찾기 + 매 단계 출력<br/>
```c
for (i=0; i<N; i++){
    if (f[i] > max) max = f[i];
    r_printf("max=%2.2f\n", max);
}
```

&ensp;이 부분도 핵심이 2개 있음<br/>
&ensp;포인트 1) 계산 자체는 복구되지 않음<br/>
* max 계산은 항상 처음부터 다시 수행됨
* 이는 정상적임
* 복구되는 것은 출력 위치이다. → 즉 max 출력을 어디까지 했는지 기억한다

&ensp;포인트 2) 출력이 매 루프마다 들어가는 이유<br/>
* 5번째까지 출력했을 때 Ctrl+C로 중단되면
* 복구 후에는 → 출력은 6번째부터 계속 실행됨
* 1~5 번째 출력은 다시 하지 않음

&ensp;중복 계산은 가능하지만 중복 출력은 방지함<br/>

&ensp;\[ 3단계 \] 문자 입력 → 소문자 개수 출력<br/>
&ensp;1) 문자 개수 N 입력<br/>
```c
r_scanf("%d", &N);
```

&ensp;2) 문자를 하나씩 입력받아 소문자면 cnt 증가<br/>
```c
for (i=0; i<N; i++){
    r_scanf("%c", &ch);
    if (ch>='a' && ch<='z') cnt++;
    r_printf("cnt=%d\n", cnt);
}
```

&ensp;여기도 완전히 동일한 복구 방식<br/>

&ensp;r_scanf → 입력 위치 저장<br/>
&ensp;r_printf → 출력 위치 저장<br/>
&ensp;cnt는 로컬 변수지만, 입력한 문자 순서가 보존되므로 다시 계산 가능<br/>

&ensp;종료 처리: r_cleanup()<br/>
```c
r_cleanup();
```

* 정상 종료 시 체크포인트 파일 삭제
* 다음 실행은 완전히 새로운 실행으로 동작
* 복구 기능은 종료됨


1차 계획서
-----

&ensp;(1) 복구 기능을 구현하기 위해 memory mapping, pipe, message queue, shared memory segment 중 어느 매체를 이용하려고 하는지 쓰고, 해당 매체를 선택한 이유를 설명하시오.<br/>
&ensp;선택 매체: Memory Mapping (메모리 매핑)<br/>
&ensp;선택 이유<br/>
* memory mapping은 파일을 프로세스의 주소 공간에 직접 매핑하여, 메모리에 접근하듯 파일에 읽고 쓸 수 있는 기능을 제공한다.
* 이를 이용하면 프로그램이 입력받은 데이터나 진행 상태를 파일 형태로 실시간 저장할 수 있다.
* 프로그램이 비정상 종료되더라도 매핑된 파일(`data1`, `data2`)에 데이터가 남아 있으므로 재실행 시 이전 상태를 그대로 복구할 수 있다.
* 또한 `msync()` 를 사용하면 메모리 변경 내용을 즉시 디스크에 반영할 수 있어 별도의 파일 입출력 함수를 사용하지 않고도 빠르고 안정적인 복구 시스템을 구현할 수 있다.
* pipe나 message queue는 데이터의 일시적 전달에 적합하고, shared memory는 프로세스 간 통신에 효과적이지만 영속성이 없으므로 복구용으로는 적절하지 않다. 반면 memory mapping은 파일 기반으로 하여 프로세스 종료 후에도 데이터가 유지된다.

&ensp;(2) r_init() 함수에 포함되어야 한다고 생각하는 기능을 설명하시오.<br/>
&ensp;memory mapping 복구 구조 흐름<br/>
&ensp;1단계: 프로그램 시작 시 (`r_init()`)<br/>
```scss
┌─────────────────────────────┐
│ 프로그램 시작               │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ backup.dat 파일 open       │
     │ O_RDWR | O_CREAT 모드      │
     │ 파일 크기 = 구조체 크기로     │
     │ ftruncate()로 미리 확보     │
     └────────────────────────────┘
             ↓
     ┌────────────────────────────┐
     │ mmap()으로 구조체 연결       │
     │ ex) state = mmap(NULL,     │
     │ sizeof(union state), ...) │
     └────────────────────────────┘
             ↓
     ┌────────────────────────────┐
     │ 파일 안에 저장된 값 확인      │
     │ - stage==0 → 새 실행        │
     │ - stage>0  → 복구 실행      │
     └────────────────────────────┘
```

* 프로그램 시작 시 복구용 파일을 열고(`open()`) 지정된 크기만큼 확장(`ftruncate()`)한다.
* `mmap()` 을 사용하여 두 개의 파일을 각각 메모리에 매핑한다.
  - data1: 입력 데이터(`DataUnion` 배열) 저장용
  - data2: 진행 상태(`입력 개수`, `출력 개수`)저장용
* 기존 파일에 저장된 데이터가 있으면 프로그램이 중단되었던 지점(`nscanf`, `nprint`)을 읽어 복구 모드(`mode=1`)로 전환한다.
* 복구 모드일 경우 사용자가 원하는 복구 지점을 선택할 수도 있다.
* 새로 실행되는 경우(`mode=0`)에는 매핑된 영역을 0으로 초기화한다.

&ensp;핵심 역할<br/>
&ensp;프로그램 시작 시 복구 파일을 연결하고 기존 데이터 존재 여부에 따라 복구/초기화를 결정하는 초기화 루틴이다.<br/>

&ensp;(3) `r_scanf()` 함수에 포함되어야 한다고 생각하는 기능을 설명하시오.<br/>
```scss
┌─────────────────────────────┐
│ scanf()로 입력받음            │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ 입력값을 state->arr[i] 에 저장│
     │ state->stage = 현재 단계 기록 │
     └────────────────────────────┘
             ↓
     ┌────────────────────────────┐
     │ msync(state, sizeof(...))  │
     │ → 파일에 즉시 반영           │
     └────────────────────────────┘
```

&ensp;이 과정이 핵심: `msync()` 를 해줘야 비정상 종료에도 `backup.dat` 에 최신 상태가 남아 복구할 수 있다.<br/>

```c
#include <sys/mman.h>

int msync(void *addr, size_t length, int flags);
```

&ensp;msync()는 mmap으로 연결한 파일에 지금 메모리 내용을 바로 저장하라는 명령<br/>

| 매개변수     | 설명                                                 |
| -------- | -------------------------------------------------- |
| `addr`   | `mmap()`으로 매핑된 메모리의 시작 주소                          |
| `length` | 동기화할 메모리의 길이                                       |
| `flags`  | 동기화 방식 제어 (`MS_SYNC`, `MS_ASYNC`, `MS_INVALIDATE`) |

&ensp;flags 종류<br/>

| 상수              | 의미                                    |
| --------------- | ------------------------------------- |
| `MS_SYNC`       | 변경 내용을 **즉시 디스크에 반영** (동기식 저장, 가장 안전) |
| `MS_ASYNC`      | OS가 비동기적으로 나중에 반영                     |
| `MS_INVALIDATE` | 다른 프로세스가 접근 중이면 해당 페이지 캐시를 무효화        |

&ensp;반환값:<br/>
* 성공 시 0
* 실패 시 -1 (이때 errno로 원인 확인)

* 일반적인 `scanf()`와 동일하게 입력을 받아 변수에 저장하되 입력값을 `data1` 의 메모리 매핑 영역에 함께 저장한다.
* 매 입력마다 입력 카운트(`cnt`)를 증가시키고 그 값을 `data2[0]`(`nscanf`)에 기록한다.
* `msync()` 를 호출하여 변경된 데이터를 즉시 파일에 반영하여 프로그램이 갑자기 종료되더라도 최신 입력 상태가 유지되도록 한다. 
* 복구 모드(`mode==1`)에서는 사용자 입력을 받지 않고 이전 실행에서 저장된 값을 addr1에서 읽어 변수에 복원한다.
  - 복구가 완료되면 mode를 0으로 돌려 정상 모드로 전환한다.

&ensp;핵심 역할<br/>
&ensp;입력값을 단순히 받는 것이 아니라 입력 데이터와 입력 진행 상태룰 파일에 백업하여 복구 가능하게 하는 함수이다.<br/>

&ensp;(4) `r_printf()` 함수에 포함되어야 한다고 생각하는 기능을 설명하시오.<br/>
```scss
┌─────────────────────────────┐
│ printf()로 결과 출력        │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ state->stage++ 업데이트     │
     │ (출력 단계 진행)            │
     │ msync() 호출로 저장         │
     └────────────────────────────┘
```

* 일반적인 `printf()` 기능을 수행하면서 출력 단계 진행 상황(`nprint`)을 `data2[1]`에 기록한다.
* 매 출력마다 현재 출력 인덱스(`out_cnt`)를 증가시키고 이를 `msync` 로 동기화하여 어디까지 출력했는지 상태를 저장한다.
* 복구 모드에서는 이미 출력이 완료된 부분(`out_cnt < nprint`)은 건너뛰고 아직 출력되지 않은 부분만 새로 출력하도록 제어한다.
* 이를 통해 비정상 종료 후 재실행 시 이전에 출력이 완료된 부분을 중복 출력하지 않고 이어서 출력할 수 있다.

&ensp;핵심 역할<br/>
&ensp;출력 내용을 단순히 표시하는 것이 아니라, 출력 진행 상태를 저장하여 재출력 위치를 제어하는 복구 출력 함수이다.<br/>

```c
┌─────────────────────────────┐
│ 프로그램 종료                │
└────────────┬────────────────┘
             ↓
     ┌────────────────────────────┐
     │ munmap(state)              │
     │ close(fd)                  │
     └────────────────────────────┘
```

2차 계획서
=====

&ensp;복구 가능한 프로그래밍: Memory Mapping → Shared Memory로 설계를 변경한 이유<br/>
&ensp;초기 설계: 일반 파일 기반 Memory Mapping(mmap) 구조<br/>
&ensp;처음에 생각한 구조는 다음과 같다.<br/>
* `data1` 파일: 입력 버퍼 + 현재 input index 저장
* `data2` 파일: 출력 진행 위치(nprint) 저장
* `r_scanf`, `r_printf` 내부에서
  - 파일을 open
  - mmap
  - 값 갱신 후 msync
  - unmap / close

&ensp;이 방식의 장점은: <br/>
&ensp;파일이므로 프로그램이 죽어도 상태가 남음 → 복구 가능한 프로그래밍의 요구사항 충족<br/>
&ensp;mmap을 사용하여 메모리 접근처럼 빠르게 사용 가능 → 일반 파일 I/O보다 효율적<br/>

&ensp;문제 1: 파일 기반 mapping은 매 호출마다 open/mmap/close 수행 → 비효율적
&ensp;`r_scanf` / `r_printf` 가 매번 호출될 때마다 다음 과정이 반복된다.<br/>
1. open()
2. mmap()
3. msync()
4. munmap()
5. close()

* 오버헤드 증가
* 코드 복잡도 증가

&ensp;파일 크기를 ftruncate로 매번 관리해야 함<br/>

&ensp;문제 2: 파일 기반 mmap은 경로 관리가 복잡함<br/>
* data 파일이 어디에 있어야 하는지
* 실행 디렉토리마다 상대 경로가 달라짐
* 다른 학생 또는 TA 환경에서는 파일 경로가 깨질 가능성

&ensp;문제 3: 파일 기반 mmap은 IPC(프로세스 간 공유) 목적에 적합하지 않음<br/>
&ensp;memory mapping을 쓰는 목적 중 하나는 프로세스 간 동일 메모리를 공유하는 것이고<br/>
* 일반 파일로 mmap하면 프로세스 간 shared mapping이 가능하긴 하지만
* write back 정책, dirty page 관리가 복잡해지고
* 동기화 문제(msync 타이밍 등)도 직접 해결해야 한다.

&ensp;파일 mmap은 프로세스 간 직접 공유(shared memory) 용도가 아니다.<br/>

&ensp;해결책: Shared Memory + mmap 구조로 전환<br/>
```scss
shm_open() → 메모리 기반 파일 디스크립터 생성
ftruncate() → 크기 지정
mmap(..., MAP_SHARED, fd) → shared memory 매핑
```

&ensp;Shared memory는 다음 특징을 가짐<br/>

&ensp;Shared Memory의 장점<br/>
&ensp;1. 진짜 "프로세스 간 공유"를 위한 기술<br/>
&ensp;shared memory는 커널이 관리하는 tmpfs 기반 파일 객체이므로 프로세스 간 접근이 매우 빠르고 설계가 단순하다.<br/>
&ensp;2. 파일 경로 관리가 필요 없다<br/>
&ensp;파일이 아니라 이름 기반이다.<br/>
```c
shm_open("data1", O_RDWR, 0600);
```

&ensp;어디에서 실행해도 항상 같은 객체에 접근 가능, 환경 의존성이 줄어든다.<br/>

&ensp;3. mmap + MAP_SHARED와 완벽하게 호환됨<br/>
&ensp;shared memory는 실제로는 메모리 기반 파일(tmpfs)이기 때문에 mmap + msync 조합이 정상적으로 동작한다.<br/>

* addr2[0] = cnt
* msync(addr2, ...)

&ensp;4. 더 빠르고 더 안정적<br/>
&ensp;파일 mmap → 디스크 기반<br/>
&ensp;shared mmap → 메모리 기반<br/>
&ensp;속도 차이는 매우 크다.<br/>

&ensp;5. 복구 가능한 프로그래밍 요구사항과 정확히 일치<br/>
&ensp;shared memory도 tmpfs 기반이므로 msync()를 통해 즉시 상태를 flush할 수 있고 프로그램이 죽어도 진행 상태가 유지된다.<br/>

&ensp;Shared Memory로 변경한 결정적인 이유<br/>
1. 복구 가능한 프로그래밍에 가장 자연스러운 형태
* shared memory + msync → 비정상 종료 후 상태 보존 → 다음 실행에서 즉시 복구
2. r_scanf/r_printf 내에서 "최소 기능만 구현"이라는 교수님 스타일과 일치
* shared memory는 한번 mmap하면 open, close, ftruncate, 경로 관리 같은 잡일이 필요 없음
3. 성능 + 구조 단순화
* 파일 mmap보다 shared memory가 구조적으로 훨씬 깔끔하고 안정적이었음.

&ensp;1. r_scanf() 기초 설계도<br/>
&ensp;r_scnaf()는 Shared Memroy(data1)에 존재하는 입력 버퍼와 현재 읽은 위치(index)를 관리하는 함수이다. 프로그램이 중간에 종료되더라도 다음 실행 시 이어서 입력을 읽을 수 있게 한다.<br/>

&ensp;r_scanf() 흐름 요약<br/>
1. 현재 입력 인덱스(cnt)를 증가시킨다.
2. **정상 모드(mode == 0)**라면 단순히 scanf()로 입력을 읽는다.
3. **복구 모드(mode == 1)**라면 Shared Memory의 로그를 참조하여 이미 읽은 입력은 건너뛰고 아직 읽지 않은 입력만 처리한다.
4. 읽은 데이터를 union 형태로 Shared Memory에 저장한다.
5. 변경된 index와 데이터는 msync()로 즉시 동기화한다.

&ensp;Flow Chart<br/>
```cpp
r_scanf 호출
      ↓
cnt = cnt + 1
      ↓
mode == 1 ?
 ┌───────────────┐        ┌────────────────────┐
 │ Yes(복구 모드) │        │ No(정상 모드)       │
 └───────┬───────┘        └──────────┬─────────┘
         ↓                           ↓
cnt <= nscan?                      scanf(format, arg)
Yes → return                         데이터 저장
No  → 입력 처리로 이동
         ↓
format에 따라
char/int/float 구분하여 저장
         ↓
Shared Memory에 기록(addr1[cnt] = data)
         ↓
addr1[0] = cnt 기록
msync(addr1)
         ↓
return
```

&ensp;2. r_printf() 기초 설계도<br/>
&ensp;`r_printf()` 는 출력 진행 위치(nprint)를 관리하여 프로그램이 죽어도 다음 실행에서 어디까지 출력했는지 이어서 출력할 수 있도록 만든 기능이다.<br/>
&ensp;r_printf() 흐름 요약<br/>
1. 현재 출력 시도 번호(cnt)를 addr2[0]에 먼저 기록한다. → 복구 중 다시 죽어도 "출력 진행 상태"가 남는다.
2. msync()로 Shared Memory에 즉시 반영한다.
3. 정상 모드면 무조건 출력한다.
4. **복구 모드(mode == 1)**라면 `cnt > nprint` 일 때만 출력하여 이미 출력된 줄은 건너뛴다.
5. 출력할 경우 vprintf()로 실제 출력한다.

&ensp;printf 사용 방식<br/>
```c
void r_printf(const char *format, ...) {
    va_list ap;
    va_start(ap, format);  // format 뒤부터 인자 읽기 시작

    if (출력 조건 만족)
        vprintf(format, ap);

    va_end(ap);            // 정리
}
```

* va_start(ap, format) → "format 뒤에 따라오는 모든 인자를 ap에 저장해라"
* vprintf(format, ap) → printf(format, …) 과 동일하지만 → printf가 직접 가변 인자를 받는 게 아니라, ap 리스트를 읽어 출력함
* va_end(ap) → 마무리(clean-up)

&ensp;Flow Chart (사진 기반 재구성)<br/>
```cpp
                    ┌───────────────────────────────┐
                    │ r_printf(const char *fmt, ...) │
                    └───────────────┬───────────────┘
                                    │
                                    ▼
           ┌──────────────────────────────────────────┐
           │ addr2[0] = cnt                           │
           │ 현재 출력 시도 번호를 Shared Memory에 기록 │
           └────────────────────┬──────────────────────┘
                                │
                                ▼
           ┌──────────────────────────────────────────┐
           │ msync(addr2)                             │
           │ 출력 위치 정보 즉시 동기화               │
           └────────────────────┬──────────────────────┘
                                │
                                ▼
     ┌────────────────────────────────────────────────────────────┐
     │    출력 여부 결정                                          │
     │ mode == 0 → 정상 모드: 항상 출력                           │
     │ mode == 1 → 복구 모드: cnt > nprint 일 때만 출력 수행      │
     └────────────────────┬────────────────────────────────────────┘
                          │
                 ┌────────┴────────┐
                 │                 │
                 ▼                 ▼
    ┌──────────────────┐    ┌────────────────────────────┐
    │ 출력 조건 충족   │    │ 출력 안 함(이미 출력됨)     │
    └──────────┬───────┘    └──────────────┬─────────────┘
               │                           │
               ▼                           ▼
 ┌─────────────────────────────────────┐    ┌───────────────────────────┐
 │ va_start → vprintf(fmt, ap) → va_end│    │       return              │
 │ 포맷 기반 실제 출력 수행            │    └───────────────────────────┘
 └───────────────────┬─────────────────┘
                     │
                     ▼
           ┌─────────────────────────────┐
           │            return           │
           └─────────────────────────────┘
```

&ensp;3. Logging을 위해 사용할 tool 을 쓰고 선택한 tool의 효율성에 대해 간단히 설명 하시오<br/>
&ensp;Logging을 Shared Memory로 선택한 이유<br/>
&ensp;처음에 일반 파일 mmap 방식을 고려했으나 구현 중 다음과 같은 단점들이 발견되었다.<br/>

&ensp;파일 mmap의 문제점<br/>
1. 매번 open → mmap → msync → close: 오버헤드가 크고 코드가 복잡해짐
2. 파일 경로 의존성: 실행 위치에 따라 파일 경로가 달라져 안정성이 떨어짐
3. 디스크 기반 I/O: 입출력 상태를 매번 디스크에 기록해야 하므로 성능 저하

&ensp;Shared Memory가 더 적합했던 이유<br/>
&ensp;1) Shared Memory는 메모리 기반 영역 (tmpfs)<br/>
&ensp;디스크가 아닌 RAM 위에 생성되므로 입출력이 훨씬 빠르고 오버헤드가 적다.<br/>
&ensp;2) IPC + Logging에 모두 적합<br/>
&ensp;Shared Memory는 원래 프로세스 간 즉시 공유를 위한 IPC 기술이다. 여기에 진행 상태 (out_cnt, nprint)를 저장하면 r_scanf(), r_printf()가 호출될 때마다 즉각적으로 상태 반영이 가능하다.<br/>
&ensp;3) 디스크 I/O 부담 없음<br/>
&ensp;파일 mmap 방식은 파일 시스템을 거치므로 dirty page를 디스크에 기록해야 하는 부담이 있다. Shared Memory는 메모리 기반이라 이런 오버헤드가 없다.<br/>
&ensp;4) 복구 가능한 프로그래밍의 핵심 요구사항 만족<br/>
&ensp;r_scanf/r_printf는 프로그램이 죽어도 진행 상태가 남아 있어야 한다. Shared Memory + msync 조합은 이 요구사항을 가장 자연스럽게 충족한다.<br/>

3차 설계과제
====

&ensp;1. 자동 복구 기능이 가능하도록 하는 기능은 r_init, r_scanf, r_printf, r_cleanup 중 어느 함수에 포함되어야 하며, 해당 함수의 설계도를 그리시오<br/>

&ensp;자동 복구 기능은 프로그램의 비정상 종료(Crash, SIGINT, Segfault 등) 를 감지하고
다시 자식 프로세스를 생성해 실행을 이어가는 기능이다.<br/>
&ensp;이 기능은 r_scanf(), r_printf(), r_cleanup() 에서는 수행할 수 없으며
반드시 r_init() 내부에서 수행되어야 한다.<br/>

&ensp;이유 1 — r_init()은 프로그램 시작 시 딱 한 번만 호출됨<br/>
* r_scanf/r_printf는 반복문 안에서 여러 번 호출되므로 그 안에서 fork()를 만들면 프로그램이 꼬인다.

&ensp;이유 2 — 자동복구에는 Parent–Child Supervisor 구조가 필요<br/>
* parent는 "죽지 않는 감시자" 역할
* child는 실제 main 로직을 수행
* child는 실제 main 로직을 수행 → 이 구조는 r_init() 에서만 만들 수 있다.

&ensp;이유 3 — mode, nscanf, nprint 를 설정하는 시점은 프로그램 시작부여야 한다 → r_init 안에서만 가능.<br/>

&ensp;2. r_init() 내부의 설계도 (우리 조 코드 기준)<br/>
&ensp;r_init() — Parent-Child Supervisor 구조<br/>
```scss
┌──────────────────────────────────────────────┐
│                  r_init() 시작               │
└──────────────────────────────────────────────┘
                     │
                     ▼
        ┌──────────────────────────┐
        │ 공유 메모리 shm_open     │
        │ LOG1, LOG2 mmap 연결     │
        └──────────────────────────┘
                     │
                     ▼
        ┌──────────────────────────┐
        │ Parent: SIGINT 무시      │
        │   (Ctrl+C에 안 죽도록)   │
        └──────────────────────────┘
                     │
                     ▼
        ┌──────────────────────────┐
        │ while (1) Supervisor Loop│
        └──────────────────────────┘
               │
               ▼
        ┌──────────────────────────┐
        │ nprint, nscanf 상태로드  │
        └──────────────────────────┘
               │
               ▼
        ┌──────────────────────────┐
        │ cnt = 0 초기화           │
        └──────────────────────────┘
               │
               ▼
        ┌──────────────────────────┐
        │     fork() 호출          │
        └──────────────────────────┘
        │                 │
  Child ▼                 ▼ Parent
─────────────       ────────────────────────────────
│ SIGINT = SIG_DFL │   │ wait(child 종료 대기)      │
│ (Ctrl+C 시 죽음) │   └───────────────────────────────
│ if mode==1        │                │
│   복구지점 입력    │                ▼
│ return → main()   │    ┌──────────────────────────┐
─────────────        │    │ 정상 종료?              │
                     │    └──────────────────────────┘
                     │       │ YES        │ NO
                     │       ▼            ▼
                     │ ┌────────────────┐ ┌──────────────────────────┐
                     │ │ r_cleanup()    │ │  mode = 1 설정           │
                     │ │ 프로그램 종료  │ │ (복구 모드 진입)         │
                     │ └────────────────┘ └──────────────────────────┘
                     │                │
                     └────────────────┘
                           (while 반복 → 새 child 생성)
```

&ensp;3. r_scanf() 자동 복구 설계도<br/>
* mode == 1 (복구 모드) → addr1[] 에 저장된 값을 재생, cnt와 nscanf 비교하여 복구 종료 여부 판단
* mode == 0 (정상 모드) → scanf로 입력 받고 addr1에 기록, nscanf 업데이트 후 msync

```scss
r_scanf
│
├─ cnt++ 증가
│
├─ mode == 1?  (복구 모드)
│     │
│     ├─ YES → addr1[cnt-1]에서 값 복구
│     │          if(cnt >= nscanf) mode=0
│     │
│     └─ return
│
└─ NO → 정상입력
       │
       ├─ scanf()
       ├─ addr1[cnt-1]에 저장
       ├─ addr2[1] (nscanf) 업데이트
       └─ msync(addr1, addr2)
```

&ensp;4. r_printf() 자동 복구 설계도<br/>
* 출력 카운터(nprint) 저장
* 복구 모드일 때 nprint 이전 출력은 skip
* 정상 모드면 그대로 출력

```scss
r_printf
│
├─ addr2[0] = cnt  (nprint 업데이트)
│  msync()
│
├─ if(mode == 1 && cnt <= nprint)
│          (이미 출력됨 → skip)
│          return
│
└─ vprintf() 호출 (실제 출력 수행)
```

&ensp;자동 복구 기능은 r_init()에서 수행되어야 한다.<br/>
&ensp;자동 복구는 부모 프로세스가 감시자 역할을 하고, 자식 프로세스가 실제 연산을 수행하는 Parent–Child Supervisor 모델을 기반으로 한다.<br/>
&ensp;r_init()은 프로그램 시작 시에 단 한 번만 호출되므로 fork(), wait(), SIGINT/SIGCHLD 처리, mode 설정, child 재생성과 같은 복구 기능을 수행하기에 가장 적합하다.<br/>
&ensp;r_scanf(), r_printf(), r_cleanup()은 반복적으로 호출되거나 정리만 수행하므로
자동복구 기능을 포함할 수 없다.<br/>
&ensp;따라서 자동 복구 기능은 반드시 r_init()에 포함되어야 한다.<br/>

&ensp;복구 지점 입력은 child(main)에서 해야 한다.<br/>
&ensp;parent는 test 프로그램의 내부 로직을 모른다. 반면 child는 main()의 흐름, 입력 순서, cnt 값 의미를 정확히 알고 있으므로 복구 기준이 되는 입력 번호 입력은 child에서 수행하는 것이 올바른 구조이다.<br/>
&ensp;이를 위해 child는 r_init에서 return 직후 main에서 mode==1인지 확인하여 복구 지점을 입력받고 addr2[1]에 반영한다.<br/>


제출 코드
-----

&ensp;**myio3.h**<br/>
```c
#ifndef MYIO3_H
#define MYIO3_H

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <stdarg.h>
#include <sys/errno.h>

// --- 상수 및 타입 정의 ---
#define SHM_LOG1 "/recover_log1"
#define SHM_LOG2 "/recover_log2"

typedef union {
    int i;
    float f;
    char c;
} DataUnion;

#define LOG_MAX_ENTRIES 256
#define LOG1_SIZE (sizeof(DataUnion) * LOG_MAX_ENTRIES)
#define LOG2_SIZE (sizeof(int) * 2)

static int mode = 0; // 0=정상, 1=복구
static int nprint = 0, nscanf = 0, cnt = 0;
static int fd1, fd2;
static DataUnion *addr1; // LOG1 (데이터)
static int *addr2;       // LOG2 (카운터)

//.............함수 정의 ........

static inline void r_cleanup() {
    munmap(addr1, LOG1_SIZE);
    munmap(addr2, LOG2_SIZE);

    // 정상 종료 시, 공유 메모리 객체를 삭제
    // (nscanf가 0보다 크다면 비정상 종료 기록이므로 삭제하지 않을 수도 있지만,
    // 주어진 코드를 따르기 위해 munmap 후 무조건 unlink 수행)
    shm_unlink(SHM_LOG1);
    shm_unlink(SHM_LOG2);
}


static inline void r_init() {
    // 1. 공유 메모리 초기화
    fd1 = shm_open(SHM_LOG1, O_RDWR | O_CREAT, 0600);
    fd2 = shm_open(SHM_LOG2, O_RDWR | O_CREAT, 0600);

    if (fd1 < 0 || fd2 < 0) {
        perror("shm_open failed");
        exit(1);
    }

    ftruncate(fd1, LOG1_SIZE);
    ftruncate(fd2, LOG2_SIZE);

    addr1 = mmap(NULL, LOG1_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0);
    addr2 = mmap(NULL, LOG2_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd2, 0);

    close(fd1);
    close(fd2);

    // 2. 부모 프로세스 시그널 설정 (SIGINT 무시)
    struct sigaction sa = {0};
    sa.sa_handler = SIG_IGN;
    sigaction(SIGINT, &sa, NULL);

    // 3. 자동 복구 루프 (Watchdog Loop)
    while (1) {
        // 4. 상태 로드 (매 루프마다 최신 상태 확인)
        nprint = addr2[0];
        nscanf = addr2[1];

        // 카운터 초기화 (자식은 항상 처음부터 시작)
        cnt = 0;

        // [Detail] fork 전 버퍼 비우기
        fflush(stdout);

        // 5. 자식 프로세스 생성
        pid_t pid = fork();

        if (pid == 0) {
            // ========== [Child Process] ==========
            // 6. 시그널 복원 (SIG_DFL)
            struct sigaction sa_child = {0};
            sa_child.sa_handler = SIG_DFL;
            sigaction(SIGINT, &sa_child, NULL);

            // 7. 복구 모드 진입 및 사용자 입력 (요청하신 대로 자식 내부로 이동)
            if (mode == 1 && nscanf > 0) {
                printf("입력번호는 %d; 원하는 입력번호는?\n", nscanf);

                int target_nscanf;
                // 여기서 Ctrl+C 누르면 자식이 죽고, 부모가 다시 살려서 여기로 돌아옴
                scanf("%d", &target_nscanf);

                if (target_nscanf > nscanf) target_nscanf = nscanf;

                nscanf = target_nscanf;
                addr2[1] = nscanf; // 공유 메모리에 반영
                msync(addr2, LOG2_SIZE, MS_SYNC);

                // if (nscanf == 0) mode = 0;

                printf("최종 복구 번호는 %d 입니다.\n", nscanf);
            } else {
                // 로그가 있어도 부모가 mode=1을 안 줬다면
                // 혹은 nscanf가 0이라면 정상 모드로 확정
                mode = 0;
            }

            // 8. r_init 탈출 -> main 함수 실행
            return;
        }
        else {
            // ========== [Parent Process] ==========
            int status;

            wait(&status);

            // 자식이 정상 종료했는지 확인
            if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
                // 정상 종료: 자원 정리 후 부모도 종료
                r_cleanup();
                exit(0);
            } else {
                // 비정상 종료 (Crash/Signal): 복구 모드 설정 후 재시작
                mode = 1; // 다음 루프에서 자식이 mode==1을 보게 됨 (메모리 상속X, 로직으로 전달해야 함)
            }
        }
    }
}


static inline void r_scanf(const char *format, void *arg) {
    cnt++;
    DataUnion data;

    // if (nscanf == 0) mode = 0;
    if (mode == 1 && cnt >= nscanf) {
        mode = 0;
        printf("... recovery completed ...\n");
    }

    if (mode == 1) { // 복구 모드

        if (strstr(format, "c")) {
            *(char *)arg = addr1[cnt-1].c;
        } else if (strstr(format, "f")) {
            *(float *)arg = addr1[cnt-1].f;
        } else {
            *(int *)arg = addr1[cnt-1].i;
        }

        return;

    }
     // 정상 모드
    scanf(format, arg);

    // 로그 데이터 저장
    if (strstr(format, "c")) {
        data.c = *(char *)arg;
    } else if (strstr(format, "f")) {
        data.f = *(float *)arg;
    } else {
        data.i = *(int *)arg;
    }
    addr1[cnt-1] = data;

    // nscanf 카운터 업데이트 및 동기화
    addr2[1] = cnt;
    msync(addr1, LOG1_SIZE, MS_SYNC);
    msync(addr2, LOG2_SIZE, MS_SYNC);
}

static inline void r_printf(const char *format, ...) {
    // nprint 카운터 업데이트 및 동기화
    addr2[0] = cnt;
    msync(addr2, LOG2_SIZE, MS_SYNC);

    // 정상 모드이거나, 복구 모드라도 nprint 이후의 출력일 때만 실제 출력
    if (mode == 0 || (mode == 1 && cnt > nprint)) {
        va_list args;
        va_start(args, format);

        vprintf(format, args);

        va_end(args);
    }
}

#endif //MYIO3_H
```

&ensp;**test.c**<br/>
```c
#include <stdio.h>
#include "myio3.h" // 복구 함수를 포함하는 헤더 파일 (추정)

int main(void){
    char ch;
    int N, i, num, sum = 0, cnt = 0;
    float f[20], max = 0;

    // 복구 기능 초기화 (추정: r_init)
    r_init();

    // 1. 정수 입력 및 합계 계산
    r_scanf("%d", &N);
    for (i = 0; i < N; ++i) {
        r_scanf("%d", &num);
        sum += num;
        r_printf("sum=%d\n", sum); // 복구 가능한 출력 함수 (추정)
    }

    // 2. 실수 입력 및 최대값 계산
    r_scanf("%d", &N);
    for (i = 0; i < N; i++) {
        r_scanf("%f", &f[i]);
    }
    for (i = 0; i < N; i++) {
        if (f[i] > max) {
            max = f[i];
        }
        r_printf("max=%.2f\n", max);
    }

    // 3. 문자 입력 및 개수 계산 (소문자 카운트)
    r_scanf("%d", &N);
    for (i = 0; i < N; ++i) {
        r_scanf(" %c", &ch); // 문자를 읽을 때 공백을 건너뛰도록 " %c" 사용
        if (ch >= 'a' && ch <= 'z') {
            cnt++;
        }
        r_printf("cnt=%d\n", cnt);
    }

    // 복구 기능 정리 (추정: r_cleanup)
    r_cleanup();

    return 0;
}
```

&ensp;코드 전체 개념 흐름<br/>
1. r_init()
* shared memory를 열고
* parent–child supervisor를 만들고
* child에서 main() 실행하도록 돌려보냄
* parent는 child가 죽으면 다시 생성해줌 (자동복구)
2. r_scanf()
* 정상 모드 → 입력을 받고 LOG1/LOG2에 기록
* 복구 모드 → LOG에서 저장된 값을 꺼내 재생
3. r_printf()
* 정상 모드 → 실제 출력
* 복구 모드 → 이미 출력된 지점은 skip, 그 이후부터 출력
4. r_cleanup()
* 공유 메모리 해제, shm_unlink

&ensp;1. r_init() 코드 설명 (자동 복구 엔진)<br/>
&ensp;(1) shared memory 생성<br/>
```c
fd1 = shm_open(SHM_LOG1, O_RDWR | O_CREAT, 0600);   // 공유 메모리 객체 생성
fd2 = shm_open(SHM_LOG2, O_RDWR | O_CREAT, 0600);
ftruncate(fd1, LOG1_SIZE);    // 공유 메모리 크기 설정
ftruncate(fd2, LOG2_SIZE);
addr1 = mmap(...);   // 그냥 배열 접근하듯이 shared memory에 접근
addr2 = mmap(...);
```

* LOG1 = 입력값(DataUnion)의 기록
* LOG2 = nprint, nscanf의 기록
* 프로그램이 죽어도 LOG는 살아남음(공유 메모리니까)

&ensp;입력/출력 기록이 파일처럼 보존됨 → 복구 가능<br/>


&ensp;1) Shared Memory: shm_open()<br/>
```c
fd1 = shm_open(SHM_LOG1, O_RDWR | O_CREAT, 0600);
```

&ensp;이건 POSIX shared memory 객체를 만드는 시스템 콜<br/>
* shm_open() → 이름 있는 shared memory 파일 디스크립터 생성
* /dev/shm/ 아래에 파일처럼 존재
* 여러 프로세스 간 공유 가능
* fork로 만든 parent–child 간 공유됨

&ensp;2) Memory Mapping: mmap()<br/>
```c
addr1 = mmap(NULL, LOG1_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0);
```

&ensp;fd1을 프로세스의 주소 공간에 매핑하는 memory mapping<br/>
&ensp;shared memory를 "내 프로세스의 메모리"처럼 바로 접근할 수 있게 만든 것<br/>

&ensp;(2) parent는 SIGINT 무시<br/>
```c
struct sigaction sa = {0};
sa.sa_handler = SIG_IGN;
sigaction(SIGINT, &sa, NULL);
```

&ensp;의미<br/>
* Ctrl+C를 눌러도 parent는 죽지 않는다.
* child만 죽구 parent는 계속 살아서 복구 루프 유지 가능

&ensp;(3) Supervisor Loop 시작<br/>
```c
while (1) {
    nprint = addr2[0];
    nscanf = addr2[1];
    cnt = 0;
```

&ensp;의미<br/>
* parent는 무한 루프를 돌면서
* 항상 child를 새로 실행하고
* child가 죽으면 다시 fork하여 재시작하는 구조

&ensp;(4) fork 실행<br/>
&ensp;child 쪽<br/>
```c
if (pid == 0) {
    struct sigaction sa_child = {0};
    sa_child.sa_handler = SIG_DFL;
    sigaction(SIGINT, &sa_child, NULL);
```

* child는 SIGINT 기본값으로 설정
* Ctrl+C를 받으면 child가 즉시 종료됨
* 이게 자동 복구 트리거

&ensp;(5) child가 복구 모드인지 판단<br/>
```c
if (mode == 1 && nscanf > 0) {
    printf("입력번호는 %d; 원하는 입력번호는?\n", nscanf);
    scanf("%d", &target_nscanf);
    addr2[1] = target_nscanf;
}
```

&ensp;의미<br/>
* child는 r_init에서 return 직후 main으로 가기 전에 mode == 1 즉 복구 모드인지 확인한다.
* 사용자가 원하는 복구 지점을 입력하도록 한다.
* 원래 nscanf 대신 새로운 복구 지점을 addr2[1]에 기록

&ensp;child가 복구 지점을 선택하는 구조 완성<br/>

&ensp;(6) parent 쪽<br/>
```c
wait(&status);
if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
    r_cleanup();
    exit(0);
} else {
    mode = 1;
}
```

* child가 정상종료하면 parent도 종료
* child가 Ctrl+C / crash로 죽으면 mode = 1로 설정하고 다시 루프 처음의 fork로 돌아가 이를 통해 자동 복구 기능 완성

&ensp;2. r_scanf() 코드 설명<br/>
&ensp;정상모드<br/>
```c
scanf(format, arg);
addr1[cnt-1] = data;
addr2[1] = cnt;
msync(...);
```

* 사용자 입력을 받는다
* addr(cnt-1)에 저장 → LOG1에 기록
* nscanf(cnt)를 addr2[1]에 저장
* msync로 즉시 동기화 → 프로그램이 크래시해도 데이터는 살아있음

&ensp;복구 모드<br/>
```c
*(int*)arg = addr1[cnt-1].i;
```

* LOG에 저장된 값을 재생
* cnt == nscanf이면 복구 완료, mode=0

&ensp;3. r_printf() 코드 설명<br/>
&ensp;정상 모드<br/>
&ensp;그대로 printf 실행<br/>
&ensp;복구 모드<br/>
```c
if (mode == 1 && cnt <= nprint)
    return;
```

* 이미 출력되었던 부분은 다시 출력하지 않는다.
* 출력 재현은 이미 찍혔던 부분은 skip 방식으로 구현됨
* cnt > nprint가 되면 출력 시작(복구 중 새로 필요해진 출력만)

&ensp;4. r_cleanup()<br/>
```c
munmap(...)
shm_unlink(...)
```

* 프로그램 정상 종료 시 공유 메모리 삭제
* 비정상 종료 시는 삭제되지 않아서 복구 가능

&ensp;전체 코드 흐름을 그림으로 표현하면<br/>
```perl
Parent
│
│ SIGINT 무시 + shared memory 준비
│
└─ while(1)
       │
       ├─ fork()
       │
 Child ▼                 Parent ▼
─────────────       ───────────────────────
│ SIGINT = 기본값 │   │  wait()           │
│ (Ctrl+C 누르면 죽음)│ └──────────────────────
│                     │
│ 복구 모드면         │  정상 종료?  → 프로그램 종료
│   복구 지점 입력    │  비정상 종료 → mode=1
│                     │
└ return → main()    ←───────────────┘
```

전체 동작 흐름(메커니즘)을 단계별로 완벽하게 설명
----

&ensp;1) r_init(): Supervisor + Shared Memory 초기화<br/>
&ensp;r_init은 프로그램 시작 시 단 한 번만 실행되며 다음 역할을 수행한다.<br/>
&ensp;(1) Shared Memory 생성<br/>
```c
fd1 = shm_open(...);
fd2 = shm_open(...);
ftruncate(fd1, LOG1_SIZE);
ftruncate(fd2, LOG2_SIZE);
addr1 = mmap(...);
addr2 = mmap(...);
```

* shm_open → 이름 있는 shared memory 객체 생성
* ftruncate → 공유 메모리 크기 설정
* mmap → 실제 메모리 주소로 매핑
* addr1: 입력값 저장용 배열
* addr2[0] = nprint, addr2[1] = nscanf

&ensp;;이 단계에서 입력 로그 / 출력 카운터가 메모리 기반으로 준비된다.<br/>


&ensp;(2) 부모 프로세스의 SIGINT 무시<br/>
```c
sa.sa_handler = SIG_IGN;
sigaction(SIGINT, &sa, NULL);
```

* 부모는 Ctrl+C에 절대 죽지 않는다.
* supervisor는 절대 죽으면 안 되기 때문이다.

&ensp;(3) supervisor loop 시작<br/>
```c
while(1) {
    ...
    pid = fork();
    ...
}
```

&ensp;부모는 다음 행동을 반복한다.<br/>
1. child 생성
2. child가 끝날 때까지 wait
3. child의 종료 상태를 보고
* 정상 종료면 → cleanup → supervisor도 exit
* 비정상 종료면 → 자동 복구 모드 → 새 child 


&ensp;부모-자식 역할 설명<br/>4
&ensp;Parent<br/>
* 절대 죽지 않음(SIGINT 무시)
* child 죽으면 다시 생성함
* 복구 모드를 결정하는 책임

```c
struct sigaction sa = {0};
sa.sa_handler = SIG_IGN;
sigaction(SIGINT, &sa, NULL);
```

&ensp;fork()를 하면 시그널 설정은 child에게 복사됨<br/>
* 메모리 내용, 파일 디스크립터, 시그널 설정 등 모든 프로세스 컨텍스트가 복사된다.
* 따라서 부모가 SIGINT를 무시하고 있는 상태라면 child도 생성 시점에서 SIGINT 무시 상태로 시작한다.

&ensp;fork 이후 child도 무시한다. 그래서 곧 바로 원래대로 되돌림<br/>

&ensp;Child<br/>
* 테스트 프로그램(main)이 실행되는 곳
* SIGINT(Default) → Ctrl+C 누르면 죽음
* 복구 모드 시 사용자에게 몇 번째 입력부터 복구? 물어봄
* r_scanf/r_printf를 사용해 실제 작업 수행

```c
struct sigaction sa_child = {0};
sa_child.sa_handler = SIG_DFL;
sigaction(SIGINT, &sa_child, NULL);
```

* 이걸 child는 SIGINT를 무시하지 않음
* 기본 동작(SIG_DFL)은 프로세스 종료(kill)
* 따라서 Ctrl+C 입력 → child 프로세스 즉시 종료

| 항목             | 부모                     | 자식                 |
| -------------- | ---------------------- | ------------------ |
| SIGINT handler | SIG_IGN (무시)           | SIG_DFL (기본=죽음)    |
| Ctrl+C 누르면?    | 안 죽음                   | 죽음                 |
| 복구는 어디서 시작?    | parent가 감지 후 child 재생성 | 새 child에서 복구 모드 실행 |

&ensp;복구 시작은?<br/>
&ensp;child가 Ctrl+C로 죽음 → exit code가 signal 원인 → parent의 wait()에서 감지됨:<br/>
```c
wait(&status);

if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
    정상 종료
else
    비정상 종료 → mode=1 → 다음 루프에서 복구 진행
```

&ensp;1. WIFEXITED(status)<br/>
&ensp;정상 종료된 경우인지만 확인하는 매크로이다.<br/>
&ensp;exit(), return from main(), 또는 _exit() 이런 프로세스가 스스로 종료된 상황을 뜻함<br/>

&ensp;반대로 SIGINT, SIGSEGV 같은 시그널로 죽으면 정상 종료가 아님()<br/>
&ensp;그런데 정상 종료했다고 해서 무조건 성공적으로 끝낸 것은 아님<br/>
&ensp;예를 들어: `exit(7);`<br/>
&ensp;이렇게 종료해도 정상종료이지만, exit code는 7이야.<br/>
&ensp;그래서 다음 단계가 필요함<br/>

&ensp;2. WEXITSTATUS(status)<br/>
&ensp;이건 exit() 또는 return 값을 알려주는 매크로.<br/>
```c
return 0;  // exit code 0
exit(0);   // exit code 0
exit(5);   // exit code 5
```

* 0이면 성공(successful termination)
* 0이 아니면 실패(failure or abnormal logic)


&ensp;2) r_scanf(): 입력 자동 기록 + 복구 재생 기능<br/>
&ensp;정상모드<br/>
```scanf()로 입력 받기
→ addr1[cnt-1]에 저장
→ addr2[1] = cnt 업데이트
→ msync로 디스크에 반영
```

&ensp;입력하면 무조건 shared memory에 저장된다. 이 덕분에 프로그램이 죽어도 다시 읽을 수 있다.<br/>

&ensp;복구 모드<br/>
```
addr1[cnt-1]에서 읽기
cnt >= nscanf → 복구 완료 → 정상 모드로 전환
```

&ensp;복구 모드일 때는 scanf()를 하지 않고 과거 입력을 그대로 재생한다.<br/>

&ensp;3) r_printf(): 출력 재생 여부 판단 + 출력 동기화<br/>
&ensp;이 동작이 핵심이다<br/>
```
addr2[0] = cnt;
```

* nprint = 마지막으로 성공한 출력 번호
* 복구 모드에서는 cnt > nprint 일 때에만 출력함

&ensp;복구 과정에서 이미 화면에 나왔던 출력은 다시 찍지 않고 아직 안 찍힌 출력만 이어서 출력한다.<br/>

&ensp;4) r_cleanup(): 정상 종료 시 shared memory 삭제<br/>
&ensp;프로그램이 오류 없이 끝나면:<br/>
```c
munmap()
shm_unlink()
```

&ensp;sharded memory 삭제 → 완전 정리 상태<br/>
&ensp;복구 모드라면 unlink하지 않음(비정상 종료 흔적을 남김)<br/>

&ensp;이해해야 할 핵심 5가지<br/>
1. shared memory = 여러 프로세스가 동시에 읽고 쓰는 메모리
2. mmap으로 매핑했으니 포인터로 배열처럼 다룸
3. parent는 supervisor, child는 test 프로그램 실행
4. Ctrl+C는 child만 죽임 (parent는 무시)
5. child가 죽어도 shared memory에 input/output 로그가 남아 복구 가능

4차 설계과제
====

&ensp;3단계 복구 프로그램<br/>

> 실행 중간 지점부터 즉시 재시작할 수 있는 진짜 효율적인 복구 시스템을 만드는 것

&ensp;프로그램이 어디서 죽어도 → 다시 실행하면 그 지점 근처부터 바로 이어서 실행 가능해야 한다.<br/>

<details>
<summary>1. 기존 방식(1·2단계)의 한계: 복구 비용이 O(N)</summary>

&ensp;문제점<br/>
* 프로그램이 재시작할 때 → 처음 입력부터 마지막 입력까지 모든 로그를 다시 재생해야 함
* 입력이 450개라면 → 1~450까지 전부 읽고 따라가야 한다. (O(N))

&ensp;왜 문제인가?<br/>
* 입력이 수천, 수만, 수십억 개라면?
* 한 번 프로그램 죽을 때마다 처음부터 로그를 다시 읽어야 한다면?
* 복구 시간이 너무 길어서 실제 서비스 환경에서는 불가능.

&ensp;그래서 3단계의 핵심 미션은 다음과 같다.<br/>

> 복구 비용을 O(N) → O(1)로 만들자! (즉각 재시작)

</details>

&ensp;2. 해결 전략: Checkpoint + Incremental Replay<br/>
&ensp;핵심 아이디어 1: Checkpointing<br/>
&ensp;"실행 중간마다 프로그램 전체 상태를 저장해두자"<br/>
&ensp;0번부터 매번 입력을 따라가는 대신 예를 들어 다음과 같이 상태를 미리 저장하는 것이다.<br/>
* 100번 지점 → snapshot 저장
* 200번 지점 → snapshot 저장
* 300번 지점 → snapshot 저장
* …

&ensp;만약 사용자가 "450번까지 복구해줘!"라고 하면?<br/>
&ensp;기존 방식 → 0부터 450까지 모든 로그를 읽어야 함<br/>
&ensp;3단계 방식 → 가장 최근 스냅샷(예: 400번 지점)에서 시작, 나머지 50개 입력만 다시 실행하면 됨<br/>

&ensp;3. Segment-Based Snapshot: 어떤 상태를 저장할 것인가?<br/>

&ensp;1·2단계에서는 "입력 로그만 저장"했기 때문에 프로그램 전체 상태를 재현하려면 결국 처음부터 재생할 수밖에 없었다.<br/>

&ensp;그래서 3단계에서는 프로그램의 모든 실행 상태(Context)를 저장한다.<br/>

&ensp;저장해야 할 정보<br/>
&ensp;(1) Data Segment<br/>
* 전역 변수 (예: mode, nscanf 같은 것들)

&ensp;(2) Stack Segment<br/>
* main 함수 안의 지역 변수 (sum, cnt, buffer 등)

&ensp;(3) Heap Segment<br/>
* malloc으로 만든 동적 메모리들

&ensp;OS 수준에서 프로그램 메모리 구조(Data / Stack / Heap)을 그대로 저장하는 방식이다.<br/>

&ensp;장점<br/>
* 어떤 프로그램이라도(문자열, 수학계산, 파일처리…) → 스냅샷만 복원하면 실행을 이어갈 수 있다.
* "프로그램 별로 저장해야 할 정보가 다르다"는 문제 해결.

&ensp;4. Snapshot 기반 복구 절차<br/>
&ensp;1) 로그의 마지막 지점 파악<br/>
* 현재 저장된 로그 중 마지막 step 확인

&ensp;2) 복구 목표보다 가장 가까운 Snapshot 찾기<br/>
&ensp;예: 사용자가 복구 목표를 450으로 지정 → 스냅샷이 400에서 저장되어 있다면 그걸 선택<br/>

&ensp;3) Snapshot 메모리 복원<br/>
* snapshot에서 Data / Stack / Heap 내용을 프로그램 메모리에 그대로 복구
* 전체 메모리 덤프를 다시 불러오는 것과 동일

&ensp;4) Snapshot 이후의 로그만 조금 재생<br/>
&ensp;400 snapshot 이후 401~450만 재실행 → 최소 비용으로 빠르게 목표 지점 도달<br/>

&ensp;5. 로그 저장 공간을 무한히 늘릴 수 없으니, Circular Buffer 채택<br/>

&ensp;문제<br/>
* 로그가 입력될 때마다 계속 append하면 → 로그 파일 크기가 무한히 커진다

&ensp;해결책: Circular Buffer<br/>
* 스냅샷 이전의 데이터는 더 이상 필요 없음
* 그러므로 고정된 크기만 유지하면서 → 가장 오래된 로그는 덮어쓰기(overwrite)

&ensp;효과<br/>
* 로그 파일 크기: O(1)
* 복구 비용: O(1)
* 시스템 부하 없음 → 안정적이고 효율적인 복구 기능 완성

&ensp;1. Snapshot 저장 구조 정의<br/>
```c
// 프로그램 전체 상태를 저장하는 스냅샷 구조체
struct snapshot {
    int cnt;            // 현재까지 입력된 번호
    int sum;            // 예시: 지역 변수 복구용
    int mode;           // 전역 변수
    int nscanf;         // 마지막 입력 번호
    int data_segment;   // 예시: 전역 변수들의 상태
    // 힙 데이터가 있다면 포인터 크기만큼 추가
};
```

&ensp;2. Snapshot 저장 함수(save_snapshot)<br/>
```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

void save_snapshot(struct snapshot *snap) {
    int fd = open("snapshot.bin", O_WRONLY | O_CREAT | O_TRUNC, 0666);
    if (fd < 0) {
        perror("open snapshot");
        return;
    }

    write(fd, snap, sizeof(struct snapshot));
    close(fd);
}
```

&ensp;3. Snapshot 로드 함수(load_snapshot)<br/>
```c
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

int load_snapshot(struct snapshot *snap) {
    int fd = open("snapshot.bin", O_RDONLY);
    if (fd < 0) {
        // 스냅샷 없으면 정상 시작
        return 0;
    }

    read(fd, snap, sizeof(struct snapshot));
    close(fd);
    return 1;   // 스냅샷 존재
}
```

&ensp;4. 순환 버퍼 기반 로그 구조<br/>
```c
#define LOG_SIZE 1000

typedef struct {
    int value;   // 입력값 저장
} LogEntry;

LogEntry logs[LOG_SIZE];  // 순환 로그 버퍼
```

&ensp;5. r_scanf() 구현 (순환 버퍼 + Logging)<br/>
```c
int cnt = 0;  // 전역 입력 카운트

void r_scanf(int *x) {
    scanf("%d", x);

    int idx = cnt % LOG_SIZE;   // 순환 버퍼
    logs[idx].value = *x;

    cnt++;
}
```

&ensp;6. 스냅샷 이후 로그만 다시 재생(replay)<br/>
```c
void replay_logs(struct snapshot *snap) {
    printf("=== Incremental Replay 시작 ===\n");

    for (int i = snap->cnt; i < cnt; i++) {
        int idx = i % LOG_SIZE;
        int v = logs[idx].value;

        printf("[Replay] %d 번째 입력값 = %d\n", i, v);

        // 여기서 프로그램 로직을 다시 적용해야 함
        // 예: sum += v;
    }
}
```

&ensp;7. 프로그램 전체 흐름 예시(main)<br/>
```c
int main() {
    struct snapshot snap;
    int recovered = load_snapshot(&snap);

    int sum = 0;

    if (recovered) {
        printf("[스냅샷 로드 완료] 마지막 입력 번호: %d\n", snap.cnt);
        cnt = snap.cnt;
        sum = snap.sum;

        // snapshot 이후 로그만 다시 실행
        replay_logs(&snap);
    } else {
        printf("[새 실행 시작]\n");
    }

    // --------- 실행 루프 예시 ---------
    for (int i = cnt; i < cnt + 10; i++) {
        int x;
        r_scanf(&x);

        sum += x;

        // 매 5단계마다 snapshot 저장
        if (i % 5 == 0) {
            snap.cnt = cnt;
            snap.sum = sum;
            save_snapshot(&snap);
        }

        printf("현재 sum = %d\n", sum);
    }

    return 0;
}
```

