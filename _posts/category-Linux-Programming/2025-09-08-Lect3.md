---
title: "Lect3. 파일 다루기"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true
Sdate: 2025-09-08
last_modified_at: 2025-09-08
---

파일 정보의 획득
======

&ensp;컴퓨터에 이 파일이 어떤 애야 하고 물어보는 방법이다.<br/>
&ensp;-> stat()이나 fstat()라는 특별한 전화(시스템 콜)를 걸면 파일의 모든 신상 정보를 알려준다.<br/>
* 비유: 파일을 사람이라고 치면 stat()은 주민등록등분 떼기랑 같다.
* 정리
    - stat("파일이름", 정보 담을 통) -> 파일 이름으로 신분증 받기
    - fstat(열린 파일 번호, 정보 담을 통) -> 이미 연 파일의 신분증 보기
    - 결과는 buf라는 상자(구조체)에 담긴다.

```bush
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *pathname, struct stat *buf);
int fstat(int filedes, struct stat *buf);
```

&ensp;buf안에 뭐가 들어있을까?<br/>
* stat()을 쓰면 buf 상자 안에 여러 가지 항목이 꽉 채워진다.
* 중요 항목들
    - st_dev, st_ino: 이 파일의 고유번호(장치+inode 번호)
    - st_mode: 권한(누가 읽고/쓰고/실행?)
    - st_nlink: 이름표(링크) 몇 개 붙어있는지
    - st_uid, st_gid: 주인 ID, 그룹 ID
    - st_size: 파일 크기(바이트 단위)
    - st_atime, st_mtime, st_ctime: 마지막 접근/수정/상태 변경 시간
* 비유: 사람의 주민등록등본에 이름, 주소, 주민번호, 발급일이 다 적히듯, 파일의 신분증에도 모든 세부사항이 적혀 있는 것이다.

access permission
=====

&ensp;파일이 가진 잠금 장치를 설명하는 부분이다.<br/>
* 읽기 = 4
* 쓰기 = 2
* 실행 = 1

&ensp;-> 이걸 더해서 권한을 만든다.<br/>
&ensp;예) 0764: 주인(rwx = 7), 그룹(rw = 6), 다른 사람(r = 4)<br/>

&ensp;비유: 집 현관문에 비밀번호를 세 자리로 두는데<br/>
* 첫째칸은 집주인
* 둘째칸은 가족(그룹)
* 셋째칸은 손님(다른 사람)

&ensp;누가 들어올 수 있고 뭘 할 수 있는지 번호로 표시해둔 것이다.<br/>

permission 확인
----

&ensp;이 파일이 읽을 수 있는 파일이야? 이게 보통 파일이야? 같은 걸 코드로 물어보는 방법이다.<br/>
* 예시

```c
if (s.st_mode & S_IRUSR)
    printf("주인이 읽을 수 있어요!");
if (S_ISREG(s.st_mode))
    printf("이건 일반 파일이에요!");
```

* 비유: 파일 신분증을 보고 이 사람은 학생증이 있네 -> 학생 맞음! 마찬가지로 파일 속성(모드)을 보고 이게 일반 파일인지, 폴더인지, 링크인지 확인할 수 있다.

그 밖의 특별한 permission
-----

&ensp;보통 권한 말고 특수 권한이라는 것도 있다.<br/>
* 예시
    - S_ISUID: 실행할 때 주인 권한으로 실행됨
    - S_ISGID: 실행할 때 그룹 권한으로 실행됨
* 비유: 마치 게임에서 특수 열쇠를 가지고 있으면 내가 아니라 왕이나 길드장 자격으로 행동할 수 있는 것과 같다.

사용자와 소유권
====

* 소유권자(owner)
    - 파일을 처음 만든 사람이다.
    - 컴퓨터는 이 사람을 uid(user id)와 gid(group id)로 구분한다.
    - 쉽게 말하면 이 집의 집주인 같은 거다.
* 사용자(user)
    - 지금 그 파일을 실제로 쓰는 사람이다.
    - 컴퓨터는 이걸 euid(effective uid), egid로 구분한다.
    - 즉, 집에 들어와서 지금 실제로 살고 있는 사람에 해당한다.

&ensp;비유<br/>
* 집주인(owner): 집 문서에 이름이 적힌 사람 -> uid/gid
* 세입자(user): 지금 그 집에 들어와서 전등 켜고 TV 보는 사람 -> euid/egid

access 시스템 호출
====

&ensp;이 파일을 내가 지금 읽을 수 있어? 쓸 수 있어? 실행할 수 있어? -> 미리 물어보는 방법이다.<br/>
&ensp;-> 그게 바로 access()라는 시스템 호출이다.<br/>

* 사용법

```c
#include <unistd.h>
int access(const char *pathname, int amode);
```

* amode에 넣은 값:
    - R_OK: 읽기 가능?
    - W_OK: 쓰기 가능?
    - X_OK: 실행 가능?
    - F_OK: 파일 존재 여부
* 결과: 0(ok), -1(불가)

* 특징: 여기서는 실제 사용자 ID(uid)기준으로 판단한다.(앞에서 나온 euid 말고)
* 비유: 도서관 문 앞에서 나 이 책 빌릴 수 있어요 하고 직원에게 물어보는 거랑 같다.

chmod 시스템 호출
====

&ensp;파일의 장금장치(권한)를 바꾸는 전화 = chmod()<br/>

* 사용법

```c
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
```

* 소유자(owner)만 바꿀 수 있음

* 예시

```bash
chmod 755 myfile
```

&ensp;-> 주인(rwx), 그룹(rx), 다른 사람(rx)

* 비유: 집주인만 자기 집 열쇠를 새로 바꿀 수 있는 것과 똑같다.

link 시스템 호출
=====

&ensp;파일에 새로운 이름표를 붙이는 기능이다. 같은 파일인데 여러 이름으로 불릴 수 있게 만드는 것 -> 하드 링크(hard link)<br/>

* 사용법

```c
#include <unistd.h>
int link(const char *original, const char *new);
int unlink(const char *name);
```

* 특징
    - 링크 카운터(link count): 이름표 개수
    - 이름표를 다 떼면(link count = 0)파일이 완전히 사라진다.

* 비유: 친구가 있는데 철수라는 이름표 말고 David라는 이름표도 붙여주는 것이다. 이름표가 다 떨어지면 친구도 사라지는 것이다.

심볼릭 링크(symbolic link)
=====

&ensp;하드 링크의 한계를 보완한 지름길 파일이다.<br/>
* 하드 링크는 디렉토리엔 못 붙이고 다른 파일시스템에도 안 된다.
* 그래서 나온 게 심볼릭 링크

* 심링크는 뭘까?: 그 자체도 하나의 작은 파일인데 안에는 진짜 파일 경로가 적혀 있다.

* 사용법

```c
#include <unistd.h>
int symlink(const char *realname, const char *symname);
```

* 비유: 내 방 문 앞에 화장실 -> 화살표를 붙여두는 표지판과 같다.

* open("링크") 했을 때, 진짜 파일이 열릴까? 아니면 링크 파일이 열릴까? → 기본적으로 진짜 파일을 따라가서 열린다.

* 링크 안의 글씨(경로)보기

```c
#include <unistd.h>
int readlink(const char *sym, char *buf, size_t size);
```

&ensp;-> 표지판(심링크)안에 적힌 주소 문자열을 읽는 것이다.<br/>
* 비유: 화살표 표지판에 써 있는 글씨를 그대로 읽어보는 거다.

&ensp;이번엔 “심링크 자체”의 신분증을 보고 싶을 때! -> lstat()을 쓴다.<br/>

* 사용법

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
int lstat(const char *linkname, struct stat *buf);
```

* 보통 stat()은 진짜 파일 신분증을 줌
* lstat()은 표지판(심링크)자체의 정보를 줌

* 비유: 표지판이 언제 만들어졌는지 크기가 얼마인지, 누가 만든 표지판인지 확인하는 것이다.

실습
====

실습-1
----

`문제 1`

&ensp;stat() 명령을 이용하여 "data1" 파일의 acess permission, link 수, 파일 크기를 출력하는 프로그램을 작성하시오.<br/>

```c
int main(void){
    struct stat buf;

    // buf에 “data1” 파일의 속성을 저장
    // mode, link수, 크기 출력

    return 0;
}
```

* 목표: stat()로 파일 속성(권한/링크 수/크기) 출력

```bash
# 폴더는 원하는 곳에서 진행해도 돼요
mkdir -p LAB09-08
cd LAB09-08

# 테스트용 파일 생성
echo "hello world" > data1

# 확인
ls -l
# -rw-r--r-- ... data1  (같은 형식이면 OK)
```

&ensp;1) stat()로 파일 속성 출력<br/>
&ensp;1-1) 코드 작성 (파일명: stat_test.c)<br/>

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int main(void) {
    struct stat buf;

    // "data1" 파일의 속성을 buf에 저장
    if (stat("data1", &buf) == -1) {
        perror("stat");
        return 1;
    }

    // 접근 권한: 하위 9비트만 보기 위해 0777로 마스킹
    printf("Access Permission: %o\n", buf.st_mode & 0777);
    // 링크 수
    printf("Link count: %ld\n", (long)buf.st_nlink);
    // 파일 크기(바이트)
    printf("File size: %ld bytes\n", (long)buf.st_size);

    return 0;
}
```

&ensp;코드 설명<br/>
1. #include
    - stdio.h → printf, perror 쓰려고
    - sys/stat.h, unistd.h → stat() 함수와 struct stat 구조체 쓰려고
2. struct stat buf;
    - struct stat = 운영체제가 파일 정보를 담아주는 구조체(자료형).
    - buf라는 변수를 만들면, 그 안에 mode, size, nlink 같은 정보가 저장됨.
3. stat("data1", &buf)
    - stat() 함수 = "data1" 파일의 정보를 가져와서, buf에 채워 넣는다.
    - &buf는 “buf의 주소”라는 뜻. 함수가 buf에 직접 값을 채워 넣어야 하니까 포인터로 주소를 전달해야 한다.
    - if (... == -1) → 만약 실패하면 perror("stat")로 에러 메시지 출력.
4. printf("Access Permission: %o\n", buf.st_mode & 0777);
    - buf.st_mode = 파일의 모드(권한, 파일 타입 등등 다 포함).
    - & 0777 → 권한 부분만 뽑아내는 비트 연산.
    - %o → 8진수로 출력 (리눅스 권한이 644, 755 이런 식으로 보인다).
5. printf("Link count: %ld\n", (long)buf.st_nlink);
    - buf.st_nlink = 링크 수.
    - p1.c에 하드링크가 있으면 값이 2, 3 이렇게 늘어남.
6. printf("File size: %ld bytes\n", (long)buf.st_size);
    - buf.st_size = 파일 크기 (바이트 단위).
    - hello world\n은 12바이트라서 12 출력됨.

&ensp;포인트<br/>
* &buf -> "buf의 주소"
    - stat() 함수는 파일 정보를 buf에 채워 넣어야 하니까 주소를 줘야 함
    - 여기서 쓰인 건 단일 포인터 개념(double pointer 아님)
* access()는 포인터 안 쓰고 그냥 파일 이름 "data1"을 문자열 상수로 전달


&ensp;1-2) 컴파일 & 실행<br/>
```bash
gcc stat_test.c -o stat_test
./stat_test
```

&ensp;기대 출력<br/>
```bash
Access Permission: 644
Link count: 1
File size: 12 bytes
```

* 644 <-> ls -l의 -rw-r--r--에 대응
* File size는 data1 내용에 따라 달라짐

`문제 2`

&ensp;access() 명령을 이용하여 “data1"이라는 이름의 파일이 존재하는지, 존재한다면 사용자에 의한 읽기와 쓰기가 모두 가능한 파일인지를 알아보는 프로그램을 작성하시오.<br/>

* 목표: access()로 파일 존재/읽기·쓰기 가능 여부 확인

```c
int main(void){
    if (/* data1 파일이 존재하는지 확인 */){
        if (/* data1 파일에 대한 읽기와 쓰기가 가능한지 확인 */)
            printf("File exists: Read/write operations are permitted.\n");
        else
            printf("File exists: Read/write operations are not permitted.\n");
        }
    else
        printf("No such file or directory ...\n");

    return 0;
}
```

&ensp;2) access()로 존재/권한 확인<br/>
&ensp;2-1) 코드 작성 (파일명: access_test.c)<br/>

```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
    // 파일 존재 여부
    if (access("data1", F_OK) == 0) {
        // 읽기/쓰기 둘 다 가능한지
        if (access("data1", R_OK | W_OK) == 0)
            printf("File exists: Read/write operations are permitted.\n");
        else
            printf("File exists: Read/write operations are not permitted.\n");
    } else {
        printf("No such file or directory ...\n");
    }
    return 0;
}
```

&ensp;코드 설명<br/>
1. access("data1", F_OK)
    - "data1" 파일이 존재하는지 확인
    - F_OK -> 파일이 있나?
    - 결과: 있으면 0, 없으면 -1
2. if (access("data1", F_OK) == 0)
    - 파일이 존재한다면 → 안쪽 코드 실행
    - 없으면 → else로 가서 "No such file or directory ..."
3. access("data1", R_OK | W_OK)
    - 파일이 **읽기 가능(R_OK)**이고 **쓰기 가능(W_OK)**인지 확인.
    - | (비트 OR) → 두 가지 권한을 동시에 확인.
    - 가능하면 0, 안 되면 -1.
4. 출력
    - 둘 다 가능 -> "Read/write operations are permiited."
    - 일부만 가능 -> "not permitted."

&ensp;2-2) 컴파일 & 실행<br/>
```bash
gcc access_test.c -o access_test
./access_test
```

&ensp;✔️ 권한 바꿔가며 테스트<br/>
```bash
chmod 444 data1   # 읽기만
./access_test     # 실행 결과 → "not permitted" ✅ 정상

chmod 666 data1   # 읽기+쓰기
./access_test1    # 실행 결과 → 그런 파일이나 디렉터리가 없습니다 ❌
```

&ensp;정리<br/>

* stat 실습: stat("data1", &buf)로 속성 읽고 st_mode & 0777, st_nlink, st_size 출력
* access 실습: access("data1", F_OK)로 존재 확인 → access("data1", R_OK|W_OK)로 읽기/쓰기 확인
* chmod로 권한을 바꿔가며 결과가 바뀌는지 꼭 확인하기

&ensp;비유<br/>
* stat() = “저 파일의 신상정보 좀 알려줘” → 주소(&buf)를 주면, 운영체제가 거기에다 이름표(권한, 크기, 링크 수)를 붙여줌
* access() = “저 파일, 존재해? 읽을 수 있어? 쓸 수 있어?” 하고 물어보는 함수. → 있으면 0(YES), 없으면 -1(NO).

&ensp;자주 나는 실수 & 빠른 해결<br/>
* gcc: no input files → 소스 파일이 없거나 파일명을 틀림. ls로 파일명 확인 후 다시 컴파일.
* undefined reference to 'main' → 소스 파일 안에 main() 함수가 없거나 오타. 파일 내용 확인.
* 실행했는데 Permission denied → 보통 실행 파일은 실행 권한이 자동으로 붙지만, 필요하면 chmod +x 실행파일 후 다시 실행.
* No such file or directory ... → data1이 현재 디렉터리에 없거나 이름이 다름. ls로 존재 확인.

실습-2
-----

`문제 1`

&ensp;1. scanf()로 두 개의 문자열을 입력받은 후, link() 명령을 사용하여 기존 file에 새로운 link를 만드는 프로그램을 작성하시오. Shell 상에서 이 프로그램을 실행시켜, “p1.c" 파일에 ”abc"라는 이름의 새로운 link를 생성한 후, ls -l 명령을 이용하여 link를 확인하시오.<br/>

&ensp;0) 디렉토리/예제 파일 준비<br/>
```bash
mkdir -p LAB09-08-02
cd LAB09-08-02

# 링크의 대상이 될 파일(아무 내용이나 OK)
cat > p1.c <<'EOF'
#include <stdio.h>
int main(void){ puts("p1"); return 0; }
EOF
ls -l
```

&ensp;1) 하드 링크 만들기: link()<br/>
&ensp;(1) 코드: link_maker.c<br/>
```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
    char src[256], dst[256];

    printf("Source file and new hardlink name? ");
    if (scanf("%255s %255s", src, dst) != 2) {
        fprintf(stderr, "입력이 잘못되었습니다.\n");
        return 1;
    }

    if (link(src, dst) == -1) {
        perror("link");
        return 1;
    }

    printf("Hard link created: %s -> %s\n", dst, src);
    return 0;
}
```

&ensp;코드 설명<br/>
* #include <stdio.h> → printf, scanf를 쓰기 위해.
* #include <unistd.h> → link() 함수를 쓰기 위해.
* char src[256], dst[256];
    - 파일 이름을 저장할 문자 배열.
    - 예: src = "p1.c", dst = "abc".
* scanf("%255s %255s", src, dst) != 2;
    - 두 문자열을 입력받는다.
    - 첫 번째: 원본 파일 이름, 두 번째: 새로 만들 링크 이름.
    - %255s는 왜 쓰는 걸까?
        + scr와 dst는 char src[256], dst[256]; 이렇게 선언돼 있죠
        + scanf("%s")는 입력 길이를 제한하지 않으면, 배열 크기를 넘어가서 버퍼 오버플로우가 날 수 있다. (심각한 버그/보안 문제)
        + 그래서 %255s라고 쓰면 최대 255글자까지만 읽고 마지막에 \0(문자열 끝 표시)를 넣어라라는 의미가 된다.
        + 배열 크기 256 = 문자 255개 + 마지막 \0 → 안전
    - != 2는 왜 붙는 걸까?
        + scanf는 성공적으로 읽은 항목의 개수를 리턴값으로 돌려준다.
        + 우리가 원하는 건 문자열 2개를 입력받는 거
        + 만약 사용자가 잘못 입력해서 1개만 주거나(p1.c만 입력), 아예 안 주면 -> scanf의 리턴값은 2가 아님
        + 그래서 if(scanf(...) != 2)라고 검사해서 잘못된 입력이면 에러 메시지를 띄우고 프로그램을 종료하는 거다.
* link(src, dst)
    - 하드 링크 생성
    - p1.c에 abc라는 이름표 하나 더 붙이는 것
* perror("link"); 
    - 실패하면 운영체제가 알려주는 오류 메시지를 출력

&ensp;(2) 실행<br/>
```bash
gcc link_maker.c -o link_maker
./link_maker
# 입력: p1.c abc
ls -l
```

&ensp;왜 이렇게 될까?<br/>
* 하드 링크는 같은 파일(같은 inode)에 이름만 하나 더 붙이는 것
* p1.c와 abc는 실제로 같은 파일이라 크기/권한이 같고 ls -l의 링크 수가 2로 증가함
* 둘 중 하나를 지워도 나머지가 그대로 남아 있음(데이터는 유지)

`문제 2`

&ensp;2. scanf()로 두 개의 문자열을 입력받은 후, symlink() 명령을 사용하여 기존 file에 symbolic link를 만드는 프로그램을 작성하시오. Shell 상에서 이 프로그램을 실행시켜, “p1.c" 파일에 ”def"라는 이름의 새로운 symbolic link를 생성한 후, ls -l 명령을 이용하여 symbolic link를 확인하시오. link와 symbolic link의 차이를 확인 해 봅니다.<br/>

&ensp;2번 코드: symlink_maker.c (심볼릭링크 만들기)<br/>
```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
    char target[256], linkname[256];

    printf("Target file and new symlink name? ");
    if (scanf("%255s %255s", target, linkname) != 2) {
        fprintf(stderr, "입력이 잘못되었습니다.\n");
        return 1;
    }

    if (symlink(target, linkname) == -1) {
        perror("symlink");
        return 1;
    }

    printf("Symbolic link created: %s -> %s\n", linkname, target);
    return 0;
}
```

&ensp;구조 설명<br/>
* 구조는 1번과 거의 동일
* symlink(target, linkname) -> linkname이라는 바로가기를 만들어 target을 가리키게 해라
* 예: symlink("p1.c", "def") -> def -> p1.c라는 바로가기 파일 생성
* 원본이 없어지면 심볼릭 링크는 깨짐
* return 1;
    - C 프로그램은 main 함수의 return 값으로 실행 결과를 운영체제(OS)에 알려준다.
    - 0 -> 정상 종료(성공)
    - 0이 아닌 값 -> 비정상 종료(에러)


&ensp;(2) 실행<br/>
```bash
gcc symlink_maker.c -o symlink_maker
./symlink_maker
# 입력: p1.c def
ls -l
```
&ensp;결과<br/>
```bash
lrwxrwxrwx. 1 s23013240 class    4 ... def -> p1.c
```

* l → 이 파일은 심볼릭 링크라는 뜻
* def -> p1.c → def가 p1.c를 가리키고 있음
* abc는 1번에서 만든 하드 링크 (inode 공유)
* def는 2번에서 만든 심볼릭 링크 (경로 문자열로 가리킴)

&ensp;왜 이렇게 될까?<br/>
* 심볼릭 링크는 경로 문자열을 저장하는 바로가기 파일
* def -> p1.c처럼 표시되고 파일 타입은 1로 시작
* 원본(p1.c)이 삭제되면 def는 깨진 링크가 됨

`문제 3`

&ensp; 3. Shell 상에서 디렉토리, A/B/C를 만듭니다. 2번의 프로그램을 이용해서 디렉토리 A/B/C에 대한 symbolic link T를 만듭니다. Shell 상에서 디렉토리 T에 data2 파일을 만듭니다. 디렉토리 A/B/C에도 data2이 생성되었는지 확인합니다.<br/>

&ensp;1) 디렉토리 생성<br/>
```bash
mkdir -p A/B/C
ls -R A   # 구조 확인
```

&ensp;출력 예시:<br/>
```bash
A:
B

A/B:
C

A/B/C:
```

&ensp;2) 심볼릭 링크 T 생성<br/>
```bash
./symlink_maker
```

&ensp;입력:<br/>
```bash
A/B/C T
```

&ensp;확인:<br/>
```bash
ls -ld T A/B/C
```

&ensp;예시 출력:<br/>
```bash
drwxr-xr-x. 2 s23013240 class 4096 2025-09-08 13:06 A/B/C 
lrwxrwxrwx. 1 s23013240 class 5 2025-09-08 13:07 T -> A/B/C
```

&ensp;T가 A/B/C를 가리키는 symbolic link가 된 것.<br/>

&ensp;3) T 경유로 파일 만들기<br/>
```bash
echo "hello via symlink" > T/data2
```

&ensp;4) 실제 A/B/C에도 파일이 생겼는지 확인<br/>
```bash
ls -l A/B/C
```

&ensp;출력 예시:<br/>
```bash
합계 4 
-rw-r--r--. 1 s23013240 class 18 2025-09-08 13:10 data2
```

&ensp;포인트<br/>
* T는 디렉토리 A/B/C를 가리키는 심볼릭 링크
* T/data2 파일을 만들면 실제 A/B/C/data2에 생성됨.
* 이유: 심볼릭 링크는 경로를 가리키는 별칭이기 때문
* T는 A/B/C로 가는 지름길이라 T/data2 == A/B/C/data2.

`문제 4`

&ensp;4. symbolic link 이름을 입력으로 받아, 해당 symbolic link 자체에 대한 stat 정보 중 access permission, 파일 크기를 symbolic link 이름과 같이 출력하고, 또한 symbolic link가 가리키는 실제 file의 stat 정보 중 access permission, 파일 크기를 실제 file 이름과 같이 출력하는 프로그램을 작성하시오. <br/>

&ensp;symbolic link 이름을 입력받아:<br/>
* 링크 자체(lstat)의 access permisstion, 파일 크기 출력
* 링크가 가리키는 실제 파일(stat)의 access permission, 파일 크기 출력

&ensp;1) 코드 작성 (symlink_stat.c)<br/>
```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

static void print_info(const char *label, const struct stat *st) {
    printf("%s: perm=%o, size=%ld bytes\n",
           label, st->st_mode & 0777, (long)st->st_size);
}

int main(void) {
    char linkname[256];
    struct stat st_link;   // symlink 자체
    struct stat st_target; // symlink가 가리키는 실제 대상

    printf("Symlink name? ");
    if (scanf("%255s", linkname) != 1) {
        fprintf(stderr, "입력이 잘못되었습니다.\n");
        return 1;
    }

    // 링크 '자체' 정보 (lstat)
    if (lstat(linkname, &st_link) == -1) {
        perror("lstat");
        return 1;
    }
    print_info(linkname, &st_link);

    // 링크가 가리키는 '타깃' 정보 (stat)
    if (stat(linkname, &st_target) == -1) {
        perror("stat");
        return 1;
    }
    print_info("-> target", &st_target);

    return 0;
}
```

&ensp;코드 설명<br/>
* struct stat -> 파일 정보(권한, 크기 등)를 담는 구조체
* lstat(linkname, &st_link)
    - 링크 자체의 정보를 가져옴
    - 심볼릭 링크 파일의 크기는 타킷 이름 문자열 길이
* stat(linkname, &st_target)
    - 링크를 따라가서 실제 파일/디렉토리의 정보를 가져옴
* print_info 함수
    - 코드 반복 줄이기 위해 만든 출력 함수
    - perm=%o -> 권한(8진수), size=%ld -> 크기

&ensp;구조체(struct)란?<br/>
* 여러 자료를 묶어 담는 사용자 정의 타입이다.
* 예: 학생을 이름, 학번, 키로 묶듯이 파일도 권한, 크기, 링크 수 등 여러 값을 한 덩어리로 묶어 담는다.

```c
struct Student {
    char name[20];
    int  id;
    float height;
};
// 하나 만들어서 쓰기
struct Student s;
```

&ensp;struct stat도 마찬가지로 파일에 대한 다양한 속성을 담는 구조체이다.<br/>

&ensp;struct stat 안에는 뭐가 들어있나? (대표 필드)<br/>
<p align="center"><img src="/assets/img/Linux Programming/Lect3/3-1.png" width="600"></p>

&ensp;stat() vs lstat():<br/>

&ensp;둘 다 운영체제에게 “이 경로의 파일 정보를 struct stat에 채워줘 라고 부탁하는 함수<br/>
* stat(path, &buf) -> 심볼릭 링크를 따라가서 “진짜 타깃” 파일의 정보를 채움(ex. def가 p1.c를 가리키면 p1.c 정보를 채움)
* lstat(path, &buf) -> 링크를 따라가지 않고, “링크 자체”의 정보를 채움(ex. def 자체가 링크 파일임을 알 수 있고, st_size는 "p1.c" 글자 수)
    - 링크 자체를 보고 싶다 → lstat
    - 링크가 가리키는 진짜 파일을 보고 싶다 → stat

&ensp;주소 연산자 &buf가 꼭 필요한 이유 (포인터 최소 이해)<br/>
&ensp;stat()/lstat()는 함수 안에서 buf에 값을 “채워 넣어야” 한다. 그래서 buf의 주소를 줘야 합니다.<br/>

```c
struct stat st;
lstat("def", &st);  // st의 '주소'를 전달 → 함수가 st 안에 값을 써 넣음
```

&ensp;st_mode 해석하기: 파일 종류 + 권한 비트<br/>
&ensp;st_mode에는 두 가지 정보가 같이 들어 있다.<br/>
1. 파일 종류(regular, directory, symlink, …)
* 매크로로 판별:
    - S_ISREG(st_mode) → 일반 파일?
    - S_ISDIR(st_mode) → 디렉토리?
    - S_ISLNK(st_mode) → 심볼릭 링크?

2. 권한 비트
* 하위 9비트를 떼어내면 rwxrwxrwx에 해당:
    - st_mode & 0777 → 8진수로 권한 표시 (예: 644, 755)
    - 개별 비트: S_IRUSR, S_IWUSR, S_IXUSR … (소유자/그룹/기타의 r/w/x)

&ensp;예시:<br/>
```c
printf("perm(octal) = %o\n", st.st_mode & 0777);

if (S_ISREG(st.st_mode)) puts("type: regular file");
if (S_ISDIR(st.st_mode)) puts("type: directory");
if (S_ISLNK(st.st_mode)) puts("type: symlink");
```

&ensp;4번 코드(symlink_stat.c)를 구조체 관점에서 다시 보기<br/>
```c
struct stat st_link;   // 링크 '자체' 정보 담을 상자
struct stat st_target; // 링크가 가리키는 '대상' 정보 담을 상자

lstat(linkname, &st_link); // 링크 파일 자체를 열람 → 여기가 symlink인지, 크기는 경로 글자 수
stat(linkname,  &st_target); // 링크 따라가서 진짜 대상 정보 열람 → 실제 파일/디렉토리 권한·크기
```

* print_info(label, &st)는 구조체 안의 st_mode, st_size를 포맷 맞춰 예쁘게 찍는 출력 전용 함수.
* 출력에서  
    - 링크 자체(lstat)는 보통 perm=777 비슷하게 보이고 size=타깃 경로 길이
    - 타깃(stat)은 진짜 권한/크기 (예: p1.c 59 bytes, A/B/C는 4096 bytes 같은 디렉토리 블록 크기)

&ensp;메모리 상자 비유로 이해하기<br/>
* struct stat st; → 여러 칸이 있는 상자를 만든 것(칸 이름: st_mode, st_size, st_nlink …)
* &st → 그 상자의 주소표
* lstat(path, &st) → 운영체제에게 상자 주소를 건네 “여기 안에 링크 정보를 채워줘!”
* stat(path, &st) → “여기 안에 타깃 파일 정보를 채워줘!”

&ensp;덤: 출력 형식(타입별 printf)<br/>
&ensp;시스템마다 타입이 다를 수 있어 안전하게 캐스팅해 쓴다.<br/>
* st_size(보통 off_t) ->(long) 또는 (long long)로 캐스팅해서 %ld(또는 %lld)
* st_nlink(보통 nlink_t) -> (long) 캐스팅 후 %ld
* 권한은 8진수 %o가 관례

&ensp;📌 비유로 전체 요약<br/>
* 하드링크(link): 하나의 공책(p1.c)에 이름표(abc)를 하나 더 붙이는 것. → 공책은 그대로, 이름만 여러 개.
* 심볼릭링크(symlink): "p1.c로 가라"라고 적힌 메모(def). → 공책이 없어지면 메모만 남아 의미 없음.
* 디렉토리 링크(T): A/B/C로 들어가는 지름길 표지판.
* stat vs lstat:
    - lstat = 메모 종이 자체 정보
    - stat = 메모가 가리키는 진짜 공책 정보

&ensp;2) 컴파일<br/>
```bash
gcc -Wall -Wextra -O2 symlink_stat.c -o symlink_stat
```

&ensp;3) 실행 예시<br/>
```bash
./symlink_stat
```

&ensp;입력:<br/>
```bash
def
```

&ensp;출력<br/>
```bash
def: perm=777, size=4 bytes
-> target: perm=644, size=59 bytes
```

* def(심볼릭 링크 자체)
    - perm=777 -> 심볼릭 링크는 권한 자체가 항상 의미 없이 777 비슷하게 나옴
    - size = 4 bytes -> 링크가 가리키는 문자열 "p1.c"의 길이 (4글자)
* -> target(실제 파일 p1.c)
    - perm=644 -> 원본 파일 권한
    - size=59 bytes -> p1.c 파일 크기

&ensp;