---
title: "Lect7. 실습"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-09-25
last_modified_at: 2025-09-25
---

실습_1
=====

`문제 1.`
&ensp; main() 함수의 인수로 정수를 하나 받아, 해당 정수 만큼의 child 프로세스를 생성하는 프로그램을 작성하시오. 생성된 child 프로세스는 자신의 프로세스 id, 프로세스 그룹 id, session id를 출력한 후 종료합니다. 아래 프로그램을 사용하세요.<br/>
```c
void do_child(void){
    // process id, group id, session id 출력
    exit(0); // 이 부분의 코드는 변경 금지
}

int main(/* 인수 설정 */){
    int num, i;
    pid_t pid;

    // main 함수의 인자를 정수로 변환

    for (i=0; i<num; i++){
        // child process 생성
        if (/* child process 인지 확인 */){
            do_child();
        }
    }

    for (i=0; i<num; i++){ // 이 부분의 코드는 변경 금지
        wait(0);
    }

    return 0;
}
```

&ensp;<b>코드</b><br/>
```c
#define _XOPEN_SOURCE 500

#include "common.h"
#include <unistd.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>

void do_child(void){
	printf("pid=%d, gid= %d, sid= %d\n", getpid(), getpgid(0), getsid(getpid()));  
	exit(0);
}

int main(int argc, char **argv){
	int num, i;
	pid_t pid;
	
	num=atoi(argv[1]);
	
	for(i = 0; i < num; i++){
		pid=fork();
		if(pid == 0){
			do_child();
		}
	}
	for(i=0; i < num;i++){
		wait(0);
	}
	
	return 0;
}
```

* main이 명령줄 인자로 받은 숫자(num)만큼 반복하며 fork() 호출
* 매 반복에서:
    - 부모: fork()가 돌려준 자식 PID(양수)를 받아 다음 반복으로 진행
    - 자식: fork()가 0을 돌려주므로 do_child() 실행 → 정보 출력 → exit(0)
* 부모는 마지막에 wait(0)을 num번 호출해 좀비 프로세스가 남지 않게 수거

&ensp;<b>코드 분석</b><br/>
```c
void do_child(void){
    printf("pid=%ld, ppid= %ld, sid= %ld", getpid(), getppid(), getsid());
    exit(0);
}
```

* 자식 프로세스가 실행하는 함수
* getpid() : 현재 프로세스 ID
* getpgid(0) : 현재 프로세스의 그룹 ID. (0은 “자기 자신”이라는 의미)
* getsid(getpid()) : 현재 프로세스가 속한 세션 ID
* exit(0) : 문제 조건에 맞춰 자식은 출력 후 종료

&ensp;메인 함수<br/>
```c
int main(int argc, char **argv){
    int num, i;
    pid_t pid;
	
    num = atoi(argv[1]);  // 명령줄 두 번째 인자를 정수로 변환
```

* 여기서 argv[1]검증이 없음 → ./a.out만 실행하면 세그폴트 발생
* 반드시 argc < 2 검사 필요

&ensp;argv[1]<br/>

&ensp;예를 들어 프로그램을 이렇게 실행:<br/>
```bash
./test1.out 5
```

* argc == 2
* argv[0] == "./test1.out" (프로그램 이름)
* argv[1] == "5" (우리가 입력한 문자열 "5")

&ensp;즉, argv[1]은 "5"라는 문자열이다.<br/>

&ensp;atoi()<br/>
* atoi = ASCII to Integer 의 약자.
* <stdlib.h>에 정의된 함수.
* "123" 같은 문자열을 정수 123으로 바꿔 

```c
int x = atoi("123");  // x == 123
```

&ensp;main 함수의 인자<br/>
```c
int main(int argc, char **argv)
```

* argc : 인자의 개수 (argument count)
* argv : 인자 문자열들을 가리키는 포인터 배열 (argument vector)

&ensp;프로그램 실행할 때 준 인자들을 문자열 배열 형태로 전달받는다.<br/>

&ensp;실행 예시<br/>
&ensp;만약 프로그램을 이렇게 실행했다고 한다.:<br/>
```bash
./a.out hello 123
```

* argc == 3
* argv[0] == "./a.out" (실행한 프로그램 이름)
* argv[1] == "hello"
* argv[2] == "123"
* argv[3] == NULL (배열 끝 표시)

&ensp;argv는 무엇인가?<br/>
* argv는 문자열(char *)들을 담고 있는 배열을 가리킵니다.
* 즉, argv 자체는 char * 타입의 배열을 가리키는 포인터 → 그래서 char **argv

&ensp;비유:<br/>
```css
argv ──▶ [주소1][주소2][주소3][NULL]
          │      │      │
          ▼      ▼      ▼
        "./a.out" "hello" "123"
```

&ensp;인덱스로 접근<br/>
* argv[i] → i번째 인자 (문자열 시작 주소, char *)
* argv[i][j] → i번째 인자의 j번째 문자 (char)

&ensp;예시:<br/>
```c
printf("%s\n", argv[1]);    // "hello"
printf("%c\n", argv[1][0]); // 'h'
printf("%c\n", argv[1][1]); // 'e'
```

&ensp;포인터 문법으로 풀어보기<br/>
* argv[i] 는 *(argv + i) 와 같음 → i번째 문자열의 시작 주소
* argv[i][j] 는 *(*(argv + i) + j) 와 같음 → i번째 문자열의 j번째 문자

&ensp;예를 들어 argv[1][2]:<br/>
1. argv + 1 → 두 번째 인자의 주소
2. *(argv + 1) → "hello" 문자열의 시작 주소
3. *( *(argv + 1) + 2 ) → "hello"의 2번째 인덱스 문자 'l'

&ensp;그림으로 표현<br/>
```css
argv (char **)
   │
   ├──> argv[0] ──> "./a.out\0"
   │
   ├──> argv[1] ──> "hello\0"
   │
   └──> argv[2] ──> "123\0"
```

* argv는 문자열 배열의 시작을 가리킴
* 각 원소(argv[i])는 문자열(=char 배열)의 시작 주소
* 그래서 이중 포인터 char **가 되는 거이다.

```c
for (i = 0; i < num; i++) {
    pid = fork();  //fork()는 현재 프로세스를 복제해서 자식 프로세스를 만든다. 부모와 자식이 둘 다 fork()호출 이후부터 실행을 이어간다.
    if (pid == 0) {
        do_child();
    }
}
```

* 부모: 계속 fork() 호출 → 자식 N개 생성
* 자식: pid==0 이면 do_child() 실행 후 exit(0) → 루프를 더 이상 돌지 않음

<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-5.png" width="600"></p>

&ensp;pid == 0의 의미<br/>
* 자식 프로세스만 이 블록을 실행
* 부모는 pid가 양수이므로 실행하지 않음 → 계속 루프 돌며 다음 fork() 호출

&ensp;결국 pid==0은 내가 지금 자식 프로세스 쪽에서 실행 중이다.라는 신호이다.<br/>

&ensp;그림으로 표현<br/>
```perl
부모 프로세스 (pid=1000)
    |
    | fork()
    |
 ┌──┴──────────────────┐
부모 (pid=1000)    자식 (pid=1001)
pid=fork()=1001    pid=fork()=0
```

* 부모 입장: pid 변수 안에는 새로 생긴 자식 PID(1001)가 들어 있음
* 자식 입장: pid 변수 안에는 항상 0

* pid == 0 → 자식 코드 실행 경로
* pid > 0 → 부모 코드 실행 경로
* pid < 0 → fork 실패

```c
for (i=0; i < num; i++) {
    wait(0);
}
```

* 부모는 자식 N개가 모두 끝날 때까지 기다림 → 좀비 프로세스 방지

&ensp;<b>실행 예시</b><br/>
```bash
$ ./test1.out 3
pid=12345, gid=12345, sid=12345
pid=12346, gid=12345, sid=12345
pid=12347, gid=12345, sid=12345
```

* 자식 3개(num=3)를 만들었으니, 세 줄 출력
* pid: 각각 다름 (자식마다 고유 ID)
* gid: 보통 첫 번째 부모의 pid (즉, 자식들이 같은 그룹에 속함)
* sid: 같은 세션에서 실행됐으므로 동일


`문제 2.`
&ensp;main() 함수의 인수로 파일 이름과 정수 하나를 입력으로 받아, 먼저 입력받은 이름의 파일을 open한 후, 해당 정수 만큼의 child 프로세스를 생성하는 프로그램을 작성하시오. 생성된 child 프로세스는 open 된 파일에서 2개의 문자를 읽어 자신의 id와 함께 출력한 후 종료 합니다. (child 프로세스가 open하는 파일에는 A부터 Z까지 26개의 문자가 저장되어 있고, 표준 출력은 printf()를 사용합니다.)<br/>
```c
void do_child(/* 인수 전달 */){
    char buf[5]={0};

    // 파일에서 문자 2개 읽어 자신의 process id와 함께 출력
    exit(0); // 이 부분의 코드는 변경 금지
}

int main(/* 인수 설정 */){
    int num, i, fd;
    pid_t pid;

    // main 함수의 인자로 주어진 파일 open
    // main 함수의 인자를 정수로 변환

    for (i=0; i<num; i++){
        // child process 생성
        if (/* child process 인지 확인 */){
            do_child();
        }
    }

    for (i=0; i<num; i++){ // 이 부분의 코드는 변경 금지
        wait(0);
    }

    return 0;
}
```

&ensp;<b>코드</b><br/>
```c
#include "common.h"

void do_child(int fd){
	char buf[5] = {0};
	
	read(fd, buf, 2);
	printf("%s by %ld\n", buf, getpid());
	exit(0);
}

int main(int argc, char **argv){
	char buf[5] = {0};
	int num, i, fd;
	pid_t pid;
	
	fd=open(argv[1], O_RDONLY);
	num=atoi(argv[2]);
	
	for(i=0;i < num;i++){
		pid=fork();
		if(pid==0){
			do_child(fd);
		}
	}
	
	for(i= 0; i < num;i++){
		wait(0);
	}
	return 0;
}
```

&ensp;<b>코드 분석</b><br/>

```c
void do_child(int fd){
    char buf[5] = {0};
	
    read(fd, buf, 2);
    printf("%s by %ld\n", buf, getpid());
    exit(0);
}
```

&ensp;do_child 함수<br/>
* fd: 파일 디스크립터(부모가 open()해서 넘겨줌)
* char buf[5] = {0};
    - 읽은 데이터를 저장할 임시 버퍼
    - 5바이트로 만든 이유는 "문자 2개" + '\0'(문자열 끝) 을 위해 여유 있게 잡은 것
* read(fd, buf, 2);
    - 파일에서 2바이트(2문자) 읽어서 buf에 저장
    - 예: 첫 번째 자식은 "AB", 두 번째는 "CD", …
* printf("%s by %ld\n", buf, getpid());
    - buf에 담긴 문자와 자기 PID를 출력
    - 예: "AB by 12345"
* exit(0);
    - 자식 프로세스 종료(문제 조건)

```c
int main(int argc, char **argv){
    char buf[5] = {0};
    int num, i, fd;
    pid_t pid;
```

&ensp;main 함수 시작<br/>
* argc, argv: 명령줄 인자
    - 예: ./prog alphabet.txt 3
    - argv[1] = "alphabet.txt", argv[2] = "3"
* fd: 파일 디스크립터
* num: 자식 프로세스 개수
* pid: fork()의 반환값 저장

```c
    fd = open(argv[1], O_RDONLY);
    num = atoi(argv[2]);
```

* argv[1]: 파일 이름 (alphabet.txt)
* open(argv[1], O_RDONLY); → 읽기 전용으로 파일 열기
* argv[2]: 문자열 "3"
* atoi(argv[2]) → 정수 3으로 변환 → num

```c
    for (i = 0; i < num; i++){
        pid = fork();
        if (pid == 0){
            do_child(fd);
        }
    }
```

&ensp;자식 생성 루프<br/>
* fork()가 자식을 생성
    - 부모: pid > 0 → 계속 반복
    - 자식: pid == 0 → do_child(fd) 실행 후 종료
* 따라서 자식 N개가 각각 read(fd, buf, 2); 실행
* 각 자식이 파일에서 이어지는 위치에서 2바이트씩 읽어옴 → 결과적으로 파일에서 순서대로 2글자씩 나눠 갖게 됨

```c
    for (i = 0; i < num; i++){
        wait(0);
    }
    return 0;
}
```

&ensp;부모 프로세스<br/>
* 모든 자식이 끝날 때까지 기다림(wait(0))
* 좀비 프로세스 방지
* 프로그램 종료

&ensp;<b>실행 과정</b><br/>
&ensp;준비<br/>
```bash
echo -n "ABCDEFGHIJKLMNOPQRSTUVWXYZ" > alphabet.txt
```

```bash
AB by 12345
CD by 12346
EF by 12347
```

&ensp;(실제로는 OS 스케줄링 때문에 순서가 뒤바뀔 수도 있음 → CD가 먼저 나오고 AB가 나올 수도 있어요.)<br/>

&ensp;<b>이해 포인트</b><br/>
1. open & fd 공유
    - 부모가 연 파일 디스크립터 fd는 fork()로 자식에게 복사됨.
    - 파일 오프셋도 공유되므로, 첫 번째 자식이 "AB" 읽으면 두 번째 자식은 "CD"부터 읽음.
2. fork() 반환값
    - 부모: 양수(자식 PID) → 루프 계속
    - 자식: 0 → do_child(fd) 실행 → exit
3. read() 동작
    - 현재 파일 오프셋에서 2바이트 읽고, 오프셋을 앞으로 2 증가시킴
    - 여러 자식이 순서대로 2바이트씩 읽게 됨
4. printf("%s by %ld\n", buf, getpid());
    - buf는 read()로 채워진 2글자 문자열
    - %ld는 long 타입 출력 (pid_t를 (long) 캐스팅하는 게 안전)
5. wait()
    - 부모가 모든 자식이 끝날 때까지 기다림
    - 좀비 방지

실습_2
=====

`문제 1.`
&ensp;다음 각 조건을 만족하는 프로그램을 작성하시오.<br/>
&ensp;(a) main() 함수의 argument로 받은 문자열을 3회 반복 출력하는 프로그램을 작성하고 해당 프로그램의 실행파일 이름을 “test1”으로 설정합니다. home directory에 bin이라는 이름의 디렉토리를 만들고, “test1” 실행파일을 home directory/bin에 복사하고 파일 이름은 “test2”로 설정합니다.<br/>
```c
int main(/* 인수 설정 */){
int i, j;
for (i=0; i<3; i++){
for (j=1; /* 종료 조건 */; j++){
// 출력
}
printf("\n");
}
exit(0);
}
```

&ensp;(b) execl() 명령을 이용하여 current working directory에 있는 "test1"을 실행시키는 프로그램을 작성하고, 3개의 문자열, ”abc", "def", "ghi"를 argument로 전달합니다.<br/>
&ensp;(c) execlp() 명령을 이용하여 home directory/bin에 있는 "test2"를 실행시키는 프로그램을 작성하고, 3개의 문자열, ”abc", "def", "ghi"를 argument로 전달합니다.<br/>
&ensp;(d) execv() 명령을 이용하여 current working directory에 있는 "test1"을 실행시키는 프로그램을 작성하고, 3개의 문자열, ”abc", "def", "ghi"를 argument로 전달합니다.<br/>
&ensp;(e) execvp() 명령을 이용하여 home directory/bin에 있는 "test2"를 실행시키는 프로그램을 작성하고, 3개의 문자열, ”abc", "def", "ghi"를 argument로 전달합니다.<br/>

&ensp;<b>코드</b><br/>
```c
#include "common.h"

int main(int argc, char **argv){
	int i, j;
	
	for(i= 0; i < 3; i++){  
		for(j = 1; j < argc; j++){  // argv[0]은 프로그램 이름
			printf("%s ", argv[j]);
		}
		printf("\n");
	}
	
	exit(0);
}
```

* argc: 인자 개수, argv: 인자들의 문자열 포인터 배열
    - argv[0]은 실행 파일(이름), argv[1]부터가 우리가 넘긴 "abc", "def", "ghi"
* 실행 예: ./test1 abc def ghi → abc def ghi 3줄 출력

&ensp;(b) execl.c - 경로 직접 지정 + 가변 인자
```c
#include "common.h"

int main(void){
	printf("execl() 실행:\n");

	execl("./test1", "test1", "abc", "def", "ghi", (char *)NULL);
	exit(1);
} 
```

* 첫 번째 인자 "./test" : 실행 파일 경로 반드시 지정
* 두 번째 인자 "test1": 새 프로그램에서 argv[0]로 보일 이름
* 뒤는 argv[1..]로 전달한 문자열들
* 마지막은 (char *)NULL로 종결

&ensp;(c) execlp.c-PATH 검색 + 가변 인자<br/>
```c
#include "common.h"

int main(void){
	printf("execlp() 실행:\n");
	execlp("test2", "test2", "abc", "def", "ghi", (char *)0);
	exit(0);
}
```

* "test2"는 파일명만 적음
* 쉘처럼 PATH에서 탐색 → ~/bin이 PATH에 있어야 찾음
    - 필요시: export PATH=$HOME/bin:$PATH
* ~/bin/test2가 존재하고 실행권한 있어야 함

&ensp;(d) execv.c — 경로 직접 지정 + 배열<br/>
```c
#include "common.h"

int main(void){
	char *ar[5] = {"test1", "abc", "def", "ghi", (char *)0};
	
	printf("execv() 실행:\n");
	execv("./test1", ar);
	exit(0);
}
```

* ar는 argv 형식의 배열, 마지막 NULL로 종결
* 경로는 ./test1처럼 정확하게 적기

&ensp;execvp.c — PATH 검색 + 배열<br/>
```c
#include "common.h"

int main(void){
	char *ar[5] = {"test2", "abc", "def", "ghi", (char *)0};
	
	printf("execvp() 실행:\n");
	execvp("test2", ar);
	exit(0);
}
```

* "test2"를 PATH에서 탐색
* 배열 전달이니 가변 인자 아님

&ensp;execlp/execvp는 인자에 슬래시(/)가 포함되어 있으면 PATH를 무시하고 그 경로를 그래도 사용한다. 즉 "test2"(슬래시 없음) → PATH 검색, "~/bin/test2"(슬래시 있음)→ 그대로 사용<br/>

&ensp;(char *)0 또는 (char *)NULL 이 부분이 exec 계열 함수의 인자 종료 표시자<br/>
&ensp;필요한 이유<br/>
* C 언어의 exec*() 함수들은 인자의 개수를 알 수 없다.
* 함수 원형:

```c
int execl(const char *path, const char *arg0, ... /* (char *)0 */);
```

* ... ← 가변 인자(몇 개가 올지 모름)
* 그래서 함수가 내부에서 언제 멈춰야 하는지 표시자가 꼭 필요
* 그 표시자가 바로 NULL 포인터

&ensp;즉:<br/>
* execl("./test1", "test1", "abc", "def", "ghi", (char *)0); → 여기서 (char *)0을 만날 때까지 인자들을 argv[]에 복사해서 새 프로그램에 전달한다.

&ensp;execv처럼 배열일 때도?<br/>
```c
char *ar[5] = {"test2", "abc", "def", "ghi", (char *)0};
execvp("test2", ar);
```

* 배열 ar 마지막 요소도 NULL로 끝나야 해요.
* execvp는 이 배열을 argv로 그대로 넘기는데, 어디까지가 유효한 인자인지 알려면 마지막 NULL이 필요합니다.
* 즉 argv = {"test2", "abc", "def", "ghi", NULL} 이 구조가 돼야 해요.

&ensp;(char *)0과 NULL 차이<br/>
* 0을 포인터로 캐스팅한 것 = NULL (옛날 코드 스타일).
* 두 개 다 "널 포인터" 라는 같은 의미

&ensp;exec 계열 요약<br/>
* 공통: exec*()가 성공하면 현재 프로세스의 코드/데이터가 통째로 새로운 프로그램으로 갈아끼워짐 (PID는 그대로) → exec 다음 줄은 실행 안 됨(오류 때만 돌아옴)
* l vs v
    - l(list): 인자를 가변 인자로 “하나씩” 나열
    - v(vector): 인자를 **배열(char* argv[])**로 전달
* p 유무
    - p 있음: PATH 검색해서 실행 파일을 찾음("ls", "test2" 등)
    - p 없음: 경로를 정확히 지정해야 함("./test1", "/usr/bin/python" 등)
* arg0(=argv[0]): 보통 실행 파일 이름을 넣음. 프로그램 내부에서는 argv[0]로 보임.
* NULL 종결 필수: execl(..., (char*)NULL) 또는 argv[last] = NULL.

<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-14.png" width="600"></p>

&ensp;무조건 외워야 할 필수 개념(시험·실전 공통)<br/>
1. exec 성공 시 복귀 없음
    - 다음 줄 실행 X, 오류일 때만 돌아옴 → 항상 perror 넣기
2. l vs v / p 유무
    - l: 가변 인자, v: 배열
    - p: PATH 검색
    - execl("./a", "a", "x", NULL);
    - execv("./a", (char*[]){"a","x",NULL});
    - execlp("a", "a", "x", NULL);
    - execvp("a", (char*[]){"a","x",NULL});
3. argv[0]은 내가 정한다
    - 관례적으로 실행파일 이름을 넣지만, 임의 문자열도 가능(프로세스 이름 표시에 영향)
4. NULL 종결
    - execl의 마지막, execv의 배열 마지막 반드시 NULL
5. PATH 동작
    - exec*p: 파일명에 슬래시 없을 때만 PATH 검색
    - 슬래시 있으면 그 경로 그대로 사용
6. fork-exec-대기(waitpid) 패턴은 표준
    - 부모는 리소스 회수, 상태 확인
    - 자식은 _exit(코드)로 종료
7. 권한/경로가 제일 흔한 실패 원인
    - "No such file or directory", "Permission denied" → 파일 위치/권한/PATH 확인

&ensp;<b>실행 결과</b><br/>
&ensp;test1.c<br/>
```bash
./test1 abc def ghi

abc def ghi
abc def ghi
abc def ghi
```


&ensp;execl.c<br/>
```bash
./execl

execl() 실행:
abc def ghi
abc def ghi
abc def ghi
```

&ensp;execlp.c<br/>
```bash
./execlp

execlp() 실행:
abc def ghi
abc def ghi
abc def ghi
```

&ensp;execv.c<br/>
```bash
./execv

execv() 실행:
abc def ghi
abc def ghi
abc def ghi
```

&ensp;execvp.c<br/>
```bash
./execvp

execvp() 실행:
abc def ghi
abc def ghi
abc def ghi
```

&ensp;정리<br/>
* 다섯 개의 실행 파일(execl, execlp, execv, execvp)은 다르게 작성됐지만, 실행 결과는 동일하다.
* 차이점은 인자를 어떻게 전달하느냐(l vs v), **PATH 검색을 쓰느냐(p vs non-p)**에 있다.

실습_3
====

`문제 1.`
&ensp;parent process는 3개의 child process를 만들고, 각 child process가 종료할 때까지 대기하였다가 child process의 exit() 값을 출력한 후 종료합니다. 단, parent process는 child process의 생성 순서의 역순으로 종료 대기를 합니다. 각 child process는 자신의 프로세스 id와 group id, session id를 5회 출력한 후, exit()을 수행합니다. 매 출력 후 sleep(1) 명령으로 1초간 쉽니다. exit()의 값은 child process가 만들어진 순서 번호입니다.<br/>
```java
void do_child(/* 함수 인자 */){
    int i;

    for (i=0; i<5; i++){
        // 프로세스 id, group id, session id 출력
        sleep(1);
    }
    exit(/* exit 값 설정 */);
}

int main(void){
    int i, n, status;
    pid_t pid[3];

    for (i=0; i<3; i++){
        // child 생성
        if (/* child 인지 확인 */){
            do_child(/* 생성 순서 전달 */);
        }
    }

    for (/* 종료 확인 순서 */){
        // 세 child의 종료 상태를 child 생성 순서의 역순으로 확인
        if (/* child 정상 종료 확인 */) {
            printf("%d......%d\n", /* child의 id와 종료 상태 출력 */);
        }
    }

    exit(0);
}
```

&ensp;<b>코드</b><br/>
```c
#include "common.h" 
void do_child(int n){ 
    int i; 
    for(i=0; i < 5; i++){ 
        printf("pid=%d, gid=%d, sid=%d\n", getpid(), getpgid(0), getsid(getpid())); 
        sleep(1); 
    } 
    exit(n); 
} 

int main(void){ 
    int i, n, status; 
    pid_t pid[3]; 
    for(i=0;i < 3;i++){ 
        pid[i] = fork(); 
        if(pid[i] == 0){ 
            do_child(i+1); 
        } 
    }

    for(i=2; i >= 0;i--){ 
        n=waitpid(pid[i], &status, 0); 
        if(WIFEXITED(status)){ 
            printf("%d......%d\n", n, WEXITSTATUS(status)); 
            } 
        } 

    exit(0); 
}
```

&ensp;<b>코드 분석</b><br/>
```c
void do_child(int n){
    int i;
    for(i=0; i < 5; i++){
        printf("pid=%d, gid=%d, sid=%d\n", getpid(), getpgid(0), getsid(getpid()));
        sleep(1);
    }
    exit(n);
}
```

* do_child는 자식이 할 일을 묶어둔 함수
* getpid() : 내 PID
* getpgid(0) : 인자 0은 “현재 프로세스”의 프로세스 그룹 ID(PGID). 세 자식이 모두 같은 PGID를 갖는 게 정상
* getsid(getpid()) : 내 세션 ID(SID). 보통 부모/형제들과 같음
* sleep(1) : 1초 쉬어서 출력이 5번, 5초 동안 분산되게 함(스케줄링 관찰용)
* exit(n) : 종료 코드를 생성 순서 번호 n으로 설정 (종료코드는 0~255 범위만 유효)

```c
int main(void){
    int i, n, status;
    pid_t pid[3];
    
    for(i=0;i < 3;i++){
        pid[i] = fork();
        if(pid[i] == 0){
            do_child(i+1);
        }
    }
```

* fork() : 부모는 **자식의 PID(>0)**를 받고, 자식은 0을 받음
* pid[i]==0이면 지금 이 흐름은 자식 프로세스 내부 → 즉시 do_child(i+1) 실행 후 exit(n)으로 종료
* 덕분에 자식은 아래의 waitpid 루프(부모용)로 내려가지 않음
* 부모는 pid[] 배열에 각 자식 PID를 모아둠(나중에 정확히 기다리려고)

```c
    for(i=2; i >= 0;i--){
        n=waitpid(pid[i], &status, 0);
        if(WIFEXITED(status)){
            printf("%d......%d\n", n, WEXITSTATUS(status));
        }
    }
    
    exit(0);
}
```

* 역순(i=2→0) 으로 waitpid(pid[i], ...) : 특정 PID를 지정해서 기다림 → 출력도 역순으로 보장
* waitpid 반환값 n은 종료된 자식의 PID
* WIFEXITED(status) : 정상 종료 여부
* WEXITSTATUS(status) : 자식의 exit(n)에서 준 n 값
* 마지막에 부모 종료

&ensp;n = waitpid(pid[i], &status, 0);<br/>
* waitpid는 자식 프로세스가 끝날 때까지 기다리는 함수예요.
* 원형:

```c
pid_t waitpid(pid_t pid, int *status, int options);
```

* pid : 어떤 자식을 기다릴지 지정
    - >0 : 그 자식 PID만 기다림
    - -1 : 아무 자식이나 기다림 (wait()과 같음)
* status : 자식의 종료 정보를 담을 변수의 주소
* options : 0이면 블로킹(끝날 때까지 기다림)
 
&ensp;여기서는 pid[i]를 넘겼으니, 배열에 저장해둔 특정 자식이 끝날 때까지 기다린다는 뜻이다. 반환값 n은 실제로 종료된 자식의 PID<br/>

&ensp;WEXITSTATUS(status)<br/>
* status에는 자식이 종료될 때 커널이 전달하는 종료 코드와 상태 정보가 들어있다.
* 하지만 status는 그냥 정수 값(비트마스크)이라 그대로 쓰면 해석하기 힘들다. 그래서 매크로로 꺼내 써야 한다.:
    - WIFEXITED(status) → 정상적으로 exit() 했는지 확인 (true/false)
    - WEXITSTATUS(status) → 정상 종료였다면, exit(n)의 n 값을 꺼냄

&ensp;즉, 자식이 exit(3) 하면 WEXITSTATUS(status) = 3이 된다.<br/>

&ensp;전체 흐름<br/>
```c
n = waitpid(pid[i], &status, 0);
if (WIFEXITED(status)) {
    printf("%d......%d\n", n, WEXITSTATUS(status));
}
```

1. waitpid → pid[i] 자식이 끝날 때까지 기다리고, 그 PID를 반환 예: n=29258.
2. status 변수에 자식 종료 정보 저장
3. WIFEXITED(status) → 자식이 exit()로 정상 종료했는지 확인
4. WEXITSTATUS(status) → exit(n)의 n 꺼내온다. 예: exit(3) 했다면 3.

&ensp;출력 예시:<br/>
```bash
29258......3
```

&ensp;→ 29258 (자식 PID), 3 (exit 값)

* waitpid → 자식 수거 + 종료 정보 받기
* WIFEXITED → 정상 종료 판별
* WEXITSTATUS → 자식이 exit()에 넘긴 값 꺼내기

&ensp;요약<br/>
```scss
[자식] exit(3)
    ↓ (정보 전달)
[커널] 종료정보 테이블에 기록
    ↓ (부모가 waitpid로 읽음)
[부모] status 변수에 기록
    ↓
WIFEXITED(status) → 정상종료? OK
WEXITSTATUS(status) → 3
출력: PID......3
```

&ensp;실행 흐름<br/>
1. 부모가 fork() 3번 → 자식 3개(PID a,b,c) 생성, 배열 pid[0]=a, pid[1]=b, pid[2]=c
2. 각 자식은 1초 간격으로 5번 pid/gid/sid 출력 후 exit(생성순서)
3. 부모는 c → b → a 순으로 waitpid(역순 대기)
    - 이미 먼저 끝난 자식이 있어도, 부모는 지정한 PID가 끝날 때까지 그 PID를 기다림
    - 그래서 출력 순서는 항상 역순으로 정렬됨

```css
c......3
b......2
a......1
```

&ensp;PID / PGID / SID 핵심 개념<br/>
* PID (Process ID): 각 프로세스 고유 번호. getpid()
* PPID (Parent PID): 부모 PID. getppid()
* PGID (Process Group ID): **작업 단위(Job Control)**로 묶인 그룹의 ID
    - getpgid(0)로 얻음
    - 같은 작업/파이프라인으로 실행된 프로세스들이 같은 PGID를 공유
    - 보통 그룹 리더의 PID == PGID
* SID (Session ID): 세션 단위. 여러 프로세스 그룹을 포함하는 상위 개념
    - 로그인 셸이 세션 리더인 경우가 흔함.
* 관찰 팁: 같은 프로그램 안에서 찍어보면 세 자식의 PGID와 SID는 모두 동일하게 나오는 게 자연스러움

&ensp;필수 개념<br/>
1. fork() 반환값 규칙
    - 부모: 자식 PID(>0), 자식: 0, 실패: -1
2. 자식에서 곧바로 exit() or _exit() 호출
    - 자식이 부모 흐름(아래 로직)으로 “떨어지지” 않게 즉시 종료하는 게 안전
3. wait() vs waitpid() 차이
    - wait() : 아무 자식이나
    - waitpid(pid, &st, 0) : 특정 pid만 기다림(정밀 제어 가능)
    - 비차단 옵션: WNOHANG
4. WIFEXITED, WEXITSTATUS 매크로
    - 정상 종료인지, 종료 코드 몇 번인지 확인하는 표준 패턴
5. 종료코드 범위: 0~255만 유효(그 이상은 하위 8비트만 전달)
6. 좀비(Zombie) 방지: 자식이 끝나면 반드시 wait*로 수거(reap)해야 함
7. 동시성 출력은 순서 보장 X
    - 여러 자식이 동시에 printf 하면 줄 단위로 섞일 수 있음(여긴 줄마다 \n 있어 비교적 안전)
8. PGID/SID 상속
    - 기본적으로 자식은 부모의 PGID, SID를 물려받음
9. 표준 입출력 버퍼링 주의
    - fork() 직전 버퍼가 비워지지 않으면 중복 출력 가능 → fflush(stdout); 습관
10. 에러 체크 습관화
    - fork, waitpid, printf 등 반환값 점검, 실패 시 perror()

&ensp;왜 역순 wait<br/>
* 문제 요구: 부모는 자식 종료를 생성 순서의 역순으로 대기
* for (i=2; i>=0; i--) waitpid(pid[i], ...) 덕분에, 자식이 실제로는 어떤 순서로 끝나든 부모 출력은 역순으로 고정됨 즉, 동시성(자식 실행 순서)과 보고(부모가 출력하는 순서) 를 분리해서 컨트롤

&ensp;실행 결과<br/>

&ensp;(1) 자식들의 출력<br/>
&ensp;자식들은 거의 동시에 실행되므로 순서가 섞여서 나온다. 각각 5회 반복 출력, 1초 간격<br/>
```markdown
pid=29256, gid=29255, sid=28125
pid=29257, gid=29255, sid=28125
pid=29258, gid=29255, sid=28125
pid=29256, gid=29255, sid=28125
pid=29257, gid=29255, sid=28125
pid=29258, gid=29255, sid=28125
...
```

* pid= → 각 자식의 고유 ID
* gid= → 부모 프로세스의 그룹 ID (모두 동일)
* sid= → 세션 ID (모두 동일)

&ensp;(2) 부모의 출력<br/>
&ensp;세 자식이 다 끝난 뒤 부모가 역순으로 출력<br/>
```markdown
29258......3
29257......2
29256......1
```

* 29258 → 세 번째 자식의 PID
* 3 → exit(3) 값
* 그 뒤로 두 번째 자식(2), 첫 번째 자식(1)

실습_4
=====

`문제 1.`
&ensp;parent process는 3개의 child process를 만들고, 각 child process가 종료할 때까지 대기하였다가 child process의 exit() 값을 출력한 후 종료 합니다. 각 child process는 순서대로 아래 3가지 프로그램 중 하나를 실행시킨 후 exit()을 수행합니다. exit()의 값은 child process가 만들어진 순서 번호입니다.<br/>

&ensp;(a) main() 함수의 인수로 받은 문자열을 5회 출력하는 프로그램입니다. 매회 출력 후 sleep(1) 명령으로 1초간 쉽니다.<br/>

&ensp;(b) 프로세스 id와 group id, session id를 5회 출력하는 프로그램입니다. 매회 출력 후 sleep(1) 명령으로 1초간 쉽니다.<br/>

&ensp;(c) ‘A'부터 ’Z'까지 26개의 알파벳이 쓰여진 “data" 파일에서 한 글자씩 읽어 10회 출력하는 프로그램입니다. 매회 출력 후 sleep(1) 명령으로 1초간 쉽니다.<br/>
```c
int main(void){
    int i, status;
    pid_t pid;

    for (i=0; i<3; i++){
        // child process 생성
        if (/* 첫 번째 child인지 확인 */){
            // 첫 번째 child가 새로운 프로그램 실행 시작
            exit(0);
        }
        else if (/* 두 번째 child인지 확인 */){
            // 두 번째 child가 새로운 프로그램 실행 시작
            exit(0);
        }
        else if (/* 세 번째 child인지 확인 */){
            // 세 번째 child가 새로운 프로그램 실행 시작
            exit(0);
        }
    }
    for (i=0; i<3; i++){
        // 세 child의 종료 상태를 종료 순서대로 확인 & 출력
    }
    exit(0);
}
```

&ensp;전체 시나리오<br/>
```bash
parent(test1)
 ├─ i=0: fork → child #1  ──exec→ child_a(문자열 5회) → exit(1)
 ├─ i=1: fork → child #2  ──exec→ child_b(PID/PGID/SID 5회) → exit(2)
 └─ i=2: fork → child #3  ──exec→ child_c(data에서 10글자) → exit(3)

parent는 wait()를 3번 호출하면서
   종료한 child의 PID와 exit코드를 (종료 ‘순서대로’) 출력.
```

* 세 자식은 동시에 달리기 때문에 출력이 섞여 보이는 건 정상
* parent가 종료 순서대로 pid.....exit_code 형식으로 출력

&ensp;<b>코드 & 분석</b><br/>
&ensp;1) parent: test1.c
```c
#include "common.h"

int main(void){
	int i, status;
	pid_t pid;

	for(i=0; i<3;i++){
		pid = fork();
		if(pid==0 && i == 0){
			execl("./child_a", "child_a", "1", "abcde", (char *)0);
			exit(0);
		}
		else if(pid==0 && i == 1){
			execl("./child_b", "child_b", "2", (char *)0);
			exit(0);
		}
		else if(pid==0){
			execl("./child_c", "child_c", "3", (char *)0);
			exit(0);
		}
	}

	for(i=0; i< 3;i++){
		pid=wait(&status);
		if(WIFEXITED(status)){
			printf("%d.....%d\n", pid, WEXITSTATUS(status));
		}
	}

	exit(0);
}
```

&ensp;분석<br/>
```c
for(i=0; i<3;i++){
    pid = fork();
    if(pid==0 && i == 0){
        execl("./child_a", "child_a", "1", "abcde", (char *)0);
        //perror("execl child_a");  execl 실패시에만 도달 -> 권장 하지만 교수님은 안 씀
        exit(0);
    }
    else if(pid==0 && i == 1){
        execl("./child_b", "child_b", "2", (char *)0);
        exit(0);
    }
    else if(pid==0){
        execl("./child_c", "child_c", "3", (char *)0);
        exit(0);
    }
}
```

* fork() 반환값:
    - child 프로세스: pid == 0
    - parent 프로세스: pid > 0 (자식의 PID)
* 위 if-else 체인은 child에서만 참이 된다.
    - i==0이면 child_a, i==1이면 child_b, i==2이면 child_c 실행.
* execl(path, argv0, arg1, ..., (char*)0);
    - argv[0] 관례상 프로그램 이름 문자열(원하는 값 넣어도 됨)
    - 마지막은 NULL 포인터로 인자 종료를 알려야 함.
* 중요: execl은 성공하면 돌아오지 않는다.

```c
for(i=0; i< 3;i++){
    pid=wait(&status);
    if(WIFEXITED(status)){
        printf("%d.....%d\n", pid, WEXITSTATUS(status));
    }
}
```

* wait 함수 원형: pid_t wait(int *status);
    - ait는 자식 프로세스가 끝날 때까지 기다렸다가:
    - 종료된 자식의 PID를 반환하고 **자식의 종료 상태(exit code + 기타 정보)**를 status라는 변수에 써준다.

* wait(&status)는 종료된 자식의 PID를 리턴, status에 종료정보를 담음.
* WIFEXITED(status)가 참이면 정상 종료한 것. WEXITSTATUS(status)는 exit(코드) 의 그 코드(0~255) 를 돌려준다.
    - 참일 조건: 자식 프로세스가 정상 종료(normal termination) 했을 때만 참. 즉 exit(n) 또는 main 함수 return n; 으로 끝난 경우
* 순서를 강제하고 싶다면 waitpid(특정PID, ...)를 쓰면 됨

&ensp;2)child_a.c - 인자로 받은 문자열 5번 출력<br/>
```c
#include "common.h"

int main(int argc, char **argv){
	int i;
	
	for(i = 0; i < 5; i++){
		printf("%s\n", argv[2]);
		sleep(1);
	}
	
	exit(atoi(argv[1]));
}
```

&ensp;분석<br/>
```c
printf("%s\n", argv[2]);
...
exit(atoi(argv[1]));
```

* argv[1] = "1" → exit(1)
* argv[2] = 출력할 문자열, 여기서는 "abcde"
* 호출 규약 복습 (parent에서 어떻게 불렀나):

```c
execl("./child_a", "child_a", "1", "abcde", (char*)0);
// argv[0]="child_a", argv[1]="1", argv[2]="abcde"
```


&ensp;3)child_b.c - PID/PGID/SID 5번 출력<br/>
```c
#include "common.h"

int main(int argc, char **argv){
	int i;
	
	for(i = 0; i < 5; i++){
		printf("pid=%d, gid=%d, sid=%d\n", getpid(), getpgid(0), getsid(getpid()));
		sleep(1);
	}
	exit(atoi(argv[1]));
}
```

&ensp;분석<br/>

```c
printf("pid=%d, gid=%d, sid=%d\n", getpid(), getpgid(0), getsid(getpid()));
```

* getpid() : 현재 프로세스 ID
* getpgid(0) : 프로세스 그룹 ID(PGID).
    - ※ 화면에는 gid로 찍지만 정확한 용어는 PGID이다.("유저 그룹 ID(gid)"랑 다름)  
* getsid(getpid()) : 세션 ID(SID). 로그인 세션/터미널과 묶음 개념
* exit(atoi(argv[1]))에서 "2" → exit(2)

&ensp;4)child_c.c - data 파일에서 한 글자씩 10회 읽어 출력<br/>
```c
#include "common.h"

int main(int argc, char **argv){
	char buf[2];
	int i, fd;
	
	fd=open("data", O_RDONLY);
	for(i = 0; i < 10; i++){
		read(fd, buf, 1);
		write(1, buf, 1);
		write(1, "\n", 1);
		sleep(1);
	}
	exit(atoi(argv[1]));
}
```

&ensp;분석<br/>
```c
fd=open("data", O_RDONLY);
read(fd, buf, 1);
write(1, buf, 1);
write(1, "\n", 1);
```

* 저수준 시스템콜 사용: open/reand/write/close (표준 I/O인 fopen/fgets/fprintf와 대비)
* 1은 표준 출력(STDOUT_FILENO), 0은 stdin 2는 stderr
* buf는 1바이트씩만 쓰니 '\0'이 없어도 write에는 문제 없음
* 안전하게 하려면 open/read 결과값 체크 + close(fd) 추가:

```c
fd = open("data", O_RDONLY);
if (fd < 0) { perror("open"); exit(1); }
...
ssize_t n = read(fd, buf, 1);
if (n <= 0) break;
...
close(fd);
```

* exit(atoi(argv[1]))에서 "3" → exit(3)

&ensp;표준 입출력(standard I/O)과 파일 디스크립터(FD)<br/>
&ensp;리눅스(유닉스)에서는 모든 입출력 장치(키보드, 모니터, 파일, 네트워크 소켓 등)를 파일처럼 다룬다. 이때 운영체제는 각 프로세스마다 "파일 디스크립터(File Descriptor, FD)"라는 작은 정수를 붙여서 관리한다.<br/>
<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-7.png" width="600"></p>

&ensp;꼭 외워야 할 필수 개념(진짜 시험/실습에서 계속 나옴)<br/>
1. fork() 반환값: child에서 0, parent에서 >0(child PID). 실패 시 -1
2. exec 계열( execl / execlp / execv / execvp )
    - 성공하면 절대 리턴하지 않음(프로세스 이미지 교체)
    - 실패 시에만 반환 → 즉시 perror() 후 exit(1) 같은 패턴이 정석
    - *p가 붙으면 PATH 검색(execlp, execvp)
3. exec 인자 규칙: argv[0]는 관례상 프로그램 이름, 마지막 인자는 NULL 포인터
4. wait / waitpid:
    - wait(&status)는 종료한 어느 자식이든 수거, PID 반환
    - waitpid(pid, &status, 0)는 특정 PID를 기다림
    - WIFEXITED(status) / WEXITSTATUS(status)는 정상 종료/코드(0~255) 판별
5. exit(code): 하위 8비트만 상태코드로 전달됨(0~255) 큰 수는 잘림
6. 표준 입출력 FD 번호: stdin=0, stdout=1, stderr=2
7. 프로세스/그룹/세션:
    - PID(프로세스 식별), PGID(프로세스 그룹), SID(세션)
    - getpgid(0)는 현재 프로세스의 프로세스 그룹 ID. 출력 레이블을 pgid로 쓰자
8. 동시성에 따른 출력 섞임: 동시에 실행되니 줄 순서는 보장 안 됨(정상)
9. 좀비 프로세스: parent가 wait하지 않으면 좀비가 남음. → 항상 자식을 수거
10. 오픈/읽기/쓰기 에러 체크: open/read/write는 반드시 반환값 확인
11. 버퍼링 이슈: fork() 후 stdio 버퍼가 복사될 수 있음. exec로 즉시 교체하면 영향 적지만 fork 직후 출력할 땐 fflush(stdout) 고려
12. 상대/절대 경로: execl("./child_a", ...)는 현재 디렉토리에 실행파일 있어야. PATH 검색은 execlp/execvp
13. 헤더: wait 매크로는 <sys/wait.h>, FD/open은 <fcntl.h>, read/write는 <unistd.h> (여기선 common.h가 다 묶었을 가능성)
14. sleep(1): 1초간 휴면. 시그널 등으로 깨어날 수 있음(반환값은 남은 시간)
15. 리턴 대신 exit: main의 return도 결국 exit와 유사하게 처리되지만 자식에서 **명시적으로 exit(code)**가 더 명확

&ensp;실행 결과<br/>
```makefile
A
pid=10882, gid=10880, sid=10503
abcde
B
pid=10882, gid=10880, sid=10503
abcde
C
pid=10882, gid=10880, sid=10503
abcde
D
pid=10882, gid=10880, sid=10503
abcde
E
abcde
pid=10882, gid=10880, sid=10503
F
10881.....1
10882.....2
G
H
I
J
10883.....3
```

&ensp;어떤 child가 무엇을 출력했나?<br/>
&ensp;1. child_c (exit(3))
* data 파일에서 알파벳 하나씩 읽어서 10개 출력
* 그래서 A, B, C, D, E, F, G, H, I, J 순서대로 보임
* → 출력: A B C D E F G H I J
&ensp;2. child_b (exit(2))<br/>
* 자기 PID/PGID/SID를 5번 출력.
* → 출력:

```makefile
pid=10882, gid=10880, sid=10503
pid=10882, gid=10880, sid=10503
...
(총 5번)
```

&ensp;3. child_a(exit(1))<br/>
* 문자열 "abcde"를 5번 출력.
* → 출력:

```makefile
abcde
abcde
abcde
abcde
abcde
```

&ensp;왜 섞여 보일까?<br/>
* 새 child가 동시에 실행되기 때문에 sleep(1) 주기마다 서로 교차해서 출력됨
* 그래서 실제 결과에서는 `A → pid=... → abcde → B → pid=... → abcde ...` 처럼 섞여 보인다.(정상 동작임)

&ensp;parent의 출력<br/>
```markdown
10881.....1
10882.....2
10883.....3
```

* parent가 wait(&status)로 자식이 끝날 때마다 결과를 출력.
* 포맷: 자식 PID.....exit 코드
    - PID=10881, exit code=1 → child_a
    - PID=10882, exit code=2 → child_b
    - PID=10883, exit code=3 → child_c
* 순서가 저렇게 된 건, child_a → child_b → child_c 순으로 먼저 종료했기 때문이에요.

&ensp;최종 정리<br/>
1. child_a → "abcde" 5번 출력 후 exit(1)
2. child_b → PID/PGID/SID 5번 출력 후 exit(2)
3. child_c → data 파일에서 A~J 10개 출력 후 exit(3)
4. parent는 종료한 자식들의 PID와 exit code를 확인해서

```markdown
10881.....1
10882.....2
10883.....3
```