---
title: "Lect7. 실습"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-09-25
last_modified_at: 2025-09-25
---

실습_1
=====

`문제 1.`
&ensp; main() 함수의 인수로 정수를 하나 받아, 해당 정수 만큼의 child 프로세스를 생성하는 프로그램을 작성하시오. 생성된 child 프로세스는 자신의 프로세스 id, 프로세스 그룹 id, session id를 출력한 후 종료합니다. 아래 프로그램을 사용하세요.<br/>
```c
void do_child(void){
    // process id, group id, session id 출력
    exit(0); // 이 부분의 코드는 변경 금지
}

int main(/* 인수 설정 */){
    int num, i;
    pid_t pid;

    // main 함수의 인자를 정수로 변환

    for (i=0; i<num; i++){
        // child process 생성
        if (/* child process 인지 확인 */){
            do_child();
        }
    }

    for (i=0; i<num; i++){ // 이 부분의 코드는 변경 금지
        wait(0);
    }

    return 0;
}
```

&ensp;<b>코드</b><br/>
```c
#define _XOPEN_SOURCE 500

#include "common.h"
#include <unistd.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>

void do_child(void){
	printf("pid=%d, gid= %d, sid= %d\n", getpid(), getpgid(0), getsid(getpid()));  
	exit(0);
}

int main(int argc, char **argv){
	int num, i;
	pid_t pid;
	
	num=atoi(argv[1]);
	
	for(i = 0; i < num; i++){
		pid=fork();
		if(pid == 0){
			do_child();
		}
	}
	for(i=0; i < num;i++){
		wait(0);
	}
	
	return 0;
}
```

* main이 명령줄 인자로 받은 숫자(num)만큼 반복하며 fork() 호출
* 매 반복에서:
    - 부모: fork()가 돌려준 자식 PID(양수)를 받아 다음 반복으로 진행
    - 자식: fork()가 0을 돌려주므로 do_child() 실행 → 정보 출력 → exit(0)
* 부모는 마지막에 wait(0)을 num번 호출해 좀비 프로세스가 남지 않게 수거

&ensp;<b>코드 분석</b><br/>
```c
void do_child(void){
    printf("pid=%ld, ppid= %ld, sid= %ld", getpid(), getppid(), getsid());
    exit(0);
}
```

* 자식 프로세스가 실행하는 함수
* getpid() : 현재 프로세스 ID
* getpgid(0) : 현재 프로세스의 그룹 ID. (0은 “자기 자신”이라는 의미)
* getsid(getpid()) : 현재 프로세스가 속한 세션 ID
* exit(0) : 문제 조건에 맞춰 자식은 출력 후 종료

&ensp;메인 함수<br/>
```c
int main(int argc, char **argv){
    int num, i;
    pid_t pid;
	
    num = atoi(argv[1]);  // 명령줄 두 번째 인자를 정수로 변환
```

* 여기서 argv[1]검증이 없음 → ./a.out만 실행하면 세그폴트 발생
* 반드시 argc < 2 검사 필요

&ensp;argv[1]<br/>

&ensp;예를 들어 프로그램을 이렇게 실행:<br/>
```bash
./test1.out 5
```

* argc == 2
* argv[0] == "./test1.out" (프로그램 이름)
* argv[1] == "5" (우리가 입력한 문자열 "5")

&ensp;즉, argv[1]은 "5"라는 문자열이다.<br/>

&ensp;atoi()<br/>
* atoi = ASCII to Integer 의 약자.
* <stdlib.h>에 정의된 함수.
* "123" 같은 문자열을 정수 123으로 바꿔 

```c
int x = atoi("123");  // x == 123
```

&ensp;main 함수의 인자<br/>
```c
int main(int argc, char **argv)
```

* argc : 인자의 개수 (argument count)
* argv : 인자 문자열들을 가리키는 포인터 배열 (argument vector)

&ensp;프로그램 실행할 때 준 인자들을 문자열 배열 형태로 전달받는다.<br/>

&ensp;실행 예시<br/>
&ensp;만약 프로그램을 이렇게 실행했다고 한다.:<br/>
```bash
./a.out hello 123
```

* argc == 3
* argv[0] == "./a.out" (실행한 프로그램 이름)
* argv[1] == "hello"
* argv[2] == "123"
* argv[3] == NULL (배열 끝 표시)

&ensp;argv는 무엇인가?<br/>
* argv는 문자열(char *)들을 담고 있는 배열을 가리킵니다.
* 즉, argv 자체는 char * 타입의 배열을 가리키는 포인터 → 그래서 char **argv

&ensp;비유:<br/>
```css
argv ──▶ [주소1][주소2][주소3][NULL]
          │      │      │
          ▼      ▼      ▼
        "./a.out" "hello" "123"
```

&ensp;인덱스로 접근<br/>
* argv[i] → i번째 인자 (문자열 시작 주소, char *)
* argv[i][j] → i번째 인자의 j번째 문자 (char)

&ensp;예시:<br/>
```c
printf("%s\n", argv[1]);    // "hello"
printf("%c\n", argv[1][0]); // 'h'
printf("%c\n", argv[1][1]); // 'e'
```

&ensp;포인터 문법으로 풀어보기<br/>
* argv[i] 는 *(argv + i) 와 같음 → i번째 문자열의 시작 주소
* argv[i][j] 는 *(*(argv + i) + j) 와 같음 → i번째 문자열의 j번째 문자

&ensp;예를 들어 argv[1][2]:<br/>
1. argv + 1 → 두 번째 인자의 주소
2. *(argv + 1) → "hello" 문자열의 시작 주소
3. *( *(argv + 1) + 2 ) → "hello"의 2번째 인덱스 문자 'l'

&ensp;그림으로 표현<br/>
```css
argv (char **)
   │
   ├──> argv[0] ──> "./a.out\0"
   │
   ├──> argv[1] ──> "hello\0"
   │
   └──> argv[2] ──> "123\0"
```

* argv는 문자열 배열의 시작을 가리킴
* 각 원소(argv[i])는 문자열(=char 배열)의 시작 주소
* 그래서 이중 포인터 char **가 되는 거이다.

```c
for (i = 0; i < num; i++) {
    pid = fork();  //fork()는 현재 프로세스를 복제해서 자식 프로세스를 만든다. 부모와 자식이 둘 다 fork()호출 이후부터 실행을 이어간다.
    if (pid == 0) {
        do_child();
    }
}
```

* 부모: 계속 fork() 호출 → 자식 N개 생성
* 자식: pid==0 이면 do_child() 실행 후 exit(0) → 루프를 더 이상 돌지 않음

<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-5.png" width="600"></p>

&ensp;pid == 0의 의미<br/>
* 자식 프로세스만 이 블록을 실행
* 부모는 pid가 양수이므로 실행하지 않음 → 계속 루프 돌며 다음 fork() 호출

&ensp;결국 pid==0은 내가 지금 자식 프로세스 쪽에서 실행 중이다.라는 신호이다.<br/>

&ensp;그림으로 표현<br/>
```perl
부모 프로세스 (pid=1000)
    |
    | fork()
    |
 ┌──┴──────────────────┐
부모 (pid=1000)    자식 (pid=1001)
pid=fork()=1001    pid=fork()=0
```

* 부모 입장: pid 변수 안에는 새로 생긴 자식 PID(1001)가 들어 있음
* 자식 입장: pid 변수 안에는 항상 0

* pid == 0 → 자식 코드 실행 경로
* pid > 0 → 부모 코드 실행 경로
* pid < 0 → fork 실패

```c
for (i=0; i < num; i++) {
    wait(0);
}
```

* 부모는 자식 N개가 모두 끝날 때까지 기다림 → 좀비 프로세스 방지

&ensp;<b>실행 예시</b><br/>
```bash
$ ./test1.out 3
pid=12345, gid=12345, sid=12345
pid=12346, gid=12345, sid=12345
pid=12347, gid=12345, sid=12345
```

* 자식 3개(num=3)를 만들었으니, 세 줄 출력
* pid: 각각 다름 (자식마다 고유 ID)
* gid: 보통 첫 번째 부모의 pid (즉, 자식들이 같은 그룹에 속함)
* sid: 같은 세션에서 실행됐으므로 동일


`문제 2.`
&ensp;main() 함수의 인수로 파일 이름과 정수 하나를 입력으로 받아, 먼저 입력받은 이름의 파일을 open한 후, 해당 정수 만큼의 child 프로세스를 생성하는 프로그램을 작성하시오. 생성된 child 프로세스는 open 된 파일에서 2개의 문자를 읽어 자신의 id와 함께 출력한 후 종료 합니다. (child 프로세스가 open하는 파일에는 A부터 Z까지 26개의 문자가 저장되어 있고, 표준 출력은 printf()를 사용합니다.)<br/>
```c
void do_child(/* 인수 전달 */){
    char buf[5]={0};

    // 파일에서 문자 2개 읽어 자신의 process id와 함께 출력
    exit(0); // 이 부분의 코드는 변경 금지
}

int main(/* 인수 설정 */){
    int num, i, fd;
    pid_t pid;

    // main 함수의 인자로 주어진 파일 open
    // main 함수의 인자를 정수로 변환

    for (i=0; i<num; i++){
        // child process 생성
        if (/* child process 인지 확인 */){
            do_child();
        }
    }

    for (i=0; i<num; i++){ // 이 부분의 코드는 변경 금지
        wait(0);
    }

    return 0;
}
```

&ensp;<b>코드</b><br/>
```c
#include "common.h"

void do_child(int fd){
	char buf[5] = {0};
	
	read(fd, buf, 2);
	printf("%s by %ld\n", buf, getpid());
	exit(0);
}

int main(int argc, char **argv){
	char buf[5] = {0};
	int num, i, fd;
	pid_t pid;
	
	fd=open(argv[1], O_RDONLY);
	num=atoi(argv[2]);
	
	for(i=0;i < num;i++){
		pid=fork();
		if(pid==0){
			do_child(fd);
		}
	}
	
	for(i= 0; i < num;i++){
		wait(0);
	}
	return 0;
}
```

&ensp;<b>코드 분석</b><br/>

```c
void do_child(int fd){
    char buf[5] = {0};
	
    read(fd, buf, 2);
    printf("%s by %ld\n", buf, getpid());
    exit(0);
}
```

&ensp;do_child 함수<br/>
* fd: 파일 디스크립터(부모가 open()해서 넘겨줌)
* char buf[5] = {0};
    - 읽은 데이터를 저장할 임시 버퍼
    - 5바이트로 만든 이유는 "문자 2개" + '\0'(문자열 끝) 을 위해 여유 있게 잡은 것
* read(fd, buf, 2);
    - 파일에서 2바이트(2문자) 읽어서 buf에 저장
    - 예: 첫 번째 자식은 "AB", 두 번째는 "CD", …
* printf("%s by %ld\n", buf, getpid());
    - buf에 담긴 문자와 자기 PID를 출력
    - 예: "AB by 12345"
* exit(0);
    - 자식 프로세스 종료(문제 조건)

```c
int main(int argc, char **argv){
    char buf[5] = {0};
    int num, i, fd;
    pid_t pid;
```

&ensp;main 함수 시작<br/>
* argc, argv: 명령줄 인자
    - 예: ./prog alphabet.txt 3
    - argv[1] = "alphabet.txt", argv[2] = "3"
* fd: 파일 디스크립터
* num: 자식 프로세스 개수
* pid: fork()의 반환값 저장

```c
    fd = open(argv[1], O_RDONLY);
    num = atoi(argv[2]);
```

* argv[1]: 파일 이름 (alphabet.txt)
* open(argv[1], O_RDONLY); → 읽기 전용으로 파일 열기
* argv[2]: 문자열 "3"
* atoi(argv[2]) → 정수 3으로 변환 → num

```c
    for (i = 0; i < num; i++){
        pid = fork();
        if (pid == 0){
            do_child(fd);
        }
    }
```

&ensp;자식 생성 루프<br/>
* fork()가 자식을 생성
    - 부모: pid > 0 → 계속 반복
    - 자식: pid == 0 → do_child(fd) 실행 후 종료
* 따라서 자식 N개가 각각 read(fd, buf, 2); 실행
* 각 자식이 파일에서 이어지는 위치에서 2바이트씩 읽어옴 → 결과적으로 파일에서 순서대로 2글자씩 나눠 갖게 됨

```c
    for (i = 0; i < num; i++){
        wait(0);
    }
    return 0;
}
```

&ensp;부모 프로세스<br/>
* 모든 자식이 끝날 때까지 기다림(wait(0))
* 좀비 프로세스 방지
* 프로그램 종료

&ensp;<b>실행 과정</b><br/>
&ensp;준비<br/>
```bash
echo -n "ABCDEFGHIJKLMNOPQRSTUVWXYZ" > alphabet.txt
```

```bash
AB by 12345
CD by 12346
EF by 12347
```

&ensp;(실제로는 OS 스케줄링 때문에 순서가 뒤바뀔 수도 있음 → CD가 먼저 나오고 AB가 나올 수도 있어요.)<br/>

&ensp;<b>이해 포인트</b><br/>
1. open & fd 공유
    - 부모가 연 파일 디스크립터 fd는 fork()로 자식에게 복사됨.
    - 파일 오프셋도 공유되므로, 첫 번째 자식이 "AB" 읽으면 두 번째 자식은 "CD"부터 읽음.
2. fork() 반환값
    - 부모: 양수(자식 PID) → 루프 계속
    - 자식: 0 → do_child(fd) 실행 → exit
3. read() 동작
    - 현재 파일 오프셋에서 2바이트 읽고, 오프셋을 앞으로 2 증가시킴
    - 여러 자식이 순서대로 2바이트씩 읽게 됨
4. printf("%s by %ld\n", buf, getpid());
    - buf는 read()로 채워진 2글자 문자열
    - %ld는 long 타입 출력 (pid_t를 (long) 캐스팅하는 게 안전)
5. wait()
    - 부모가 모든 자식이 끝날 때까지 기다림
    - 좀비 방지