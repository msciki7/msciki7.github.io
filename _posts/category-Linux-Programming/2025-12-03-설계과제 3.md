---
title: "설계과제 3"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-12-03
last_modified_at: 2025-12-03
---


talk 프로그램
====

&ensp;목표: 3명의 사용자가 서로 문자열을 주고받는 대화(talk)가 가능한 프로그램을 IPC(FIFO 등)으로 구현하는 과제<br/>

&ensp;1. 문제 전체 이해<br/>
&ensp;문제는 3명의 사용자(프로세스)가 동시에 실행되면서 서로 문자열을 주고받는 talk 프로그램을 만드는 것이다.<br/>

&ensp;예시<br/>
```shell
$ ./talk 1   ← 사용자 1
$ ./talk 2   ← 사용자 2
$ ./talk 3   ← 사용자 3
```

&ensp;이 3개가 동시에 실행되면 누가 무엇을 입력하든 모든 사용자가 메시지를 비동기적으로 보게된다.<br/>

&ensp;문제 조건 분석<br/>
&ensp;(a) 통신 시작 시 ID 전달, 메시지 번호(msg#) 증가<br/>
&ensp;프로그램 실행 시 main 인자로 id(1~3)을 받는다.<br/>
&ensp;그리고 메시지를 출력할 때는 항상 다음 형태<br/>
```bash
[sender=N & msg#=M] 메시지내용
```

&ensp;여기서<br/>
* sender = 보낸 사용자 번호
* msg# = 전역 메시지 번호 (1부터 전체 메시지 개수까지 증가)

&ensp;사용자 1이 보내든, 사용자 3이 보내든 "전체 메시지 순서"는 하나여야 한다.<br/>

&ensp;(b) 3명 모두 talk를 시작하고, 3명 모두 talk를 종료해야 함<br/>
&ensp;3명 전부 실행 중이어야 한다. 한 명만 먼저 꺼지면 안 됨.<br/>

&ensp;(c) 입력은 비동기적으로 처리 (동시에 입력해도 OK)<br/>
&ensp;누가 입력하든 상관없이 입력 → 전송은 독립적으로 이루어진다. 즉, read()가 block 되더라도 output은 block 되면 안 된다.<br/>

&ensp;(d) 메시지는 전역 순서대로 출력되어야 한다<br/>
&ensp;문제의 핵심은 **메시지 번호가 꼬이지 않도록 보장**하는 것<br/>

&ensp;아래처럼 메시지가 전역적으로 순서를 하나로 맞춰야 한다:<br/>
```bash
[sender=1 & msg#=1] abc
[sender=2 & msg#=2] def
[sender=1 & msg#=3] ghi
[sender=3 & msg#=4] jkl
...
```

&ensp;msg#은 3명이 공유하는 전역카운터이며 메시지가 출력되는 순서도 동일해야 한다.<br/>

&ensp;(e) 자기 자신이 입력한 메시지는 다시 출력 X<br/>
&ensp;사용자 1이 입력한 메시지는 사용자 1 화면에는 보이면 안 된다.<br/>

&ensp;문제 예시 분석<br/>

&ensp;실행 표 요약<br/>

| 사용자 1                       | 사용자 2                       | 사용자 3                       |
| --------------------------- | --------------------------- | --------------------------- |
| talk 1 실행                   | talk 2 실행                   | talk 3 실행                   |
| abc 입력                      |                             |                             |
| 출력: [sender=1 & msg#=1] abc | 출력 동일                       | 출력 동일                       |
|                             | def 입력                      |                             |
| 출력: def                     | 출력: [sender=2 & msg#=2] def | 출력 동일                       |
| ghi 입력                      |                             |                             |
| 출력: [sender=1 & msg#=3] ghi | 출력 동일                       | 출력 동일                       |
|                             |                             | jkl 입력                      |
| 출력: jkl                     | 출력: jkl                     | 출력: [sender=3 & msg#=4] jkl |

&ensp;메시지는 전역 순서로 움직인다. → 메시지 입력 순서대로 msg# 증가.<br/>
&ensp;메시지는 모든 사용자에게 동시에 전달된다. → 보낸 사용자에게는 출력하지 않는다.<br/>

1차 계획서
=====

### 1. (c) 조건을 만족시키기 위해 필요한 작업

> (c): 사용자가 입력한 문자열은 전송된 사용자 ID와 함께 출력된다.

&ensp;1) 송신 메시지 포맷 정의<br/>
&ensp;모든 메시지는 다음 형태로 전송한다.<br/>
```bash
[sender=ID & msg#=K] 내용
```

&ensp;여기서<br/>
* `ID` = 메시지를 보낸 사용자 번호(1, 2, 3)
* `msg#` = 해당 사용자가 보낸 메시지 번호

&ensp;2) 송신 시 두 사용자에게 메시지를 각각 전달<br/>
&ensp;예: user 1이 메시지를 보냄 → user 2, user 3에게 각각 write.<br/>

&ensp;3) FIFO를 통해 메시지를 전송받는 프로세스는 그대로 출력<br/>
&ensp;수신자가 prefix가 붙은 문자열을 그대로 화면에 출력하면 조건 (c)가 충족된다.<br/>

### 2. FIFO를 이용하여 talk 프로그램을 구현하는 경우, 필요한 FIFO의 개수

&ensp;FIFO는 단방향(one-way) 통신이다. 한 FIFO는 한쪽에서 write → 다른 쪽에서 read만 가능하다.<br/>
&ensp;3명의 사용자(User1, User2, User3)가 서로 양방향 통신하려면 다음 경로가 필요하다<br/>

| 방향    | 설명                    |
| ----- | --------------------- |
| 1 → 2 | user1이 user2에게 보내는 경로 |
| 2 → 1 | user2가 user1에게 보내는 경로 |
| 1 → 3 | user1이 user3에게 보내는 경로 |
| 3 → 1 | user3가 user1에게 보내는 경로 |
| 2 → 3 | user2 → user3         |
| 3 → 2 | user3 → user2         |

&ensp;총 6개의 단방향 경로가 필요하므로<br/>
&ensp;**필요한 FIFO의 개수 = 6개**<br/>

### 3. FIFO만 사용했을 때 (d) 조건을 만족시킬 수 있는가?

&ensp;예<br/>
&ensp;이유: 본 프로그램은 3명의 사용자 중 **사용자 1을 ‘중앙 서버(server)’ 역할로 지정하는 구조**를 사용하였다.<br/>
&ensp;모든 메시지는 사용자 2와 3에서 발생하더라도 반드시 사용자 1을 거쳐 전달되는 구조이므로 FIFO만으로도 (d)의 조건을 충족할 수 있다.<br/>

&ensp;1) 전체 구조: 사용자 1 = 서버 + 사용자<br/>
* 사용자 2, 3은 자신의 메시지를 raw 텍스트 그래도 사용자 1에게 보냄(FIFO: 2→1, 3→1)
* 사용자 1은 메시지를 받는 즉시
    - **전역 메시지 번호(global_seq)** 를 증가시키고
    - `[sender=X & msg#=K]` 메시지 형식으로 변환하여
    - 사용자 2, 3에게 다시 전송(FIFO: 1→2, 1→3)

&ensp;결과적으로 모든 메시지의 흐름은 user2 → user1 → user2/3,
user3 → user1 → user2/3, user1 → user2/3 형태가 되고 전역 순서는 항상 user1에서 결정된다.<br/>

&ensp;2) 전역 메시지 번호(global ordering) 보장<br/>
&ensp;전역 메시지 번호 global_seq는 사용자 1 내부 변수로만 관리되며 메시지가 들어올 때마다 하나씩 증가한다.<br/>
&ensp;순서는:<br/>
&ensp;1 → 2 → 3 → 4 → 5 → …<br/>
&ensp;모든 메시지가 사용자 1을 반드시 통과하므로 모든 사용자에게 **동일한 순서, 동일한 번호**로 메시지가 전달된다.<br/>

&ensp;3) 중복 및 누락 문제 없음<br/>
&ensp;각 메시지는 다음 순서를 따른다.<br/>
1. 사용자 2 또는 3이 raw 메시지를 1에게 write
2. 사용자 1이 단 한 번 global_seq를 증가
3. 1→2, 1→3 두 FIFO에 정확히 한 번씩 write
4. 사용자 2, 3은 자기에게 전달된 메시지 그대로 출력
* 각 메시지는 사용자 1에서 정확히 한 번만 번호가 매겨지고,
* 사용자 2와 3에게도 정확히 한 번씩만 전달되므로
* 중복/누락이 발생할 수 없다.

&ensp;4) FIFO만 사용했음에도 가능한 이유<br/>
&ensp;이 구조는 다음 특징 때문에 가능하다.<br/>
* FIFO만 사용했지만
* 메시지 순서 관리와 브로드캐스트를 모두 사용자 1이 담당하는 방식이기 때문에 FIFO가 가지는 순서 보장 불가 문제를 중앙 집중 방식으로 해결한다.

&ensp;FIFO는 단순한 데이터 스트림이지만 전역 순서를 사용자 1에게 결정함으로써 FIFO의 구조적 한계를 우회한 방식이다.<br/>

&ensp;talk-fifo 코드<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/select.h>

#define MAX 256

void make_name(char *buf, int from, int to) {
    sprintf(buf, "/tmp/fifo_%d_%d", from, to);
}

/* ================= FIFO 생성 (1번만 실행) ================= */
void init_fifos_for_server() {
    char path[32];
    int pairs[4][2] = {
        {2,1}, {3,1},
        {1,2}, {1,3}
    };

    for (int i = 0; i < 4; i++) {
        make_name(path, pairs[i][0], pairs[i][1]);
        unlink(path);
        mkfifo(path, 0600);
    }
}

/* ================= SERVER + USER 1 ================= */
void run_server_and_user1() {
    char f21[32], f31[32];
    make_name(f21, 2, 1);
    make_name(f31, 3, 1);

    int fd21 = open(f21, O_RDONLY | O_NONBLOCK);
    int fd31 = open(f31, O_RDONLY | O_NONBLOCK);

    if (fd21 < 0 || fd31 < 0) {
        perror("open fifo");
        exit(1);
    }

    int maxfd = fd21 > fd31 ? fd21 : fd31;
    if (STDIN_FILENO > maxfd) maxfd = STDIN_FILENO;

    int global_seq = 0;
    fd_set set;

    char buf[MAX], line[MAX], out[MAX], path[32];

    while (1) {
        FD_ZERO(&set);
        FD_SET(STDIN_FILENO, &set);
        FD_SET(fd21, &set);
        FD_SET(fd31, &set);

        select(maxfd + 1, &set, NULL, NULL, NULL);

        /* ---------- 1번 사용자 입력 ---------- */
        if (FD_ISSET(STDIN_FILENO, &set)) {
            if (!fgets(line, sizeof(line), stdin)) break;

            if (!strcmp(line, "talk_quit\n")) {
                strcpy(out, "talk_quit\n");

                for (int to = 2; to <= 3; to++) {
                    make_name(path, 1, to);
                    int fd = open(path, O_WRONLY);
                    if (fd >= 0) {
                        write(fd, out, strlen(out));
                        close(fd);
                    }
                }
                break;
            }

            global_seq++;

            /* snprintf로 메시지 포맷 생성 */
            snprintf(out, sizeof(out),
                     "[sender=%d & msg#=%d] %s",
                     1, global_seq, line);

            /* 1번은 자신 제외 → 2,3에게만 전송 */
            for (int to = 2; to <= 3; to++) {
                make_name(path, 1, to);
                int fd = open(path, O_WRONLY);
                if (fd >= 0) {
                    write(fd, out, strlen(out));
                    close(fd);
                }
            }
        }

        /* ---------- 2번 메시지 처리 ---------- */
        if (FD_ISSET(fd21, &set)) {
            int n = read(fd21, buf, MAX - 1);
            if (n > 0) {
                buf[n] = '\0';

                if (!strcmp(buf, "talk_quit\n")) {
                    strcpy(out, "talk_quit\n");
                    for (int to = 2; to <= 3; to++) {
                        make_name(path, 1, to);
                        int fd = open(path, O_WRONLY);
                        if (fd >= 0) {
                            write(fd, out, strlen(out));
                            close(fd);
                        }
                    }
                    break;
                }

                global_seq++;

                printf("[sender=2 & msg#=%d] %s", global_seq, buf);

                /* 포맷된 메시지 */
                snprintf(out, sizeof(out),
                         "[sender=%d & msg#=%d] %s",
                         2, global_seq, buf);

                /* sender=2 → 받는 쪽은 1,3 */
                int receivers[2] = {1, 3};
                for (int i = 0; i < 2; i++) {
                    int to = receivers[i];
                    make_name(path, 1, to);
                    int fd = open(path, O_WRONLY);
                    if (fd >= 0) {
                        write(fd, out, strlen(out));
                        close(fd);
                    }
                }
            }
        }

        /* ---------- 3번 메시지 처리 ---------- */
        if (FD_ISSET(fd31, &set)) {
            int n = read(fd31, buf, MAX - 1);
            if (n > 0) {
                buf[n] = '\0';

                if (!strcmp(buf, "talk_quit\n")) {
                    strcpy(out, "talk_quit\n");
                    for (int to = 2; to <= 3; to++) {
                        make_name(path, 1, to);
                        int fd = open(path, O_WRONLY);
                        if (fd >= 0) {
                            write(fd, out, strlen(out));
                            close(fd);
                        }
                    }
                    break;
                }

                global_seq++;

                printf("[sender=3 & msg#=%d] %s", global_seq, buf);

                snprintf(out, sizeof(out),
                         "[sender=%d & msg#=%d] %s",
                         3, global_seq, buf);

                /* sender=3 → 받는 쪽은 1,2 */
                int receivers[2] = {1, 2};
                for (int i = 0; i < 2; i++) {
                    int to = receivers[i];
                    make_name(path, 1, to);
                    int fd = open(path, O_WRONLY);
                    if (fd >= 0) {
                        write(fd, out, strlen(out));
                        close(fd);
                    }
                }
            }
        }
    }
}

/* ======================= CLIENT 2,3 ======================= */
void run_client(int myid) {
    char fin[32], fout[32];

    make_name(fin, 1, myid);   // 서버 → 클라이언트
    make_name(fout, myid, 1);  // 클라이언트 → 서버

    int fd_in = open(fin, O_RDONLY | O_NONBLOCK);
    if (fd_in < 0) { perror("open fifo_in"); exit(1); }

    int maxfd = fd_in > STDIN_FILENO ? fd_in : STDIN_FILENO;

    fd_set set;
    char buf[MAX], line[MAX];

    while (1) {
        FD_ZERO(&set);
        FD_SET(STDIN_FILENO, &set);
        FD_SET(fd_in, &set);

        select(maxfd + 1, &set, NULL, NULL, NULL);

        /* 키보드 입력 */
        if (FD_ISSET(STDIN_FILENO, &set)) {
            if (!fgets(line, sizeof(line), stdin)) break;

            if (!strcmp(line, "talk_quit\n")) {
                int fd = open(fout, O_WRONLY);
                if (fd >= 0) {
                    write(fd, "talk_quit\n", 10);
                    close(fd);
                }
                break;
            }

            int fd = open(fout, O_WRONLY);
            if (fd >= 0) {
                write(fd, line, strlen(line));
                close(fd);
            }
        }

        /* 서버가 보낸 메시지 수신 */
        if (FD_ISSET(fd_in, &set)) {
            int n = read(fd_in, buf, MAX - 1);
            if (n > 0) {
                buf[n] = '\0';

                if (!strcmp(buf, "talk_quit\n"))
                    break;

                printf("%s", buf);
            }
        }
    }
}

/* ============================ MAIN ============================ */
int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("usage: %s <id:1~3>\n", argv[0]);
        exit(1);
    }

    int myid = atoi(argv[1]);

    if (myid == 1)
        init_fifos_for_server();

    if (myid == 1)
        run_server_and_user1();
    else
        run_client(myid);

    return 0;
}
```

### 4. message queue를 이용하여 talk 프로그램을 구현하는 경우 필요한 message queue의 개를 쓰시오

&ensp;정답 1개<br/>
&ensp;Message Queue는 FIFO(named pipe)와 달리 하나의 큐 안에서 메시지 타입(mtype)을 통해 메시지를 분류할 수 있는 구조이다.<br/>

&ensp;Message Queue 1개로 충분한 이유<br/>

&ensp;1. 메시지가 큐 내부에서 순서대로 저장된다.<br/>
&ensp;Message Queue는 ENQUEUE → DEQUEUE 구조이므로 들어간 순서대로 메시지가 보관된다.<br/>

&ensp;메시지가 다음처럼 들어오면,<br/>
1. user1: “A”
2. user3: “B”
3. user2: “C”

&ensp;큐 내부 상태는: <br/>
```css
[A] → [B] → [C]
```

&ensp;→ 모든 프로세스는 동일한 순서로 메시지를 읽을 수 있는 기반이 이미 마련됨<br/>

&ensp;2. 메시지 타입(mtype)으로 수신자를 구분할 수 있다.<br/>
* 서버 inbox : `mtype = 100`
* user2 inbox : `mtype = 2`
* user3 inbox : `mtype = 3`

| 목적지               | mtype |
| ----------------- | ----- |
| 서버가 읽어야 하는 메시지    | 100   |
| user2가 읽어야 하는 메시지 | 2     |
| user3가 읽어야 하는 메시지 | 3     |

&ensp;사용자별로 우편함이 따로 있는 효과를 만들어낸다.<br/>

&ensp;3. 한 큐 안에 다양한 타입 메시지를 넣을 수 있어, 여러 큐가 필요 없다.<br/>
&ensp;Message Queue는 다음을 지원한다:<br/>
```scss
msgrcv(qid, buf, size, mtype, ...)
```

* mtype=2 → user2 전용 메시지만 읽음
* mtype=3 → user3 전용 메시지만 읽음
* mtype=100 → 서버 전용 수신함

&ensp;하나의 큐 안에 서버 서버 inbox + user2 inbox + user3 inbox 모두 담을 수 있다. 따라서 message queue는 1개만 필요하다.<br/>

### 5. Message Queue로 (d) 조건을 만족할 수 있는가?

> (d) 동일한 문자열이 두 번 이상 출력되거나 누락되지 않아야 하며, 모든 사용자에서 출력되는 메시지의 순서가 항상 동일해야 한다.

&ensp; 예<br/>

&ensp;이유<br/>

&ensp;1) 모든 메시지가 서버를 거치므로 전역 순서를 서버가 통제한다.<br/>
&ensp;클라이언트(user2, user3)는 메시지를 보낼 때:<br/>
```shell
mtype = 100 (서버 inbox)
```

&ensp;서버는 모든 메시지를 한 줄로 받는다.<br/>
```css
user2 → "a"  → 서버
user3 → "b"  → 서버
user2 → "c"  → 서버
```

| 수신순서 | sender | 내용 | 부여된 msg# |
| ---- | ------ | -- | -------- |
| 1    | 2      | a  | 1        |
| 2    | 3      | b  | 2        |
| 3    | 2      | c  | 3        |

&ensp;이 번호는 서버 단 하나만 관리하므로 충돌하지 않는다.<br/>

&ensp;2) 서버는 각 메시지를 2번, 3번 사용자에게만 전송한다.<br/>
&ensp;자기 자신에게는 보내지 않기 때문에 중복도 없다.<br/>
```bash
mtype = 2 → user2 inbox
mtype = 3 → user3 inbox
```

&ensp;따라서 user2, user3은 반드시 이 순서대로 메시지를 받는다.<br/>
```bash
msg#1 → msg#2 → msg#3
```

&ensp;사용자마다 출력 순서가 다를 가능성이 없다.<br/>

&ensp;3) Message Queue는 메시지를 절대로 섞지 않는다.<br/>
&ensp;Message Queue는 다음을 보장한다:<br/>
* 메시지 단위 유지(partial read 없음)
* 타입별 filtering 지원
* 같은 타입끼리는 입력 순서대로 dequeue됨

&ensp;메시지 순서가 뒤바뀌지 않는다.<br/>
&ensp;메시지가 중간에 사라지지도 않는다.<br/>
&ensp;2번 사용자오 3번 사용자는 항상 동일한 최종 순서를 본다.<br/>

&ensp;4) 종료(exit) 메시지 또한 타입 기반으로 정확하게 전달된다.<br/>
&ensp;중앙서버 종료 시:<br/>
```bash
mtype=2, mtype=3 → "exit"
```

&ensp;을 따로 전송했기 때문에 각 사용자 inbox(mtype = 자신 ID)로 정확하게 전달되어 안정적으로 종료된다.<br/>

&ensp;talk-msgq.c 코드<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/select.h>

#define MSGKEY 1234
#define MAX 256

struct msg {
    long mtype;
    char mtext[MAX];
    int sender;
};

/* ============================
      종료 브로드캐스트
   ============================ */
void broadcast_exit(int qid) {
    struct msg m;

    for (int to = 2; to <= 3; to++) {
        m.mtype = to;
        strcpy(m.mtext, "exit");
        m.sender = 1;
        msgsnd(qid, &m, sizeof(m) - sizeof(long), 0);
    }
}

/* ============================
        USER 1 (SERVER)
   ============================ */
void run_server_and_user1(int qid) {
    int global_seq = 0;
    struct msg recvmsg, outmsg;
    fd_set set;

    while (1) {

        /* ===== 1) 클라이언트 메시지를 먼저 체크 ===== */
        int r = msgrcv(qid, &recvmsg, sizeof(recvmsg)-sizeof(long),
                       100, IPC_NOWAIT);

        if (r != -1) {

            /* 클라이언트에서 exit 발생 */
            if (!strcmp(recvmsg.mtext, "exit")) {
                printf("Client requested exit.\n");

                broadcast_exit(qid);
                usleep(50000);   // 클라이언트들이 exit 메시지 받을 시간
                exit(0);
            }

            /* 일반 메시지 처리 */
            global_seq++;

            printf("[sender=%d & msg#=%d] %s",
                   recvmsg.sender, global_seq, recvmsg.mtext);
            fflush(stdout);

            /* sender에게는 다시 보내지 않음 */
            for (int to = 2; to <= 3; to++) {
                if (to == recvmsg.sender) continue;

                outmsg.mtype = to;
                snprintf(outmsg.mtext, MAX,
                         "[sender=%d & msg#=%d] %s",
                         recvmsg.sender, global_seq, recvmsg.mtext);

                msgsnd(qid, &outmsg, sizeof(outmsg)-sizeof(long), 0);
            }
        }

        /* ===== 2) user1의 stdin 입력 처리 ===== */
        FD_ZERO(&set);
        FD_SET(STDIN_FILENO, &set);

        struct timeval tv = {0, 30000};

        if (select(STDIN_FILENO + 1, &set, NULL, NULL, &tv) > 0 &&
            FD_ISSET(STDIN_FILENO, &set))
        {
            char line[MAX];

            if (!fgets(line, MAX, stdin))
                exit(0);

            if (!strcmp(line, "talk_quit\n")) {
                broadcast_exit(qid);   // 2,3에게 exit 알림
                usleep(50000);         // **여기서 잠깐 기다리기**
                // msgctl(qid, IPC_RMID, NULL);  <-- 이 줄 제거!!
                exit(0);
            }

            global_seq++;

            /* user1은 자기 메시지를 출력하지 않음 */

            for (int to = 2; to <= 3; to++) {
                outmsg.mtype = to;
                snprintf(outmsg.mtext, MAX,
                         "[sender=1 & msg#=%d] %s",
                         global_seq, line);
                msgsnd(qid, &outmsg, sizeof(outmsg)-sizeof(long), 0);
            }
        }
    }
}

/* ============================
        USER 2, USER 3
   ============================ */
void run_client(int id, int qid) {
    struct msg sendmsg, recvmsg;

    while (1) {

        /* ===== 1) 서버 메시지를 먼저 전부 수신 ===== */
        while (msgrcv(qid, &recvmsg, sizeof(recvmsg)-sizeof(long),
                      id, IPC_NOWAIT) != -1)
        {
            /* 종료 메시지 */
            if (!strcmp(recvmsg.mtext, "exit")) {
                printf("Server requested exit.\n");
                exit(0);
            }

            /* 자기 메시지는 오지 않음 → 항상 남의 메시지 */
            printf("%s", recvmsg.mtext);
            fflush(stdout);
        }

        /* ===== 2) stdin 입력 처리 ===== */
        fd_set set;
        FD_ZERO(&set);
        FD_SET(STDIN_FILENO, &set);

        struct timeval tv = {0, 30000};

        if (select(STDIN_FILENO+1, &set, NULL, NULL, &tv) > 0 &&
            FD_ISSET(STDIN_FILENO, &set))
        {
            if (!fgets(sendmsg.mtext, MAX, stdin))
                exit(0);

            /* 종료 요청 */
            if (!strcmp(sendmsg.mtext, "talk_quit\n")) {
                sendmsg.mtype = 100;
                strcpy(sendmsg.mtext, "exit");
                sendmsg.sender = id;

                msgsnd(qid, &sendmsg, sizeof(sendmsg)-sizeof(long), 0);
                exit(0);
            }

            /* 일반 메시지 → 서버에게 전달 */
            sendmsg.mtype = 100;
            sendmsg.sender = id;

            msgsnd(qid, &sendmsg, sizeof(sendmsg)-sizeof(long), 0);
        }
    }
}

/* ============================
              MAIN
   ============================ */
int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("usage: %s <id:1~3>\n", argv[0]);
        exit(1);
    }

    int id = atoi(argv[1]);
    if (id < 1 || id > 3) {
        printf("id must be 1,2,3\n");
        exit(1);
    }

    int qid = msgget(MSGKEY, IPC_CREAT | 0600);
    if (qid < 0) {
        perror("msgget");
        exit(1);
    }

    if (id == 1)
        run_server_and_user1(qid);
    elser
        run_client(id, qid);

    return 0;
}
```

### 6. Shared Memory를 이용한 talk 프로그램 구현할 경우 shared memory segment에 저장할 필요가 있는 모든 정보를 쓰시오

<details>
<summary>1) 전역 메시지 번호 (global message number)</summary>

* 모든 메시지에 대해 전역적인 순서(1, 2, 3, 4, ...)를 유지하기 위해 필요
* (d)조건 "모든 사용자 간 출력 순서 동일을 만족시키는 핵심 값"

```c
int global_msg_no;
```

</details>

<details>
<summary>2) 메시지 버퍼(로그) 배열</summary>

각 메시지에 필요한 정보

* msg_no : 메시지의 전역 번호
* sender id : 누가 보냈는지
* text : 메시지 본문 문자열

TALK 시스템이 N:N 통신을 지원하려면 모든 사용자가 공통 메시지 저장소에서 자신의 메시지 순서(next_no 부터)를 읽어가야 한다.

```c
struct message {
    int msg_no;
    int sender;
    char text[MAXTEXT];
};

struct message log[MAXMSG];
```

</details>

<details>
<summary>3) shared memory 초기화 여부 플래그(init_done)</summary>

각 메시지에 필요한 정보

* msg_no : 메시지의 전역 번호
* sender id : 누가 보냈는지
* text : 메시지 본문 문자열

TALK 시스템이 N:N 통신을 지원하려면 모든 사용자가 공통 메시지 저장소에서 자신의 메시지 순서(next_no 부터)를 읽어가야 한다.

```c
struct message {
    int msg_no;
    int sender;
    char text[MAXTEXT];
};

struct message log[MAXMSG];
```

</details>

<details>
<summary>4) 메시지 기록 위치(write pointer / write_index)</summary>

전역 메시지 번호는 증가하지만 log[]는 fixed size ring-buffer이므로 어디에 새 메시지를 쓸 것인가를 나타내는 index가 필요하다.

* 새로운 메시지를 log 배열의 어느 위치에 기록할지 나타내는 포인터
* ring buffer 구조를 사용할 경우 필수적

```c
int write_index;
```

</details>

| 저장 항목           | 설명                  | 목적                    |
| --------------- | ------------------- | --------------------- |
| `init_done`     | 공유메모리 초기화 여부        | 클라이언트가 잘못된 메모리 읽지 않도록 |
| `global_msg_no` | 현재까지 기록된 마지막 메시지 번호 | 전역적인 메시지 순서 유지        |
| `write_index`   | log 배열의 다음 기록 위치    | 순환 버퍼 관리              |
| `log[]`         | 메시지 구조체 배열          | 모든 프로세스가 읽는 메시지 저장소   |

### 7. shared memory + semaphore 기반 talk 프로그램 전체 구조 정리

&ensp;Shared memory 방식의 Talk 프로그램은 모든 프로세스(1, 2, 3)가 하나의 message log를 공유하는 구조로 구현된다. 메시지를 기록하는 순간만 세마포어로 동기화하며 각 프로세스는 자신의 읽기 포인터(next_no)를 이용해 이미 읽은 메시지 이후의 메시지만 출력한다. 
&ensp;이 방식은 메시지 전달이 매우 빠르며 모든 프로세스가 동일한 전역 순서(global sequence)를 공유하므로 문제의 (d)조건을 완벽히 충족한다.<br/>

&ensp;1. 전체 구조 개요<br/>
&ensp;공유 메모리는 다음의 역할을 한다.<br/>
* 전역 메시지 번호(global_msg_no): 프로그램 전체 메시지의 절대적 순서
* 메시지 로그(log[]): 모든 메시지가 기록되는 공용 공간
* 쓰기 지점(write_index): 다음 메시지를 기록할 위치
* 초기화 플래그(init_done): 서버(1번) 초기화 여부

&ensp;모든 프로세스(1, 2, 3)는 동일한 Shared Memory에 접근하고 세마포어 mutex는 메시지를 기록할 때만 임계 구역을 보호한다.<br/>

&ensp;2. Shared Memory 내부 구성<br/>
```c
struct message {
    int msg_no;        // 전역 메시지 번호
    int sender;        // 메시지 보낸 사용자 (1,2,3)
    char text[256];    // 메시지 본문
};

struct shm_area {
    int init_done;     // 초기화 완료 여부
    int global_msg_no; // 지금까지 기록한 메시지 수
    int write_index;   // log[]의 기록 위치
    struct message log[MAXMSG];
};
```

&ensp;3. 세마포어 역할<br/>
&ensp;세마포어는 단 하나(mutex)만 사용한다.<br/>

| 세마포어 번호 | 값 | 역할                        |
| ------- | - | ------------------------- |
| 0       | 1 | 메시지 기록(write)을 보호하는 mutex |

&ensp;세마포어는 메시지를 기록하는 순간에만 lock(P)/unlock(V)으로 사용된다.<br/>
&ensp;이는 다음을 보장한다.<br/>
* 여러 프로세스가 동시에 메시지를 기록해도 전역 번호(gobal_msg_no)가 꼬이지 않음
* 메시지 기록이 정확히 하나의 순서 흐름을 갖게 됨
* log 배열이 손상되지 않게 보호

&ensp;4. 메시지 기록 과정(write flow)<br/>
&ensp;사용자가 메시지를 입력하면<br/>

&ensp;(1) 세마포어 P(mutex)<br/>
&ensp;공유 메모리 쓰기 보호<br/>

&ensp;(2) 전역 메시지 번호 증가<br/>
```c
new_no = ++shm->global_msg_no;
```

&ensp;(3) 메시지 log\[new_no\] 위치에 저장<br/>
```c
shm->log[idx].sender = myid;
strcpy(shm->log[idx].text, line);
shm->log[idx].msg_no = new_no;
```

&ensp;(4) write_index 갱신<br/>
&ensp;순한 버퍼 구조라서 mod 연산 적용<br/>

&ensp;(5) 세마포어 V(mutex)<br/>
&ensp;임계구역 해제 → 이 구조 덕분에 메시지 순서가 절대로 뒤바뀌지 않는다.<br/>

&ensp;5. 메시지 읽기 과정 (read flow)<br/>
&ensp;각 사용자 프로세스는 로컬 변수 `next_no` 를 갖는다.<br/>
```text
next_no = 내가 다음에 읽어야 할 메시지 번호
```

&ensp;(1) global_msg_no 스냅샷 획득<br/>
&ensp;읽는 동안 변경되는 것을 막기 위해 mutex로 보호해서 snapshot으로 가져온다.<br/>
```c
P(mutex);
snapshot = shm->global_msg_no;
V(mutex);
```

&ensp;(2) next_no ~ snapshot 사이의 메시지를 모두 출력<br/>
* sender == myid 이면 출력하지 않음
* text == "exit"이면 종료

&ensp;(3) next_no 증가시키면서 반복<br/>
&ensp;따라서 누락 없이 중복 없이 순서대로 읽게 된다.<br/>

&ensp;6. talk_quit 처리<br/>
&ensp;어떤 사용자가 `talk_quit` 을 입력하면:<br/>
1. exit 메시지를 공유 메모리에 기록
2. exit 메시지를 공유 메모리에 기록 "exit" 메시지를 만나면 종료됨


&ensp;talk-shared.c 코드<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/select.h>

#define SHMKEY 1234
#define SEMKEY 5678
#define MAXMSG 512
#define MAXTEXT 256

/* ===== 메시지 구조 ===== */
struct message {
    int msg_no;            // 메시지 번호
    int sender;            // 보낸 사용자
    char text[MAXTEXT];    // 내용
};

/* ===== 공유 메모리 구조 ===== */
struct shm_area {
    int init_done;         // 서버 초기화 여부
    int global_msg_no;     // 마지막 메시지 번호
    struct message log[MAXMSG];
};

/* ===== 세마포어 wait(P) ===== */
void sem_wait(int semid) {
    struct sembuf op;
    op.sem_num = 0;       // 0번 세마포어 하나만 사용
    op.sem_op  = -1;      // wait(P)
    op.sem_flg = 0;
    semop(semid, &op, 1); // 수행
}

/* ===== 세마포어 signal(V) ===== */
void sem_signal(int semid) {
    struct sembuf op;
    op.sem_num = 0;
    op.sem_op  = +1;      // signal(V)
    op.sem_flg = 0;
    semop(semid, &op, 1);
}

/* System V Semaphore에서 반드시 필요! */
union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
    struct seminfo *_buf;   // Linux/WSL에서는 이 필드가 있어야 함
};


 // 공   통   유   저
void run_user(int myid, struct shm_area *shm, int semid) {

    int next_no = 1;      // 내가 다음에 읽어야 할 메시지 번호
    char line[MAXTEXT];

    while (1) {

      
        // 1. 공유메모리에서 새 메시지 읽기
        int snapshot;

        /* global_msg_no 읽기 보호 */
        sem_wait(semid);
        snapshot = shm->global_msg_no;
        sem_signal(semid);

        /* next_no ~ snapshot 까지 출력 */
        while (next_no <= snapshot) {

            int idx = (next_no - 1) % MAXMSG;
            struct message m = shm->log[idx];

            /* 종료 메시지 발견 */
            if (!strcmp(m.text, "exit")) {

                if (m.sender != myid) {
                    printf("Server requested exit.\n");
                    fflush(stdout);
                }
                exit(0);
            }

            /* 자기 메시지는 출력하지 않음 */
            if (m.sender != myid) {
                printf("[sender=%d & msg#=%d] %s",
                       m.sender, m.msg_no, m.text);
                fflush(stdout);
            }

            next_no++;
        }

        // 2. stdin 입력 감시 (50ms) 
        fd_set set;
        FD_ZERO(&set);
        FD_SET(STDIN_FILENO, &set);

        struct timeval tv = {0, 50000};

        int r = select(STDIN_FILENO + 1, &set, NULL, NULL, &tv);

        if (r > 0 && FD_ISSET(STDIN_FILENO, &set)) {

            if (!fgets(line, MAXTEXT, stdin))
                exit(0);

            /* 종료 요청 */
            if (!strcmp(line, "talk_quit\n")) {

                sem_wait(semid);

                int new_no = shm->global_msg_no + 1;
                int idx = (new_no - 1) % MAXMSG;

                shm->log[idx].sender = myid;
                strcpy(shm->log[idx].text, "exit");
                shm->log[idx].msg_no = new_no;

                shm->global_msg_no = new_no;

                sem_signal(semid);

                exit(0);
            }

            /* 일반 메시지 기록 */
            sem_wait(semid);

            int new_no = shm->global_msg_no + 1;
            int idx = (new_no - 1) % MAXMSG;

            shm->log[idx].sender = myid;
            strncpy(shm->log[idx].text, line, MAXTEXT - 1);
            shm->log[idx].text[MAXTEXT - 1] = '\0';
            shm->log[idx].msg_no = new_no;

            shm->global_msg_no = new_no;

            sem_signal(semid);
        }
    }
}


// MAIN
int main(int argc, char *argv[]) {

    if (argc != 2) {
        fprintf(stderr, "usage: %s <id:1~3>\n", argv[0]);
        exit(1);
    }

    int myid = atoi(argv[1]);
    if (myid < 1 || myid > 3) {
        fprintf(stderr, "id must be 1, 2, or 3\n");
        exit(1);
    }

    /* ===== 공유 메모리 획득 ===== */
    int shmid = shmget(SHMKEY, sizeof(struct shm_area), IPC_CREAT | 0600);
    if (shmid == -1) exit(1);

    struct shm_area *shm = (struct shm_area *)shmat(shmid, NULL, 0);
    if (shm == (void *)-1) exit(1);

    /* ===== 세마포어 생성 ===== */
    int semid = semget(SEMKEY, 1, IPC_CREAT | 0600);
    if (semid == -1) exit(1);

    /* ===== 1번 프로세스가 초기화를 담당 ===== */
    if (myid == 1) {

        union semun arg;
        arg.val = 1;   // mutex = unlocked 상태

        if (semctl(semid, 0, SETVAL, arg) == -1)
            exit(1);

        shm->global_msg_no = 0;
        shm->init_done = 1;

    } else {
        /* 2,3번은 서버 초기화 기다리기 */
        while (shm->init_done == 0) {
            usleep(1000); // 1ms
        }
    }

    /* ===== 채팅 실행 ===== */
    run_user(myid, shm, semid);

    return 0;
}
```

2차 계획서
====

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>

#define KEY_PATH   "msgkey"
#define PROJ_ID    1
#define MSG_TEXT_SIZE 128
#define NUSER      3
#define MAX_BUFFER 256

struct msg {
    long mtype;                // 수신자 ID (1,2,3)
    int  sender;               // 보낸 사람 ID
    char text[MSG_TEXT_SIZE];  // 내용 (번호 없음!)
};

// ======================================================
// sender(): 입력 → 모든 사용자에게 전송 (번호는 보내지 않음)
// ======================================================
void sender(int myid, int msqid) {
    char buf[MSG_TEXT_SIZE];

    while (1) {
        if (fgets(buf, sizeof(buf), stdin) == NULL)
            break;

        buf[strcspn(buf, "\n")] = '\0';

        for (int dest = 1; dest <= NUSER; dest++) {
            struct msg m;
            m.mtype  = dest;
            m.sender = myid;
            strncpy(m.text, buf, MSG_TEXT_SIZE);
            m.text[MSG_TEXT_SIZE - 1] = '\0';

            if (msgsnd(msqid, &m, sizeof(struct msg) - sizeof(long), 0) == -1){
                printf("msgsnd data error\n");
                exit(1);
            }
        }

        if (strcmp(buf, "talk_quit") == 0)
            break;
    }
}

// ======================================================
// receiver(): 메시지를 수신하고 FIFO 순서로 번호 부여 후 출력
// ======================================================
void receiver(int myid, int msqid) {
    int msg_num = 1;   // 메시지 번호는 receiver가 local하게 증가시킴

    while (1) {
        struct msg m;

        // 나에게 온 메시지만 받음
        if (msgrcv(msqid, &m, sizeof(struct msg) - sizeof(long), myid, 0) == -1){
            printf("msgrcv error\n");
            exit(1);
        }

        // 내가 보낸 메시지는 출력하지 않음
        if (m.sender != myid && strcmp(m.text, "talk_quit") != 0){
            printf("[sender=%d & msg#=%d] %s\n", m.sender, msg_num, m.text);
            fflush(stdout);
        }

        // talk_quit이면 종료
        if (m.sender == myid && strcmp(m.text, "talk_quit") == 0)
            break;

        msg_num++;  // 다음 메시지 번호 증가
    }
}

// ======================================================
// main(): 큐 생성 → fork → sender/receiver 실행
// ======================================================
int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <id(1~3)>\n", argv[0]);
        exit(1);
    }

    int myid = atoi(argv[1]);
    if (myid < 1 || myid > 3) {
        printf("id must be 1~3\n");
        exit(1);
    }

    // ftok용 파일 준비
    FILE *fp = fopen(KEY_PATH, "a");
    if (!fp) { printf("key file error\n"); exit(1); }
    fclose(fp);

    key_t key = ftok(KEY_PATH, PROJ_ID);
    if (key == -1) { printf("ftok error\n"); exit(1); }

    int msqid = msgget(key, IPC_CREAT | 0600);
    if (msqid == -1) { printf("msgget error\n"); exit(1); }

    pid_t pid = fork();

    if (pid == 0) {
        receiver(myid, msqid);
        exit(0);
    } else {
        sender(myid, msqid);
        wait(NULL);
    }

    return 0;
}
```

* main() : 큐 만들고 fork()로 sender / receiver 분리
* sender() : 입력 받아서 모든 사용자에게 전송 (번호 X)
* receiver() : 자기 타입 메시지만 FIFO로 받으면서 msg_num local 증가

&ensp;전체 구조<br/>
```scss
             ┌────────────────────────────┐
             │         Message Queue      │
             │                            │
             │  [type=1] → receiver(1)    │
             │  [type=2] → receiver(2)    │
             │  [type=3] → receiver(3)    │
             └───────▲────────▲──────────┘
                     │        │
      msgsnd(mtype=1,2,3)     │
                     │        │
          ┌──────────┴────────┴─────────┐
          │         sender(각 프로세스) │
          │ ./msgq2 1 / ./msgq2 2 / ...  │
          └──────────────────────────────┘
```

* 각 프로세스는 실행 시 `fork()`로 sender + receiver 두 개로 나뉨
* `sender(myid)`는 입력한 문자열을 1,2,3 모두에게 전송.
* `receiver(myid)`는 mtype = myid인 메시지만 FIFO로 받아서 번호 붙이고 출력.

### (1) message queue를 이용하여 talk 프로그램을 구현하려고 한다. message를 보내는 작업은 sender()함수에서 message를 받는 작업은 receiver() 함수에서 수행한다고 했을 때 main 함수의 설계도를 그리시오

```text
                ┌────────────────────┐
                │        main        │
                └────────┬───────────┘
                         │
          ┌──────────────▼────────────────┐
          │ 1. 인자 개수 확인 (argc != 2?) │
          └───────┬───────────────────────┘
                  │Yes
                  ▼
        ┌───────────────────────┐
        │ Usage 출력 후 종료    │
        └───────────────────────┘

                  │No
                  ▼
          ┌─────────────────────────────┐
          │ 2. myid = atoi(argv[1])     │
          │   if (myid <1 || myid >3)   │
          └───────┬─────────────────────┘
                  │ 잘못된 ID이면
                  ▼
        ┌───────────────────────┐
        │ 에러 출력 후 종료     │
        └───────────────────────┘

                  │ 정상 ID
                  ▼
          ┌─────────────────────────────┐
          │ 3. KEY_PATH 파일 open("a")  │
          │    없으면 생성 후 닫기      │
          └────────┬────────────────────┘
                   ▼
          ┌─────────────────────────────┐
          │ 4. ftok(KEY_PATH, PROJ_ID)  │
          │    → key 생성               │
          └────────┬────────────────────┘
                   ▼
          ┌─────────────────────────────┐
          │ 5. msgget(key, IPC_CREAT    │
          │           | 0600) → msqid   │
          └────────┬────────────────────┘
                   ▼
          ┌─────────────────────────────┐
          │ 6. pid = fork()             │
          └────────┬─────────┬──────────┘
                   │child(=0)│parent(>0)
                   ▼         ▼
     ┌─────────────────┐  ┌──────────────────────┐
     │ receiver(myid,  │  │ sender(myid, msqid)  │
     │          msqid) │  │                      │
     └─────────┬───────┘  │  sender 종료 후     │
               │          │  wait(NULL)          │
               ▼          └──────────┬───────────┘
     ┌──────────────────────┐        ▼
     │  child 프로세스 종료 │  ┌────────────────┐
     └──────────────────────┘  │   main 종료    │
                               └────────────────┘
```

### (2) 사용자가 입력한 message를 다른 사용자에게 보내는 작업을 하는 sender() 함수의 설계도를 그리시오

```text
                    ┌──────────────────────────────┐
                    │          sender()            │
                    └───────────┬──────────────────┘
                                │
                    ┌───────────▼───────────┐
                    │  무한 루프 while(1)   │
                    └───────────┬───────────┘
                                │
                 ┌──────────────▼──────────────────┐
                 │ 1. fgets(buf, stdin)            │
                 │    - EOF면 break                │
                 └──────────────┬──────────────────┘
                                │
                 ┌──────────────▼────────────────────┐
                 │ 2. buf에서 '\n' 제거              │
                 └──────────────┬────────────────────┘
                                │
                 ┌──────────────▼───────────────────────────────┐
                 │ 3. for (dest = 1; dest <= NUSER; dest++) {   │
                 │       m.mtype  = dest;                       │
                 │       m.sender = myid;                       │
                 │       m.text   = buf;                        │
                 │       msgsnd(msqid, &m, size, 0);            │
                 │    }                                         │
                 └──────────────┬───────────────────────────────┘
                                │
                 ┌──────────────▼────────────────────────┐
                 │ 4. if (strcmp(buf,"talk_quit")==0)    │
                 │        break;                         │
                 └──────────────┬────────────────────────┘
                                │
                                └─── while(1) 처음으로

(루프 탈출 시)
┌─────────────────────────────────────┐
│ sender() 종료, main에서 wait() 호출│
└─────────────────────────────────────┘
```

&ensp;역할<br/>
* 키보드에서 문자열 입력
* 입력 한 번 받을 때마다 1,2,3번 모두에게 메시지 전송
* "talk_quit" 입력 시 전송 후 종료

&ensp;포인트<br/>
* sender는 번호를 전혀 신경 쓰지 않는다.
* 그냥 “누가 보냈는지(sender)”와 “내용(text)”만 메시지에 넣어서 큐에 던진다.
* 번호는 오직 receiver가 붙임.

### (3) 다른 사용자로부터 받은 message를 화면에 출력하는 작업을 하는 receiver() 함수의 설계도를 그리시오.

```text
                 ┌─────────────────────────────┐
                 │         receiver()          │
                 └────────────┬────────────────┘
                              │
          ┌───────────────────▼─────────────────────┐
          │ 1. int msg_num = 1;  // ★ 최초 1회만    │
          └───────────────────┬─────────────────────┘
                              │
                    ┌─────────▼───────────┐
                    │ 2. while(1) 반복    │
                    └─────────┬───────────┘
                              │
          ┌───────────────────▼────────────────────────────┐
          │ 3. msgrcv(msqid, &m, size, myid, 0);          │
          │    → type = myid 큐에서 메시지 하나 가져옴     │
          └───────────────────┬────────────────────────────┘
                              │
          ┌───────────────────▼─────────────────────────────────────┐
          │ 4. if (m.sender != myid &&                             │
          │        strcmp(m.text, "talk_quit") != 0) {             │
          │        printf("[sender=%d & msg#=%d] %s\n",            │
          │                   m.sender, msg_num, m.text);          │
          │    }                                                   │
          └───────────────────┬─────────────────────────────────────┘
                              │
          ┌───────────────────▼────────────────────────────────────┐
          │ 5. if (m.sender == myid &&                            │
          │        strcmp(m.text, "talk_quit") == 0) {            │
          │        break;  // 내 talk_quit → 종료                │
          │    }                                                  │
          └───────────────────┬───────────────────────────────────┘
                              │
          ┌───────────────────▼─────────────────────┐
          │ 6. msg_num++;   // ★ 다음 메시지 번호로 │
          └──────────────────┬──────────────────────┘
                              │
                              └── while(1) 처음으로

(루프 탈출 시)
┌──────────────────────────────┐
│ receiver() 종료 → child 종료 │
└──────────────────────────────┘
```

&ensp;역할<br/>
* mtype = myid인 메시지만 수신
* 메시지를 받는 순서대로 msg_num = 1, 2, 3, ... 증가
* 자기 자신이 보낸 메시지는 화면에 출력하지 않음
* "talk_quit"을 내가 보냈을 때만 종료

&ensp;msg_num 이 local인데도 global 순서처럼 되는 이유<br/>
&ensp;각 receiver는 **자기 타입 큐(type = myid)**만 본다:<br/>
* type=1 큐: [abc][def][ghi]...
* type=2 큐: [abc][def][ghi]...
* type=3 큐: [abc][def][ghi]...

&ensp;sender가 항상<br/>
```text
abc 보낼 때: dest=1 →2 →3 순서로 send
def 보낼 때: dest=1 →2 →3 순서로 send
ghi 보낼 때: dest=1 →2 →3 순서로 send
```

&ensp;이렇게 넣기 때문에 모든 type 큐 안의 순서는 항상 동일하다.<br/>
```text
type=1: abc → def → ghi → ...
type=2: abc → def → ghi → ...
type=3: abc → def → ghi → ...
```

&ensp;그래서 receiver 쪽에서:<br/>
```text
첫 번째 msgrcv() → abc   → msg#1  
두 번째 msgrcv() → def   → msg#2  
세 번째 msgrcv() → ghi   → msg#3
...
```

&ensp;이렇게 모든 프로세스에서 동일한 순서 + 동일한 번호가 된다. (msg_num은 각 receiver에서 1,2,3,...로만 커지고, 절대 중간에 1로 돌아가지 않음)<br/>
