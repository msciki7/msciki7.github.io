---
title: "Lect11-2. Semaphore"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-26
last_modified_at: 2025-11-26
---

Semaphore
=====

&ensp;세마포어가 필요한 이유<br/>
* 여러 프로세스/쓰레드가 같은 자원(공유 변수, 파일, 메모리 등)을 동시에 쓰려고 하면 → 값이 꼬이거나 덮어쓰거나 이상한 결과가 나오(race condition, 경쟁 상태)
    - race Condition: 둘 이상의 프로세스/쓰레드가 같은 데이터(공유 자원)에 동시에 접근해서 그 결과가 누가 먼저 실행되느냐에 따라 달라지는 상태
    - 실행 순서에 의해 결과가 달라지는 위험한 상황
* 그래서 한 번에 몇 명까지만 들어와 라는 출입 관리 장치가 필요함

&ensp;비유<br/>
* 화장실 칸이 3개 있는 공용 화장실 → 동시에 최대 3명까지 사용 가능, 이 3이라는 숫자를 관리하는 게 세마포어 값(sem)이라고 보면 됨

&ensp;세마포어의 정체<br/>
&ensp;세마포어는 커널이 관리하는 정수 변수 + 대기 큐(queue)라고 보면 된다.<br/>

* 내부에 정수 값 `sem` 을 하나 가지고 있고
* `sem`이 0이하면 더 이상 못 들어오게 막고 기다리는 프로세스들을 큐에 줄 세워둠
* 두 가지 연산만 제공
    - `P(sem)` = `wait(sem)` (문 앞에 기다림 / 자원 잠금)
    - `V(sem)` = `signal(sem)` (문 열어줌 / 자원 해제)
* 이 두 가지 연산을 이용해서 임계구역(critical section)을 보호함

&ensp;둘 다 원자적(atomic)으로 수행됨 → 중간에 끊기지 않음.<br/>

<details>
<summary>race condition 예제</summary>
&ensp;예: 밥솥에 밥이 공기 남았다.<br/>

* 소희가 밥솥을 확인함 → 남은밥 = 1
* 명우도 동시에 밥솥을 확인함 → 남은밥 = 1

&ensp;둘 다 생각함: 밥이 있네<br/>
1. 남은밥 = 1
2. 둘 다 “밥 감소” 실행 → 남은밥 = 0이 되어야 함 하지만 둘 다 이전 값을 보고, 둘 다 1에서 0을 빼지 않고 둘 다 1 → 0을 실행해버림. 또는 둘 다 1을 쓰기도 하고 값이 0 대신 -1이 되기도 함

&ensp;결과적으로 밥솥 상태가 꼬임 → race condition(경쟁 상태)<br/>

&ensp;Race Condition이 왜 발생하는가?<br/>
&ensp;공유 자원을 접근하는 과정은 이렇게 생겼다.<br/>
&ensp;**실제 프로그램의 한 줄은 원자적(atomic)이지 않음**<br/>
```c
x = x + 1;
```

&ensp;이렇게 생겼지만 실제 CPU는 이렇게 나눈다.<br/>
1. 메모리에서 x 읽기
2. 레지스터에 x 저장
3. 1 증가
4. 다시 메모리에 저장

&ensp;이 중 어떤 순간에든 다른 프로세스가 끼어들 수 있음 그래서 프로세스 A가 값을 읽고 → 증가하기 전, 프로세스 B가 값을 읽고 → 증가하기 전. 서로 꼬임<br/>

</details>

P(sem) / wait(sem) 동작
====

```text
p(sem) or wait(sem)
    if (sem > 0)
        decrement sem by one;     // sem = sem - 1;
    else
        wait until sem becomes non-zero;
        then decrement;
```

&ensp;해석<br/>
1. `P(sem)`을 호출하면
2. 현재 값 `sem` 을 본다
* `sem > 0` 이면 → "들어가도 되는 상태", `sem` 을 1 줄이고 (자리 하나 차지) → 바로 진행
* `sem == 0` 또는 `sem < 0` 이면 → "자리가 없다", 이 프로세스를 잠재워(블록) 대기 큐에 넣고 나중에 누가 V(sem) 해서 자리 비워줄 때까지 기다림

<details>
<summary>비유</summary>
&ensp;화장실 비유<br/>

* `sem` = 남은 칸 수
* `P(sem)` = 들어가도 되나 하고 문 열어 보는 행동
    - 남은 칸 > 0 → 들어가고 남은 칸 수 1 줄임
    - 남은 칸 = 0 → 문 잠겨있으니까 복도에서 기다림

</details>

V(sem) / signal(sem) 동작
=====

```text
v(sem) or signal(sem)
    increment sem by one;         // sem = sem + 1;
    if (queue of waiting processes not empty)
        restart first process in wait queue;
```

&ensp;해석<br/>
1. `V(sem)`을 호출하면
2. `sem` 값을 1 증가시킴 → "자리 하나 비었다!"
3. 만약 기다리고 있는 프로세스들이 있다면
    - 대기 큐에서 맨 앞에 있는 하나를 깨워서 실행 다시 시작시킴
    - 그 깨어난 프로세스가 다시 `P(sem)` 를 수행해서 자리를 차지

<details>
<summary>비유</summary>

* `V(sem)` = 볼일 보고 나와서 칸 하나 비웠다. → `sem++`
* 복도에 줄 서 있던 사람 있으면 → 맨 앞사람 불러서 "이제 들어가세요~" 하고 들여보냄.

</details>

세마포어 사용 패턴
====

```c
p(sem);
something interesting;
v(sem);
```

&ensp;이 패터닝 세마포어의 기본 사용법이다.<br/>
* `p(sem);` → 공유 자원에 들어가기 전 잠금(lock) 요청, 들어갈 수 있으면 `sem--` 하고 들어감, 안 되면 기다림.
* `something interesting;` → 실제로 공유 자원 읽고/쓰기 하는 부분, OS 책에서 말하는 critical section (임계 구역).
* `v(sem);` → 다 썼으니 잠금 해제(unlock), `sem++` 하고 혹시 기다리는 애 있으면 하나 깨워줌

&ensp;즉, 임계 구역 앞뒤에 항상 `P` / `V` 를 쌍으로 둔다:<br/>
```c
P(sem);      // wait(sem)
  // --- critical section ---
  // 공유 변수, 공유 메모리 접근
V(sem);      // signal(sem)
```

&ensp;세마포어 종류 두 가지<br/>
1. binary semaphore(mutex 처럼)
* 초기값: 1
* 한 번에 딱 1개 프로세스만 임계 구역 진입 가능
* `P` 하면 1 → 0 (들어감), 다른 프로세스가 오면 0이니까 기다림
* `V` 하면 0 → 1 (나옴, 다른 사람 들어갈 수 있음)
2. counting semaphore
* 초기값: `N` (자원이 N개)
* 한 번에 최대 N개까지 들어올 수 있음
* 예: 프린터 3개, 버퍼 슬롯 10개, 화장실 칸 4개 등

semget()
====

&ensp;`semget` 시스템 콜 이해<br/>
&ensp;리눅스에서 실제로 세마포어를 어떻게 만들까?<br/>

&ensp;segment 함수 형태<br/>
```c
#include <sys/sem.h>
#include <sys/types.h>
#include <sys/ipc.h>

int semget(key_t key, int nsems, int permflags);
```

&ensp;각 인자 설명<br/>
* `key`: 세마포어 집합을 구분하는 이름 같은 것
    - `ftok("파일이름", 숫자)` 로 만들어진다.
    - 같은 `key` 를 쓰면 같은 세마포어 집합을 공유함
* `nsems`
    - 이 집합 안에 세마포어가 몇 개 있나?
    - 예를 들어 4개짜리 세마포어 배열을 만들고 싶으면 `nsems = 4`
* `permflags`
    - 권한 및 생성 옵션
    - 예: `0600 | IPC_CREAT`
    - IPC_CREAT | IPC_EXCL 조합은 “초기화 한 번만” 하기 위해 반드시 필요
    - 최초 생성 성공한 프로세스만 초기화 수행해야 함
* return 값: 
    - 성공 시 → 세마포어 집합 ID (semid)
    - 실패 시 → -1

&ensp;이 `semid` 는 나중에 `semop`, `semctl` 같은 함수에 넘겨서 실제 `P/V` 연산을 하거나 초기값 설정할 때 사용함<br/>

```text
semid  ──>  [ index 0 ]  [ index 1 ]  [ index 2 ]  [ index 3 ]
             semval=2     semval=4     semval=1     semval=3
```

* `semget(key, 4, ...)` 을 호출해서 4개짜리 세마포어 집합을 만들었다고 가정
* 커널 안에는 세마포어 배열이 생김
* `semid`: 이 세마포어 집합 전체를 가리키는 ID (정수 하나)
* `index`: 집합 안에서 몇 번째 세마포어인지를 나타냄
* `semval`: 각각의 세마포어 값(자원의 개수, 남은 자리 수 같은 것)

&ensp;하나의 `semid` 안에 여러 개의 세마포어를 묶어서 관리할 수 있다.<br/>
&ensp;각각은 `index` 로 접근함<br/>
* 예: 0번 세마포어롤 생상자/소비자 버퍼 관리, 1번 세마포어로 다른 자원 관리 

&ensp;지금 까지 내용 요약<br/>
1. 세마포어는 공유 자원 동기화를 위한 정수 + 대기 큐.
2. 두 연산만 있다. 
    - P(sem) / wait(sem) :
        + sem > 0 이면 sem-- 하고 통과
        + sem <= 0 이면 큐에 넣고 잠재움.
    - V(sem) / signal(sem) :
        + sem++
        + 기다리는 프로세스 있으면 한 명 깨움.
3. 리눅스 System V에서 세마포어 만들기:
    - `semget(key, nsems, permflags)`
    - 리턴 값 `semid`는 세마포어 집합 ID
4. 한 `semid` 안에는 `nsems`개의 세마포어(배열)가 있고 각각의 현재 값이 `semval` 로 관리됨

세마포어 상태 값
----

&ensp;세마포어 "집합" 안의 각 세마포어(index 별)이 가지고 있는 값<br/>
&ensp;1) `semval`<br/>
&ensp;**세마포어 값(현재 자원의 개수)**<br/>
* `P` 하면 줄어드는 값
* `V` 하면 증가
* 초기화 반드시 필요 (안 하면 쓰레기 값)

&ensp;예:<br/>
&ensp;버퍼 크기 1인 경우 → `semval = 1`, 빈 버퍼 10개 → `semval = 10` <br/>

&ensp;2) `sempid` <br/>
&ensp;**마지막으로 이 세마포어를 건드린(process) 프로세스의 PID** <br/>
* 최근에 P/V 연산을 수행한 프로세스 ID가 저장됨
* 디버깅용으로 사용

&ensp;예: Producer 프로세스가 sem[0] 을 `P` 했다면 → producer PID가 들어감<br/>

&ensp;3) `semncnt` <br/>
&ensp;**세마포어 값이 증가하기를 기다리는 프로세스 수** <br/>
&ensp;세마포어 값이 0이어서 P를 못 하고 "언제 V(signaling)해서 세마포어 값이 늘어나나.." 기다리는 프로세스들 → 일반적으로 P(sem) 때문에 잠들어 있는 프로세스 수라고 보면 된다.<br/>

&ensp;4) `semzcnt` <br/>
&ensp;**세마포어 값이 0이 되기를 기다리는 프로세스 수** <br/>
&ensp;일부 프로그램에서는 "값이 0이 되면 진행해라" 같은 조건에서 사용됨<br/>
&ensp;예: 모든 작업 끝날 때까지 기다리는 프로세스 같은 경우<br/>

| 상태값         | 설명                           |
| ----------- | ---------------------------- |
| **semval**  | 실제 세마포어 값 (임계구역 접근 가능 횟수)    |
| **sempid**  | 마지막으로 이 세마포어를 P/V 한 프로세스 PID |
| **semncnt** | `P` 때문에 block된 프로세스 수        |
| **semzcnt** | 세마포어 값이 0이 되기를 기다리는 수        |

semctl()
=====

&ensp;세마포어의 상태를 읽거나 초기화하려면 `semctl()`을 사용해야 한다.<br/>

```c
int semctl(int semid, int sem_num, int command, union semun arg);
```

&ensp;매개변수 의미<br/>
&ensp;1) `semid` <br/>
&ensp;`semget()`에서 받은 세마포어 집합 ID<br/>
&ensp;2) `sem_num` <br/>
&ensp;집합 안에 있는 **몇 번째 세마포어인지(index)** 지정<br/>
&ensp;예: `sem_num = 0` → 첫 번째 세마포어<br/>
&ensp;3) `command` <br/>
* 값 읽기 (`GETVAL`)
* 값 설정 (`SETVAL`)
* 전체 세마포어 초기화 (`SETALL`)
* 세마포어 집합 제거 (`IPC_RMID`)
* 상태 정보 가져오기 (`IPC_STAT`)
* 등등...

&ensp;4) `arg` <br/>
* 세마포어 값을 설정하거나
* 상태 구조체를 저장하거나
* 전체 배열을 초기화할 때 사용되는 구조체

&ensp;command에 따라 **arg가 쓰이기도 하고 안 쓰이기도 함** <br/>

semctl() 명령 종류
-----

### 단일 세마포어에 대한 명령

&ensp;**GETVAL**<br/>
&ensp;특정 index의 `semval` 값 읽기<br/>
```c
int value = semctl(semid, 0, GETVAL, arg);
```

&ensp;**SETVAL** <br/>
&ensp;특정 index의 `semval` 값을 설정<br/>
```c
arg.val = 1;
semctl(semid, 0, SETVAL, arg);
```

&ensp;**GETPID** <br/>
&ensp;세마포어를 마지막에 P/V 한 PID 가져오기<br/>

&ensp;**GETNCNT / GETZCNT** <br/>
&ensp;대기 queue 상태 값 확인<br/>

### 세마포어 집합 전체에 대한 명령

&ensp;**GETALL** <br/>
&ensp;모든 세마포어의 `semval` 을 arg.array에 저장<br/>
&ensp;**SETALL** <br/>
&ensp;모든 세마포어의 값을 한 번에 초기화<br/>
&ensp;예<br/>
```c
unsigned short values[4] = {1, 0, 2, 3};
arg.array = values;
semctl(semid, 0, SETALL, arg);
```

union semun 구조체
-----

&ensp;이 구조체는 command 종류에 따라 전달할 데이터를 선택하는 용도이다.<br/>

```c
union semun {
    int val;               // SETVAL에 사용
    struct semid_ds *buf;  // IPC_STAT, IPC_SET 등에 사용
    unsigned short *array; // GETALL, SETALL에 사용
};
```

&ensp;**val** <br/>
* 단일 세마포어의 값을 설정할 때 사용 (SETVAL)

&ensp;**buf** <br/>
* 세마포어 상태 전체를 받아오는 구조체 (거의 사용 잘 안 함)

&ensp;**array**<br/>
* 전체 세마포어 집합의 값을 읽거나 설정할 때 사용 (GETALL, SETALL)

&ensp;세마포어 초기화 전체 예제<br/>
&ensp;보통 System V 세마포어 초기화는 이렇게 한다.<br/>
```c
key_t key = ftok("key", 1);
int semid = semget(key, 1, 0600 | IPC_CREAT);

union semun arg;
arg.val = 1;   // binary semaphore 1로 초기화

semctl(semid, 0, SETVAL, arg);
```

* 세마포어 집합 1개 만들고
* 그 안의 0번 세마포어 값을 1로 초기화

semop()
====

```c
int semop(int semid, struct sembuf *op_array, size_t num_ops);
```

&ensp;각 인자 설명<br/>

| 인자           | 의미                          |
| ------------ | --------------------------- |
| **semid**    | 세마포어 집합 ID (`semget`로 만들어짐) |
| **op_array** | 하나 또는 여러 개의 연산을 담고 있는 배열    |
| **num_ops**  | 배열(op_array)에 들어있는 연산의 개수   |

&ensp;한 번의 semop() 호출에서 여러 개 세마포어에 대한 여러 연산을 동시에 수행할 수 있음 (원자적 atomic 실행)<br/>

struct sembuf 구조체
----

&ensp;semop()는 struct sembuf 배열을 인자로 받는다.<br/>
```c
struct sembuf {
    unsigned short sem_num;   // 세마포어 index
    short sem_op;             // 수행할 연산
    short sem_flg;            // 옵션
};
```

&ensp;필드 설명<br/>

| 필드          | 의미                             |
| ----------- | ------------------------------ |
| **sem_num** | 세마포어 집합 안에서 몇 번째 세마포어인지(index) |
| **sem_op**  | 수행할 연산 (양수/0/음수)               |
| **sem_flg** | 옵션 (IPC_NOWAIT 또는 SEM_UNDO)    |

&ensp;세마포어 연산에서 flag의 의미<br/>
&ensp;IPC_NOWAIT<br/>
* P 연산 실패 시 블록하지 않고 즉시 -1 리턴

&ensp;SEM_UNDO
* 종료 시 지금까지의 P/V 효과를 원복

sem_op의 연산 의미
----

&ensp;sem_opp의 값에 따라 의미가 완전히 달라짐<br/>

&ensp;1) sem_op < 0 → wait(P) 연산<br/>
&ensp;Ex) `sem_op = -1` → 우리가 말하는 P(sem) 동작<br/>
&ensp;동작<br/>
```c
if (semval >= |sem_op| )
    semval = semval - |sem_op|;
else
    블록(block) 상태로 기다림
```

* 남은 자원이 충분하면 즉시 들어감
* 아니면 대기 큐에서 잠듦

&ensp;2) sem_op > 0 → signal(V) 연산<br/>
&ensp;Ex) `sem_op = 1` <br/>
```c
semval = semval + sem_op
```

&ensp;→ 우리가 말하는 V(sem)<br/>
* 자원 반납
* 대기 프로세스 있으면 깨움

&ensp;3) sem_op = 0 → 0이 될 때까지 기다림<br/>
&ensp;특이한 연산이지만 가끔 사용됨<br/>
&ensp;Ex) 다른 프로세스가 모든 자원을 다 쓸 때까지 기다리는 경우<br/>

| sem_op   | 의미    | 동작                        |
| -------- | ----- | ------------------------- |
| **< 0**  | P 연산  | semval이 충분할 때만 감소, 아니면 대기 |
| **> 0**  | V 연산  | semval 증가 후 대기자 깨움        |
| **== 0** | 특수 대기 | semval == 0이 될 때까지 대기     |


semaphore 연산 실행의 예
-----

```c
struct sembuf p_buf;
p_buf.sem_num = 0;
p_buf.sem_op = -1;   // wait (P)
semop(semid, &p_buf, 1);

printf("process %d in critical section\n", pid);
sleep(10);

printf("process %d leaving critical section\n", pid);

p_buf.sem_num = 0;
p_buf.sem_op = 1;    // signal (V)
semop(semid, &p_buf, 1);
```

&ensp;이 코드의 의미<br/>
&ensp;(1) 임계구역에 들어가기 전<br/>
* `sem_op = -1` → P 연산
* 세마포어 값이 1이었다면 0으로 감소하고 진입
* 값이 0이었다면 → 기다림

&ensp;(2) critical section 실행<br/>
* sleep(10)은 임계구역 점유를 흉내낸 것

&ensp;(3) 임계구역 나올 때<br/>
* `sem_op = +1` → V 연산
* 세마포어 값 1 증가
* 대기 프로세스가 있으면 한 명 깨워줌

실습
=====

&ensp;1. 공유 메모리를 이용하는 두 개의 프로그램을 작성합니다. 프로그램 A는 scanf() 명령으로 10개의 정수를 입력받아 공유 메모리에 저장하는 작업을 10회 반복 실행합니다. 프로그램 B는 공유 메모리에 저장된 내용을 printf() 명령으로 출력하는 작업을 10회 반복 실행합니다. 이때, 프로그램 B는 프로그램 A가 정수를 쓴 후 읽어야 합니다. 이러한 동기화 작업은 semaphore를 사용합니다.<br/>

&ensp;프로그램 A (Writer)<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>

union semun{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int main(void){
    int shmid, semid, i, *buf;
    key_t key1, key2;
    union semun arg;
    struct sembuf p_buf;

    key1 = ftok("key", 1);
    semid = semget(key1, 1, IPC_CREAT | IPC_EXCL | 0600);
    if(semid == -1){
        semid = semget(key1, 1, 0);
    }
    else{
        arg.val = 0;
        semctl(semid, 0, SETVAL, arg);
    }

    key2 = ftok("key", 2);
    shmid = shmget(key2, sizeof(int) * 10, IPC_CREAT | 0600);
    buf = (int *)shmat(shmid, 0, 0);

    for(i = 0; i < 10; i++){
        scanf("%d", (buf + i));

        p_buf.sem_num = 0;
        p_buf.sem_op = 1;   // signal
        p_buf.sem_flg = 0;
        semop(semid, &p_buf, 1);
    }

    exit(0);
}
```

&ensp;프로그램 B (Reader)<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>

union semun{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int main(void){
    int shmid, semid, i, *buf;
    key_t key1, key2;
    union semun arg;
    struct sembuf p_buf;

    key1 = ftok("key", 1);
    semid = semget(key1, 1, IPC_CREAT | IPC_EXCL | 0600);
    if(semid == -1){
        semid = semget(key1, 1, 0);
    }
    else{
        arg.val = 0;
        semctl(semid, 0, SETVAL, arg);
    }

    key2 = ftok("key", 2);
    shmid = shmget(key2, sizeof(int) * 10, 0600 | IPC_CREAT);
    buf = (int *)shmat(shmid, 0, 0);

    for(i = 0; i < 10; i++){
        p_buf.sem_num = 0;
        p_buf.sem_op = -1;  // wait
        p_buf.sem_flg = 0;
        semop(semid, &p_buf, 1);

        printf("%d\n", *(buf + i));
    }

    shmctl(shmid, IPC_RMID, 0);
    exit(0);
}
```
## 전체 흐름 한눈에 보기

&ensp;실행 순서<br/>
```css
A 실행 → 입력 쓰기 → signal → B 실행 → wait → 출력
```

&ensp;둘이 이런 식으로 정확히 10번 핑퐁함<br/>

&ensp;1. key와 IPC 자원 생성 과정<br/>
&ensp;**key1 = 세마포어용 키**<br/>
```c
key1 = ftok("key", 1);
semid = semget(key1, 1, IPC_CREAT | IPC_EXCL | 0600);
```

* 첫 번째 실행한 프로그램만 IPC_EXCL로 인해 처음 생성자가 됨
* 다른 프로그램은 `semid = semget(key1, 1, 0);` 로 이미 만들어진 세마포어를 그대로 가져와 사용함

&ensp;두 프로그램이 같은 세마포어(번호 0)를 공유하는 것<br/>

&ensp;**key2 = 공유 메모리용 키**<br/>
```c
key2 = ftok("key", 2);
shmid = shmget(key2, sizeof(int)*10, IPC_CREAT | 0600);
buf = shmat(shmid, 0, 0);
```

* 공유 메모리 구역에 정수 10개 저장 가능
* A와 B 모두 같은 공유메모리 주소(buf)를 얻어 서로 접근 가능

&ensp;2. 세마포어 초기화 핵심<br/>
&ensp;**A 또는 B 중 먼저 실행된 프로그램만 초기 값을 설정함**<br/>
```c
arg.val = 0;
semctl(semid, 0, SETVAL, arg);
```

&ensp;초기에는 0<br/>

&ensp;3. 프로그램 A: Writer의 동작<br/>
&ensp;**핵심: 입력 → 메모리에 저장 → signal(+1)** <br/>
&ensp;반복문 10번:<br/>
```c
scanf("%d", buf + i);     // 정수 입력 → 공유메모리에 저장
p_buf.sem_op = 1;         // signal
semop(semid, &p_buf, 1);  // 세마포어 값 +1
```

&ensp;쉽게 말하면?<br/>
&ensp;A가 1개 입력하면:<br/>
```makefile
세마포어: +1
```

&ensp;= “B야! 한 개 써놨으니까 읽어!”<br/>
&ensp;A는 입력받은 만큼 세마포어를 증가시키며 B에게 메시지를 보내는 것<br/>

&ensp;4. 프로그램 B: Reader의 동작<br/>
&ensp;**핵심: wait(-1) → 메모리 읽기 → 출력** <br/>
&ensp;반복문 10번:<br/>
```c
p_buf.sem_op = -1;   // wait
semop(semid, &p_buf, 1);  // 세마포어 값 -1 될 때까지 기다림

printf("%d\n", buf[i]);   // 공유메모리에서 데이터 읽음
```

&ensp;B는 A가 signal(+1)하기 전에는 절대 읽지 못함<br/>
&ensp;세마포어는 다음과 같이 동작함<br/>
```scss
A가 signal (+1) → 세마포어 1이 됨 → B의 wait(-1) 통과 → 0으로 감소
```

&ensp;= 읽어도 좋다 신호를 받은 B만 출력 가능<br/>

&ensp;5. 동작 시나리오 전체 흐름<br/>
&ensp;Step 1: 초기 상태<br/>
```text
세마포어 = 0   (B는 기다림)
공유메모리 = [ ?, ?, ?, ... ]
```

&ensp;Step 2: A가 1번째 숫자를 입력받음<br/>
&ensp;예: 입력 = 5<br/>
```
buf[0] = 5
세마포어 = 1   (signal)
```

&ensp;Step 3: B wait(-1)<br/>
```css
B: 세마포어 = 0 이 될 때까지 기다림
```

&ensp;세마포어가 1이 되었으므로 wait(-1) 성공:<br/>
```
세마포어 = 1 → 0
B는 buf[0] 출력
```

&ensp;이 과정이 10번 반복됨<br/>
```scss
A 입력 → 저장 → signal(+1)
B wait(-1) → 출력
```

&ensp;두 프로그램이 정확히 1:1 로 교대로 동작함<br/>

&ensp;공유 메모리 삭제는 B만<br/>
&ensp;문제 조건 때문에 Reader(B)가 마지막 cleanup 담당<br/>
```c
shmctl(shmid, IPC_RMID, 0);
```

&ensp;A는 exit만 함<br/>

* 공유메모리는 데이터를 실제로 담는 곳
* 세마포어는 읽기/쓰기 순서를 조절하는 신호등
* Writer(A)는 데이터를 쓰고 signal(+1)
* Reader(B)는 wait(-1)해서 신호를 받기 전에는 절대 읽을 수 없음
* A와 B는 정확히 10번 ping-pong 구조로 동기화됨
* A는 writer만 B는 read만 하도록 분업됨

## 코드 분석

&ensp;union semun<br/>
```c
union semun{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
```

* 여기서는 `arg.val`만 사용해서 세마포어 초기값 설정에 씀

### 프로그램 A

```c
int shmid, semid, i, n, *buf;
key_t key1, key2;
union semun arg;
struct sembuf p_buf;
```

* shmid: 공유 메모리 ID(shmget의 결과)
* semid: 세마포어 ID(semget의 결과)
* i: for 루프 인덱스
* n: 여기선 안 쓰이지만 보통 scanf 임시 저장에 쓰는 int
* *buf: shmat로 받은 공유 메모리의 시작 주소(int 포인트)
* key1: 세마포어용 키
* key2: 공유 메모리용 키
* arg: semcnl 호출 시 세마포어 초기값 설정요
* p_buf: semop에 넘기는 구조체 하나

```c
struct sembuf {
    unsigned short sem_num; // 세마포어 번호 (여기선 0번만 존재)
    short          sem_op;  // +1: signal, -1: wait, 0: 0될 때까지 기다림
    short          sem_flg; // 0, IPC_NOWAIT, SEM_UNDO 등
};
```

&ensp;시험 포인트<br/>
* `struct sembuf` 에서 `sem_op`가 뭐 하는지, +1/-1 의미 자주 물음
* sem_num = 세마포어 set에서의 인덱스(여기선 0)

&ensp;3. 세마포어 생성 / 초기화 메커니즘<br/>
```c
key1 = ftok("key", 1);
```

* "key" 라는 파일 경로 +1이라는 proj_id로부터 고유한 IPC 키(key_t)를 생성
* Writer/Reader 둘 다 같은 인자로 ftok를 호출해야 같은 key를 얻어서 같은 세마포어/공유메모리에 붙을 수 있음

* `ftok("key", 1);` 에사
    - "key" 를 다른 값으로 바꾸면? → 서로 다른 IPC 객체
    - 1과 2를 섞어 쓰면? → key1/key2 구분 안 되어서 구조 깨짐

```c
semid = semget(key1, 1, IPC_CREAT | IPC_EXCL | 0600);
```

* `semget(키, 세마포어 개수, 플래그)`
* 여기선 1 → 세마포어 1개짜리 set.
* `IPC_CREAT | IPC_EXCL | 0600`
    - IPC_CREAT: 없으면 새로 만들고 있으면 열어달라
    - IPC_EXCL: 이미 존재하면 실패(-1) 시켜라 
    - 0600: 권한(소유 read/writer만 가능)
&ensp;이 키로 된 세마포어 set을 처음 만드는 경우에만 성공하고 이미 있으면 -1을 리턴해라<br/>

```c
if(semid == -1){
    semid = semget(key1, 1, 0);
}else{
    arg.val = 0;
    semctl(semid, 0, SETVAL, arg);
}
```

* semid == -1인 경우 → 이미 누가 IPC_CREAT | IPC_EXCL로 만들어둔 상태, 나는 단순히 그 세마포어에 접속만 하면 됨

```c
semid = semget(key1, 1, 0);
```

&ensp;플래그 0 → "그냥 열어줘" 의미.<br/>

* else(세마포어를 내가 최초로 생성한 프로세스) → 초기값 설정해야 함

```c
arg.val = 0;
semctl(semid, 0, SETVAL, arg);
```

* `semctl(세마ID, 세마번호, SETVAL, arg)`
* 여기서 0은 set 안에서의 세마포어 인덱스(0번 세마포어)
* `arg.val = 0` → 초기 세마포어 값은 0

&ensp;4. 공유 메모리 생성 / 붙이기<br/>
```c
key2 = ftok("key", 2);
shmid = shmget(key2, sizeof(int) * 10, IPC_CREAT | 0600);  
buf = (int *)shmat(shmid, 0, 0);
```

* key2: 공유 메모리용 키(prog_id 2로 다름 주의)
* shmget(key2, sizeof(int)* 10, IPC_CREAT | 0600)  // IPC_CREAT만 있어도 “있으면 열기 / 없으면 만들기”가 자동 충족
    - 크기: 10 * sizeof(int) bytes
* shmat : 공유 메모리 ID → 실제 프로세스 주소 공간에 붙이기
    - shmat(shmid, 0, 0) → 커널이 알아서 적절한 주소에 붙여라.

&ensp;5. for 루프 (A = Writer)<br/>
```c
for(i = 0;i < 10; i++){
    scanf("%d", (buf + i));
    p_buf.sem_num = 0;
    p_buf.sem_op = 1;
    p_buf.sem_flg = 0;
    semop(semid, &p_buf, 1);
}
```

&ensp;5-1. `scanf("%d", (buf + i));` <br/>
* 공유 메모리를 배열처럼 사용하는 부분
* buf: int *
* buf + i: i 번째 int 위치를 가리키는 포인트 → scanf에 주소를 넘겨야 하니까 이렇게 쓴 것.

&ensp;동작<br/>
1. 사용자한테 정수를 하나를 입력 받음
2. 공유 메모리의 i번째 칸에 그 숫자를 저장

&ensp;5-2. 세마포어 signal 설정<br/>
```c
p_buf.sem_num = 0;
p_buf.sem_op = 1;
p_buf.sem_flg = 0;
semop(semid, &p_buf, 1);
```

* sem_num = 0 : 세마포어 set 안에서 0번 세마포어 사용
* sem_op = 1 : signal 연산
    - 현재 값에 1만큼 더해라
    - sem_op > 0이면 그냥 더하고 끝남 (블록 X)
* sem_flg = 0 : 기본 동작 (블록 허용, SEM_UNDO 안 씀)

&ensp;semop(semid, &p_buf, 1); → semid에 해당하는 세마포어 set에 대해 p_buf에 적힌 연산을 1개 적용해라<br/>

&ensp;동작 메커니즘<br/>
* A가 한 번 입력하고 나면 세마포어 값: 0 → 1 → 2 → ...
* B는 sem_op = -1로 기다리고 있다가 이 값이 양수일 때 통과.

### 프로그램 B

&ensp;1. for 루프 (B = Reader)<br/>
```c
for(i = 0; i < 10; i++){
    p_buf.sem_num = 0;
    p_buf.sem_op = -1;
    p_buf.sem_flg = 0;
    semop(semid, &p_buf, 1);
    printf("%d\n", *(buf + i));
}
```

&ensp;(1) p_buf 설정<br/>
```c
p_buf.sem_num = 0;
p_buf.sem_op = -1;
p_buf.sem_flg = 0;
semop(semid, &p_buf, 1);
```

* `sem_op = -1`: wait(P 연산) → 현재 세마포어 값이 1 이상이 될 때까지 블록, 가능해지면 값에서 1을 빼고 진행

&ensp;상황예시<br/>
* 처음: sem 값 = 0
* A가 입력 후 signal: sem = 1
* B가 sem_op = -1 호출: sem = 0, 블록 해제 → 진행
* 다시 A가 입력 후 signal: sem = 1
* B가 다시 wait(-1): sem = 0 …

&ensp;→ 이렇게 해서 A가 한 번 쓰면, B가 한 번 읽을 수 있도록 1:1 동기화됨<br/>

&ensp;(2) 공유 메모리 읽기<br/>
```c
printf("%d\n", *(buf + i));
```

* buf + i : i번째 int 주소
* *(buf + i) : 그 위치에 저장된 int 값 → A가 scanf로 입력해 놓은 값

&ensp;2. 공유 메모리 해제<br/>
```c
shmctl(shmid, IPC_RMID, 0);
```

* shmctl: 공유 메모리 제어
* IPC_RMID: 이 공유메모리 ID를 시스템에서 삭제하라

&ensp;동작 메커니즘<br/>
* 커널이 참조 카운트를 보고 더 이상 붙어 있는 프로세스가 없으면 실제로 제거

&ensp;전체 메커니즘 한 줄 정리<br/>
* A(Writer)
1. 공유메모리 buf[i]에 정수 입력
2. sem_op = +1 → 세마포어 증가 → "읽어도 된다" 신호

* B(Reader)
1. sem_op = -1 → 세마포어가 0 이상이 될 때까지 기다림
2. 값이 1 이상이면 1 감소시키고 통과
3. 그 시점에서 buf[i] 값을 안전하게 읽어서 출력