---
title: "Lect11-2. Semaphore"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-26
last_modified_at: 2025-11-26
---

Semaphore
=====

&ensp;세마포어가 필요한 이유<br/>
* 여러 프로세스/쓰레드가 같은 자원(공유 변수, 파일, 메모리 등)을 동시에 쓰려고 하면 → 값이 꼬이거나 덮어쓰거나 이상한 결과가 나오(race condition, 경쟁 상태)
    - race Condition: 둘 이상의 프로세스/쓰레드가 같은 데이터(공유 자원)에 동시에 접근해서 그 결과가 누가 먼저 실행되느냐에 따라 달라지는 상태
    - 실행 순서에 의해 결과가 달라지는 위험한 상황
* 그래서 한 번에 몇 명까지만 들어와 라는 출입 관리 장치가 필요함

&ensp;비유<br/>
* 화장실 칸이 3개 있는 공용 화장실 → 동시에 최대 3명까지 사용 가능, 이 3이라는 숫자를 관리하는 게 세마포어 값(sem)이라고 보면 됨

&ensp;세마포어의 정체<br/>
&ensp;세마포어는 커널이 관리하는 정수 변수 + 대기 큐(queue)라고 보면 된다.<br/>

* 내부에 정수 값 `sem` 을 하나 가지고 있고
* `sem`이 0이하면 더 이상 못 들어오게 막고 기다리는 프로세스들을 큐에 줄 세워둠
* 두 가지 연산만 제공
    - `P(sem)` = `wait(sem)` (문 앞에 기다림 / 자원 잠금)
    - `V(sem)` = `signal(sem)` (문 열어줌 / 자원 해제)
* 이 두 가지 연산을 이용해서 임계구역(critical section)을 보호함

&ensp;둘 다 원자적(atomic)으로 수행됨 → 중간에 끊기지 않음.<br/>

<details>
<summary>race condition 예제</summary>
&ensp;예: 밥솥에 밥이 공기 남았다.<br/>

* 소희가 밥솥을 확인함 → 남은밥 = 1
* 명우도 동시에 밥솥을 확인함 → 남은밥 = 1

&ensp;둘 다 생각함: 밥이 있네<br/>
1. 남은밥 = 1
2. 둘 다 “밥 감소” 실행 → 남은밥 = 0이 되어야 함 하지만 둘 다 이전 값을 보고, 둘 다 1에서 0을 빼지 않고 둘 다 1 → 0을 실행해버림. 또는 둘 다 1을 쓰기도 하고 값이 0 대신 -1이 되기도 함

&ensp;결과적으로 밥솥 상태가 꼬임 → race condition(경쟁 상태)<br/>

&ensp;Race Condition이 왜 발생하는가?<br/>
&ensp;공유 자원을 접근하는 과정은 이렇게 생겼다.<br/>
&ensp;**실제 프로그램의 한 줄은 원자적(atomic)이지 않음**<br/>
```c
x = x + 1;
```

&ensp;이렇게 생겼지만 실제 CPU는 이렇게 나눈다.<br/>
1. 메모리에서 x 읽기
2. 레지스터에 x 저장
3. 1 증가
4. 다시 메모리에 저장

&ensp;이 중 어떤 순간에든 다른 프로세스가 끼어들 수 있음 그래서 프로세스 A가 값을 읽고 → 증가하기 전, 프로세스 B가 값을 읽고 → 증가하기 전. 서로 꼬임<br/>

</details>

P(sem) / wait(sem) 동작
====

```text
p(sem) or wait(sem)
    if (sem > 0)
        decrement sem by one;     // sem = sem - 1;
    else
        wait until sem becomes non-zero;
        then decrement;
```

&ensp;해석<br/>
1. `P(sem)`을 호출하면
2. 현재 값 `sem` 을 본다
* `sem > 0` 이면 → "들어가도 되는 상태", `sem` 을 1 줄이고 (자리 하나 차지) → 바로 진행
* `sem == 0` 또는 `sem < 0` 이면 → "자리가 없다", 이 프로세스를 잠재워(블록) 대기 큐에 넣고 나중에 누가 V(sem) 해서 자리 비워줄 때까지 기다림

<details>
<summary>비유</summary>
&ensp;화장실 비유<br/>

* `sem` = 남은 칸 수
* `P(sem)` = 들어가도 되나 하고 문 열어 보는 행동
    - 남은 칸 > 0 → 들어가고 남은 칸 수 1 줄임
    - 남은 칸 = 0 → 문 잠겨있으니까 복도에서 기다림

</details>

V(sem) / signal(sem) 동작
=====

```text
v(sem) or signal(sem)
    increment sem by one;         // sem = sem + 1;
    if (queue of waiting processes not empty)
        restart first process in wait queue;
```

&ensp;해석<br/>
1. `V(sem)`을 호출하면
2. `sem` 값을 1 증가시킴 → "자리 하나 비었다!"
3. 만약 기다리고 있는 프로세스들이 있다면
    - 대기 큐에서 맨 앞에 있는 하나를 깨워서 실행 다시 시작시킴
    - 그 깨어난 프로세스가 다시 `P(sem)` 를 수행해서 자리를 차지

<details>
<summary>비유</summary>

* `V(sem)` = 볼일 보고 나와서 칸 하나 비웠다. → `sem++`
* 복도에 줄 서 있던 사람 있으면 → 맨 앞사람 불러서 "이제 들어가세요~" 하고 들여보냄.

</details>

세마포어 사용 패턴
====

```c
p(sem);
something interesting;
v(sem);
```

&ensp;이 패터닝 세마포어의 기본 사용법이다.<br/>
* `p(sem);` → 공유 자원에 들어가기 전 잠금(lock) 요청, 들어갈 수 있으면 `sem--` 하고 들어감, 안 되면 기다림.
* `something interesting;` → 실제로 공유 자원 읽고/쓰기 하는 부분, OS 책에서 말하는 critical section (임계 구역).
* `v(sem);` → 다 썼으니 잠금 해제(unlock), `sem++` 하고 혹시 기다리는 애 있으면 하나 깨워줌

&ensp;즉, 임계 구역 앞뒤에 항상 `P` / `V` 를 쌍으로 둔다:<br/>
```c
P(sem);      // wait(sem)
  // --- critical section ---
  // 공유 변수, 공유 메모리 접근
V(sem);      // signal(sem)
```

&ensp;세마포어 종류 두 가지<br/>
1. binary semaphore(mutex 처럼)
* 초기값: 1
* 한 번에 딱 1개 프로세스만 임계 구역 진입 가능
* `P` 하면 1 → 0 (들어감), 다른 프로세스가 오면 0이니까 기다림
* `V` 하면 0 → 1 (나옴, 다른 사람 들어갈 수 있음)
2. counting semaphore
* 초기값: `N` (자원이 N개)
* 한 번에 최대 N개까지 들어올 수 있음
* 예: 프린터 3개, 버퍼 슬롯 10개, 화장실 칸 4개 등

semget()
====

&ensp;`semget` 시스템 콜 이해<br/>
&ensp;리눅스에서 실제로 세마포어를 어떻게 만들까?<br/>

&ensp;segment 함수 형태<br/>
```c
#include <sys/sem.h>
#include <sys/types.h>
#include <sys/ipc.h>

int semget(key_t key, int nsems, int permflags);
```

&ensp;각 인자 설명<br/>
* `key`: 세마포어 집합을 구분하는 이름 같은 것
    - `ftok("파일이름", 숫자)` 로 만들어진다.
    - 같은 `key` 를 쓰면 같은 세마포어 집합을 공유함
* `nsems`
    - 이 집합 안에 세마포어가 몇 개 있나?
    - 예를 들어 4개짜리 세마포어 배열을 만들고 싶으면 `nsems = 4`
* `permflags`
    - 권한 및 생성 옵션
    - 예: `0600 | IPC_CREAT`
    - IPC_CREAT | IPC_EXCL 조합은 “초기화 한 번만” 하기 위해 반드시 필요
    - 최초 생성 성공한 프로세스만 초기화 수행해야 함
* return 값: 
    - 성공 시 → 세마포어 집합 ID (semid)
    - 실패 시 → -1

&ensp;이 `semid` 는 나중에 `semop`, `semctl` 같은 함수에 넘겨서 실제 `P/V` 연산을 하거나 초기값 설정할 때 사용함<br/>

```text
semid  ──>  [ index 0 ]  [ index 1 ]  [ index 2 ]  [ index 3 ]
             semval=2     semval=4     semval=1     semval=3
```

* `semget(key, 4, ...)` 을 호출해서 4개짜리 세마포어 집합을 만들었다고 가정
* 커널 안에는 세마포어 배열이 생김
* `semid`: 이 세마포어 집합 전체를 가리키는 ID (정수 하나)
* `index`: 집합 안에서 몇 번째 세마포어인지를 나타냄
* `semval`: 각각의 세마포어 값(자원의 개수, 남은 자리 수 같은 것)

&ensp;하나의 `semid` 안에 여러 개의 세마포어를 묶어서 관리할 수 있다.<br/>
&ensp;각각은 `index` 로 접근함<br/>
* 예: 0번 세마포어롤 생상자/소비자 버퍼 관리, 1번 세마포어로 다른 자원 관리 

&ensp;지금 까지 내용 요약<br/>
1. 세마포어는 공유 자원 동기화를 위한 정수 + 대기 큐.
2. 두 연산만 있다. 
    - P(sem) / wait(sem) :
        + sem > 0 이면 sem-- 하고 통과
        + sem <= 0 이면 큐에 넣고 잠재움.
    - V(sem) / signal(sem) :
        + sem++
        + 기다리는 프로세스 있으면 한 명 깨움.
3. 리눅스 System V에서 세마포어 만들기:
    - `semget(key, nsems, permflags)`
    - 리턴 값 `semid`는 세마포어 집합 ID
4. 한 `semid` 안에는 `nsems`개의 세마포어(배열)가 있고 각각의 현재 값이 `semval` 로 관리됨

세마포어 상태 값
----

&ensp;세마포어 "집합" 안의 각 세마포어(index 별)이 가지고 있는 값<br/>
&ensp;1) `semval`<br/>
&ensp;**세마포어 값(현재 자원의 개수)**<br/>
* `P` 하면 줄어드는 값
* `V` 하면 증가
* 초기화 반드시 필요 (안 하면 쓰레기 값)

&ensp;예:<br/>
&ensp;버퍼 크기 1인 경우 → `semval = 1`, 빈 버퍼 10개 → `semval = 10` <br/>

&ensp;2) `sempid` <br/>
&ensp;**마지막으로 이 세마포어를 건드린(process) 프로세스의 PID** <br/>
* 최근에 P/V 연산을 수행한 프로세스 ID가 저장됨
* 디버깅용으로 사용

&ensp;예: Producer 프로세스가 sem[0] 을 `P` 했다면 → producer PID가 들어감<br/>

&ensp;3) `semncnt` <br/>
&ensp;**세마포어 값이 증가하기를 기다리는 프로세스 수** <br/>
&ensp;세마포어 값이 0이어서 P를 못 하고 "언제 V(signaling)해서 세마포어 값이 늘어나나.." 기다리는 프로세스들 → 일반적으로 P(sem) 때문에 잠들어 있는 프로세스 수라고 보면 된다.<br/>

&ensp;4) `semzcnt` <br/>
&ensp;**세마포어 값이 0이 되기를 기다리는 프로세스 수** <br/>
&ensp;일부 프로그램에서는 "값이 0이 되면 진행해라" 같은 조건에서 사용됨<br/>
&ensp;예: 모든 작업 끝날 때까지 기다리는 프로세스 같은 경우<br/>

| 상태값         | 설명                           |
| ----------- | ---------------------------- |
| **semval**  | 실제 세마포어 값 (임계구역 접근 가능 횟수)    |
| **sempid**  | 마지막으로 이 세마포어를 P/V 한 프로세스 PID |
| **semncnt** | `P` 때문에 block된 프로세스 수        |
| **semzcnt** | 세마포어 값이 0이 되기를 기다리는 수        |

semctl()
=====

&ensp;세마포어의 상태를 읽거나 초기화하려면 `semctl()`을 사용해야 한다.<br/>

```c
int semctl(int semid, int sem_num, int command, union semun arg);
```

&ensp;매개변수 의미<br/>
&ensp;1) `semid` <br/>
&ensp;`semget()`에서 받은 세마포어 집합 ID<br/>
&ensp;2) `sem_num` <br/>
&ensp;집합 안에 있는 **몇 번째 세마포어인지(index)** 지정<br/>
&ensp;예: `sem_num = 0` → 첫 번째 세마포어<br/>
&ensp;3) `command` <br/>
* 값 읽기 (`GETVAL`)
* 값 설정 (`SETVAL`)
* 전체 세마포어 초기화 (`SETALL`)
* 세마포어 집합 제거 (`IPC_RMID`)
* 상태 정보 가져오기 (`IPC_STAT`)
* 등등...

&ensp;4) `arg` <br/>
* 세마포어 값을 설정하거나
* 상태 구조체를 저장하거나
* 전체 배열을 초기화할 때 사용되는 구조체

&ensp;command에 따라 **arg가 쓰이기도 하고 안 쓰이기도 함** <br/>

semctl() 명령 종류
-----

### 단일 세마포어에 대한 명령

&ensp;**GETVAL**<br/>
&ensp;특정 index의 `semval` 값 읽기<br/>
```c
int value = semctl(semid, 0, GETVAL, arg);
```

&ensp;**SETVAL** <br/>
&ensp;특정 index의 `semval` 값을 설정<br/>
```c
arg.val = 1;
semctl(semid, 0, SETVAL, arg);
```

&ensp;**GETPID** <br/>
&ensp;세마포어를 마지막에 P/V 한 PID 가져오기<br/>

&ensp;**GETNCNT / GETZCNT** <br/>
&ensp;대기 queue 상태 값 확인<br/>

### 세마포어 집합 전체에 대한 명령

&ensp;**GETALL** <br/>
&ensp;모든 세마포어의 `semval` 을 arg.array에 저장<br/>
&ensp;**SETALL** <br/>
&ensp;모든 세마포어의 값을 한 번에 초기화<br/>
&ensp;예<br/>
```c
unsigned short values[4] = {1, 0, 2, 3};
arg.array = values;
semctl(semid, 0, SETALL, arg);
```

union semun 구조체
-----

&ensp;이 구조체는 command 종류에 따라 전달할 데이터를 선택하는 용도이다.<br/>

```c
union semun {
    int val;               // SETVAL에 사용
    struct semid_ds *buf;  // IPC_STAT, IPC_SET 등에 사용
    unsigned short *array; // GETALL, SETALL에 사용
};
```

&ensp;**val** <br/>
* 단일 세마포어의 값을 설정할 때 사용 (SETVAL)

&ensp;**buf** <br/>
* 세마포어 상태 전체를 받아오는 구조체 (거의 사용 잘 안 함)

&ensp;**array**<br/>
* 전체 세마포어 집합의 값을 읽거나 설정할 때 사용 (GETALL, SETALL)

&ensp;세마포어 초기화 전체 예제<br/>
&ensp;보통 System V 세마포어 초기화는 이렇게 한다.<br/>
```c
key_t key = ftok("key", 1);
int semid = semget(key, 1, 0600 | IPC_CREAT);

union semun arg;
arg.val = 1;   // binary semaphore 1로 초기화

semctl(semid, 0, SETVAL, arg);
```

* 세마포어 집합 1개 만들고
* 그 안의 0번 세마포어 값을 1로 초기화

semop()
====

```c
int semop(int semid, struct sembuf *op_array, size_t num_ops);
```

&ensp;각 인자 설명<br/>

| 인자           | 의미                          |
| ------------ | --------------------------- |
| **semid**    | 세마포어 집합 ID (`semget`로 만들어짐) |
| **op_array** | 하나 또는 여러 개의 연산을 담고 있는 배열    |
| **num_ops**  | 배열(op_array)에 들어있는 연산의 개수   |

&ensp;한 번의 semop() 호출에서 여러 개 세마포어에 대한 여러 연산을 동시에 수행할 수 있음 (원자적 atomic 실행)<br/>

struct sembuf 구조체
----

&ensp;semop()는 struct sembuf 배열을 인자로 받는다.<br/>
```c
struct sembuf {
    unsigned short sem_num;   // 세마포어 index
    short sem_op;             // 수행할 연산
    short sem_flg;            // 옵션
};
```

&ensp;필드 설명<br/>

| 필드          | 의미                             |
| ----------- | ------------------------------ |
| **sem_num** | 세마포어 집합 안에서 몇 번째 세마포어인지(index) |
| **sem_op**  | 수행할 연산 (양수/0/음수)               |
| **sem_flg** | 옵션 (IPC_NOWAIT 또는 SEM_UNDO)    |

&ensp;세마포어 연산에서 flag의 의미<br/>
&ensp;IPC_NOWAIT<br/>
* P 연산 실패 시 블록하지 않고 즉시 -1 리턴

&ensp;SEM_UNDO
* 종료 시 지금까지의 P/V 효과를 원복

sem_op의 연산 의미
----

&ensp;sem_opp의 값에 따라 의미가 완전히 달라짐<br/>

&ensp;1) sem_op < 0 → wait(P) 연산<br/>
&ensp;Ex) `sem_op = -1` → 우리가 말하는 P(sem) 동작<br/>
&ensp;동작<br/>
```c
if (semval >= |sem_op| )
    semval = semval - |sem_op|;
else
    블록(block) 상태로 기다림
```

* 남은 자원이 충분하면 즉시 들어감
* 아니면 대기 큐에서 잠듦

&ensp;2) sem_op > 0 → signal(V) 연산<br/>
&ensp;Ex) `sem_op = 1` <br/>
```c
semval = semval + sem_op
```

&ensp;→ 우리가 말하는 V(sem)<br/>
* 자원 반납
* 대기 프로세스 있으면 깨움

&ensp;3) sem_op = 0 → 0이 될 때까지 기다림<br/>
&ensp;특이한 연산이지만 가끔 사용됨<br/>
&ensp;Ex) 다른 프로세스가 모든 자원을 다 쓸 때까지 기다리는 경우<br/>

| sem_op   | 의미    | 동작                        |
| -------- | ----- | ------------------------- |
| **< 0**  | P 연산  | semval이 충분할 때만 감소, 아니면 대기 |
| **> 0**  | V 연산  | semval 증가 후 대기자 깨움        |
| **== 0** | 특수 대기 | semval == 0이 될 때까지 대기     |


semaphore 연산 실행의 예
-----

```c
struct sembuf p_buf;
p_buf.sem_num = 0;
p_buf.sem_op = -1;   // wait (P)
semop(semid, &p_buf, 1);

printf("process %d in critical section\n", pid);
sleep(10);

printf("process %d leaving critical section\n", pid);

p_buf.sem_num = 0;
p_buf.sem_op = 1;    // signal (V)
semop(semid, &p_buf, 1);
```

&ensp;이 코드의 의미<br/>
&ensp;(1) 임계구역에 들어가기 전<br/>
* `sem_op = -1` → P 연산
* 세마포어 값이 1이었다면 0으로 감소하고 진입
* 값이 0이었다면 → 기다림

&ensp;(2) critical section 실행<br/>
* sleep(10)은 임계구역 점유를 흉내낸 것

&ensp;(3) 임계구역 나올 때<br/>
* `sem_op = +1` → V 연산
* 세마포어 값 1 증가
* 대기 프로세스가 있으면 한 명 깨워줌

