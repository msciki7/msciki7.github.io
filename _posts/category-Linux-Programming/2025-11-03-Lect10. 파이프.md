---
title: "Lect10. pipe"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-03
last_modified_at: 2025-11-03
---

파이프(Pipe)
=====

&ensp;파이프(pipe)는 두 프로세스 간 데이터를 주고받기 위한 통신 채널(통로)이다.<br/>

* 한 프로세스가 데이터를 `write()` 로 파이프에 쓰면 다른 프로세스가 `read()` 로 그 데이터를 읽는다.
* 기본적으로 단방향(한쪽 방향) 통신만 가능하다.
    - 한쪽 쓰기 전용, 다른 한쪽은 읽기 전용
* 파일처럼 동작하지만 실제 파일 시스템에는 존재하지 않는다.

&ensp;파이프의 특징<br/>

| 항목                | 설명                                                                 |
| ----------------- | ------------------------------------------------------------------ |
| **통신 방식**         | 부모 ↔ 자식 프로세스 간 **단방향 통신**                                          |
| **처리 방식**         | FIFO(First In First Out) — 먼저 쓴 데이터가 먼저 읽힘                         |
| **파일 디스크립터**      | 파이프를 만들면 2개의 fd(file descriptor)가 생김<br> `p[0]`: 읽기용 / `p[1]`: 쓰기용 |
| **파일 시스템에 없음**    | 파이프는 메모리 상의 특수한 버퍼이기 때문에 디스크에 저장되지 않음                              |
| **`lseek()` 불가능** | 랜덤 접근 불가. 순차적으로만 읽고 써야 함.                                          |
| **상속 가능**         | `fork()` 시 부모가 만든 파이프는 자식에게도 상속됨.                                  |

# 파이프 생성 함수

```c
#include <unistd.h>
int pipe(int filedes[2]);
```

* 반환값: 성공 시 0, 실패 시 -1 반환
* `filedes[0]`: 읽기 전용 (read end)
* `filedes[1]`: 쓰기 전용 (write end)
* 제한: 프로세스당 열 수 있는 파일 수 제한 존재

&ensp;pipe() 호출 시 OS가 내부적으로 두 개의 파일 디스크립터 생성, 하나는 읽기용, 하나는 쓰기용으로 사용됨<br/>

&ensp;동작 구조(기본 원리)<br/>
```scss
부모 프로세스                         자식 프로세스
  ↓                                       ↓
[쓰기용 파이프 open]                  [읽기용 파이프 open]
       ↓                                       ↓
     write()  ----------------------->       read()
```

* 부모는 데이터를 쓰고
* 자식은 그 데이터를 읽는다.
* 양쪽 모두 필요 없는 방향의 파이프를 닫아야 한다.(`close()`)

&ensp;pipe의 특성<br/>
* FIFO (First In First Out) 방식으로 동작
* `lseek()` 불가 — 랜덤 접근이 아닌 순차 처리만 가능
* `fork()` 시 상속됨 → 부모가 만든 파이프를 자식이 물려받음

&ensp;부모 → 자식 단방향 통신 순서<br/>
1. `pipe()` 호출 (부모에서 파이프 생성)
2. `fork()`로 자식 생성 → 파이프 복사됨
3. 부모는 읽기용 닫기, 자식은 쓰기용 닫기
4. 부모 → 자식 데이터 전송 가능 (`write() / read()`)

&ensp;파이프 예제 코드<br/>
```c
main() {
    char ch[10];
    int pid, p[2];

    if (pipe(p) == -1) {
        perror("pipe call");
        exit(1);
    }

    pid = fork();

    if (pid == 0) {  // 자식 프로세스
        close(p[1]);                 // 쓰기용 닫기
        read(p[0], ch, 10);          // 파이프로부터 데이터 읽기
        printf("%s\n", ch);          // 읽은 내용 출력
        exit(0);
    }

    close(p[0]);                     // 부모는 읽기용 닫기
    scanf("%s", ch);                 // 입력 받기
    write(p[1], ch, 10);             // 자식에게 데이터 쓰기
    wait(0);                         // 자식 종료 대기
    exit(0);
}
```

1. 부모가 `pipe()` 로 파이프 생성
2. `fork()` → 자식이 복사된 파이프 핸들을 상속
3. 부모가 문자열 입력 → `write()`
4. 자식이 `read()`로 읽고 `printf()`로 출력
5. 종료

&ensp;실행 결과 예시<br/>
```shell
$ ./pipe_program
hello
hello
```

&ensp;부모가 입력한 "hello" 를 파이프로 전달받은 자식이 출력한다.<br/>

# 양방향 통신

&ensp;기본적인 pipe는 단방향(one-way) 통신만 가능하다. 하지만 양방향(dual-way) 통신을 하고 싶다면 파이프를 2개 만들어야 한다.<br/>

&ensp;구조<br/>

| 구분    | 역할         | 부모 프로세스      | 자식 프로세스      |
| ----- | ---------- | ------------ | ------------ |
| pipe1 | 부모 → 자식 전송 | write end 사용 | read end 사용  |
| pipe2 | 자식 → 부모 전송 | read end 사용  | write end 사용 |

&ensp;동작 과정<br/>
1. `pipe()` 두 번 호출 → `pipe1`, `pipe2` 생성
2. `fork()` 호출 → 부모의 파이프 복사
3. 각 프로세스는 필요 없는 파이프 끝을 `close()`
    - 부모: pipe1의 read end, pipe2의 write end 닫음
    - 자식: pipe1의 write end, pipe2의 read end 닫음
4. 서로 데이터를 주고받으며 양방향 통신 가능

&ensp;Blocking read / Blocking write<br/>

| 구분          | Blocking이 발생하는 경우               |
| ----------- | ------------------------------- |
| **read()**  | 파이프가 **비어 있을 때** (읽을 데이터가 없을 때) |
| **write()** | 파이프가 **가득 찼을 때** (버퍼가 꽉 찼을 때)   |

&ensp;파이프는 버퍼 기반으로 동작하며 버퍼가 비어 있거나 가득차면 프로세스는 일시 정지(block) 된다.<br/>

# 파이프 닫기

&ensp;파이프의 끝을 닫을 때는 어떤 프로세스가 읽기/쓰기 역할인지에 따라 동작이 다르다.<br/>

&ensp;쓰기 전용 파이프 닫기<br/>
* 더 이상 writer가 없는 상태에서 reader가 `read()`를 시도하면? → 0 반환 (EOF와 동일한 효과)

&ensp;writer가 모두 종료되면 reader는 읽을 데이터 없음으로 판단한다.<br/>

&ensp;읽기 전용 파이프 닫기<br/>
* 더 이상 reader가 없는 상태에서 writer가 `write()`하면? → `SIGPIPE` 시그널 발생 → 처리하지 않으면 프로세스 비정상 종료

```bash
Broken pipe
```

* 만약 시그널을 직접 처리(`signal(SIGPIPE, handler)`) 하면 writer 는 -1 을 반환하고 `errno` 에 `EPIPE` 가 설정된다.

&ensp;핵심요약<br/>
* eader가 없을 때 write하면 SIGPIPE
* writer가 없을 때 read하면 0 반환 (EOF)

# Non-blocking I/O

&ensp;Blocking 방식에서는<br/>
* 읽을 데이터가 없을 때 `read()`는 멈추고
* 버퍼가 꽉 찼을 때 `write()`도 멈춘다.

&ensp;→ 이를 피하기 위해 Non-blocking I/O 방식을 사용할 수 있다.<br/>

&ensp;Non-blocking 설정 방법<br/>
```c
#include <fcntl.h>

fcntl(filedes, F_SETFL, O_NONBLOCK);
```

* 특정 파일 디스크립터(`filedes`)에 논블로킹 모드를 설정한다.

&ensp;동작 방식<br/>

| 상황                      | 반환값  | 설명                       |
| ----------------------- | ---- | ------------------------ |
| **쓰기 전용인데 버퍼가 가득 찼을 때** | `-1` | 즉시 실패 (`errno = EAGAIN`) |
| **읽기 전용인데 버퍼가 비었을 때**   | `-1` | 즉시 실패 (`errno = EAGAIN`) |

&ensp;기다리지 않고 지금은 불가능하니 나중에 다시 시도해라 는 뜻으로 `EAGAIN` 을 반환한다.<br/>

&ensp;예시 코드<br/>
```c
int fd[2];
pipe(fd);
fcntl(fd[0], F_SETFL, O_NONBLOCK); // 읽기 비차단 모드

char buf[20];
int n = read(fd[0], buf, sizeof(buf));

if (n == -1 && errno == EAGAIN)
    printf("현재 읽을 데이터가 없습니다.\n");
```

* `O_NONBLOCK` 옵션을 설정하면 `read()` / `write()`가 즉시 반환된다.
* `EAGAIN`은 “지금은 불가능, 나중에 다시 시도하라”는 의미이다.
* 여러 파이프를 동시에 관리해야 할 때 유용하다.

&ensp;요약<br/>

| 구분               | 내용                                         |
| ---------------- | ------------------------------------------ |
| **단방향 통신**       | pipe 1개, 부모 → 자식                           |
| **양방향 통신**       | pipe 2개, 각각 반대 방향                          |
| **blocking**     | 비어있으면 read block, 가득 차면 write block        |
| **닫기 동작**        | reader 없음 → SIGPIPE, writer 없음 → EOF(0 반환) |
| **non-blocking** | 즉시 -1, errno=EAGAIN 반환                     |

파이프를 이용한 Client–Server & select()
=====

# 파이프 기반 Client-Server 모델

&ensp;여러 개의 클라이언트(client) 프로세스가 각각 자신의 파이프를 통해 요청(request)을 보내고 서버(Server) 프로세스는 여러 파이프를 모니터링하며 요청을 읽는 구조이다.<br/>

&ensp;구조 요약<br/>

| 역할         | 설명                                                  |
| ---------- | --------------------------------------------------- |
| **Client** | 자신의 파이프(예: `pipe1`, `pipe2` …)에 요청 데이터를 **write()** |
| **Server** | 여러 파이프의 **read end**를 열고 요청이 들어오면 **read()**로 처리    |

&ensp;동작 원리<br/>

1. 서버는 여러 클라이언트의 파이프를 `read()` 할 준비를 한다.
2. 아무 요청도 없으면 → 서버는 blocking 상태 (대기 중)
3. 어느 한 클라이언트라도 write() 하면 → 그 파이프에서 요청을 읽는다.
4. 동시에 여러 요청이 들어오면 → 순서대로(FIFO) 읽는다.

&ensp;문제점<br/>
* 단순 `read()`만 사용하면 “어느 파이프에 데이터가 있는지” 알기 어렵다.
* 모든 파이프를 동시에 감시하려면 `select()` 같은 시스템 호출이 필요하다.

# select() 시스템 호출

&ensp;역할<br/>
&ensp;`select()` 는 여러 파일 디스크립터(fd) 중 어느 것이 읽기/쓰기/에러 처리 가능 상태인지 감시하는 시스템 콜이다.<br/>

&ensp;필요성<br/>
* 서버가 여러 개의 파이프나 소켓을 동시에 감시해야 할 때 하나씩 `read()` 하면 효율이 떨어진다.
* `select()` 는 **“준비된 fd만 알려주는 함수”**로 비효율적 blocking을 방지할 수 있다.

&ensp;주요 특징<br/>

| 항목                 | 설명                                  |
| ------------------ | ----------------------------------- |
| **읽기/쓰기 가능 여부 감시** | 지정된 fd들 중 어떤 것이 read/write 가능한지 확인  |
| **blocking 발생**    | 모든 fd가 준비되지 않으면 대기                  |
| **timeout 설정 가능**  | 일정 시간 후 자동으로 빠져나오게 설정하여 영구 block 방지 |

&ensp;`select()` 는 여러 입력을 동시에 감시할 수 있게 해주는 멀티 I/O 감시 시스템 콜이다. <br/>

&ensp;select() 사용법<br/>
```c
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds,
           fd_set *readfds,
           fd_set *writefds,
           fd_set *errorfds,
           struct timeval *timeout);
```

&ensp;매개변수 설명<br/>

| 인자           | 의미                             |
| ------------ | ------------------------------ |
| **nfds**     | 감시할 파일 디스크립터 중 **가장 큰 번호 + 1** |
| **readfds**  | 읽기 가능한 fd 집합                   |
| **writefds** | 쓰기 가능한 fd 집합                   |
| **errorfds** | 에러가 발생한 fd 집합                  |
| **timeout**  | 타임아웃 설정 (NULL이면 무한 대기)         |

&ensp;fd_set 관련 매크로<br/>
&ensp;`fd_set` 은 `select()` 가 감시할 파일 디스크립터 집합을 관리하는 비트마스크(bitmask) 구조이다. 어떤 fd를 감시할지 0/1 로 표시하는 일종의 비트 배열이다.<br/>

&ensp;주요 매크로<br/>

| 매크로                               | 설명                                 |
| --------------------------------- | ---------------------------------- |
| `FD_ZERO(fd_set *fdset)`          | fd 집합을 초기화 (모든 비트 0으로 설정)          |
| `FD_SET(int fd, fd_set *fdset)`   | 특정 fd를 감시 대상에 추가 (비트를 1로 설정)       |
| `FD_CLR(int fd, fd_set *fdset)`   | 특정 fd를 감시 대상에서 제거 (비트를 0으로 설정)     |
| `FD_ISSET(int fd, fd_set *fdset)` | 특정 fd가 감시 대상에 포함되어 있는지 확인 (1인지 검사) |

&ensp;사용 예시<br/>
```c
fd_set readfds;

FD_ZERO(&readfds);        // 초기화
FD_SET(pipe1[0], &readfds);  // 감시할 fd 추가
FD_SET(pipe2[0], &readfds);

select(max_fd + 1, &readfds, NULL, NULL, NULL);

if (FD_ISSET(pipe1[0], &readfds))
    printf("pipe1에 데이터가 도착했습니다!\n");
```

&ensp;`select()` 호출 후에는 FD_ISSET()으로 어떤 fd가 준비되었는지 확인한다.<br/>
&ensp;`fd_set`은 `select()`가 감시할 fd들의 목록을 관리하는 구조체이며 `FD_SET`, `FD_CLR`, `FD_ISSET`, `FD_ZERO` 네 가지 매크로로 제어한다.<br/>

# timeval 구조체

&ensp;`timeval` 은 `select()` 의 대기 시간(timeout)을 정의하는 구조체이다.<br/>
&ensp;구조 정의<br/>
```c
struct timeval {
    long tv_sec;   // 초 단위 (seconds)
    long tv_usec;  // 마이크로초 단위 (microseconds)
};
```

&ensp;timeout 인자의 의미<br/>

| 설정 값         | 의미                             |
| ------------ | ------------------------------ |
| `NULL`       | 이벤트 발생 시까지 무한 대기 (영구 blocking) |
| `0`          | non-blocking (즉시 반환)           |
| 특정 값 (예: 5초) | 지정된 시간 동안 대기 후, 이벤트 없으면 반환     |

&ensp;예시<br/>
```c
struct timeval tv;
tv.tv_sec = 5;     // 5초 동안 대기
tv.tv_usec = 0;

select(max_fd + 1, &readfds, NULL, NULL, &tv);
```

* 만약 5초 안에 읽을 수 있는 fd가 없으면 `select()`는 0을 반환한다.
* "타임아웃 발생"을 의미한다.

&ensp;핵심 요약<br/>
&ensp;`timeval`은 select()의 대기 시간을 제어하는 구조체이며 NULL → 무한대기, 0 → 즉시 반환, 숫자 → 지정 시간 대기<br/>

# select() 반환값

&ensp;select() 호출 후 반환값을 통해 현재 어떤 상태인지 판단할 수 있다.<br/>

&ensp;반환값 의미<br/>

| 반환값   | 의미                          |
| ----- | --------------------------- |
| `-1`  | 오류 발생 (보통 인터럽트나 잘못된 fd)     |
| `0`   | 타임아웃 (timeout 시간 동안 이벤트 없음) |
| 양의 정수 | 읽기/쓰기 가능한 fd의 **개수**        |

&ensp;예시 코드<br/>
```c
int n = select(max_fd + 1, &readfds, NULL, NULL, &tv);

if (n == -1)
    perror("select error");
else if (n == 0)
    printf("timeout: 입력 없음\n");
else {
    if (FD_ISSET(pipe1[0], &readfds))
        printf("pipe1에서 데이터 수신\n");
    if (FD_ISSET(pipe2[0], &readfds))
        printf("pipe2에서 데이터 수신\n");
}
```

&ensp;주의사항<br/>
&ensp;`select()` 호출 후에는 fd_set이 내부적으로 변경됨. 따라서, 다음 `select()` 호출 전에 반드시 `FD_ZERO()` → `FD_SET()`으로 다시 설정해야 한다.<br/>

&ensp;요약<br/>
* select()는 읽기/쓰기 가능한 fd 개수를 반환한다.
* 0은 타임아웃, -1은 오류
* 반환 후 fd_set은 변경되므로 반드시 재설정해야 한다.

&ensp;select() + pipe()를 이용한 멀티프로세스 통신 예제<br/>

&ensp;부모 프로세스(서버)가 **3개의 자식 프로세스(클라이언트)**를 생성하고 각 자식은 파이프를 통해 “hello”와 “bye!!” 메시지를 부모에게 보낸다. 부모는 select()를 이용해 3개의 파이프를 동시에 감시하며 어느 자식이 메시지를 보내든 바로 읽어 처리한다.<br/>

&ensp;main() 함수<br/>
```c
#define MSGSIZE 6

char *msg1 = "hello";
char *msg2 = "bye!!";
void parent(int p[3][2]);
int child(int p[2]);

main() {
    int pip[3][2];
    int i;

    for (i = 0; i < 3; i++) {
        pipe(pip[i]);          // 각 자식별 파이프 생성
        if (fork() == 0)       // 자식 생성
            child(pip[i]);     // 자식 함수 실행
    }

    parent(pip);               // 부모는 모든 파이프 관리
    for (i = 0; i < 3; i++)
        wait(0);
    exit(0);
}
```

* pip[3][2] → 자식 3명 각각에게 1개의 파이프(읽기/쓰기용 2개 fd)
* fork() 3회 → 자식 프로세스 3개 생성
* 자식은 각자 child() 실행
* 부모는 parent()를 통해 모든 파이프를 동시에 감시

&ensp;부모는 3개의 파이프를 동시에 감시하고 자식의 각자 메시지를 독립적으로 보낸다.<br/>

&ensp;parent() 함수<br/>
```c
void parent(int p[3][2]) {
    char buf[MSGSIZE];
    fd_set set, master;
    int i;

    // 부모는 각 파이프의 쓰기쪽 닫기
    for (i = 0; i < 3; i++)
        close(p[i][1]);

    FD_ZERO(&master);           // fd_set 초기화

    for (i = 0; i < 3; i++)
        FD_SET(p[i][0], &master);   // 읽기용 파이프 등록

    while ((set = master, select(p[2][0] + 1, &set, NULL, NULL, NULL)) > 0) {
        for (i = 0; i < 3; i++) {
            if (FD_ISSET(p[i][0], &set)) {
                if (read(p[i][0], buf, MSGSIZE) > 0)
                    printf("MSG from %d = %s\n", i, buf);
            }
        }
        if (waitpid(-1, NULL, WNOHANG) == -1)
            return;
    }
}
```

&ensp;동작 설명<br/>
1. 부모는 자식이 쓰는 p[i][1] (write end)을 모두 닫음 → 부모는 읽기만 함
2. `FD_ZERO()`로 fd 집합 초기화, `FD_SET()`으로 3개의 파이프 등록
3. `select()`는 3개 파이프를 동시에 감시
    - 데이터가 들어온 파이프만 활성화됨.
4. `FD_ISSET()`으로 어떤 파이프가 읽기 가능한지 판별
5. `read()`로 데이터 읽고 화면에 출력.

&ensp;select()의 핵심 부분<br/>
```c
select(p[2][0] + 1, &set, NULL, NULL, NULL);
```

* p[2][0] + 1 → 감시할 fd 중 가장 큰 번호 + 1
* NULL → 쓰기/에러는 감시 안 함
* NULL timeout → 무한 대기

&ensp;parent()는 select()로 3개의 파이프를 동시에 감시하며 데이터가 들어온 자식의 파이프만 즉시 읽는다.<br/>

&ensp;child() 함수<br/>
```c
int child(int p[2]) {
    int count;

    close(p[0]);                  // 읽기쪽 닫기

    for (count = 0; count < 2; count++) {
        write(p[1], msg1, MSGSIZE);  // "hello" 전송
        sleep(getpid() % 4);         // 랜덤 딜레이
    }

    write(p[1], msg2, MSGSIZE);      // 마지막 메시지 "bye!!"
    exit(0);
}
```

&ensp;동작 설명<br/>
* 각 자식은 p[1]을 통해 부모에게 메시지 전송
* "hello"를 2회 보내고, 마지막에 "bye!!" 전송
* sleep(getpid() % 4)로 실행 타이밍을 다르게 만들어 부모가 동시에 여러 파이프에서 메시지를 받는 상황을 시뮬레이션함.

&ensp;실행 흐름 요약<br/>

| 단계 | 동작                        |
| -- | ------------------------- |
| 1  | 부모가 `pipe()` 3개 생성        |
| 2  | `fork()`로 자식 3명 생성        |
| 3  | 각 자식은 파이프를 통해 메시지 전송      |
| 4  | 부모는 `select()`로 3개 파이프 감시 |
| 5  | 메시지가 도착한 파이프의 내용만 즉시 출력   |
| 6  | 모든 자식 종료 후 부모도 종료         |

&ensp;실행 예시<br/>
```bash
MSG from 0 = hello
MSG from 2 = hello
MSG from 1 = hello
MSG from 0 = hello
MSG from 1 = bye!!
MSG from 2 = bye!!
MSG from 0 = bye!!
```

&ensp;핵심 정리<br/>

| 항목    | 내용                      |
| ----- | ----------------------- |
| 통신 방식 | 부모(서버) ↔ 여러 자식(클라이언트)   |
| 기술    | pipe + fork + select    |
| 부모 역할 | 여러 파이프 감시, 메시지 읽기       |
| 자식 역할 | 주기적으로 메시지 전송            |
| 장점    | 다중 파이프 I/O를 효율적으로 처리 가능 |
