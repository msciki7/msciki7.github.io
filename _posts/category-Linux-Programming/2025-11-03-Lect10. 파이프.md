---
title: "Lect10. pipe"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-03
last_modified_at: 2025-11-03
---

파이프(Pipe)
=====

&ensp;파이프(pipe)는 두 프로세스 간 데이터를 주고받기 위한 통신 채널(통로)이다.<br/>

* 한 프로세스가 데이터를 `write()` 로 파이프에 쓰면 다른 프로세스가 `read()` 로 그 데이터를 읽는다.
* 기본적으로 단방향(한쪽 방향) 통신만 가능하다.
    - 한쪽 쓰기 전용, 다른 한쪽은 읽기 전용
* 파일처럼 동작하지만 실제 파일 시스템에는 존재하지 않는다.

&ensp;파이프의 특징<br/>

| 항목                | 설명                                                                 |
| ----------------- | ------------------------------------------------------------------ |
| **통신 방식**         | 부모 ↔ 자식 프로세스 간 **단방향 통신**                                          |
| **처리 방식**         | FIFO(First In First Out) — 먼저 쓴 데이터가 먼저 읽힘                         |
| **파일 디스크립터**      | 파이프를 만들면 2개의 fd(file descriptor)가 생김<br> `p[0]`: 읽기용 / `p[1]`: 쓰기용 |
| **파일 시스템에 없음**    | 파이프는 메모리 상의 특수한 버퍼이기 때문에 디스크에 저장되지 않음                              |
| **`lseek()` 불가능** | 랜덤 접근 불가. 순차적으로만 읽고 써야 함.                                          |
| **상속 가능**         | `fork()` 시 부모가 만든 파이프는 자식에게도 상속됨.                                  |

# 파이프 생성 함수

```c
#include <unistd.h>
int pipe(int filedes[2]);
```

* 반환값: 성공 시 0, 실패 시 -1 반환
* `filedes[0]`: 읽기 전용 (read end)
* `filedes[1]`: 쓰기 전용 (write end)
* 제한: 프로세스당 열 수 있는 파일 수 제한 존재

&ensp;pipe() 호출 시 OS가 내부적으로 두 개의 파일 디스크립터 생성, 하나는 읽기용, 하나는 쓰기용으로 사용됨<br/>

&ensp;동작 구조(기본 원리)<br/>
```scss
부모 프로세스                         자식 프로세스
  ↓                                       ↓
[쓰기용 파이프 open]                  [읽기용 파이프 open]
       ↓                                       ↓
     write()  ----------------------->       read()
```

* 부모는 데이터를 쓰고
* 자식은 그 데이터를 읽는다.
* 양쪽 모두 필요 없는 방향의 파이프를 닫아야 한다.(`close()`)

&ensp;pipe의 특성<br/>
* FIFO (First In First Out) 방식으로 동작
* `lseek()` 불가 — 랜덤 접근이 아닌 순차 처리만 가능
* `fork()` 시 상속됨 → 부모가 만든 파이프를 자식이 물려받음

&ensp;부모 → 자식 단방향 통신 순서<br/>
1. `pipe()` 호출 (부모에서 파이프 생성)
2. `fork()`로 자식 생성 → 파이프 복사됨
3. 부모는 읽기용 닫기, 자식은 쓰기용 닫기
4. 부모 → 자식 데이터 전송 가능 (`write() / read()`)

&ensp;파이프 예제 코드<br/>
```c
main() {
    char ch[10];
    int pid, p[2];

    if (pipe(p) == -1) {
        perror("pipe call");
        exit(1);
    }

    pid = fork();

    if (pid == 0) {  // 자식 프로세스
        close(p[1]);                 // 쓰기용 닫기
        read(p[0], ch, 10);          // 파이프로부터 데이터 읽기
        printf("%s\n", ch);          // 읽은 내용 출력
        exit(0);
    }

    close(p[0]);                     // 부모는 읽기용 닫기
    scanf("%s", ch);                 // 입력 받기
    write(p[1], ch, 10);             // 자식에게 데이터 쓰기
    wait(0);                         // 자식 종료 대기
    exit(0);
}
```

1. 부모가 `pipe()` 로 파이프 생성
2. `fork()` → 자식이 복사된 파이프 핸들을 상속
3. 부모가 문자열 입력 → `write()`
4. 자식이 `read()`로 읽고 `printf()`로 출력
5. 종료

&ensp;실행 결과 예시<br/>
```shell
$ ./pipe_program
hello
hello
```

&ensp;부모가 입력한 "hello" 를 파이프로 전달받은 자식이 출력한다.<br/>

# 양방향 통신

&ensp;기본적인 pipe는 단방향(one-way) 통신만 가능하다. 하지만 양방향(dual-way) 통신을 하고 싶다면 파이프를 2개 만들어야 한다.<br/>

&ensp;구조<br/>

| 구분    | 역할         | 부모 프로세스      | 자식 프로세스      |
| ----- | ---------- | ------------ | ------------ |
| pipe1 | 부모 → 자식 전송 | write end 사용 | read end 사용  |
| pipe2 | 자식 → 부모 전송 | read end 사용  | write end 사용 |

&ensp;동작 과정<br/>
1. `pipe()` 두 번 호출 → `pipe1`, `pipe2` 생성
2. `fork()` 호출 → 부모의 파이프 복사
3. 각 프로세스는 필요 없는 파이프 끝을 `close()`
    - 부모: pipe1의 read end, pipe2의 write end 닫음
    - 자식: pipe1의 write end, pipe2의 read end 닫음
4. 서로 데이터를 주고받으며 양방향 통신 가능

&ensp;Blocking read / Blocking write<br/>

| 구분          | Blocking이 발생하는 경우               |
| ----------- | ------------------------------- |
| **read()**  | 파이프가 **비어 있을 때** (읽을 데이터가 없을 때) |
| **write()** | 파이프가 **가득 찼을 때** (버퍼가 꽉 찼을 때)   |

&ensp;파이프는 버퍼 기반으로 동작하며 버퍼가 비어 있거나 가득차면 프로세스는 일시 정지(block) 된다.<br/>

# 파이프 닫기

&ensp;파이프의 끝을 닫을 때는 어떤 프로세스가 읽기/쓰기 역할인지에 따라 동작이 다르다.<br/>

&ensp;쓰기 전용 파이프 닫기<br/>
* 더 이상 writer가 없는 상태에서 reader가 `read()`를 시도하면? → 0 반환 (EOF와 동일한 효과)

&ensp;writer가 모두 종료되면 reader는 읽을 데이터 없음으로 판단한다.<br/>

&ensp;읽기 전용 파이프 닫기<br/>
* 더 이상 reader가 없는 상태에서 writer가 `write()`하면? → `SIGPIPE` 시그널 발생 → 처리하지 않으면 프로세스 비정상 종료

```bash
Broken pipe
```

* 만약 시그널을 직접 처리(`signal(SIGPIPE, handler)`) 하면 writer 는 -1 을 반환하고 `errno` 에 `EPIPE` 가 설정된다.

&ensp;핵심요약<br/>
* eader가 없을 때 write하면 SIGPIPE
* writer가 없을 때 read하면 0 반환 (EOF)

# Non-blocking I/O

&ensp;Blocking 방식에서는<br/>
* 읽을 데이터가 없을 때 `read()`는 멈추고
* 버퍼가 꽉 찼을 때 `write()`도 멈춘다.

&ensp;→ 이를 피하기 위해 Non-blocking I/O 방식을 사용할 수 있다.<br/>

&ensp;Non-blocking 설정 방법<br/>
```c
#include <fcntl.h>

fcntl(filedes, F_SETFL, O_NONBLOCK);
```

* 특정 파일 디스크립터(`filedes`)에 논블로킹 모드를 설정한다.

&ensp;동작 방식<br/>

| 상황                      | 반환값  | 설명                       |
| ----------------------- | ---- | ------------------------ |
| **쓰기 전용인데 버퍼가 가득 찼을 때** | `-1` | 즉시 실패 (`errno = EAGAIN`) |
| **읽기 전용인데 버퍼가 비었을 때**   | `-1` | 즉시 실패 (`errno = EAGAIN`) |

&ensp;기다리지 않고 지금은 불가능하니 나중에 다시 시도해라 는 뜻으로 `EAGAIN` 을 반환한다.<br/>

&ensp;예시 코드<br/>
```c
int fd[2];
pipe(fd);
fcntl(fd[0], F_SETFL, O_NONBLOCK); // 읽기 비차단 모드

char buf[20];
int n = read(fd[0], buf, sizeof(buf));

if (n == -1 && errno == EAGAIN)
    printf("현재 읽을 데이터가 없습니다.\n");
```

* `O_NONBLOCK` 옵션을 설정하면 `read()` / `write()`가 즉시 반환된다.
* `EAGAIN`은 “지금은 불가능, 나중에 다시 시도하라”는 의미이다.
* 여러 파이프를 동시에 관리해야 할 때 유용하다.

&ensp;요약<br/>

| 구분               | 내용                                         |
| ---------------- | ------------------------------------------ |
| **단방향 통신**       | pipe 1개, 부모 → 자식                           |
| **양방향 통신**       | pipe 2개, 각각 반대 방향                          |
| **blocking**     | 비어있으면 read block, 가득 차면 write block        |
| **닫기 동작**        | reader 없음 → SIGPIPE, writer 없음 → EOF(0 반환) |
| **non-blocking** | 즉시 -1, errno=EAGAIN 반환                     |

파이프를 이용한 Client–Server & select()
=====

# 파이프 기반 Client-Server 모델

&ensp;여러 개의 클라이언트(client) 프로세스가 각각 자신의 파이프를 통해 요청(request)을 보내고 서버(Server) 프로세스는 여러 파이프를 모니터링하며 요청을 읽는 구조이다.<br/>

&ensp;구조 요약<br/>

| 역할         | 설명                                                  |
| ---------- | --------------------------------------------------- |
| **Client** | 자신의 파이프(예: `pipe1`, `pipe2` …)에 요청 데이터를 **write()** |
| **Server** | 여러 파이프의 **read end**를 열고 요청이 들어오면 **read()**로 처리    |

&ensp;동작 원리<br/>

1. 서버는 여러 클라이언트의 파이프를 `read()` 할 준비를 한다.
2. 아무 요청도 없으면 → 서버는 blocking 상태 (대기 중)
3. 어느 한 클라이언트라도 write() 하면 → 그 파이프에서 요청을 읽는다.
4. 동시에 여러 요청이 들어오면 → 순서대로(FIFO) 읽는다.

&ensp;문제점<br/>
* 단순 `read()`만 사용하면 “어느 파이프에 데이터가 있는지” 알기 어렵다.
* 모든 파이프를 동시에 감시하려면 `select()` 같은 시스템 호출이 필요하다.

# select() 시스템 호출

&ensp;역할<br/>
&ensp;`select()` 는 여러 파일 디스크립터(fd) 중 어느 것이 읽기/쓰기/에러 처리 가능 상태인지 감시하는 시스템 콜이다.<br/>

&ensp;필요성<br/>
* 서버가 여러 개의 파이프나 소켓을 동시에 감시해야 할 때 하나씩 `read()` 하면 효율이 떨어진다.
* `select()` 는 **“준비된 fd만 알려주는 함수”**로 비효율적 blocking을 방지할 수 있다.

&ensp;주요 특징<br/>

| 항목                 | 설명                                  |
| ------------------ | ----------------------------------- |
| **읽기/쓰기 가능 여부 감시** | 지정된 fd들 중 어떤 것이 read/write 가능한지 확인  |
| **blocking 발생**    | 모든 fd가 준비되지 않으면 대기                  |
| **timeout 설정 가능**  | 일정 시간 후 자동으로 빠져나오게 설정하여 영구 block 방지 |

&ensp;`select()` 는 여러 입력을 동시에 감시할 수 있게 해주는 멀티 I/O 감시 시스템 콜이다. <br/>

&ensp;select() 사용법<br/>
```c
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds,
           fd_set *readfds,
           fd_set *writefds,
           fd_set *errorfds,
           struct timeval *timeout);
```

&ensp;매개변수 설명<br/>

| 인자           | 의미                             |
| ------------ | ------------------------------ |
| **nfds**     | 감시할 파일 디스크립터 중 **가장 큰 번호 + 1** |
| **readfds**  | 읽기 가능한 fd 집합                   |
| **writefds** | 쓰기 가능한 fd 집합                   |
| **errorfds** | 에러가 발생한 fd 집합                  |
| **timeout**  | 타임아웃 설정 (NULL이면 무한 대기)         |

&ensp;fd_set 관련 매크로<br/>
&ensp;`fd_set` 은 `select()` 가 감시할 파일 디스크립터 집합을 관리하는 비트마스크(bitmask) 구조이다. 어떤 fd를 감시할지 0/1 로 표시하는 일종의 비트 배열이다.<br/>

&ensp;주요 매크로<br/>

| 매크로                               | 설명                                 |
| --------------------------------- | ---------------------------------- |
| `FD_ZERO(fd_set *fdset)`          | fd 집합을 초기화 (모든 비트 0으로 설정)          |
| `FD_SET(int fd, fd_set *fdset)`   | 특정 fd를 감시 대상에 추가 (비트를 1로 설정)       |
| `FD_CLR(int fd, fd_set *fdset)`   | 특정 fd를 감시 대상에서 제거 (비트를 0으로 설정)     |
| `FD_ISSET(int fd, fd_set *fdset)` | 특정 fd가 감시 대상에 포함되어 있는지 확인 (1인지 검사) |

&ensp;사용 예시<br/>
```c
fd_set readfds;

FD_ZERO(&readfds);        // 초기화
FD_SET(pipe1[0], &readfds);  // 감시할 fd 추가
FD_SET(pipe2[0], &readfds);

select(max_fd + 1, &readfds, NULL, NULL, NULL);

if (FD_ISSET(pipe1[0], &readfds))
    printf("pipe1에 데이터가 도착했습니다!\n");
```

&ensp;`select()` 호출 후에는 FD_ISSET()으로 어떤 fd가 준비되었는지 확인한다.<br/>
&ensp;`fd_set`은 `select()`가 감시할 fd들의 목록을 관리하는 구조체이며 `FD_SET`, `FD_CLR`, `FD_ISSET`, `FD_ZERO` 네 가지 매크로로 제어한다.<br/>

# timeval 구조체

&ensp;`timeval` 은 `select()` 의 대기 시간(timeout)을 정의하는 구조체이다.<br/>
&ensp;구조 정의<br/>
```c
struct timeval {
    long tv_sec;   // 초 단위 (seconds)
    long tv_usec;  // 마이크로초 단위 (microseconds)
};
```

&ensp;timeout 인자의 의미<br/>

| 설정 값         | 의미                             |
| ------------ | ------------------------------ |
| `NULL`       | 이벤트 발생 시까지 무한 대기 (영구 blocking) |
| `0`          | non-blocking (즉시 반환)           |
| 특정 값 (예: 5초) | 지정된 시간 동안 대기 후, 이벤트 없으면 반환     |

&ensp;예시<br/>
```c
struct timeval tv;
tv.tv_sec = 5;     // 5초 동안 대기
tv.tv_usec = 0;

select(max_fd + 1, &readfds, NULL, NULL, &tv);
```

* 만약 5초 안에 읽을 수 있는 fd가 없으면 `select()`는 0을 반환한다.
* "타임아웃 발생"을 의미한다.

&ensp;핵심 요약<br/>
&ensp;`timeval`은 select()의 대기 시간을 제어하는 구조체이며 NULL → 무한대기, 0 → 즉시 반환, 숫자 → 지정 시간 대기<br/>

# select() 반환값

&ensp;select() 호출 후 반환값을 통해 현재 어떤 상태인지 판단할 수 있다.<br/>

&ensp;반환값 의미<br/>

| 반환값   | 의미                          |
| ----- | --------------------------- |
| `-1`  | 오류 발생 (보통 인터럽트나 잘못된 fd)     |
| `0`   | 타임아웃 (timeout 시간 동안 이벤트 없음) |
| 양의 정수 | 읽기/쓰기 가능한 fd의 **개수**        |

&ensp;예시 코드<br/>
```c
int n = select(max_fd + 1, &readfds, NULL, NULL, &tv);

if (n == -1)
    perror("select error");
else if (n == 0)
    printf("timeout: 입력 없음\n");
else {
    if (FD_ISSET(pipe1[0], &readfds))
        printf("pipe1에서 데이터 수신\n");
    if (FD_ISSET(pipe2[0], &readfds))
        printf("pipe2에서 데이터 수신\n");
}
```

&ensp;주의사항<br/>
&ensp;`select()` 호출 후에는 fd_set이 내부적으로 변경됨. 따라서, 다음 `select()` 호출 전에 반드시 `FD_ZERO()` → `FD_SET()`으로 다시 설정해야 한다.<br/>

&ensp;요약<br/>
* select()는 읽기/쓰기 가능한 fd 개수를 반환한다.
* 0은 타임아웃, -1은 오류
* 반환 후 fd_set은 변경되므로 반드시 재설정해야 한다.

&ensp;select() + pipe()를 이용한 멀티프로세스 통신 예제<br/>

&ensp;부모 프로세스(서버)가 **3개의 자식 프로세스(클라이언트)**를 생성하고 각 자식은 파이프를 통해 “hello”와 “bye!!” 메시지를 부모에게 보낸다. 부모는 select()를 이용해 3개의 파이프를 동시에 감시하며 어느 자식이 메시지를 보내든 바로 읽어 처리한다.<br/>

&ensp;main() 함수<br/>
```c
#define MSGSIZE 6

char *msg1 = "hello";
char *msg2 = "bye!!";
void parent(int p[3][2]);
int child(int p[2]);

main() {
    int pip[3][2];
    int i;

    for (i = 0; i < 3; i++) {
        pipe(pip[i]);          // 각 자식별 파이프 생성
        if (fork() == 0)       // 자식 생성
            child(pip[i]);     // 자식 함수 실행
    }

    parent(pip);               // 부모는 모든 파이프 관리
    for (i = 0; i < 3; i++)
        wait(0);
    exit(0);
}
```

* pip[3][2] → 자식 3명 각각에게 1개의 파이프(읽기/쓰기용 2개 fd)
* fork() 3회 → 자식 프로세스 3개 생성
* 자식은 각자 child() 실행
* 부모는 parent()를 통해 모든 파이프를 동시에 감시

&ensp;부모는 3개의 파이프를 동시에 감시하고 자식의 각자 메시지를 독립적으로 보낸다.<br/>

&ensp;parent() 함수<br/>
```c
void parent(int p[3][2]) {
    char buf[MSGSIZE];
    fd_set set, master;
    int i;

    // 부모는 각 파이프의 쓰기쪽 닫기
    for (i = 0; i < 3; i++)
        close(p[i][1]);

    FD_ZERO(&master);           // fd_set 초기화

    for (i = 0; i < 3; i++)
        FD_SET(p[i][0], &master);   // 읽기용 파이프 등록

    while ((set = master, select(p[2][0] + 1, &set, NULL, NULL, NULL)) > 0) {
        for (i = 0; i < 3; i++) {
            if (FD_ISSET(p[i][0], &set)) {
                if (read(p[i][0], buf, MSGSIZE) > 0)
                    printf("MSG from %d = %s\n", i, buf);
            }
        }
        if (waitpid(-1, NULL, WNOHANG) == -1)
            return;
    }
}
```

&ensp;동작 설명<br/>
1. 부모는 자식이 쓰는 p[i][1] (write end)을 모두 닫음 → 부모는 읽기만 함
2. `FD_ZERO()`로 fd 집합 초기화, `FD_SET()`으로 3개의 파이프 등록
3. `select()`는 3개 파이프를 동시에 감시
    - 데이터가 들어온 파이프만 활성화됨.
4. `FD_ISSET()`으로 어떤 파이프가 읽기 가능한지 판별
5. `read()`로 데이터 읽고 화면에 출력.

&ensp;select()의 핵심 부분<br/>
```c
select(p[2][0] + 1, &set, NULL, NULL, NULL);
```

* p[2][0] + 1 → 감시할 fd 중 가장 큰 번호 + 1
* NULL → 쓰기/에러는 감시 안 함
* NULL timeout → 무한 대기

&ensp;parent()는 select()로 3개의 파이프를 동시에 감시하며 데이터가 들어온 자식의 파이프만 즉시 읽는다.<br/>

&ensp;child() 함수<br/>
```c
int child(int p[2]) {
    int count;

    close(p[0]);                  // 읽기쪽 닫기

    for (count = 0; count < 2; count++) {
        write(p[1], msg1, MSGSIZE);  // "hello" 전송
        sleep(getpid() % 4);         // 랜덤 딜레이
    }

    write(p[1], msg2, MSGSIZE);      // 마지막 메시지 "bye!!"
    exit(0);
}
```

&ensp;동작 설명<br/>
* 각 자식은 p[1]을 통해 부모에게 메시지 전송
* "hello"를 2회 보내고, 마지막에 "bye!!" 전송
* sleep(getpid() % 4)로 실행 타이밍을 다르게 만들어 부모가 동시에 여러 파이프에서 메시지를 받는 상황을 시뮬레이션함.

&ensp;실행 흐름 요약<br/>

| 단계 | 동작                        |
| -- | ------------------------- |
| 1  | 부모가 `pipe()` 3개 생성        |
| 2  | `fork()`로 자식 3명 생성        |
| 3  | 각 자식은 파이프를 통해 메시지 전송      |
| 4  | 부모는 `select()`로 3개 파이프 감시 |
| 5  | 메시지가 도착한 파이프의 내용만 즉시 출력   |
| 6  | 모든 자식 종료 후 부모도 종료         |

&ensp;실행 예시<br/>
```bash
MSG from 0 = hello
MSG from 2 = hello
MSG from 1 = hello
MSG from 0 = hello
MSG from 1 = bye!!
MSG from 2 = bye!!
MSG from 0 = bye!!
```

&ensp;핵심 정리<br/>

| 항목    | 내용                      |
| ----- | ----------------------- |
| 통신 방식 | 부모(서버) ↔ 여러 자식(클라이언트)   |
| 기술    | pipe + fork + select    |
| 부모 역할 | 여러 파이프 감시, 메시지 읽기       |
| 자식 역할 | 주기적으로 메시지 전송            |
| 장점    | 다중 파이프 I/O를 효율적으로 처리 가능 |

실습 1
====

&ensp;1. pipe를 이용하여 통신하는 parent와 child 프로그램을 아래 코드를 사용하여 작성하시오. parent process는 세 개의 child process를 만들고 parent process에서 child process로의 단방향 통신이 가능한 pipe를 만듭니다. parent process는 외부 입력으로 정수를 12개 입력받아, 세 child process에게 순서대로 보냅니다. child process는 자신이 받은 정수를 자신의 프로세스 id와 함께 출력 합니다. parent process는 모든 정수를 전달한 후 정수 -1을 전달하고, -1을 전달받으면 child process는 종료합니다. 모든 child process의 종료를 확인한 후 parent process는 종료합니다.<br/>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

void do_child(int id, int p[3][2]){
	int i, in, pid=getpid();
	
    // 불필요한 pipe 닫기
	for(i=0;i<3;i++){
		close(p[i][1]);
		if(id != i)
			close(p[i][0]);
	}

	while(1){
		read(p[id][0], &in, sizeof(int));
        // pipe에서 정수 읽기
		if(in==-1)
			exit(0);
		 else
			printf("%d %d\n", pid, in);
	}
}


int main(void){
	int i, in, pid, p[3][2];
	
    // pipe 3개 생성
	for(i=0; i<3; i++){
		pipe(p[i]);
	}
	
    // 불필요한 pipe 닫기
	for(i=0;i<3; i++){
		if(fork()==0){
			do_child(i, p);
		}
	}
	
	for(i=0;i<3; i++){
		close(p[i][0]);
	}
	
	for(i=0;i<12;i++){
		scanf("%d", &in);
		write(p[i%3][1], &in, sizeof(int));   // pipe에 in 쓰기
	}
	
	in=-1;
	for(i=0;i<3;i++){
		write(p[i][1], &in, sizeof(int));   // -1 전달
	}
	
	for(i=0;i<3;i++){
		wait(0);
	}

	exit(0);
}

```

&ensp;1) 전체 목표 요약<br/>
* 부모 프로세스가 파이프 3개를 만들어 단방향(부모→자식) 통신
* 부모는 정수 12개를 입력받아 라운드 로빈(0, 1, 2, 0, 1, 2, ...)으로 각 자식에게 보냄
* 각 자식은 자기 파이프에서 정수를 읽거 자신의 PID와 함께 출력
* 부모는 모든 정수 전송 후 -1을 각 자식에게 보내어 정상 종료 신호를 전달
* 자식은 -1을 받으면 종료. 부모는 모든 자식 종료(wait)를 확인하고 종료

&ensp;2) 파이프와 FD(파일 디스크립터) 구조<br/>
* `int p[3][2];` 는 파이프 3개를 의미
    - p[i][0] : i번째 파이프의 읽기(read) 끝
    - p[i][1] : i번째 파이프의 쓰기(write) 끝
* 부모 → 자식 단방향 구조이므로:
    - 부모는 각 파이프의 읽기 끝(p[i][0])을 모두 닫고 쓰기 끝(p[i][1])만 유지
    - 각 자식은 자기 번호 id의 파이프 읽기 끝(p[id][0])만 유지하고 나머지 읽기/쓰기 끝은 모두 닫음
    - 이렇게 해야 커널이 파이프에 아직 쓰는 쪽이 남아 있다./없다.를 정확히 판단해서 EOF(0 바이트 read) 나 블록/깨끗한 종료가 올바르게 동작함

&ensp;3) 프로세스 생성과 FD 정리 흐름<br/>
&ensp;(1) 부모가 파이프 3개 생성<br/>
```c
for (i=0; i<3; i++) {
    pipe(p[i]);
}
```

* 이제 부모 `p[0]`, `p[1]`, `p[2]` 세 파이프의 read/write FD를 모두 가지고 있음.

&ensp;(2) fork로 자식 3개 생성<br/>
```c
for (i=0; i<3; i++) {
    if (fork() == 0) { // 자식 프로세스
        do_child(i, p);
    }
}
```

* i=0일 때 생성된 자식은 id=0, i=1 일 때 자식은 id=1, i=2일 때 자식은 id=2의 역할

&ensp;(3) 각 자식: 불필요한 FD 닫기<br/>
```c
// 자식 내부 do_child(id, p)
for (i=0; i<3; i++) close(p[i][1]);     // 모든 쓰기 끝 닫음
for (i=0; i<3; i++) if (i != id) close(p[i][0]); // 자기 것이 아닌 읽기 끝 닫음
```

* 결과적으로 자식 id는 p[id][0] (읽기)만 남김

&ensp;(4) 부모: 불필요한 FD 닫기<br/>
```c
for (i=0; i<3; i++) close(p[i][0]); // 부모는 읽기 끝 전부 닫음
```

* 부모는 쓰기 전용으로만 남김: p[0][1], p[1][1], p[2][1]

&ensp;4) 데이터 전송(라운드 로빈)과 출력<br/>
&ensp;(1) 부모의 전송<br/>
```c
for (i=0; i<12; i++) {
    scanf("%d", &in);                 // 외부에서 정수 입력
    write(p[i % 3][1], &in, sizeof(int));  // 0,1,2,0,1,2 ... 로 분배
}
```

* 입력 순서 12개를 0→1→2→0→1→2 순서로 고르게 보냄
* 예: 입력이 1..12라고 하면
    - 자식0: 1, 4, 7, 10
    - 자식1: 2, 5, 8, 11
    - 자식2: 3, 6, 9, 12

&ensp;(2) 자식의 처리<br/>
```c
while (1) {
    read(p[id][0], &in, sizeof(int)); // 자기 파이프에서 정수 수신
    if (in == -1) exit(0);            // 종료 신호
    printf("%d %d\n", pid, in);       // "자기 PID"와 "수신 정수" 출력
}
```

* 자식은 자기에게 온 수만 읽고 출력. 다른 파이프는 아예 닫혀 있으므로 섞이지 않음

&ensp;5) 종료 시그널과 깨끗한 종료<br/>
&ensp;(1) 부모가 종료 신호(-1) 전송<br/>
```c
in = -1;
for (i=0; i<3; i++) {
    write(p[i][1], &in, sizeof(int)); // 각 자식에게 하나씩 -1
}
```

* 각 자식은 자기 파이프에서 -1을 읽는 순간 exit(0)

&ensp;(2) 부모가 FD 닫고 자식 종료 대기<br/>
```c
for (i=0; i<3; i++) close(p[i][1]); // 더 이상 쓸 것 없으니 닫기(안 닫아도 -1로 종료되지만 깔끔)
for (i=0; i<3; i++) wait(0);        // 자식 3명 모두 종료 확인
exit(0);
```

* 모든 자식 종료(wait) 후 부모 종료 → 좀비 프로세스 방지


&ensp;코드 동작 과정 단계별 설명<br/>
&ensp;1. int p[3][2] — 파이프 생성 준비<br/>
```c
int p[3][2];
```

* p[i][0]: 읽기(read)용 파일 디스크립터
* p[i][1]: 쓰기(write)용 파일 디스크립터

&ensp;파이프 3개를 생성하면<br/>
```bash
p[0]: (read0, write0)
p[1]: (read1, write1)
p[2]: (read2, write2)
```

&ensp;이렇게 3쌍의 통로가 생긴다.<br/>

&ensp;2. 부모가 파이프 3개 생성<br/>
```c
for(i=0; i<3; i++){
    pipe(p[i]);
}
```

* 부모 프로세스가 3개의 파이프를 생성한다.
* 이 시점에서 부모는 모든 파이프의 읽기와 쓰기 끝을 둘 다 가지고 있다.

&ensp;3. 부모가 자식 3개 생성 (fork 3번)<br/>
```c
for(i=0;i<3; i++){
    if(fork()==0){
        do_child(i, p);
    }
}
```

* i=0, 1, 2 순서로 3번 fork()를 호출하므로 자식 프로세스가 3개 생긴다.
* 각 자식은 do_child(i, p)로 이동하고, id=i가 된다.

&ensp;예를 들어<br/>

| 프로세스             | 역할      | id |
| ---------------- | ------- | -- |
| Parent (원래 프로세스) | 부모      | 없음 |
| Child 1          | 첫 번째 자식 | 0  |
| Child 2          | 두 번째 자식 | 1  |
| Child 3          | 세 번째 자식 | 2  |

&ensp;4. 각 자식 프로세스: 불필요한 파이프 닫기<br/>
```c
for(i=0;i<3;i++){
    close(p[i][1]);
    if(id != i)
        close(p[i][0]);
}
```

&ensp;이 부분이 매우 중요<br/>
* 자식 프로세스는 자기에게 연결된 파이프의 읽기 끝(p[id][0])만 필요함.
* 그래서 다음과 같이 정리됨:

| 프로세스 | 남는 FD        | 닫는 FD                   |
| ---- | ------------ | ----------------------- |
| 자식 0 | p[0][0] (읽기) | 나머지 모든 p[i][0], p[i][1] |
| 자식 1 | p[1][0] (읽기) | 나머지 모든 p[i][0], p[i][1] |
| 자식 2 | p[2][0] (읽기) | 나머지 모든 p[i][0], p[i][1] |

&ensp;각 자식은 자기에게만 온 데이터만 읽을 수 있다.<br/>

&ensp;5. 자식 프로세스: 데이터 읽고 출력<br/>
```c
while(1){
    read(p[id][0], &in, sizeof(int)); // 부모가 보낸 정수 읽기
    if(in==-1)
        exit(0);                      // -1이면 종료
    else
        printf("%d %d\n", pid, in);   // PID와 함께 정수 출력
}
```

* 부모가 파이프를 통해 보낸 데이터를 계속 읽는다.
* read()는 blocking 방식이므로 데이터가 들어올 때가지 기다린다.
* 읽은 값이 -1이면 “종료 신호”로 간주하고 exit(0)으로 종료.
* 그렇지 않으면 현재 자신의 PID와 함께 값을 출력한다.

&ensp;출력 예시<br/>
```bash
1234 10
1234 40
5678 20
5678 50
```

&ensp;(각 숫자는 자식 PID와 부모가 보낸 정수)<br/>

&ensp;6. 부모 프로세스: 불필요한 읽기 끝 닫기<br/>
```c
for(i=0;i<3; i++){
    close(p[i][0]);
}
```

* 부모는 **읽기 끝(p[i][0])**을 닫는다. 부모는 데이터를 읽지 않고 쓰기만 하기 때문.

&ensp;7. 부모 프로세스: 정수 12개 입력받기<br/>
```c
for(i=0;i<12;i++){
    scanf("%d", &in);
    write(p[i%3][1], &in, sizeof(int));   // 라운드 로빈 방식으로 보냄
}
```

&ensp;작동방식<br/>
* 부모는 외부로부터 12개의 정수를 입력받는다.
* `i % 3` 을 이용해 각 자식에게 순서대로 보낸다.

| 입력 순서 | i   | i%3 | 수신 자식 |
| ----- | --- | --- | ----- |
| 1번째   | 0   | 0   | 자식 0  |
| 2번째   | 1   | 1   | 자식 1  |
| 3번째   | 2   | 2   | 자식 2  |
| 4번째   | 3   | 0   | 자식 0  |
| 5번째   | 4   | 1   | 자식 1  |
| ...   | ... | ... | ...   |

&ensp;자식0 → 자식1 → 자식2 → 자식0 → 자식1 → 자식2 순서로 반복된다.<br/>
&ensp;라운드 로빈(Round-Robin) 방식으로 정수를 고르게 분배하는 구조<br/>

&ensp;8. 부모: 종료 신호 -1 보내기<br/>
```c
in=-1;
for(i=0;i<3;i++){
    write(p[i][1], &in, sizeof(int));
}
```

* 3개의 자식에게 각각 종료 신호(-1)를 한 번씩 보낸다.
* 각 자식은 자기 파이프에서 -1을 읽으면 exit(0)으로 종료된다.

&ensp;9. 부모: 모든 자식이 끝날 때까지 대기<br/>
```c
for(i=0;i<3;i++){
    wait(0);
}
```

* 부모는 세 자식 프로세스가 모두 종료될 때까지 기다린다.
* 모든 자식이 종료되는 부모도 종료

&ensp;전체 데이터 흐름 요약<br/>
```scss
입력: 1 2 3 4 5 6 7 8 9 10 11 12

부모
├── p[0][1] → 자식0(p[0][0]): 1, 4, 7, 10, -1
├── p[1][1] → 자식1(p[1][0]): 2, 5, 8, 11, -1
└── p[2][1] → 자식2(p[2][0]): 3, 6, 9, 12, -1
```

&ensp;출력예시<br/>
```bash
1234 1
1234 4
1234 7
1234 10
5678 2
5678 5
5678 8
5678 11
9101 3
9101 6
9101 9
9101 12
```

&ensp;1) 부모는 ‘라운드로빈’으로 보냈지만, 출력 순서는 뒤섞일 수 있다.<br/>
* 부모는 i%3으로 0→1→2→0→1→2… 순서로 12개를 보낸다.
    - 자식0은 4개, 자식1은 4개, 자식2는 4개를 받는 분배 자체는 항상 일정한다.
* 하지만 각 자식의 printf가 화면에 언제 찍히느냐는 OS 스케줄러에 달려 있다.
    - 자식0이 어떤 순간엔 CPU를 더 빨리 받아서 연달아 두 줄 찍을 수도 있고,
    - 자식1/2는 조금 뒤에 한꺼번에 찍을 수도 있어요.
* 즉 각 자식이 받는 값의 '집합'은 고정이지만 터미널에 찍히는 '순서'는 비결정적이다. → "부모가 0,1,2 순서로 보냈는데 왜 2가 먼저 찍히지?" = 정상

&ensp;파이프는 "각 파이프 내에서의 순서"만 보장합니다. 서로 다른 파이프(자식0용/1용/2용) 끼리는 상대 순서가 보장되지 않는다.<br/>

&ensp;2) 각 자식은 자기 파이프만 읽으므로 ‘받는 값’은 정확한다.<br/>
* 자식 id는 p[id][0]만 남기고 나머지 파이프의 읽기/쓰기 FD를 모두 닫는다.
* 부모도 읽기 끝을 닫고 p[0][1], p[1][1], p[2][1] 쓰기 전용만 남긴다.
* 그래서 자식0은 p[0]에서만, 자식1은 p[1], 자식2는 p[2]에서만 읽는다. → 다른 자식의 데이터가 섞여 들어오는 일은 구조적으로 불가능.

&ensp;3) 한 줄씩 깔끔히 찍히지만 '섞여 보이는' 이유<br/>
* printf("%d %d\n", pid, in); 처럼 개행이 있기 때문에 각 줄은 표준출력에서 라인 버퍼링으로 대부분 한 줄 단위로 찍힌다.
* 다만 여러 프로세스가 동시에 같은 터미널로 출력하니 자식0 줄 → 자식2 줄 → 자식1 줄처럼 라인 단위가 서로 섞여 보이는 것은 정상이다. (라인 내부가 깨져 섞이진 않지만, 라인 간 순서가 서로 섞일 수 있다.)

&ensp;4) "왜 같은 자식이 연속으로 많이 찍히지?"도 정상<br/>
* 부모는 보낼 때 0→1→2 순으로 고르게 보내지만 자식이 읽고 printf하는 타이밍은 각각 다르다.
* 예를 들어 자식0이 CPU를 오래 쥐고 있으면 자식0이 받은 4개를 연달아 쭉 찍고 그 다음에 자식1/2가 몰아서 찍을 수도 있다. → 분배는 공평하지만, 출력 타이밍은 공평하지 않을 수 있음.

&ensp;5) -1 종료 신호는 출력되지 않는 게 정상<br/>
* 자식은 `read(...); if(in==-1) exit(0);` 이라서 -1을 출력하지 않고 바로 종료한다.
* 부모가 각 파이프에 -1을 한 번씩 쓰고 자식이 그걸 받는 즉시 깨끗이 종료된다.
* 부모는 wait(0) 3번으로 좀비 없이 종료를 확인한다.


| 역할           | 설명                    |
| ------------ | --------------------- |
| `pipe(p[i])` | 부모가 세 개의 단방향 통신 채널 생성 |
| `fork()`     | 부모가 세 자식 생성           |
| `close()`    | 부모/자식이 불필요한 파이프 FD 닫음 |
| `write()`    | 부모 → 자식으로 데이터 전송      |
| `read()`     | 자식이 부모로부터 데이터 수신      |
| `-1`         | 종료 신호                 |
| `wait()`     | 부모가 자식 종료 대기          |
