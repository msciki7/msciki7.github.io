---
title: "설계과제 3-3"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-12-10
last_modified_at: 2025-12-10
---

2차 계획서 var2
====


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <errno.h>

#define MAX_TEXT    256
#define BUFFER_SIZE 100

// 공통 메시지 구조체
typedef struct {
    long mtype;          // 1,2,3(유저용) or 999(token)
    int  sender;         // 보낸 사람 ID (1~3), token 때는 0
    int  msg_num;        // 전역 메시지 번호 (1,2,3,...)
    char text[MAX_TEXT]; // 내용
} Message;

#define MSG_SIZE (sizeof(Message) - sizeof(long))

int msgq_id;

// =============== token(999) 초기화 ===============
void init_counter() {
    // 간단하게: user1만 token을 만든다고 가정
    Message token;
    token.mtype  = 999;
    token.sender = 0;
    token.msg_num = 1;   // 1번부터 시작
    token.text[0] = '\0';

    if (msgsnd(msgq_id, &token, MSG_SIZE, 0) < 0) {
        exit(1);
    }
}

// =============== token(999)에서 전역 msg# 얻기 ===============
int get_next_msg_num() {
    Message token;

    // 1) token(999) 메시지 받기 → 현재 전역 번호
    if (msgrcv(msgq_id, &token, MSG_SIZE, 999, 0) < 0) {
        return -1;
    }

    int current = token.msg_num;

    // 2) 다음 번호로 token 다시 큐에 넣기
    token.msg_num = current + 1;

    if (msgsnd(msgq_id, &token, MSG_SIZE, 0) < 0) {
        perror("msgsnd token");
        return -1;
    }

    return current;  // 이 값을 이번 메시지의 msg#로 사용
}

// =============== msg_num 기준 정렬 함수 ===============
int compare_msg_num(const void *a, const void *b) {
    const Message *m1 = (const Message *)a;
    const Message *m2 = (const Message *)b;
    return m1->msg_num - m2->msg_num;
}

// =============== 자식: 송신 프로세스 ===============
void sender(int my_id) {
    char input[MAX_TEXT];

    while (1) {

        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;  // EOF (Ctrl+D 등)
        }

        // 개행 제거
        input[strcspn(input, "\n")] = '\0';

        if (strlen(input) == 0)
            continue;

        // 종료 명령
        if (strcmp(input, "talk_quit") == 0) {
            printf("[Child %d] talk_quit. Exiting sender.\n", my_id);
            break;
        }

        // 1) 전역 메시지 번호 얻기 (token 사용)
        int msg_no = get_next_msg_num();
        if (msg_no < 0) {
            fprintf(stderr, "get_next_msg_num failed\n");
            continue;
        }

        // 2) 메시지 준비
        Message msg;
        msg.sender = my_id;
        msg.msg_num = msg_no;
        strncpy(msg.text, input, MAX_TEXT - 1);
        msg.text[MAX_TEXT - 1] = '\0';

        // 3) 나를 제외한 (1~3)에게 브로드캐스트
        for (int i = 1; i <= 3; i++) {
            if (i == my_id) continue;  // 자기 자신에게는 보내지 않음

            msg.mtype = i;            // i번 사용자가 받을 메시지

            if (msgsnd(msgq_id, &msg, MSG_SIZE, 0) < 0) {
                perror("msgsnd user");
            }
        }
        // 내가 입력한 내용은 터미널이 에코해주니까 따로 안 찍어도 됨
    }

    exit(0);
}

// =============== 부모: 수신 + 출력 프로세스 ===============
void receive(int my_id, pid_t child_pid) {
    Message buffer[BUFFER_SIZE];
    int buffer_count = 0;
    int last_printed = 0;   // 내가 마지막으로 출력한 msg#
    int child_running = 1;

    while (child_running) {
        Message msg;
        ssize_t r = msgrcv(msgq_id, &msg, MSG_SIZE, my_id, IPC_NOWAIT);

        if (r > 0) {
            // 내게 온 메시지 → 버퍼에 저장
            if (buffer_count < BUFFER_SIZE) {
                buffer[buffer_count++] = msg;

                // msg_num 기준 정렬
                qsort(buffer, buffer_count, sizeof(Message), compare_msg_num);

                // 아직 출력 안 한 것들 중에서 msg_num이
                // last_printed보다 큰 것들 모두 출력
                int i = 0;
                while (i < buffer_count) {
                    if (buffer[i].msg_num > last_printed) {
                        printf("\r[sender=%d & msg#=%d] %s\n", buffer[i].sender, buffer[i].msg_num, buffer[i].text);
                        last_printed = buffer[i].msg_num;

                        // 출력한 메시지는 버퍼에서 제거
                        memmove(&buffer[i], &buffer[i + 1], (buffer_count - i - 1) * sizeof(Message));
                        buffer_count--;
                        // i는 그대로 (다음 요소가 당겨졌으니 같은 인덱스에서 다시 검사)
                    } else {
                        i++;
                    }
                }
            } else {
                fprintf(stderr, "[Warning] buffer full\n");
            }
        }

        // 자식(송신 프로세스) 종료 체크
        int status;
        pid_t res = waitpid(child_pid, &status, WNOHANG);
        if (res > 0) {
            printf("\n[Parent %d] Child terminated. Exiting receiver.\n", my_id);
            child_running = 0;
        }

        usleep(50000); // 0.05초 쉬기
    }
}

// =============== 메시지 큐 초기화 ===============
int init_message_queue() {
    key_t key = ftok("msgkey", 'T');
    if (key == -1) {
        return -1;
    }

    msgq_id = msgget(key, IPC_CREAT | 0666);
    if (msgq_id == -1) {
        return -1;
    }

    return 0;
}

// =============== main ===============
int main(int argc, char *argv[]) {
    if (argc != 2) {
        return 1;
    }

    int my_id = atoi(argv[1]);
    if (my_id < 1 || my_id > 3) {
        fprintf(stderr, "Error: user_id must be 1, 2, or 3\n");
        return 1;
    }

    if (init_message_queue() < 0) {
        fprintf(stderr, "Failed to init message queue\n");
        return 1;
    }

    // token(999)은 user1이 한 번만 만들어줌
    if (my_id == 1) {
        init_counter();
    }

    pid_t pid = fork();
    if (pid < 0) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        // 자식 → 송신
        sender(my_id);
    } else {
        // 부모 → 수신
        receive(my_id, pid);
    }

    return 0;
}
```

## main() Flowchar

```scss
                     ┌─────────────────────────────┐
                     │           Start              │
                     └──────────────┬──────────────┘
                                    │
                  ┌─────────────────▼──────────────────┐
                  │ argv[1]을 정수 my_id로 변환         │
                  │ (1~3이 아니면 에러 종료)           │
                  └─────────────────┬──────────────────┘
                                    │
                  ┌─────────────────▼──────────────────┐
                  │   메시지 큐 생성(init_message_queue)│
                  │   실패 시 종료                     │
                  └─────────────────┬──────────────────┘
                                    │
                      my_id == 1 ?  │
                     ┌──────────────▼─────────────┐
                     │ token 초기화(init_counter)  │
                     └──────────────┬─────────────┘
                                    │
                     ┌──────────────▼──────────────┐
                     │        fork() 실행           │
                     └───────┬───────────┬─────────┘
                             │child=0     │ parent
          ┌──────────────────▼───┐   ┌────▼───────────────────┐
          │   sender(my_id)      │   │   receiver(my_id, pid) │
          │  (입력 → 전송 담당)  │   │  (수신 → 출력 담당)     │
          └──────────────────────┘   └────────────────────────┘
```

## sender() 설계도 (전송 프로세스)

```scss
                     ┌───────────────────────────────┐
                     │          sender() 시작          │
                     └─────────────────┬──────────────┘
                                       │
                     ┌─────────────────▼────────────────┐
                     │ while(1): stdin에서 문자열 입력   │
                     └─────────────────┬────────────────┘
                                       │
                            입력 EOF or "talk_quit" ?
                    ┌───────────────┬───────────────┐
                    │ Yes           │ No            │
                    ▼               ▼               │
        ┌──────────────────┐    ┌───────────────────────┐
        │ sender 종료       │    │  공백 문자열이면 continue │
        └──────────────────┘    └───────────────────────┘
                                       │
                     ┌─────────────────▼────────────────┐
                     │  1) msg_no = get_next_msg_num()   │
                     └─────────────────┬────────────────┘
                                       │
                     ┌─────────────────▼────────────────────────┐
                     │ 2) 메시지 구조체 msg 구성                 │
                     │    - msg.sender = my_id                  │
                     │    - msg.msg_num = msg_no                │
                     │    - msg.text = 입력 문자열              │
                     └─────────────────┬────────────────────────┘
                                       │
                     ┌─────────────────▼────────────────────────────┐
                     │ 3) for i = 1..3                               │
                     │       if i != my_id →                         │
                     │          msg.mtype = i                        │
                     │          msgsnd(msgq, msg)                    │
                     └─────────────────┬────────────────────────────┘
                                       │
                                       ▼
                           (while 루프 처음으로)
```

## receiver() 설계도 (수신 + 출력 프로세스)

```scss
                       ┌─────────────────────────────────┐
                       │        receiver() 시작           │
                       └───────────────────┬──────────────┘
                                           │
                ┌──────────────────────────▼──────────────────────────┐
                │  버퍼(buffer[]) 초기화                               │
                │  last_printed = 0                                    │
                └──────────────────────────┬──────────────────────────┘
                                           │
                           ┌───────────────▼───────────────────┐
                           │ while(child 프로세스 살아있음):   │
                           └────────────────┬───────────────────┘
                                            │
          ┌─────────────────────────────────▼────────────────────────────────┐
          │ non-blocking msgrcv(mtype=my_id) → 메시지 도착?                 │
          └─────────────────────────────────┬────────────────────────────────┘
                                            │
                            Yes             │              No
                     ┌───────────────┐      │      ┌────────────────────────┐
                     │ 버퍼에 저장    │      │      │ 아무 메시지도 없음      │
                     └──────┬────────┘      │      └────────────────────────┘
                            │               │
                     ┌──────▼───────────────────────────────────────────────┐
                     │ 버퍼를 msg_num 기준으로 qsort로 정렬                 │
                     └──────┬───────────────────────────────────────────────┘
                            │
                     ┌──────▼───────────────────────────────────────────────┐
                     │ 버퍼 앞에서부터                                       │
                     │ msg_num > last_printed 인 메시지 모두 출력            │
                     │ 출력 후 버퍼에서 삭제                                 │
                     └──────┬───────────────────────────────────────────────┘
                            │
                     ┌──────▼───────────────────────────────────────────────┐
                     │ waitpid(child, WNOHANG) 로 자식 종료 체크            │
                     └──────┬───────────────────────────────────────────────┘
                            │
                        종료되었는가?
                       ┌───────┬─────────┐
                       │ Yes   │ No      │
                       ▼        ▼         │
      ┌────────────────────┐   ┌──────────▼────────────┐
      │ "[Parent] 종료" 출력 │   │ usleep(50ms) 후 반복 │
      └────────────────────┘   └────────────────────────┘
```

&ensp;main()<br/>
* 메시지 큐 생성
* user1만 token(999) 생성
* fork 후
    - child → sender
    - parent → receiver

&ensp;sender()<br/>
* 입력 받기 → token에서 msg_num 할당받기
* 나 제외한 모든 사용자에게 mtype=상대방_id 로 전송

&ensp;receiver()<br/>
* mtype=my_id 로 도착한 메시지를
    - 버퍼에 저장
    - msg_num 정렬
    - 순서대로 출력
* child 종료되면 receiver 종료

3차 계획서
====

&ensp;전체 시스템 구조<br/>
```scss
┌─────────────┐
│   talk 프로그램 실행   │
└──────┬────────┘
       │
       ▼
┌────────────────────────────────────────┐
│ Shared Memory (사용자 관리 + seq)      │
│  next_msg_num                          │
│  active_users                          │
│  user_alive[1..3]                      │
└────────────────────────────────────────┘
            ▲
            │  lock(P/V)
            ▼
┌───────────────────────────────┐
│   Sender Process  (fork #1)   │
│  - 입력 → seq 할당 → 메시지큐로 전송    │
└───────────────────────────────┘
            │ msgsnd()
            ▼
┌───────────────────────────────┐
│     Message Queue (통신)       │
│   mtype = seq * 10 + user_id   │
│   → 정렬 불필요, blocking 불필요 │
└───────────────────────────────┘
            ▲   msgrcv(type)
            │
┌──────────────────────────────────┐
│ Receiver Process (fork #2)       │
│ - (내 user_id)에 해당하는 msg 수신  │
│ - seq 순서 보장                    │
│ - sender 종료 감지 시 종료          │
│ - active_users=0이면 종료          │
└───────────────────────────────────┘
```

&ensp;**프로세스가 3개인 이유(fork 두 번의 이유)**<br/>
&ensp;부모 프로세스<br/>
* 두 자식 (sender/receiver)을 wait()
* 마지막 유저가 종료되면 IPC 전체 삭제

&ensp;sender 프로세스(fork #1)<br/>
* 사용자의 입력을 릭음
* 공유메모리로부터 seq 번호를 받음
* 같은 메시지를 모든 활성 사용자에게 브로드캐스트
* 메시지큐에 메시지 삽입

&ensp;receiver 프로세스 (fork #2)<br/>
* 내 mtype에 해당하는 메시지를 수신
* 메시지가 없으면 기다림(msgrcv NONBLOCK + usleep)
* sender 프로세스가 종료되면(receiver도 종료) → A 조건
* 모든 user_alive = 0이면 종료 → B 조건

&ensp;**메시지큐(mtype) = seq * 10 + user_id 설계의도**<br/>
&ensp;메시지 번호(seq) = 전역 순서<br/>
&ensp;mtype = seq * 10 + user_id<br/>

| seq | user_id | mtype |
| --- | ------- | ----- |
| 1   | 1       | 11    |
| 1   | 2       | 12    |
| 1   | 3       | 13    |
| 2   | 1       | 21    |
| 2   | 2       | 22    |

&ensp;왜 이렇게 하는 이유<br/>
1. receiver는 자기 user_id만 읽으면 됨 → 내가 user 2이면 `21, 22, 23 ...` 중 type= seq*10+2만 읽음
2. 메시지 정렬이 자동으로 됨 → mtype= 11,12,13,21,22,23… 순으로 들어감, 별도 정렬 알고리즘 필요 없음
3. multi-user-broadcast 구현 간단

&ensp;**Shared Memory + Semaphore(세마포어)의 역할**<br/>

| 기능               | Shared Memory | Semaphore         |
| ---------------- | ------------- | ----------------- |
| next_msg_num     | 메시지 번호 증가     | race condition 방지 |
| active_users     | 총 접속자 수       | 동시 업데이트 방지        |
| user_alive[1..3] | 각 사용자 참여 여부   | read/write 동기화    |

&ensp;shared memory를 전역 상태 저장소로 사용하고 semaphore를 배타적 접근으로 사용함<br/>

&ensp;**sender 동작 흐름**<br/>

```css
입력 받기 → talk_quit 검사 → next_msg_num 증가(P/V 보호) 
→ alive 사용자 목록 읽기 → 모든 유저에게 메시지큐로 전송
```

&ensp;sender 종료 조건<br/>
* talk_quit
* EOF(Ctrl + D)

&ensp;sender가 종료되면 receiver도 종료해야 함 → A조건 충족

&ensp;**receiver 동작 흐름**

```c
while (1):
    if(sender_pid 죽음) break
    type = next_seq * 10 + my_id
    if(msgrcv 성공):
         출력
         next_seq++
    if(active_users == 0) break
```

&ensp;sender가 죽으면 receiver도 종료(A번)<br/>
&ensp;모든 사용자가 나가면 receiver도 종료(B번)<br/>
&ensp;메시지 순서 보장(C번)<br/>

&ensp;**전체 종료(cleanup)**<br/>
&ensp;마지막 유저가 나갈 때<br/>
```scss
msgctl(..., IPC_RMID)
shmctl(..., IPC_RMID)
semctl(..., IPC_RMID)
```

&ensp;IPC 자원이 완전히 사라짐<br/>



## main() 전체 구조

```scss
 ┌──────────────────────────────────────────────┐
 │                    main                      │
 └──────────────────────────────────────────────┘
                 │
                 ▼
      ┌───────────────────────┐
      │ init_ipc() 호출       │
      │ - msgget              │
      │ - shmget + shmat      │
      │ - semget + SETVAL=1   │
      └───────────────────────┘
                 │
                 ▼
      ┌───────────────────────┐
      │ assign_id(&start_seq) │
      │ - 세마포어 P()        │
      │ - user_alive[]에서    │
      │   비어있는 ID 배정    │
      │ - next_msg_num 설정   │
      │ - 세마포어 V()        │
      └───────────────────────┐
                 │             │
       [my_id < 0이면 종료]    │
                               ▼
                ┌───────────────────────────────┐
                │ User X joined (start_seq=Y)   │
                └───────────────────────────────┘
                               │
                               ▼
      ┌─────────────────────────────────────────┐
      │ fork()  → sender 프로세스 생성          │
      └─────────────────────────────────────────┘
                               │
                               ▼
      ┌─────────────────────────────────────────┐
      │ fork()  → receiver 프로세스 생성        │
      └─────────────────────────────────────────┘
                               │
                               ▼
      ┌─────────────────────────────────────────┐
      │ parent: waitpid(sender), waitpid(receiver)
      └─────────────────────────────────────────┘
                               │
                               ▼
      ┌─────────────────────────────────────────┐
      │ unregister_user(my_id)                  │
      │ - active_users 감소                     │
      │ - 모두 나가면 IPC 삭제                 │
      └─────────────────────────────────────────┘
                               │
                               ▼
                        프로그램 종료
```



## sender 프로세스 동작 흐름

&ensp;sender는 stdin(키보드)에서 입력을 읽고 → 각 사용자에게 메시지 큐를 통해 메시지를 전송한다.

&ensp;메시지 타입 = `seq *10 + user_id` 를 만드는 프로세스 → 모든 사용자가 같은 순서로 메시지를 받도록 보장한다.

&ensp;sender()동작 설계도<br/>

```scss
              ┌──────────────────────────────┐
              │           sender()           │
              └──────────────────────────────┘
                           │
                           ▼
        ┌──────────────────────────────────────┐
        │ while(입력 fgets 성공)               │
        └──────────────────────────────────────┘
                           │
                           ▼
        ┌──────────────────────────────────────┐
        │ "talk_quit" ? → break                │
        └──────────────────────────────────────┘
                           │
                           ▼
        ┌──────────────────────────────────────────────┐
        │ seq = get_next_msg_num()                     │
        │  • next_msg_num 읽고 증가                    │
        │  • 세마포어 P/V로 보호                       │
        └──────────────────────────────────────────────┘
                           │
                           ▼
        ┌──────────────────────────────────────────────┐
        │ alive[] 복사                                 │
        │ (공유메모리 user_alive를 읽기 위해 P/V 보호) │
        └──────────────────────────────────────────────┘
                           │
                           ▼
        ┌──────────────────────────────────────────────┐
        │ for uid=1..3                                 │
        │   alive[uid]==1 인 사용자에게만              │
        │   메시지 큐에 msgsnd() 수행                  │
        │                                               │
        │   mtype = seq*10 + uid                       │
        │   msg.text = 입력 문자열                     │
        └──────────────────────────────────────────────┘
                           │
                           ▼
                  [다음 입력을 기다림]
```

## receiver 프로세스 동작 흐름

&ensp;receiver는 오직 자기에게 도착하는 메시지 타입만 읽는다. → 타입: seq * 10 + my_id<br/>
&ensp;seq 증가 → 정확한 순서로 메시지를 받는다.<br/>

```scss
              ┌──────────────────────────────┐
              │          receiver()          │
              └──────────────────────────────┘
                           │
                           ▼
       ┌────────────────────────────────────────┐
       │ next_seq = start_seq                   │
       └────────────────────────────────────────┘
                           │
                           ▼
       ┌────────────────────────────────────────┐
       │ while (true)                           │
       └────────────────────────────────────────┘
                           │
                           ▼
   ┌──────────────────────────────────────────────┐
   │ 1) sender 프로세스 생존 여부 확인             │
   │    kill(sender_pid, 0) == -1 → 종료          │
   └──────────────────────────────────────────────┘
                           │
                           ▼
   ┌──────────────────────────────────────────────┐
   │ 2) 내가 받아야 할 메시지 타입 계산           │
   │    type = next_seq * 10 + my_id             │
   └──────────────────────────────────────────────┘
                           │
                           ▼
   ┌──────────────────────────────────────────────┐
   │ 3) msgrcv(type) 시도 (IPC_NOWAIT)            │
   │    → 메시지 도착 시: 출력 후 next_seq++     │
   └──────────────────────────────────────────────┘
                           │
                           ▼
   ┌──────────────────────────────────────────────┐
   │ 4) active_users == 0 → talk 종료             │
   └──────────────────────────────────────────────┘
                           │
                           ▼
            ┌─────────────────────────┐
            │ 5) 50ms sleep           │
            └─────────────────────────┘
```

| 프로세스         | 역할                                            | 주요 IPC                 | 핵심 기능                   |
| ------------ | --------------------------------------------- | ---------------------- | ----------------------- |
| **main**     | IPC 초기화, 사용자 ID 배정, sender/receiver 생성, 종료 처리 | msgget, shmget, semget | 전체 프로그램의 관리자            |
| **sender**   | 사용자 입력 → 모든 사용자에게 전송                          | msgsnd                 | seq 번호 생성 + 메시지 fan-out |
| **receiver** | seq 순서대로 메시지 수신                               | msgrcv                 | 정확한 순서대로 메시지 출력         |

