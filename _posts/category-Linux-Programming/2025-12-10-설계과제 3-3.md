---
title: "설계과제 3-3"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-12-10
last_modified_at: 2025-12-10
---

2차 계획서 var2
====


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <errno.h>

#define MAX_TEXT    256
#define BUFFER_SIZE 100

// 공통 메시지 구조체
typedef struct {
    long mtype;          // 1,2,3(유저용) or 999(token)
    int  sender;         // 보낸 사람 ID (1~3), token 때는 0
    int  msg_num;        // 전역 메시지 번호 (1,2,3,...)
    char text[MAX_TEXT]; // 내용
} Message;

#define MSG_SIZE (sizeof(Message) - sizeof(long))

int msgq_id;

// =============== token(999) 초기화 ===============
void init_counter() {
    // 간단하게: user1만 token을 만든다고 가정
    Message token;
    token.mtype  = 999;
    token.sender = 0;
    token.msg_num = 1;   // 1번부터 시작
    token.text[0] = '\0';

    if (msgsnd(msgq_id, &token, MSG_SIZE, 0) < 0) {
        exit(1);
    }
}

// =============== token(999)에서 전역 msg# 얻기 ===============
int get_next_msg_num() {
    Message token;

    // 1) token(999) 메시지 받기 → 현재 전역 번호
    if (msgrcv(msgq_id, &token, MSG_SIZE, 999, 0) < 0) {
        return -1;
    }

    int current = token.msg_num;

    // 2) 다음 번호로 token 다시 큐에 넣기
    token.msg_num = current + 1;

    if (msgsnd(msgq_id, &token, MSG_SIZE, 0) < 0) {
        perror("msgsnd token");
        return -1;
    }

    return current;  // 이 값을 이번 메시지의 msg#로 사용
}

// =============== msg_num 기준 정렬 함수 ===============
int compare_msg_num(const void *a, const void *b) {
    const Message *m1 = (const Message *)a;
    const Message *m2 = (const Message *)b;
    return m1->msg_num - m2->msg_num;
}

// =============== 자식: 송신 프로세스 ===============
void sender(int my_id) {
    char input[MAX_TEXT];

    while (1) {

        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;  // EOF (Ctrl+D 등)
        }

        // 개행 제거
        input[strcspn(input, "\n")] = '\0';

        if (strlen(input) == 0)
            continue;

        // 종료 명령
        if (strcmp(input, "talk_quit") == 0) {
            printf("[Child %d] talk_quit. Exiting sender.\n", my_id);
            break;
        }

        // 1) 전역 메시지 번호 얻기 (token 사용)
        int msg_no = get_next_msg_num();
        if (msg_no < 0) {
            fprintf(stderr, "get_next_msg_num failed\n");
            continue;
        }

        // 2) 메시지 준비
        Message msg;
        msg.sender = my_id;
        msg.msg_num = msg_no;
        strncpy(msg.text, input, MAX_TEXT - 1);
        msg.text[MAX_TEXT - 1] = '\0';

        // 3) 나를 제외한 (1~3)에게 브로드캐스트
        for (int i = 1; i <= 3; i++) {
            if (i == my_id) continue;  // 자기 자신에게는 보내지 않음

            msg.mtype = i;            // i번 사용자가 받을 메시지

            if (msgsnd(msgq_id, &msg, MSG_SIZE, 0) < 0) {
                perror("msgsnd user");
            }
        }
        // 내가 입력한 내용은 터미널이 에코해주니까 따로 안 찍어도 됨
    }

    exit(0);
}

// =============== 부모: 수신 + 출력 프로세스 ===============
void receive(int my_id, pid_t child_pid) {
    Message buffer[BUFFER_SIZE];
    int buffer_count = 0;
    int last_printed = 0;   // 내가 마지막으로 출력한 msg#
    int child_running = 1;

    while (child_running) {
        Message msg;
        ssize_t r = msgrcv(msgq_id, &msg, MSG_SIZE, my_id, IPC_NOWAIT);

        if (r > 0) {
            // 내게 온 메시지 → 버퍼에 저장
            if (buffer_count < BUFFER_SIZE) {
                buffer[buffer_count++] = msg;

                // msg_num 기준 정렬
                qsort(buffer, buffer_count, sizeof(Message), compare_msg_num);

                // 아직 출력 안 한 것들 중에서 msg_num이
                // last_printed보다 큰 것들 모두 출력
                int i = 0;
                while (i < buffer_count) {
                    if (buffer[i].msg_num > last_printed) {
                        printf("\r[sender=%d & msg#=%d] %s\n", buffer[i].sender, buffer[i].msg_num, buffer[i].text);
                        last_printed = buffer[i].msg_num;

                        // 출력한 메시지는 버퍼에서 제거
                        memmove(&buffer[i], &buffer[i + 1], (buffer_count - i - 1) * sizeof(Message));
                        buffer_count--;
                        // i는 그대로 (다음 요소가 당겨졌으니 같은 인덱스에서 다시 검사)
                    } else {
                        i++;
                    }
                }
            } else {
                fprintf(stderr, "[Warning] buffer full\n");
            }
        }

        // 자식(송신 프로세스) 종료 체크
        int status;
        pid_t res = waitpid(child_pid, &status, WNOHANG);
        if (res > 0) {
            printf("\n[Parent %d] Child terminated. Exiting receiver.\n", my_id);
            child_running = 0;
        }

        usleep(50000); // 0.05초 쉬기
    }
}

// =============== 메시지 큐 초기화 ===============
int init_message_queue() {
    key_t key = ftok("msgkey", 'T');
    if (key == -1) {
        return -1;
    }

    msgq_id = msgget(key, IPC_CREAT | 0666);
    if (msgq_id == -1) {
        return -1;
    }

    return 0;
}

// =============== main ===============
int main(int argc, char *argv[]) {
    if (argc != 2) {
        return 1;
    }

    int my_id = atoi(argv[1]);
    if (my_id < 1 || my_id > 3) {
        fprintf(stderr, "Error: user_id must be 1, 2, or 3\n");
        return 1;
    }

    if (init_message_queue() < 0) {
        fprintf(stderr, "Failed to init message queue\n");
        return 1;
    }

    // token(999)은 user1이 한 번만 만들어줌
    if (my_id == 1) {
        init_counter();
    }

    pid_t pid = fork();
    if (pid < 0) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        // 자식 → 송신
        sender(my_id);
    } else {
        // 부모 → 수신
        receive(my_id, pid);
    }

    return 0;
}
```

## main() Flowchar

```scss
                     ┌─────────────────────────────┐
                     │           Start              │
                     └──────────────┬──────────────┘
                                    │
                  ┌─────────────────▼──────────────────┐
                  │ argv[1]을 정수 my_id로 변환         │
                  │ (1~3이 아니면 에러 종료)           │
                  └─────────────────┬──────────────────┘
                                    │
                  ┌─────────────────▼──────────────────┐
                  │   메시지 큐 생성(init_message_queue)│
                  │   실패 시 종료                     │
                  └─────────────────┬──────────────────┘
                                    │
                      my_id == 1 ?  │
                     ┌──────────────▼─────────────┐
                     │ token 초기화(init_counter)  │
                     └──────────────┬─────────────┘
                                    │
                     ┌──────────────▼──────────────┐
                     │        fork() 실행           │
                     └───────┬───────────┬─────────┘
                             │child=0     │ parent
          ┌──────────────────▼───┐   ┌────▼───────────────────┐
          │   sender(my_id)      │   │   receiver(my_id, pid) │
          │  (입력 → 전송 담당)  │   │  (수신 → 출력 담당)     │
          └──────────────────────┘   └────────────────────────┘
```

## sender() 설계도 (전송 프로세스)

```scss
                     ┌───────────────────────────────┐
                     │          sender() 시작          │
                     └─────────────────┬──────────────┘
                                       │
                     ┌─────────────────▼────────────────┐
                     │ while(1): stdin에서 문자열 입력   │
                     └─────────────────┬────────────────┘
                                       │
                            입력 EOF or "talk_quit" ?
                    ┌───────────────┬───────────────┐
                    │ Yes           │ No            │
                    ▼               ▼               │
        ┌──────────────────┐    ┌───────────────────────┐
        │ sender 종료       │    │  공백 문자열이면 continue │
        └──────────────────┘    └───────────────────────┘
                                       │
                     ┌─────────────────▼────────────────┐
                     │  1) msg_no = get_next_msg_num()   │
                     └─────────────────┬────────────────┘
                                       │
                     ┌─────────────────▼────────────────────────┐
                     │ 2) 메시지 구조체 msg 구성                 │
                     │    - msg.sender = my_id                  │
                     │    - msg.msg_num = msg_no                │
                     │    - msg.text = 입력 문자열              │
                     └─────────────────┬────────────────────────┘
                                       │
                     ┌─────────────────▼────────────────────────────┐
                     │ 3) for i = 1..3                               │
                     │       if i != my_id →                         │
                     │          msg.mtype = i                        │
                     │          msgsnd(msgq, msg)                    │
                     └─────────────────┬────────────────────────────┘
                                       │
                                       ▼
                           (while 루프 처음으로)
```

## receiver() 설계도 (수신 + 출력 프로세스)

```scss
                       ┌─────────────────────────────────┐
                       │        receiver() 시작           │
                       └───────────────────┬──────────────┘
                                           │
                ┌──────────────────────────▼──────────────────────────┐
                │  버퍼(buffer[]) 초기화                               │
                │  last_printed = 0                                    │
                └──────────────────────────┬──────────────────────────┘
                                           │
                           ┌───────────────▼───────────────────┐
                           │ while(child 프로세스 살아있음):   │
                           └────────────────┬───────────────────┘
                                            │
          ┌─────────────────────────────────▼────────────────────────────────┐
          │ non-blocking msgrcv(mtype=my_id) → 메시지 도착?                 │
          └─────────────────────────────────┬────────────────────────────────┘
                                            │
                            Yes             │              No
                     ┌───────────────┐      │      ┌────────────────────────┐
                     │ 버퍼에 저장    │      │      │ 아무 메시지도 없음      │
                     └──────┬────────┘      │      └────────────────────────┘
                            │               │
                     ┌──────▼───────────────────────────────────────────────┐
                     │ 버퍼를 msg_num 기준으로 qsort로 정렬                 │
                     └──────┬───────────────────────────────────────────────┘
                            │
                     ┌──────▼───────────────────────────────────────────────┐
                     │ 버퍼 앞에서부터                                       │
                     │ msg_num > last_printed 인 메시지 모두 출력            │
                     │ 출력 후 버퍼에서 삭제                                 │
                     └──────┬───────────────────────────────────────────────┘
                            │
                     ┌──────▼───────────────────────────────────────────────┐
                     │ waitpid(child, WNOHANG) 로 자식 종료 체크            │
                     └──────┬───────────────────────────────────────────────┘
                            │
                        종료되었는가?
                       ┌───────┬─────────┐
                       │ Yes   │ No      │
                       ▼        ▼         │
      ┌────────────────────┐   ┌──────────▼────────────┐
      │ "[Parent] 종료" 출력 │   │ usleep(50ms) 후 반복 │
      └────────────────────┘   └────────────────────────┘
```

&ensp;main()<br/>
* 메시지 큐 생성
* user1만 token(999) 생성
* fork 후
    - child → sender
    - parent → receiver

&ensp;sender()<br/>
* 입력 받기 → token에서 msg_num 할당받기
* 나 제외한 모든 사용자에게 mtype=상대방_id 로 전송

&ensp;receiver()<br/>
* mtype=my_id 로 도착한 메시지를
    - 버퍼에 저장
    - msg_num 정렬
    - 순서대로 출력
* child 종료되면 receiver 종료