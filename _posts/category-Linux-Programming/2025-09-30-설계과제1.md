---
title: "설계과제1"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-09-30
last_modified_at: 2025-09-30
---


&ensp;구현해야 할 내용<br/>
&ensp;리눅스 기본 명령어 직접 구현하는 shell 프로그램 구현<br/>
&ensp;bash같은 쉘에서 쓰는 cat, cd, cp, ls -l, mkdir, rm, vi, ./a.out 같은 명령어를 직접 C언어로 구현<br/>

&ensp;구현해야 하는 명령어<br/>
1. cat_m FILE_NAME
* 파일 내용을 출력
2. d_m DIRECTORY_NAME
* 디렉토리 이동
3. cp_m FILE_NAME1 FILE_NAME2
* 파일 복사
4. ls_m -l
* 현재 디렉토리 내용 상세 출력
5. mkdir_m DIRECTORY_NAME mode
* 새로운 디렉토리 생성 (mode는 권한)
6. rm_m FILE_NAME or DIRECTORY_NAME
* 파일/디렉토리 삭제
7. vi_m FILE_NAME
* 파일 수정 (간단한 편집 기능)
8. ./a.out 1 10
* 프로그램 실행 시 매개변수로 받은 범위를 출력 (ex: 1 ~ 10까지 숫자)

&ensp;실행 예시<br/>
```bash
HW   > ls_m l
F 0600 1 2020 2000 969 Sun Oct 6 16:56:39 2025 p1.c
F 0600 1 2020 2000 995 Sun Oct 6 16:55:17 2025 temp
F 0700 1 2020 2000 8078 Sun Oct 6 16:56:43 2025 p1
F 0600 1 2020 2000 209 Sun Oct 6 16:55:33 2025 test1.c
```

* ls_m -l 명령으로 현재 directory에 있는 파일 정보 출력<br/>
* prompt는 현재 directory의 이름만 표시

```bash
HW1 > mkdir_m A 711
HW1 > Is_m -l
...
D 0711 2 2020 2000 4096 Sun Oct 6 17:55:08 2025 A
```

* mkdir_m 명령으로 현재 directory에 A라
는 이름의 subdirectory 만들기
*  Is_m -l 명령으로 A directory 생성 확인

```bash
HW1 > cp_m test1.c A/test.c
```

* cp_m 명령으로 test1.c 파일을 복사하여 A 디렉토리 안에 test.c 파일로 만들기

```bash
HW1 > cd_m A
A > Is_m -l
F 0600 1 2020 2000 209 Sun Oct 6 17:58:10 2025 test.c
A > cat_m test.c

/* test.c 파일의 내용 출력 */
```

* cd_m 명령으로 A directory 로 이동(prompt가 “A"로 변경)
* Is_m -l 명령으로 test.c 생성 확인
* cat_m 명령으로 test.c의 내용 확인

```bash
A> vi_m abc
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCC
quit
A> cat_m abc
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCO
```

* vi_m 명령으로 A directory에 abc라는 이
름의 파일 만들기
* 파일 내용 입력하고 "quit"으로 종료
*  cat_m 명령으로 abc 파일 내용 확인

```bash
A> vi_m abc
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb

(5) 파일 및 서브디렉토리를 마지막으로 update 한 날짜는 문자 형식으로

cccCCCCCC

출력

ddddddddddddddddddddd
eeeeeee

quit

후 "quit"로 종료

A> cat m abo
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCC
ddddddddddddddddddddd
quit
A> cat m abo
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCC
ddddddddddddddddddddd
eeeeeee
```

* vi_m 명령으로 abc 파일 수정하기 먼저 기존 파일 내용 보이고, 2줄 추가 후 "quit"로 종료
* cat_m 명령으로 abc 파일 수정된 내용 확인

```bash
A > cd_m ..
...
HW1 > Is_m -l
E 0600 1 2020 2000 995 Sun Oct 6 16:55:17 2025 temp
HW1 > rm_m temp
HW1 > Is_m -l
/* temp 삭제 확인 */
HW1 > rm_m A
HW1 > Is_m -l
/* temp 삭제 확인 */
```

* cd_m 명령으로 상위 directory 로 이동
* ls_m 명령으로 temp 파일 확인 후, rm_m 명령으로 temp 파일 삭제하고 삭제 확인
* rm_m 명령으로 directory A 삭제, A directory 안에는 "abc", "test1.c" 파일이 있지만 subdirectory는 가지고 있지 않음(파일 삭제후 directory 삭제)

```bash
HW1 > ./test1 20 25
...... 20
...... 21
..... 22
..... 23
..... 24
..... 24
..... 25
```

* 현재 directory 에 있는 test1 실행파일 실행(test1 파일은 argument로 주어진 두 정수와 그 사이의 정수를 순차적으로 출력)

```bash
HW1> exit
```

* exit으로 종료

&ensp;필수 시스템 콜 & 함수<br/>
&ensp;(1)파일 다루기<br/>
* open() : 파일 열기
* read() : 파일 읽기
* write() : 파일 쓰기
* close() : 파일 닫기

&ensp;(2) 디렉토리 다루기<br/>
* chdir() : 디렉토리 변경
* mkdir() : 디렉토리 생성
* rmdir() : 디렉토리 삭제
* opendir(), readdir() : 디렉토리 내용 읽기

&ensp;(3) 파일 상태<br/>
* stat() : 파일 크기, 권한, 소유자 등 정보 확인
* chmod() : 권한 변경
* unlink() : 파일 삭제

&ensp;(4) 프로세스<br/>
* fork() : 자식 프로세스 생성
* execvp() : 새로운 프로그램 실행 (vi, a.out 실행에 필요)
* wait() : 자식 프로세스가 끝날 때까지 기다리기

&ensp;프로그램 전체 구조 (흐름)<br/>
1. 프로그램 실행 → 무한 루프 시작
2. 사용자 입력 받기 (scanf, fgets)
3. strcmp로 명령어, 종료조건 판별
4. 첫 번째 단어가 어떤 명령어인지 확인
    - cat_m → cat 함수 실행
    - cd_m → cd 함수 실행
    - ...
    - exit → 프로그램 종료
5. 각 명령어는 위의 시스템 콜을 사용해서 기능 수행
6. 결과 출력
7. 다시 루프 시작

&ensp;전체 구조 플로우 차트<br/>
```css
[시작]
   ↓
[초기화: 현재 작업 디렉토리 확인]
   ↓
┌───────────────────────────┐
│ [무한 루프 시작]          │
└───────────────────────────┘
   ↓
[프롬프트 출력 → 사용자 입력 받기]
   ↓
[입력 문자열을 공백 단위로 분리]
   ↓
[첫 번째 단어 확인]
   ↓
 ┌─────────────────────────────────────────┐
 │ cat_m → cat_m 함수 실행                  │
 │ cd_m → cd_m 함수 실행                    │
 │ cp_m → cp_m 함수 실행                    │
 │ ls_m -l → ls_m 함수 실행                 │
 │ mkdir_m → mkdir_m 함수 실행              │
 │ rm_m → rm_m 함수 실행                    │
 │ vi_m → vi_m 함수 실행                    │
 │ ./a.out → a.out 실행                     │
 │ exit → 프로그램 종료                     │
 │ 그 외 입력 → "잘못된 명령어" 출력        │
 └─────────────────────────────────────────┘
   ↓
[명령어 실행 결과 출력]
   ↓
[루프 반복]
   ↓
(exit 입력 시)
   ↓
[종료]
```

&ensp;핵심 포인트<br/>
1. 메인 루프가 있어서 사용자가 exit을 입력할 때까지 계속 실행돼요.
2. 입력받은 문자열을 토큰화(strtok) 해서 첫 번째 단어(명령어)로 분기 처리한다.
3. 각 명령어는 따로 함수(cat_m(), cd_m() …)로 구현해 두고 호출합니다.
4. exit이 들어오면 루프를 빠져나와 프로그램을 종료합니다.

&ensp;프로그램 실행 방식 (큰 흐름)<br/>
1. 프로그램 시작
* 우리가 만든 쉘 프로그램(hw1.c → ./hw1.out)을 실행하면 시작한다.
* main() 안에서 무한 루프를 돌면서 계속 사용자 입력을 기다린다.
2. 프롬프트 출력 & 입력 대기
* 화면에 HW1 > 같은 프롬프트가 뜬다.
* 사용자가 cat_m abc 같은 명령어를 입력한다..
3. 입력 파싱 (문자열 분리)
* fgets() 등으로 입력받은 문자열을 공백 단위로 잘라서(strtok) → [명령어][인자1][인자2] ... 형태로 분리한다.
4. 명령어 판별
* if-else 또는 switch 문으로 첫 번째 단어가 뭔지 확인한다.
    - cat_m → cat 함수 실행
    - cd_m → cd 함수 실행
    - ls_m -l → ls 함수 실행
    - exit → 종료
    - 그 외 → "잘못된 명령어" 출력
5. 프로세스 생성 (fork)
* 명령어 실행이 필요할 때는 보통 자식 프로세스를 만듭니다.
* pid = fork();
    - pid == 0 → 자식 프로세스 (명령어 실행 담당)
    - pid > 0 → 부모 프로세스 (프롬프트 유지)
6. 자식 프로세스 실행 (execvp)
* 자식 프로세스는 execvp()를 호출해서 실제 명령어(cat_m, ls_m, ./a.out 등)를 실행한다.
* execvp가 호출되면 자식 프로세스의 메모리는 새로운 프로그램으로 덮어씌운다.
7. 부모 프로세스 대기 (wait)
* 부모 프로세스는 wait()로 자식이 끝날 때까지 기다린다.
* 자식이 종료되면 종료 상태를 확인한다. (정상 종료인지 오류인지)
8. 결과 출력
* 실행된 명령어의 결과(파일 내용, 디렉토리 목록, 복사 성공 여부 등)가 화면에 출력된다.
9. 루프 반복
* 다시 프롬프트(HW1 > )를 띄우고 새로운 입력을 기다린다.
* 사용자가 exit을 입력하면 루프를 탈출하고 프로그램을 종료한다.

&ensp;실행 과정 요약<br/>
```scss
[시작]
   ↓
[프롬프트 출력 → 입력 받기]
   ↓
[명령어 분리]
   ↓
[명령어 판별]
   ↓
 ┌───────────────┐
 │ exit ?        │─── Yes ─→ [프로그램 종료]
 └───────────────┘
   ↓ (No)
[fork() 호출 → 자식 프로세스 생성]
   ↓
[자식 → execvp() 실행 → 실제 명령어 실행]
   ↓
[부모 → wait()로 자식 종료 기다림]
   ↓
[결과 출력 후 루프 반복]
```


&ensp;추가로 사용되는 시스템 콜<br/>
1. fork()
* 새로운 프로세스(자식 프로세스)를 생성
* 쉘은 새로운 명령어 실행할 때 항상 자식 프로세스를 만든다.
* 부모는 계속 루프를 돌면서 프롬프트를 띄워야 하기 때문에 실행은 자식이 담당하게 하는 구조이다.
2. execvp()
* 자식 프로세스에서 실제 명령어(cat, ls, vi, ./a.out 등)를 실행시킬 때 사용
* execvp는 현재 프로세스 메모리를 새로운 프로그램으로 교체하기 때문에, 보통 fork() 뒤에 바로 사용한다.
3. wait() 또는 waitpid()
* 부모 프로세스가 자식이 끝날 때까지 기다리도록 하는 시스템 콜
* 안 쓰면 좀비 프로세스가 생길 수 있다.
* 즉, 부모는 wait()로 자식 종료를 확인한다.
4. exit()
* 프로세스 종료
* 자식 프로세스가 자기 할 일을 다 하면 exit(0) 같은 식으로 종료한다.
* 부모 프로세스도 쉘 자체를 끝낼 때 exit(0)을 호출한다.

&ensp;핵심 정리
* 쉘 프로그램은 기본적으로 (입력 → 파싱 → fork → exec → wait → 출력 → 반복) 구조로 실행된다.
* fork & execvp는 새로운 명령어 실행을 위해 필요하고,
* wait는 좀비 프로세스 방지 및 결과 확인을 위해 필요하고,
* exit는 프로그램 종료를 위해 필요하다.

&ensp;exec 계열 중 execvp를 사용해야 하는 이유<br/>
1. 사용자가 입력한 명령어를 배열로 받아 처리해야 함
* 쉘 프로그램에서는 입력을 scanf나 fgets로 받아서 → args[] 배열에 저장한다.
* 그러므로 execvp(file, argv)처럼 배열을 인자로 주는 방식이 맞다.
2. 절대 경로를 몰라도 실행 가능해야 함
* 사용자가 cat_m이나 ls_m을 입력했을 때,
* ./cat_m, ./ls_m 같은 실행 파일이 현재 디렉토리에 있을 수 있다.
* execv라면 전체 경로를 다 써줘야 하지만,
* execvp는 PATH 환경변수를 검색해서 실행 파일을 찾아준다.
3. 실제 쉘(bash)도 execvp 계열을 사용
* 표준 쉘 구현에서 execvp를 쓰는 이유가 위와 동일하다.
* ls, cat, gcc 같은 명령어를 다 절대경로로 쓰라고 하면 너무 불편

&ensp;쉘 프로그램에서는 사용자가 입력한 명령어와 인자를 공백 단위로 분리하여 배열(args[])에 저장한 뒤 이를 실행 파일에 전달해야 한다. 따라서 exec 계열 함수 중에서 배열을 인자로 받을 수 있는 execvp(file, argv)를 사용하는 것이 적합하다. execl이나 execlp는 인자를 하나씩 나열해야 하므로 동적으로 입력을 처리하기 어렵고, execv는 배열을 받을 수 있지만 실행 파일의 절대 경로를 직접 지정해야 하는 불편함이 있다. 반면 execvp는 배열 전달이 가능하면서도 PATH 환경변수에 등록된 경로를 자동으로 탐색하여 실행 파일을 찾을 수 있기 때문에, 사용자가 cat_m, ls_m과 같은 명령어를 입력했을 때 별도의 절대 경로를 지정하지 않아도 실행이 가능하다. 이러한 이유로 쉘 구현에서는 execvp를 사용하는 것이 가장 적절하다.<br/>

&ensp;fork()를 사용하는 이유<br/>
&ensp;fork()는 새로운 프로세스를 생성해서 부모(쉘)는 계속 명령어를 받을 수 있고 자식은 사용자가 요청한 명령어를 실행하도록 하기 위해 사용된다.<br/>

&ensp;fork없이 exec만 쓰면<br/>
* 현재 쉘 프로세스가 사라지고그 자리에 새로운 프로그램(cat_m, ls_m 등)**이 덮어씌워진다.
* → 즉, 쉘이 사라져버려서 다음 명령을 받을 수 없다.

&ensp;그래서 fork()를 써서 새로운 자식 프로세스를 만든다.<br/>
* 부모: 쉘 본체 (명령 입력 받고 대기)
* 자식: 사용자가 요청한 명령어 실행 담당

```scss
[부모 프로세스: myshell] ──fork()──> [자식 프로세스: cat_m]
      │                                      │
      ├─ wait() (자식이 끝날 때까지 대기)   │
      └─ 프롬프트 출력 반복                 └─ execvp("cat_m", args)
```

* 쉘은 그대로 살아 있고,
* 자식이 명령어를 실행하고 종료되면,
* 부모(쉘)는 다시 프롬프트를 띄워서 다음 명령을 받을 수 있다.

&ensp;쉘 프로그램에서 fork()를 사용하는 이유는 사용자가 입력한 명령을 실행하기 위해 새로운 자식 프로세스를 생성하기 위함이다. 만약 exec()를 직접 호출하면 현재 쉘 프로세스가 새로운 프로그램으로 덮어써져 쉘이 사라지게 된다. 따라서 fork()를 통해 부모(쉘)는 계속 실행 상태를 유지하고 자식 프로세스만 명령어를 execvp()로 실행하도록 해야 쉘이 지속적으로 명령을 받을 수 있다.<br/>

&ensp;cp_m 구현하기<br/>
```c
#include <stdio.h>
#include <fcntl.h>      
#include <unistd.h>     
#include <stdlib.h>     
#include <sys/stat.h>   

int main(int argc, char **argv) {
	 int fd1, fd2;
	 char buf[1024];
	 int n;


	fd1 = open(argv[1], O_RDONLY);
	if(fd1 < 0){
		return 0;
	}

	fd2= open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);

	while ((n = read(fd1, buf, sizeof(buf))) > 0) {
        	write(fd2, buf, n);
    	}

	close(fd1);
	close(fd2);

	return 0;
}
```

&ensp;ls_m -l 구현하기<br/>
```c
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    DIR *dp;
    struct dirent *entry;
    struct stat st;
    struct tm *tm;
    char timebuf[100];

    dp = opendir(".");   // 현재 디렉터리 열기
    if (dp == NULL) {
        perror("opendir");
        exit(1);
    }

    while ((entry = readdir(dp)) != NULL) {
        // 파일 상태 정보 읽기
        if (stat(entry->d_name, &st) == -1)
            continue;

        // (2) 파일 종류 표시
        char type;
        if (S_ISDIR(st.st_mode)) type = 'D';
        else if (S_ISREG(st.st_mode)) type = 'F';
        else type = '-';

        // (5) 시간 문자열로 변환
        tm = localtime(&st.st_mtime);
        strftime(timebuf, sizeof(timebuf), "%a %b %d %H:%M:%S %Y", tm);

        // (1)(3)(4)(5)(6) 출력 형식
        printf("%c %04o %ld %d %d %ld %s %s\n",
               type,
               st.st_mode & 0777,       // 접근권한 (8진수)
               (long)st.st_nlink,        // 링크 수
               st.st_uid,                // 사용자 ID
               st.st_gid,                // 그룹 ID
               (long)st.st_size,         // 파일 크기
               timebuf,                  // 수정 날짜
               entry->d_name);           // 파일명
    }

    closedir(dp);
    return 0;
}
```

&ensp;vi_m 구현하기<br/>
```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>


int main(int argc, char *argv[]) {
    int fd;
    ssize_t nread;
    char buf[1024];
    char input[1024];
    ssize_t len;

   fd = open(argv[1], O_RDWR | O_CREAT, 0600);
   if (fd < 0){
      exit(1);
   }

    // 기존 파일 내용 출력
    lseek(fd, 0, SEEK_SET);
    while ((nread = read(fd, buf, BUF_SIZE)) > 0) {
        write(1, buf, nread);
    }

    // 파일 끝으로 이동 후 입력 대기
    lseek(fd, 0, SEEK_END);

    while (1) {
      len = read(0, input, BUF_SIZE);
      if (len <= 0) 
         break;
      if (strstr(input, "quit") != NULL) 
         break;
      write(fd, input, len);
    }

    close(fd);
    return 0;
}
```

&ensp;main함수 구현<br/>
```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <ftw.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>

int main(void){
    char in[100], *res[20] = {0};
    int i, status;
    pid_t pid;
    char cwd[256];   // 현재 디렉토리 저장용

    while (1){
        // system call 필요 → 현재 디렉토리 경로 표시
        getcwd(cwd, sizeof(cwd));
        printf("%s > ", cwd);

        i = 0;
        res[i] = strtok(in, "/");
        while (res[i]) {
            res[++i] = strtok(NULL, "/");
        }
        printf("%s > ", res[i-1]);

        fgets(in, sizeof(in), stdin);
        in[strcspn(in, "\n")] = '\0';
        if (in[0] == '\0')
            continue;

        i = 0;
        res[i] = strtok(in, " ");
        while (res[i]) {
            res[++i] = strtok(NULL, " ");
        }

        // exit 입력 시 종료
        if (strcmp(res[0], "exit") == 0)
            break;

        // fork + execvp (에러 메시지 출력 없음)
        pid = fork();
        if (pid == 0) {   // 자식 프로세스
            execvp(res[0], res);
            exit(1);      // 실패 시 그냥 종료
        } 
        else if (pid > 0) {  // 부모 프로세스
            wait(&status);
        }
    }

    return 0;
}
```