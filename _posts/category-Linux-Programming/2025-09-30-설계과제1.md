---
title: "설계과제1"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-09-30
last_modified_at: 2025-09-30
---


&ensp;구현해야 할 내용<br/>
&ensp;리눅스 기본 명령어 직접 구현하는 shell 프로그램 구현<br/>
&ensp;bash같은 쉘에서 쓰는 cat, cd, cp, ls -l, mkdir, rm, vi, ./a.out 같은 명령어를 직접 C언어로 구현<br/>

&ensp;구현해야 하는 명령어<br/>
1. cat_m FILE_NAME
* 파일 내용을 출력
2. d_m DIRECTORY_NAME
* 디렉토리 이동
3. cp_m FILE_NAME1 FILE_NAME2
* 파일 복사
4. ls_m -l
* 현재 디렉토리 내용 상세 출력
5. mkdir_m DIRECTORY_NAME mode
* 새로운 디렉토리 생성 (mode는 권한)
6. rm_m FILE_NAME or DIRECTORY_NAME
* 파일/디렉토리 삭제
7. vi_m FILE_NAME
* 파일 수정 (간단한 편집 기능)
8. ./a.out 1 10
* 프로그램 실행 시 매개변수로 받은 범위를 출력 (ex: 1 ~ 10까지 숫자

&ensp;실행 예시<br/>
```bash
HW   > ls_m l
F 0600 1 2020 2000 969 Sun Oct 6 16:56:39 2025 p1.c
F 0600 1 2020 2000 995 Sun Oct 6 16:55:17 2025 temp
F 0700 1 2020 2000 8078 Sun Oct 6 16:56:43 2025 p1
F 0600 1 2020 2000 209 Sun Oct 6 16:55:33 2025 test1.c
```

* ls_m -l 명령으로 현재 directory에 있는 파일 정보 출력<br/>
* prompt는 현재 directory의 이름만 표시

```bash
HW1 > mkdir_m A 711
HW1 > Is_m -l
...
D 0711 2 2020 2000 4096 Sun Oct 6 17:55:08 2025 A
```

* mkdir_m 명령으로 현재 directory에 A라
는 이름의 subdirectory 만들기
*  Is_m -| 명령으로 A directory 생성 확인

```bash
HW1 > cp_m test1.c A/test.c
```

* cp_m 명령으로 test1.c 파일을 복사하여 A 디렉토리 안에 test.c 파일로 만들기

```bash
HW1 > cd_m A
A > Is_m -I
F 0600 1 2020 2000 209 Sun Oct 6 17:58:10 2025 test.c
A > cat_m test.c

/* test.c 파일의 내용 출력 */
```

* cd_m 명령으로 A directory 로 이동(prompt가 “A"로 변경)
* Is_m -| 명령으로 test.c 생성 확인
* cat_m 명령으로 test.c의 내용 확인

```bash
A> vi_m abc
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCC
quit
A> cat_m abc
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCO
```

* vi_m 명령으로 A directory에 abc라는 이
름의 파일 만들기
* 파일 내용 입력하고 "quit"으로 종료
*  cat_m 명령으로 abc 파일 내용 확인

```bash
A> vi_m abc
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb

(5) 파일 및 서브디렉토리를 마지막으로 update 한 날짜는 문자 형식으로

cccCCCCCC

출력

ddddddddddddddddddddd
eeeeeee

quit

후 "quit"로 종료

A> cat m abo
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCC
ddddddddddddddddddddd
quit
A> cat m abo
aaaaaaaaaaaaa
bbbbbbbbbbbbbbb
CCCCCCCCC
ddddddddddddddddddddd
eeeeeee
```

* vi_m 명령으로 abc 파일 수정하기 먼저 기존 파일 내용 보이고, 2줄 추가 후 "quit"로 종료
* cat_m 명령으로 abc 파일 수정도니 내용 확인

```bash
A > cd_m ..
...
HW1 > Is_m -l
E 0600 1 2020 2000 995 Sun Oct 6 16:55:17 2025 temp
HW1 > rm_m temp
HW1 > Is_m -l
/* temp 삭제 확인 */
HW1 > rm_m A
HW1 > Is_m -l
/* temp 삭제 확인 */
```

* cd_m 명령으로 상위 directory 로 이동
* ls_m 명령으로 temp 파일 확인 후, rm_m 명령으로 temp 파일 삭제하고 삭제 확인
* rm_m 명령으로 directory A 삭제, A directory 안에는 "abc", "test1.c" 파일이 있지만 subdirectory는 가지고 있지 않음(파일 삭제후 directory 삭제)

```bash
HW1 > ./test1 20 25
...... 20
...... 21
..... 22
..... 23
..... 24
..... 24
..... 25
```

* 현재 directory 에 있는 test1 실행파일 실행(test1 파일은 argument로 주어진 두 정수와 그 사이의 정수를 순차적으로 출력)

```bash
HW1> exit
```

* exit으로 종료

&ensp;필수 시스템 콜 & 함수<br/>
&ensp;(1)파일 다루기<br/>
* open() : 파일 열기
* read() : 파일 읽기
* write() : 파일 쓰기
* close() : 파일 닫기

&ensp;(2) 디렉토리 다루기<br/>
* chdir() : 디렉토리 변경
* mkdir() : 디렉토리 생성
* rmdir() : 디렉토리 삭제
* opendir(), readdir() : 디렉토리 내용 읽기

&ensp;(3) 파일 상태<br/>
* stat() : 파일 크기, 권한, 소유자 등 정보 확인
* chmod() : 권한 변경
* unlink() : 파일 삭제

&ensp;(4) 프로세스<br/>
* fork() : 자식 프로세스 생성
* execvp() : 새로운 프로그램 실행 (vi, a.out 실행에 필요)
* wait() : 자식 프로세스가 끝날 때까지 기다리기

&ensp;프로그램 전체 구조 (흐름)<br/>
1. 프로그램 실행 → 무한 루프 시작
2. 사용자 입력 받기 (scanf, fgets)
3. 입력을 공백 기준으로 토큰 분리 (strtok)
4. 첫 번째 단어가 어떤 명령어인지 확인
    - cat_m → cat 함수 실행
    - cd_m → cd 함수 실행
    - ...
    - exit → 프로그램 종료
5. 각 명령어는 위의 시스템 콜을 사용해서 기능 수행
6. 결과 출력
7. 다시 루프 시작

&ensp;전체 구조 플로우 차트<br/>
```css
[시작]
   ↓
[초기화: 현재 작업 디렉토리 확인]
   ↓
┌───────────────────────────┐
│ [무한 루프 시작]          │
└───────────────────────────┘
   ↓
[프롬프트 출력 → 사용자 입력 받기]
   ↓
[입력 문자열을 공백 단위로 분리]
   ↓
[첫 번째 단어 확인]
   ↓
 ┌─────────────────────────────────────────┐
 │ cat_m → cat_m 함수 실행                  │
 │ cd_m → cd_m 함수 실행                    │
 │ cp_m → cp_m 함수 실행                    │
 │ ls_m -l → ls_m 함수 실행                 │
 │ mkdir_m → mkdir_m 함수 실행              │
 │ rm_m → rm_m 함수 실행                    │
 │ vi_m → vi_m 함수 실행                    │
 │ ./a.out → a.out 실행                     │
 │ exit → 프로그램 종료                     │
 │ 그 외 입력 → "잘못된 명령어" 출력        │
 └─────────────────────────────────────────┘
   ↓
[명령어 실행 결과 출력]
   ↓
[루프 반복]
   ↓
(exit 입력 시)
   ↓
[종료]
```

&ensp;핵심 포인트<br/>
1. 메인 루프가 있어서 사용자가 exit을 입력할 때까지 계속 실행돼요.
2. 입력받은 문자열을 토큰화(strtok) 해서 첫 번째 단어(명령어)로 분기 처리합니다.
3. 각 명령어는 따로 함수(cat_m(), cd_m() …)로 구현해 두고 호출합니다.
4. exit이 들어오면 루프를 빠져나와 프로그램을 종료합니다.

&ensp;프로그램 실행 방식 (큰 흐름)<br/>
1. 프로그램 시작
* 우리가 만든 쉘 프로그램(hw1.c → ./hw1.out)을 실행하면 시작한다.
* main() 안에서 무한 루프를 돌면서 계속 사용자 입력을 기다린다.
2. 프롬프트 출력 & 입력 대기
* 화면에 HW1 > 같은 프롬프트가 뜬다.
* 사용자가 cat_m abc 같은 명령어를 입력한다..
3. 입력 파싱 (문자열 분리)
* fgets() 등으로 입력받은 문자열을 공백 단위로 잘라서(strtok) → [명령어][인자1][인자2] ... 형태로 분리한다..
4. 명령어 판별
* if-else 또는 switch 문으로 첫 번째 단어가 뭔지 확인한다.
    - cat_m → cat 함수 실행
    - cd_m → cd 함수 실행
    - ls_m -l → ls 함수 실행
    - exit → 종료
    - 그 외 → "잘못된 명령어" 출력
5. 프로세스 생성 (fork)
* 명령어 실행이 필요할 때는 보통 자식 프로세스를 만듭니다.
* pid = fork();
    - pid == 0 → 자식 프로세스 (명령어 실행 담당)
    - pid > 0 → 부모 프로세스 (프롬프트 유지)
6. 자식 프로세스 실행 (execvp)
* 자식 프로세스는 execvp()를 호출해서 실제 명령어(cat_m, ls_m, ./a.out 등)를 실행한다.
* execvp가 호출되면 자식 프로세스의 메모리는 새로운 프로그램으로 덮어씌운다.
7. 부모 프로세스 대기 (wait)
* 부모 프로세스는 wait()로 자식이 끝날 때까지 기다린다.
* 자식이 종료되면 종료 상태를 확인한다. (정상 종료인지 오류인지)
8. 결과 출력
* 실행된 명령어의 결과(파일 내용, 디렉토리 목록, 복사 성공 여부 등)가 화면에 출력된다.
9. 루프 반복
* 다시 프롬프트(HW1 > )를 띄우고 새로운 입력을 기다린다.
* 사용자가 exit을 입력하면 루프를 탈출하고 프로그램을 종료한다.

&ensp;실행 과정 요약<br/>
```scss
[시작]
   ↓
[프롬프트 출력 → 입력 받기]
   ↓
[명령어 분리]
   ↓
[명령어 판별]
   ↓
 ┌───────────────┐
 │ exit ?        │─── Yes ─→ [프로그램 종료]
 └───────────────┘
   ↓ (No)
[fork() 호출 → 자식 프로세스 생성]
   ↓
[자식 → execvp() 실행 → 실제 명령어 실행]
   ↓
[부모 → wait()로 자식 종료 기다림]
   ↓
[결과 출력 후 루프 반복]
```


&ensp;추가로 사용되는 시스템 콜<br/>
1. fork()
* 새로운 프로세스(자식 프로세스)를 생성
* 쉘은 새로운 명령어 실행할 때 항상 자식 프로세스를 만든다.
* 부모는 계속 루프를 돌면서 프롬프트를 띄워야 하기 때문에 실행은 자식이 담당하게 하는 구조이다.
2. execvp()
* 자식 프로세스에서 실제 명령어(cat, ls, vi, ./a.out 등)를 실행시킬 때 사용
* execvp는 현재 프로세스 메모리를 새로운 프로그램으로 교체하기 때문에, 보통 fork() 뒤에 바로 사용한다.
3. wait() 또는 waitpid()
* 부모 프로세스가 자식이 끝날 때까지 기다리도록 하는 시스템 콜
* 안 쓰면 좀비 프로세스가 생길 수 있다.
* 즉, 부모는 wait()로 자식 종료를 확인한다.
4. exit()
* 프로세스 종료
* 자식 프로세스가 자기 할 일을 다 하면 exit(0) 같은 식으로 종료한다.
* 부모 프로세스도 쉘 자체를 끝낼 때 exit(0)을 호출한다.

&ensp;핵심 정리
* 쉘 프로그램은 기본적으로 (입력 → 파싱 → fork → exec → wait → 출력 → 반복) 구조로 실행된다.
* fork & execvp는 새로운 명령어 실행을 위해 필요하고,
* wait는 좀비 프로세스 방지 및 결과 확인을 위해 필요하고,
* exit는 프로그램 종료를 위해 필요하다.