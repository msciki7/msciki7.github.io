---
title: "Lect7. 프로세스 생성과 실행"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-09-22
last_modified_at: 2025-09-22
---


Process의 생성
=====

fork()
-----

* **프로그램(레시피)**을 실행하면 **프로세스(요리사)**가 생긴다.
* fork()는 요리사를 복제해서 같은 지점부터 두 사람이 동시에 요리를 계속하게 만드는 버튼이다.

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

* 한 번 호출 → 두 번 돌아감.
    - 부모 프로세스에서도 리턴하고 자식 프로세스에서도 리턴한다.
* 리턴값으로 누가 누군지 구분
    - 부모에게는 자식의 PID(>0)가 돌아옴
    - 자식에게는 0이 돌아옴
    - 실패하면 부모에게만 -1(자식은 생기지 않음)
* 메모리는 복사된 것처럼 보이지만 실제로는 copy-on-write라서 바꾸기 전까지는 같은 걸 공유처럼 쓰고 바꾸는 순간에 필요한 페이지만 복사됨
* 파일 디스크립터(fd)는 공유된 열린 파일 상태를 가리킴 → 파일 오프셋과 플래그가 공유돼서 부모·자식이 같은 파일을 이어서 읽고 쓸 수 있다.

&ensp;부모/자식 차이와 실패<br/>
* PID/PPID가 다르다.
    - 자식의 getppid()는 부모의 PID
    - 부모의 getpid()와 자식의 getpid()는 당연히 서로 다름
* 리턴값으로 분기하기

```c
pid_t pid = fork();
if (pid == 0) { /* child */ }
else if (pid > 0) { /* parent, child's pid = pid */ }
else { /* fork 실패 */ }
```

* 실패(-1) 원인 예
    - 시스템 전체 프로세스 수 한도 초과
    - 현재 프로세스가 만들 수 있는 한도 초과(리소스 부족 등)

<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-1.png" width="600"></p>

* printf("open\n");은 fork 이전이므로 한 번만 출력(단 버퍼 주의)
* fork()이후에는 부모/자식이 모두 printf("two\n");를 실행 → two가 두 번 출력
* 순서는 보장되지 않음: 스케줄링에 따라
    - one\ntwo\ntwo\n 혹은
    - one\ntwo\ntwo\n (겉보기엔 같지만 실제로 어느 프로세스가 먼저 찍을지는 랜덤)
    - 아주 가끔 two\none\ntwo\n 같은 꼬임을 보기도 하는데, 일반적으로 one은 fork 전에 출력되니 먼저 보임

&ensp;버퍼링 주의<br/>
* 표준출력(stdout)이 터미널이면 줄 단위 버퍼링이라 \n이 있으면 바로 비움 → one은 한 번
* 만약 \n이 없거나 파일로 리타이렉션하면 버퍼가 비워지지 않은 채로 fork되어 부모·자식이 둘 다 같은 버퍼를 flush → one이 두 번 나올 수도 있음 → 해결: fflush(stdout); 후 fork()

&ensp;예제<br/>
```c
int main(void){
    pid_t pid;

    printf("Calling fork ...\n");
    pid = fork();

    if (pid == 0) {
        printf("I am the child\n");
    } else if (pid > 0) {
        printf("I am the parent, child has pid %d\n", pid);
    } else {
        printf("Fork returned error code\n");
    }
    return 0;
}
```

&ensp;어떻게 출력될까?<br/>
* 자식: I am the child
* 부모: I am the parent, child has pid 12345(숫자는 실제 자식 PID)
* 순서는 랜덤: 보통은 부모/자식 중 누가 먼저 찍을지 모름

&ensp;예<br/>
```css
Calling fork ...
I am the parent, child has pid 12345
I am the child
```

&ensp;또는<br/>
```css
Calling fork ...
I am the child
I am the parent, child has pid 12345
```

&ensp;plus) printf가 두 번 찍히는 함정<br/>
&ensp;printf("Calling fork...\n"); 처럼 개행이 있으면 버퍼가 비워져서 한 번만<br/>
&ensp;개행이 없었다면 fork() 후 부모·자식이 같은 버퍼를 각각 flush해서 두 번 찍힐 수 있다.<br/>

&ensp;정리<br/>
1. fork() 후 프로세스는 몇 개?
* 한 번 성공하면 2개(부모, 자식)
* 두 번 연속 호출되면 최대 4개 일반화하면 fork()가 k번 실행되면 최대 2^k개
2. 자식에서 getppid()는 누구?
* 현재 자식을 만든 부모의 PID (부모가 먼저 종료되면 init/systemd가 부모가 되기도)
3. 파일 읽기/쓰기 동작은?
* 부모·자식이 같은 열린 파일 상태를 공유(오프셋 공유) → 부모가 100바이트 읽고 나면, 자식이 같은 fd로 읽으면 그 다음 위치에서 읽힘
4. fork() 뒤 보통 뭘 하게?
* 자식에서 exec*()로 새 프로그램 실행
* 부모는 wait()/waitpid()로 자식 종료 기다림(좀비 방지)

&ensp;fork(): 파일과 자료<br/>
* fork() → 새로운 프로세스(child process)를 만드는 시스템 콜
* child process는 parent process의 복제본
    - 모든 변수 값이 그대로 복사된다.
    - 단 fork이후에 parent가 변수 값을 바꿔도 child에게는 영향이 없다.(서로 독립됨)
* 파일 디스크립터(file descriptor)도 복사된다.
    - 즉 parent가 열어둔 파일은 child도 같이 open 상태를 가진다.
    - 그래서 parent와 child가 같은 파일을 동시에 쓸 수도 있음

&ensp;정리: fork()는 부모 프로세스의 복제본(변수 + 파일 디스크립터)을 만들어 새로운 프로세스를 실행한다.<br/>    

exit 시스템 호출
-----

&ensp;사용법<br/>
```c
#include <stdlib.h>
void exit(int status);
```

* 역할: 
    - 프로세스를 정상 종료
    - 종료 전에 열려 있는 파일 닫기(close)
    - clean-up action 
* status → 종료 코드(0: 정상 종료, 0이 아니면 에러 종료)
* 프로세스가 끝난 후 종료 코드는 **$?*** 로 확인 가능

```bash
$ ./a.out
$ echo $?
```

&ensp;정리: exit는 프로세스를 끝내고 열려 있던 리소스를 정리(clean-up)한 뒤 종료 코드를 남긴다.<br/>

* clean-up-action 지정 가능 → atexit() 함수 사용

```c
#include <stdlib.h>

int atexit(void (*func)(void));
```

* 동작
    - 프로그램 종료 시 등록된 함수들을 실행한다.
    - 여러 개 등록했다면 역순으로 실행된다.

&ensp;정리: atexit()을 이용하면 프로그램이 종료될 때까지 자동으로 실행할 작업을 미리 등록할 수 있다.<br/>

&ensp;요약<br/>
* fork() → 부모 프로세스 복제, 파일도 공유
* exit() → 프로세스 종료 + 리소스 정리
* atexit() → 종료 시 실행할 함수 등록

exec로 새 프로그램 수행
=====

&ensp;exec가 하는 일<br/>
* 현재 프로세스의 메모리 내용을 통째로 지우고 다른 프로그램의 코드/데이터로 갈아낀다.
* pID는 그래로 유지되고 성공하면 return이 없다.(실패할 때만 -1 반환)

&ensp;그래서 exec 다음 줄의 코드는 성공하면 절대 실행되지 않음

&ensp;함수 종류<br/>
&ensp;`#include <unistd.h>`<br/>

<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-2.png" width="600"></p>

&ensp;확장형도 있음<br/>
* execle(path, ..., (char*)0, char *const envp[]) : environment(환경변수 배열)까지 직접 전달
* execve(path, argv, envp): 시스템콜 원형(리눅스 커널 진입점)

&ensp;인자 규칙(중요)<br/>
* arg0는 관례적으로 프로그램 이름(보통 argv[0]에 들어갈 문자열).<br/>
&ensp;예) execl("/bin/ls", "ls", "-l", (char*)0);<br/>
* 마지막 인자는 반드시 NULL 포인터로 끝내기<br/>
&ensp;(나열형 l은 (char*)0, 배열형 v는 argv[last]=NULL)<br/>
* path vs file
    - path: /bin/ls 같은 경로나 ./myprog처럼 경로를 직접 적는다.
    - file: 단순 이름만 적고 PATH 검색(execlp/execvp)으로 찾아 실행
        + echo $PATH에 있는 디렉터리들에서 순서대로 탐색

&ensp;execl("bin/ls", ...)처럼 앞에 /가 없으면 상대경로가 되므로 의도와 다를 수 있다. 일반적으로 절대경로 "/bin/ls" 또는 execlp("ls", ...)를 사용한다.<br/>

&ensp;공통 동작<br/>
* 호출 프로세스의 가상 메모리 공간을 새 프로그램으로 덮어씀(텍스트/데이터/힙/스택/전부 교체)
* 호출하던 코드(기존 프로그램)는 더 이상 존재하지 않음
* 새 프로그램은 처음부터 시작(즉 그 프로그램의 main부터 실행)
* PID는 유지(기존 프로세스의 껍데기를 그대로 쓰되 내용만 교체)
* 성공 시 return 없음, 실패 시 -1 (예: 파일 없음, 실행 권한 없음, 인자 규칙 위반 등)

&ensp;fork와의 차이: fork는 부모와 자식이 병렬로 달라지만 exec는 현재 프로세스를 다른 프로그램으로 바꿔치기하므로 병렬이 아님<br/>

&ensp;무엇이 그대로 남고 무엇이 리셋될까?<br/>
* 그래로 남는 것(대표적인 것들)
    - PID, 현재 작업 디렉터리, 리소스 제한(ulimit), umask, 환경변수(env)(단 ececle/execve로 바꾸면 변경 가능)
    - 열려 있던 파일 디스크립터(기본값) → 단, FD_CLOEXEC(close-on-exec) 플래그가 설정된 FD는 닫힘
        + 누수 방지: open에 O_CLOEXEC 쓰거나 fcntl(fd, F_SETFD, FD_CLOEXEC);
* 리셋/변경되는 것(대표적인 것들)
    - 코드/데이터/힙/스택(완전 교체), atexit으로 등록한 clean-up함수들(더 이상 실행 안 됨)
    - 대부분의 시그널 핸들러는 기본 동작으로 재설정(무시로 설정된 건 유지)

&ensp;가장 흔한 사용 패턴: fork + exec<br/>
&ensp;쉘이 명령을 실행할 때 하는 전형적 흐름:<br/>
```c
pid_t pid = fork();
if (pid == 0) {                // child
    execlp("ls", "ls", "-l", (char*)0);
    perror("exec failed");     // 여기까지 왔다는 건 실패했다는 뜻
    _exit(127);                // 표준: exec 실패 시 127로 종료
} else if (pid > 0) {          // parent
    int status;
    waitpid(pid, &status, 0);  // 자식 종료 대기
} else {
    perror("fork failed");
}
```

* 왜 _exit()? → 버퍼가 중복 플러시되는 문제를 피하려고(특히 fork 후 stdio 버퍼 상태 공유 이슈)
* 성공했다면 execlp 다음 줄은 절대 실행되지 않음

&ensp;빠르게 쓰는 예시 레시피<br/>

&ensp;(1) 경로를 직접 아는 경우<br/>
```c
execl("/bin/ls", "ls", "-l", (char*)0);   // l: 가변 인자 나열
// 또는
char *argv[] = {"ls", "-l", NULL};
execv("/bin/ls", argv);                   // v: 배열 전달
```

&ensp;(2) PATH에서 찾아 실행하고 싶을 때<br/>
```c
execlp("python3", "python3", "script.py", (char*)0);  // PATH 검색
// 또는
char *argv[] = {"python3", "script.py", NULL};
execvp("python3", argv);
```

&ensp;(3) 환경변수까지 바꿔서 실행하고 싶을 때<br/>
```c
char *argv[] = {"env", NULL};
char *envp[] = {"HELLO=WORLD", "LANG=C", NULL};
execve("/usr/bin/env", argv, envp);   // 환경을 완전히 교체
```

exec와 fork를 함께 사용
======

```c
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    pid_t pid;
    switch (pid = fork()) {
    case -1:                      // ① fork 실패 (부모에서만 발생)
        perror("fork failed");
        exit(1);

    case 0:                       // ② child 경로
        execl("/bin/ls", "ls", "-l", (char*)0);   // 성공 시 return 없음
        perror("exec failed");    // ③ exec 실패했을 때만 도달
        _exit(127);               // 관례적으로 127 (exit 말고 _exit 권장)
                                  // (stdio 버퍼 중복 플러시 방지)
    default:                      // ④ parent 경로 (pid>0, 자식 PID 반환)
        wait((int*)0);            // ⑤ 임의의 한 자식 종료 대기 (옛 스타일)
        printf("ls completed\n"); // ⑥ 자식이 끝난 뒤 출력
        exit(0);
    }
}
```

&ensp;포인터<br/>
* case -1: 자식 자체가 만들어지지 않았으니 부모가 에러 처리하고 종료.
* case 0 (child):
    - execl("/bin/ls", "ls", "-l", NULL); 실행 → 성공하면 그 다음 줄로 절대 오지 않음.
    - 실패하면 perror 찍고 _exit(127)로 깔끔 종료.
* default (parent):
    - wait((int*)0)는 아무 자식 한 명이 끝날 때까지 블록.
    - 자식이 끝나면 "ls completed" 출력.

&ensp;실무에서는 wait((int*)0) 대신 아래처럼 정확한 자식을 기다리고 상태를 해석한다.:<br/>

```c
int status;
waitpid(pid, &status, 0);
if (WIFEXITED(status)) {
    int code = WEXITSTATUS(status);   // 자식의 exit 코드
}
```

&ensp;PC가 어떻게 움직이나<br/>
<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-3.png" width="600"></p>

&ensp;fork 전<br/>
* (하나의 프로세스) pid = fork(); 위치에서 실행 중. PC는 fork 호출 지점

&ensp;fork 후<br/>
* 부모와 자식 두 복제본이 생성되고, 둘 다 같은 다음 줄에서 실행을 재개하지만
    - 부모는 switch (pid > 0 ) → default 분기로 가서 wait(...)
    - 자식은 switch (pid==0) → case 0으로 가서 execl(...)

&ensp;exec 호출되면<br/>
* 자식의 가상 메모리(코드/데이터/힙/스택)가 /bin/ls의 내용으로 교체된다.
* 자식의 PC는 ls 프로그램의 시작점으로 이동
* ls가 화면에 파일 목록을 출력

&ensp;자식 종료 → 부모의 wait 반환<br/>
<p align="center"><img src="/assets/img/Linux Programming/Lect7/7-4.png" width="600"></p>

* ls가 exit(...)로 끝나면 커널이 부모에게 SIGCGHLD 를 보내고 wait(...)가 리턴
* 그제서야 부모가 "ls completed\n" 을 출력

&ensp;그래서 화면에서는 출력<br/>
1. ls 결과가 먼저 주르륵 출력되고
2. 마지막에 ls completed가 찍혀. (부모가 자식 종료를 기다렸기 때문)

프로세스의 동기화
======

&ensp;wait<br/>
```c
#include <sys/wait.h>
#include <sys/types.h>

pid_t wait(int *status);          // 아무 자식 1명
pid_t waitpid(pid_t pid, int *status, int options);  // 특정 자식/옵션
```

* 반환값: 종료한 자식의 PID, 자식이 없으면 -1(errno=ECHILD)
* status 포인터로 종료 상태 전달:
    - WIFEXITED(status): 정상 종료?
    - WEXITSTATUS(status): exit(code)의 code
    - WIFSIGNALED(status): 시그널로 죽었나?
    - WTERMSIG(status): 그 시그널 번호
* 왜 wait가 필요?
    - 자식이 끝나면 테이블 엔트리를 남긴 좀비(zombie)상태가 됨. 부모가 wiat*()로 수거(reap)해야 리소스가 완전히 회수됨
* 여러 자식을 만들었다면
    - while ((wp = wait(&st)) > 0) { ... } 식으로 모두 수거하거나
    - waitpid(특정pid, ...)로 원하는 자식만 차례로 기다림

&ensp;버그·실수 방지 체크리스트<br/>
1. exec 성공 후 코드를 실행할 거라고 착각 → 성공하면 절대 return 없음
2. 자식에서 exit() 사용 → 가급적 _exit()로 (버퍼 이중 플러시, atexit 훅 실행 방지)
3. wait 안 해서 좀비 발생 → 부모는 반드시 wait*() 호출
4. 경로 문제 → 절대경로 사용("/bin/ls") 또는 execlp/execvp로 PATH 검색
5. 마지막 인자 NULL 누락 → execl(..., (char*)0); / argv[last]=NULL;
6. 원하지 않는 FD 전파 → O_CLOEXEC or FD_CLOEXEC로 닫히게 설정

```c
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    pid_t pid;
    int status, exit_status;

    pid = fork();
    if (pid < 0) {                    // fork 실패(부모만 도달)
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) {                   // child
        sleep(4);                     // 4초 뒤
        _exit(5);                     // 종료코드 5로 종료(권장: _exit)
    }

    // parent
    if ((pid = wait(&status)) == -1) { // 아무 자식 한 명 끝날 때까지 대기
        perror("wait failed");
        exit(2);
    }

    if (WIFEXITED(status)) {          // 정상 종료?
        exit_status = WEXITSTATUS(status);  // 자식의 exit 코드
        printf("Exit status from %d was %d\n", pid, exit_status);
    }
    return 0;
}
```

* child: 4초 잠들었다가 종료 코드 5로 끝남
* parent: wait(&status)에서 블록 → 자식이 끝나면 깨어남
* WIFEXITED(status)가 참이면 정상 종료, WEXITSTATUS(status)로 5를 얻음

&ensp;왜 _exit(5)?: fork 직후 자식에서 표준입출력 버퍼 중복 플러시를 피하기 위해 권장된다.(여기선 큰 차이 없지만 습관 들이기)<br/>

&ensp;status 비트 해석<br/>
&ensp;커널은 자식의 종료 정보를 status에 비트로 인코딩해 준다. POSIX에선 반드시 매크로로 해석해야 한다.(직접 비트 연산은 비이식적)<br/>

* WIFEXITED(status)
    - 정상 종료인지 확인. (내부적으로는 “하위 8비트가 0인지” 등으로 판별)
* WEXITSTATUS(status)
    - 자식이 exit(code) 또는 _exit(code)로 넘긴 code(0~255) 반환.
    - 보통 상위 8비트 영역에서 꺼내온다고 생각해도 됨(플랫폼마다 다를 수 있어 매크로로만 접근!).

&ensp;추가로 알아두면 좋은 것들:<br/>
* WIFSIGNALED(status) → 시그널 때문에 죽었나?
    - WTERMSIG(status) → 그 시그널 번호(예: 9=SIGKILL)
* WCOREDUMP(status) → 코어 덤프 생성 여부(플랫폼 의존)

&ensp;wait vs waitpid<br/>
```c
pid_t wait(int *status);                         // 임의의 자식 1명 대기
pid_t waitpid(pid_t pid, int *status, int options);
```

&ensp;waitpid의 pid 인자 의미<br/>
* pid > 0 : 그 PID의 자식만 기다림
* pid == -1: 임의의 자식(= wait와 동일)
* pid == 0: 호출한 프로세스와 같은 그룹의 임의 자식
* pid < -1: 프로세스 그룹 ID가 -pid인 자식들 중 임의

&ensp;options 자주 쓰는 값<br/>
* 0: 기본(블록)
* WNOHANG: 논블록. 자식이 아직 안 끝났으면 즉시 0 반환
* (참고) WUNTRACED, WCONTINUED 등도 있음

&ensp;폴링/좀비 수거 패턴<br/>
```c
int status;
pid_t r = waitpid(child_pid, &status, WNOHANG);
if (r == 0) {
    // 아직 안 끝남 → 다른 일 하다가 나중에 다시 확인
} else if (r > 0) {
    // status 해석 (WIFEXITED/WIFSIGNALED 등)
} else {
    // -1: 에러 (errno 확인)
}
```

&ensp;왜 wait가 필요? 자식은 종료 후 좀비(zombie) 로 남아 PID/종료정보를 보관한다 부모가 wait*()로 수거(reap) 해야 커널 리소스가 완전히 해제된다.<br/>

&ensp;상황별 예시로 이해하기<br/>

&ensp;1. 정상 종료<br/>
```c
// child
_exit(42);

// parent
wait(&st);
WIFEXITED(st) == true
WEXITSTATUS(st) == 42
```

&ensp;2. 시그널로 종료<br/>
```c
// child
raise(SIGSEGV);

// parent
wait(&st);
WIFEXITED(st) == false
WIFSIGNALED(st) == true
WTERMSIG(st) == SIGSEGV
```

&ensp;3. 여러 자식 수거<br/>
```c
int st;
pid_t wp;
while ((wp = wait(&st)) > 0) {
    // 자식 하나 수거
}
if (wp == -1 && errno == ECHILD) {
    // 더 이상 자식 없음
}
```