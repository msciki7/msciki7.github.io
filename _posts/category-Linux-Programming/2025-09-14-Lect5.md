---
title: "Lect5. 시스템 정보"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true
Sdate: 2025-09-14
last_modified_at: 2025-09-14
---

uid, gid 검색(getuid, gateuid, getgid, getegid)
=====

&ensp;비유<br/>
* uid(user id) = 주민등록번호처럼 "진짜 나"
* euid(effective uid) = 도서관 열쇠를 임시로 빌려 받은 신분증. 문을 열 권한만 잠깐 빌린 느낌
* gid/egid는 위의 그룹 버전

&ensp;파일 만든 사람은 uid, 실행할 때 실제 적용되는 권한은 euid이다.<br/>


&ensp;uid 검색<br/>
```c
#include<unistd.h>
#include<sys/types.h>

uid_t getuid(void);
uid_t geteuid(void);
```

&ensp;guid 검색<br/>
```c
#include<unistd.h>
#include<sys/types.h>

gid_t getgid(void);
gid_t getegid(void);
```

&ensp;사용하는 곳<br/>
* getuid() / getgid(): “진짜 나/우리 그룹이 누구지?” 확인.
* geteuid() / getegid(): “지금 권한은 누구 걸 쓰고 있지?” 확인. setuid 프로그램처럼 권한을 빌린 경우에 특히 중요.

&ensp;access(path, amode)는 euid가 아니라 uid 기준으로 접근 가능 여부를 체크한다. 그래서 권한을 빌린(euid) 상태인지와는 별개로 "진짜 나" 기준으로 된느지 확인할 때 쓴다.(리턴 0이면 가능, -1이면 불가)<br/>

directory tree의 "산책"
=====

ftw
-----

&ensp;ftw(File Tree Walk): 어떤 폴더(path)에서 시작해서 그 안의 모든 하위 폴더/파일을 쭉 돌며 우리가 적어 준 콜백 함수(func) 를 하나씩 호출해준다.<br/>

&ensp;ftw<br/>
```c
#include <ftw.h>

int ftw(const char *path, int(*func)(), int depth); 
```

* path: 시작 폴더.
* func: 항목을 만날 때마다 호출되는 함수.
* depth: 내부에서 동시에 열어둘 수 있는 파일 디스크립터 최대 개수(너무 작으면 깊은 트리에서 실패 가능). → "산책 인원 제한" 느낌.

&ensp;콜백 함수(다른 함수가 필요할 때 자동으로 불러주는 내 함수) 모양<br/>
```c
int func(const char *name, const struct stat *sptr, int type)
```

* name: 지금 만난 대상 경로 이름.
* sptr: 그 대상의 stat 정보(크기, 권한 등).
* type: 대상 종류를 숫자로 알려줘서 분기처리 쉽게 함. 슬라이드의 표기:
    - FTW_F : 일반 파일
    - FTW_D : 디렉터리
    - FTW_DNR: 읽을 수 없는 디렉터리(권한 없음 등)
    - FTW_NS : stat 정보를 못 얻음(Not Stat)

&ensp;콜백이 0이 아닌 값을 리턴하면 ftw는 중단한다. 즉 찾았다 멈취 같은 조기 종료가 가능하다.<br/>

&ensp;쓰는 이유<br/>
* 이 폴더에 파일이 몇 개?, 확장자.txt만 골라서 뭐 하기, 총 용량 계산 같은 걸 재귀 코드를 직접 안 짜고 깔끔히 처리

&ensp;실제 예시 코드<br/>
```c
#include <ftw.h>
#include <stdio.h>
#include <sys/stat.h>

int print_file(const char *name, const struct stat *st, int type) {
    if (type == FTW_F) {
        printf("파일 발견: %s (크기 %ld)\n", name, st->st_size);
    }
    return 0; // 계속 탐색
}

int main() {
    ftw(".", print_file, 10); // 현재 폴더(.)에서 시작
    return 0;
}
```

&ensp;요약<br/>
* uid vs euid 차이 정확히: “진짜 신분(UID)” vs “실행 권한(EUID)”. 슬라이드 문장 그대로 기억!
* access()는 uid 기준 체크(0/ -1). 헷갈리기 쉬움
* ftw는 "디렉터리 전체 순회 + 콜백". type 값으로 분기, depth는 동시에 열 수 있는 파일 수 제한(너무 작게 주면 에러 날 수 있음)
* 콜백이 0이 아니면 중단 가능한 구조

실습
=====

&ensp;1. Current working directory와 그의 descendent directory들 중 비어있는 디렉토리의 이름을 출력하는 프로그램을 작성하시오.<br/>

```c
int list(/* 함수 인자 */) {
  int cnt;
  struct dirent *d;
  DIR *dp;

  if (/* name의 객체가 directory 인지 확인 */){
    // 해당 directory가 비어있는지 확인하고 비어있는 경우에만
    // directory 이름 출력
 }

 return 0;
}

int main(void) {
  // ftw 호출
  return 0;
}
```

```c
#define _XOPEN_SOURCE 500
#include "common.h"
#include <dirent.h>
#include <sys/stat.h>
#include <ftw.h>

int list(const char *name, const struct stat *status, int type) {
    int cnt = 0;
    struct dirent *d;
    DIR *dp;

    if (type == FTW_D) {   // 디렉토리일 때만
        dp = opendir(name);  //디렉토리 열기
        if (dp == NULL) return 0;

        //디렉토리 안에 항목이 몇 개 있는지 센다.
        while (d = readdir(dp)) {
            cnt++;
        }
        closedir(dp);

        //디렉토리 안에는 항상 ".", ".." 두 개가 기본으로 있음
        //따라서 항목이 2개뿐이면 "빈 디렉토리"
        if (cnt <= 2) {   // '.' , '..' 만 있으면
            printf("empty directory : %s\n", name);
        }
    }
    return 0;
}

int main(void) {
    ftw(".", list, 1);   // 현재 디렉토리부터 탐색
    return 0;
}
```

* ftw(".", list, 1);<br/>
&ensp;현재 디렉토리부터 시작해서 모든 하위 디렉토리를 탐색. 뭔가 찾으면 list 함수를 호출해줌.<br/>

* if (type == FTW_D)<br/>
&ensp;지금 보고 있는 게 디렉토리일 때만 검사.<br/>

* opendir() + readdir()
&ensp;디렉토리 내부를 열어서 안에 뭐가 있는지 확인.<br/>
&ensp;항상 있는 "."과 ".."만 있으면 빈 디렉토리라고 출력.<br/>

&ensp;실행 예시<br/>
```bash
empty directory : ./LAB09-17-01/empty1
```

&ensp;동작 그림<br/>
&ensp;예시 디렉토리 구조:<br/>
```csharp
LAB09-17-01/
 ├── empty1/       ← 비어 있음
 ├── not_empty/    ← 파일 있음
 ├── test1         ← 일반 파일
 └── ftw_empty.out ← 실행 파일
```

&ensp;탐색 과정:<br/>
* empty1/ → 안에 아무것도 없음 → 출력됨
* not_empty/ → 파일 있음 → 출력 안 됨
* 파일들은 검사 대상 아님

&ensp;출력 결과<br/>
```bash
empty directory : ./LAB09-17-01/empty1
```