---
title: "Lect5. 시스템 정보"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true
Sdate: 2025-09-14
last_modified_at: 2025-09-14
---

uid, gid 검색(getuid, gateuid, getgid, getegid)
=====

&ensp;비유<br/>
* uid(user id) = 주민등록번호처럼 "진짜 나"
* euid(effective uid) = 도서관 열쇠를 임시로 빌려 받은 신분증. 문을 열 권한만 잠깐 빌린 느낌
* gid/egid는 위의 그룹 버전

&ensp;파일 만든 사람은 uid, 실행할 때 실제 적용되는 권한은 euid이다.<br/>


&ensp;uid 검색<br/>
```c
#include<unistd.h>
#include<sys/types.h>

uid_t getuid(void);
uid_t geteuid(void);
```

&ensp;guid 검색<br/>
```c
#include<unistd.h>
#include<sys/types.h>

gid_t getgid(void);
gid_t getegid(void);
```

&ensp;사용하는 곳<br/>
* getuid() / getgid(): “진짜 나/우리 그룹이 누구지?” 확인.
* geteuid() / getegid(): “지금 권한은 누구 걸 쓰고 있지?” 확인. setuid 프로그램처럼 권한을 빌린 경우에 특히 중요.

&ensp;access(path, amode)는 euid가 아니라 uid 기준으로 접근 가능 여부를 체크한다. 그래서 권한을 빌린(euid) 상태인지와는 별개로 "진짜 나" 기준으로 된느지 확인할 때 쓴다.(리턴 0이면 가능, -1이면 불가)<br/>

directory tree의 "산책"
=====

ftw
-----

&ensp;ftw(File Tree Walk): 어떤 폴더(path)에서 시작해서 그 안의 모든 하위 폴더/파일을 쭉 돌며 우리가 적어 준 콜백 함수(func) 를 하나씩 호출해준다.<br/>

&ensp;ftw<br/>
```c
#include <ftw.h>

int ftw(const char *path, int(*func)(), int depth); 
```

* path: 시작 폴더.
* func: 항목을 만날 때마다 호출되는 함수.
* depth: 내부에서 동시에 열어둘 수 있는 파일 디스크립터 최대 개수(너무 작으면 깊은 트리에서 실패 가능). → "산책 인원 제한" 느낌.

&ensp;콜백 함수(다른 함수가 필요할 때 자동으로 불러주는 내 함수) 모양<br/>
```c
int func(const char *name, const struct stat *sptr, int type)
```

* name: 지금 만난 대상 경로 이름.
* sptr: 그 대상의 stat 정보(크기, 권한 등).
* type: 대상 종류를 숫자로 알려줘서 분기처리 쉽게 함. 슬라이드의 표기:
    - FTW_F : 일반 파일
    - FTW_D : 디렉터리
    - FTW_DNR: 읽을 수 없는 디렉터리(권한 없음 등)
    - FTW_NS : stat 정보를 못 얻음(Not Stat)

&ensp;콜백이 0이 아닌 값을 리턴하면 ftw는 중단한다. 즉 찾았다 멈취 같은 조기 종료가 가능하다.<br/>

&ensp;쓰는 이유<br/>
* 이 폴더에 파일이 몇 개?, 확장자.txt만 골라서 뭐 하기, 총 용량 계산 같은 걸 재귀 코드를 직접 안 짜고 깔끔히 처리

&ensp;실제 예시 코드<br/>
```c
#include <ftw.h>
#include <stdio.h>
#include <sys/stat.h>

int print_file(const char *name, const struct stat *st, int type) {
    if (type == FTW_F) {
        printf("파일 발견: %s (크기 %ld)\n", name, st->st_size);
    }
    return 0; // 계속 탐색
}

int main() {
    ftw(".", print_file, 10); // 현재 폴더(.)에서 시작
    return 0;
}
```

&ensp;요약<br/>
* uid vs euid 차이 정확히: “진짜 신분(UID)” vs “실행 권한(EUID)”. 슬라이드 문장 그대로 기억!
* access()는 uid 기준 체크(0/ -1). 헷갈리기 쉬움
* ftw는 "디렉터리 전체 순회 + 콜백". type 값으로 분기, depth는 동시에 열 수 있는 파일 수 제한(너무 작게 주면 에러 날 수 있음)
* 콜백이 0이 아니면 중단 가능한 구조