---
title: "Lect6. 프로세스 정보"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true
Sdate: 2025-09-14
last_modified_at: 2025-09-14
---

프로세스
====

&ensp;프로그램(program): 그냥 파일에 저장된 코드 묶음(예: a.out, python.exe)<br/>
&ensp;프로세스(process): 프로그램이 실제로 메모리에 올라가서 실행 중인 것<br/>
* 코드(명령어)
* 변수 값
* 스택(함수 호출 기록, 지역 변수)
* PCB(Process Control Block: 운영체제가 관리하는 프로세스 정보)

&ensp;비유:<br/>
* 프로그램 = 요리책
* 프로세스 = 요리사가 실제로 주방에서 그 요리책을 보고 요리하는 상황

&ensp;프로세스의 계층 구조<br/>
* 부모 프로세스 → 자식 프로세스
    - 새 프로세스는 기존 프로세스가 "fork"해서 만들어냄
* 리눅스의 모든 프로세스는 int(또는 systemd)의 후손

&ensp;비유:<br/>
* init은 “할아버지 프로세스”
* 모든 프로세스는 그 할아버지의 자식, 손자, 증손자 같은 계보를 가짐

&ensp;프로세스 목록 보기<br/>
* 현재 실행 중인 프로세스 목록 확인
```bash
$ ps
```

* 프로세스 종료
```bash
$ kill -9 프로세스번호
```

&ensp;비유:<br/>
* ps = “우리 집안 식구 명단 출력”
* kill = "특정 사람에게 즉시 나가라고 명령"

&ensp;프로세스 식별자 PID<br/>
* PID (Process ID): 프로세스를 구분하는 번호 (음이 아닌 정수)
    - 0번: swapper (커널 프로세스)
    - 1번: init (최초 부모 프로세스)
* 시스템 콜

```c
pid_t getpid(void);   // 내 PID 가져오기
pid_t getppid(void);  // 내 부모 PID 가져오기
```

&ensp;비유<br/>
* PID = 주민등록번호
* getpid() = 내 주민등록번호 보기
* getppid() = 아버지 주민등록번호 보기

Process Identifier (PID) — "사람 주민번호"
=======

* PID: 실행 중인 프로세스를 구별하는 번호표(음이 아닌 정수)
* 특별한 PID: 0(커널 스와퍼), 1(init/systemd)

&ensp;함수<br/>
```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);   // 내 PID
pid_t getppid(void);  // 내 부모 PID
```

&ensp;비유

* 프로그램=요리책, 프로세스=주방에서 실제 요리 중인 요리사.
* getpid()는 "내 주민번호 보기", getppid()는 "아버지 주민번호 보기"

&ensp;초간단 예<br/>
```c
printf("me=%d, parent=%d\n", getpid(), getppid());
```

&ensp;→ 실행할 때마다 me 값은 달라지고, parent는 보통 현재 셸의 PID<br/>

Process Group
=====

* 프로세스 그룹: 여러 프로세스를 하나의 팀으로 묶은 것(팀 번호=PGID).
한 번에 같은 시그널을 보내거나(예: Ctrl-C), 잡 제어(foreground/background)를 하려고 씀.
* 그룹 리더: PGID와 같은 PID를 가진 프로세스.
(보통 팀을 만들 때 리더의 PID로 PGID가 정해짐. 리더가 죽어도 팀은 남을 수 있음.)
* 현실 비유
    - PID=개인 번호, PGID=팀 번호.
    - 셸이 파이프라인 a | b | c 를 실행할 때, 셋을 한 팀으로 묶어 Ctrl-C를 팀 전체에 보내기 쉽게 함.

&ensp;내 팀 번호 확인<br/>
&ensp;함수<br/>
```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpgrp(void);        // 내 PGID
pid_t getpgid(pid_t pid);   // pid의 PGID (pid=0이면 자기 자신)
```

&ensp;예<br/>
```c
printf("pgid(me)=%d, pgid(parent)=%d\n", getpgrp(), getpgid(getppid()));
```

&ensp;팀 배정/팀 만들기<br/>
&ensp;함수<br/>
```c
#include <sys/types.h>
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);
```

* pid 프로세스의 그룹 ID를 pgid로 설정.
* pid==0이면 자기 자신, pgid==0이면 pid의 값을 PGID로 사용(=자신을 리더로 새 팀 만들기).

* 사용하는 곳
    - 보통 fork() 후 자식에서 일찍 호출해 새 그룹을 만들거나(자식 PID=PGID) 부모가 자식을 특정 그룹으로 묶을 때 사용. (잡 제어 구현의 핵심)
* 주의(감만 잡기)
    - 같은 세션 안에서만 가능, 보통 exec() 전에 해야 함(너무 늦으면 EPERM)

&ensp;짧은 흐름 예시 (감 잡기)<br/>
```c
pid_t pid = fork();
if (pid == 0) {               // child
    setpgid(0, 0);            // 자기를 리더로 새 그룹 생성 (PGID=child PID)
    /* exec... */
} else {
    setpgid(pid, pid);        // 부모가 자식의 PGID를 자식 PID로 보장
}
```

&ensp;요약<br/>
* PID: 개인 번호(프로세스 주민번호). getpid(), getppid()
* PGID: 팀 번호(프로세스 그룹). getpgrp(), getpgid(pid)
* 그룹 리더: PID == PGID
* 팀 만들기/배정: setpgid(pid, pgid) (보통 fork 직후)
* 전체 신호 보내기: kill(-PGID, SIG) / Ctrl-C는 foreground 그룹으로

Session
======

&ensp;비유<br/>
* PID = 개인 번호, PGID(프로세스 그룹) = 팀 번호였지?
* **Session(세션)**은 같은 터미널을 공유하며 일하는 팀들(여러 PGID)의 큰 묶음이다.
    - 한 세션에는 보통 foreground 팀 1개와 background 팀 여러 개가 같이 들어있다.
    - 각 프로세스 그룹은 딱 하나의 세션에만 속함.

&ensp;핵심
* 세션 ID(SID)는 "세션의 번호"다.
* 내 프로세스나 다른 프로세스가 어느 세션에 속했는지 알고 싶으면:

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getsid(pid_t pid);   // pid의 세션 ID 반환. pid=0이면 '나 자신'
```

&ensp;실습(터미널에서 눈으로 확인)<br/>
```bash
# 내 셸 프로세스의 pid/pgid/sid/tty를 한 번에 보기
$ ps -o pid,ppid,pgid,sid,tty,cmd -p $$
```

* 같은 TTY(터미널)에서 돌아가는 파이프라인 a|b|c는 보통 PGID가 같고, 그 PGID가 포함된 SID도 동일하다.

&ensp;setsid() : "나만의 새 세션 + 새 팀 만들기"<br/>
&ensp;한 줄 정의<br/>
* setsid()는 제어 터미널이 없는 새 세션을 만들고, 호출한 프로세스를 그 세션의 리더 + 새 프로세스 그룹의 리더로 만든다.

&ensp;→ 결과적으로 SID = PID, PGID = PID가 됨.<br/>
```c
#include <sys/types.h>
#include <unistd.h>
pid_t setsid(void);   // 성공: 새 세션 ID(=호출한 프로세스의 PID), 실패: -1
```

&ensp;주의<br/>
* 현재 "그룹 리더"인 프로세스는 setsid()가 실패(–1) 한다. 왜? “이미 팀 리더면 새 팀/세션을 바로 만들 수 없게” 하는 규칙 때문이다.
* 그래서 보통은 이렇게 한다.:
1. fork()로 자식을 만들고
2. 자식에서 setsid() 호출 (자식은 막 태어나서 그룹 리더가 아닐 가능성이 큼)

&ensp;짧은 예<br/>
```c
pid_t pid = fork();
if (pid == 0) {            // child
    pid_t sid = setsid();  // 새 세션 + 새 그룹, 리더가 됨
    // 여기서부터는 백그라운드 데몬 준비 등...
}
```

&ensp;main() 함수 인자<br/>
&ensp;개념<br/>
* 프로그램을 실행할 때 뒤에 붙이는 단어들(토큰)을 명령줄 인자라고 한다.
* C의 main은 이렇게 받는다:

```c
int main(int argc, char **argv)
```

* argc : 인자 개수(숫자)
* argv : 인자들의 문자열 배열
    - argv[0] : 보통 프로그램 이름
    - argv[1]부터 사용자가 넘긴 말들
    - 마지막은 NULL 포인터로 끝남

```c
int main(int argc, char **argv){
    int i;
    printf("%d\n", argc);  // 인자 개수 출력
    i = 0;
    while(argv[i] != NULL){ // argv[0]부터 NULL 나오기 전까지
        printf("%s\n", argv[i]);
        i++;
    }
    return 0;
}
```

* argv[0]도 찍으니 프로그램 이름까지 모두 줄줄이 출력된다.

&ensp;실행/출력 예시<br/>
```bash
$ ./a.out hello 123
```

&ensp;화면 예상<br/>
```bash
3
./a.out
hello
123
```

&ensp;(인자 3개: ./a.out, hello, 123)<br/>

&ensp;자주 하는 실수<br/>
* argv[argc]는 항상 NULL이니, while(i < argc) 또는 while(argv[i]!=NULL) 둘 중 하나 방식으로 도는 게 안전.
* 공백이 포함된 인자를 넘길 때는 따옴표 사용:

```bash
$ ./a.out "hello world"
```

&ensp;요약<br/>
* Session = 같은 터미널을 쓰는 여러 프로세스 그룹(PGID)의 큰 묶음(SID로 구분).
    - getsid(pid)로 세션 ID 확인.
* setsid() = 새 세션 + 새 그룹 만들고 내가 리더가 됨.
    - 그룹 리더 상태에서는 실패, 보통 fork 후 자식에서 호출.
* 명령줄 인자: argc(개수), argv(문자열 배열).
    - argv[0]은 프로그램 이름, 마지막은 NULL.

실습
======

&ensp;1. Directory 이름을 main 함수의 인자로 받아, 해당 directory와 그의 descendent directory들 안에 저장된 모든 파일과 서브디렉토리들에 대해, 디렉토리와 실행 파일들만 선택하여 그 이름과 크기를 출력하는 프로그램을 작성하시오. 또한, 실행파일 출력 후에, 실행 중인 프로그램의 프로세스 id, 프로세스 그룹 id, session id를 출력한다.<br/> 
&ensp;힌트) S_IXUSR & status->st_mode || S_IXGRP & status->st_mode || S_IXOTH & status->st_mode<br/>
```c
int list(/* 함수 인자 */) {
    if (/* name의 객체가 directory 인지 확인 */){
    printf("%s : %d\n", /* 이름과 크기 출력 */);
    }
    else if (/* name의 객체가 파일 인지 확인 */){
        if (/* name이 실행가능한 파일인지 확인 */)
            printf("%s : %d\n", /* 이름과 크기 출력 */);
 }

 return 0;
}

int main(/* main 함수 인자 */) {
    // 함수의 인자로 주어진 이름의 driectory부터 탐색을 시작하는 ftw 호출
    // 프로세스 id, 프로세스 그룹 id, session id 출력
    return 0;
}
```

&ensp;문제 요구사항<br/>
1. 어떤 디렉토리(폴더)와 그 안의 모든 하위 폴더를 차례로 살펴본다.
2. 그 안에 들어있는 디렉토리는 무조건 출력한다. (이름과 크기)
3. 그 안에 들어있는 파일은, "실행할 수 있는 파일(=프로그램)"일 경우에만 출력한다.
    - 예: a.out, ftw_empty.out 같은 실행파일
    - 실행 권한 없는 일반 텍스트 파일은 출력하지 않는다.
4. 마지막에는 현재 실행 중인 프로그램의 프로세스 정보(PID, PGID, SID)를 출력한다.

```c
#define _XOPEN_SOURCE 500
#include "common.h"
#include <ftw.h>

int list(const char *name, const struct stat *status, int type){
    
    //디렉토리라면 출력
	if(type==FTW_D || type==FTW_DNR){
		printf("%s : %d\n", name, status->st_size);
	}
	else if(type==FTW_F){
		if(S_IXUSR & status->st_mode || S_IXGRP & status->st_mode || S_IXOTH & status -> st_mode){
			printf("%s : %d\n", name, status->st_size);
		}
	}
	
	return 0;
}

int main(int argc, char **argv){

    //인자로 받은 디렉토리부터 탐색
	ftw(argv[1], list, 1);

    //현재 실행 중인 프로세스 정보 출력
	printf("pid=  %d, gid= %d, sid= %d\n", getpid(), getpgid(0), getsid(getpid()));
	
	return 0;
}
```

&ensp;코드의 동작 흐름<br/>
&ensp;1. ftw()함수<br/>
* ftw는 파일 트리 워크(file tree walk)의 줄임말
* 쉽게 말하면 주어진 폴더 안을 자동으로 훑어주는 함수이다.
* 우리가 직접 일일이 cd해서 들어가서 ls를 안 해도 ftw()가 알아서 모든 하위 디렉토리까지 다 들여다본다.
* ftw(탐색시작할 디렉토리, 호출할 함수, 깊이 제한) 이렇게 쓰는데 여기서는 argv[1](즉 실행할 입력한 디렉토리 이름)을 시작점으로 줬다.

&ensp;2. list()함수<br/> 
* ftw가 디렉토리 안의 파일이나 폴더를 발견할 때마다 list라는 함수를 불러준다.
* list함수는 얘가 폴더냐? 파일이냐? 를 판단해서 출력한다.

&ensp;(1) 디렉토리일 경우<br/>
```c
if (type==FTW_D || type==FTW_DNR) {
    printf("%s : %ld\n", name, (long)status->st_size);
}
```

* FTW_D = 디렉토리
* FTW_DNR = 디렉토리지만 읽을 수 없음
* 둘 다 디렉토리니까 이름과 크기를 출력한다.

&ensp;출력 예<br/>
&ensp;`LAB09-17-01 : 4096`<br/>
&ensp;여기서 4096은 폴더 크기(보통 고정값)이다.<br/>

&ensp;(2) 파일일 경우<br/>
```c
else if(type==FTW_F) {
    if(status->st_mode & S_IXUSR || //사용자 실행 권한
       status->st_mode & S_IXGRP || //그룹 실행 권한
       status->st_mode & S_IXOTH) {  //다른 사용자 실행 권한
        printf("%s : %ld\n", name, (long)status->st_size);
    }
}
```

* FTW_F = 파일
* status->st_mode 안에는 이 파일의 속성이 들어 있다.
    - 읽기 가능(읽을 수 있음)
    - 쓰기 가능(편집할 수 있음)
    - 실행 가능(프로그램처럼 실행할 수 있음)
* S_IXUSR, S_IXGRP, S_IXOTH 는 실행 권한을 나타내는 깃발(flag)
    - S_IXUSR → 소유자가 실행 가능?
    - S_IXGRP → 같은 그룹이 실행 가능?
    - S_IXOTH → 다른 사용자도 실행 가능?
* 따라서 이 조건문은 이 파일이 실행 가능한가? 를 검사하는 부분이다.
* 실행 가능한 파일이면 이름과 크기를 출력한다.

&ensp;출력 예<br/>
&ensp;`LAB09-17-01/ftw_empty.out : 8237`<br/>

&ensp;3. 프로세스 정보 출력<br/>
```c
printf("pid=  %d, gid= %d, sid= %d\n", getpid(), getpgid(0), getsid(getpid()));
```

* getpid() → 현재 실행 중인 프로그램의 프로세스 ID (운영체제에서 이 프로그램을 구분하는 번호)
* getpgid(0) → 현재 프로그램이 속한 프로세스 그룹 ID (보통 pid와 같음)
* getsid(getpid()) → 현재 프로그램이 속한 세션 ID

&ensp;마지막에 이 프로그램이 운영체제 안에서 어떤 번호로 실행되고 있는지 보여주는 부분이다.<br/>
&ensp;출력 예<br/>
&ensp;`pid= 31851, gid= 31851, sid= 31207`<br/>

&ensp;실행 예시<br/>
```bash
LAB09-17-01 : 4096
LAB09-17-01/empty1 : 4096
LAB09-17-01/not_empty : 4096
LAB09-17-01/ftw_empty.out : 8237
pid=  31851, gid= 31851, sid= 31207
```

&ensp;비유<br/>
* ftw() = 청소기 로봇 → 집안 구석구석(디렉토리와 파일)을 다 돌아다니면서 뭔가를 발견하면 호출 버튼(list)을 눌러줌.
* list() = 집주인 → 로봇이 "이건 폴더에요!", "이건 파일이에요!" 알려줄 때마다 폴더면 그냥 적어두고 파일이면 "이게 실행 가능한 파일이냐?" 검사해서 맞으면 적어둠.
* 마지막에 프로그램 자기 자신의 번호(pid, gid, sid)를 출력 → "나는 지금 이 집에서 일하고 있는 청소기 번호 31851번이에요!" 라고 말하는 것.

&ensp;동작 그림<br/>
```csharp
LAB09-17-01/
 ├── empty1/         ← 디렉토리
 ├── not_empty/      ← 디렉토리
 ├── test1           ← 일반 파일 (실행 불가)
 └── ftw_empty.out   ← 실행 파일
```

&ensp;탐색 과정:<br/>
* LAB09-17-01/ → 디렉토리 → 출력
* empty1/ → 디렉토리 → 출력
* not_empty/ → 디렉토리 → 출력
* test1 → 일반 파일, 실행 불가 → 출력 안 함
* ftw_empty.out → 실행 파일 → 출력

&ensp;마지막에 프로세스 정보도 출력<br/>
```bash
LAB09-17-01 : 4096
LAB09-17-01/empty1 : 4096
LAB09-17-01/not_empty : 4096
LAB09-17-01/ftw_empty.out : 8237
pid= 31851, gid= 31851, sid= 31207
```

&ensp;1. 구조체(struct)란?<br/>
&ensp;여러 종류의 데이터를 한 덩어리로 묶는 상자이다.<br/>
&ensp;배열은 같은 자료형만 모을 수 있지만 구조체는 다른 자료형도 함께 묶을 수 있다는 점이 다르다.<br/>

&ensp;비유<br/>
&ensp;예: 학생 정보를 저장해야 한다고 해보자<br/>
&ensp;학생마다 필요한 정보:<br/>
* 이름(문자열)
* 나이(정수)
* 키(실수)

&ensp;만약 구조체가 없다면 각각 따로 변수를 만들어야 한다.<br/>
```c
char name[20];
int age;
float height;
```

&ensp;그런데 학생이 30명이면? 변수가 90개...관리가 불가능하다.<br/>
&ensp;구조체를 쓰면 학생을 하나의 묶음으로 정의할 수 있다.<br/>
```c
struct Student {
    char name[20];
    int age;
    float height;
};
```

&ensp;이제 학생 한 명을 이렇게 선언한다.<br/>
```c
struct Student s1 = {"철수", 20, 175.5};
```

&ensp;2. 구조체 사용법<br/>
&ensp;(1) 선언<br/>
```c
struct Student {
    char name[20];
    int age;
    float height;
};
```

&ensp;(2) 변수 생성<br/>
```c
struct Student s1;    // 학생 한 명
```

&ensp;(3)값 사용<br/>
```c
printf("%s, %d살, %.1fcm\n", s1.name, s1.age, s1.height);
```

&ensp;(4) 값 사용<br/>
```c
printf("%s, %d살, %.1fcm\n", s1.name, s1.age, s1.height);
```

&ensp;출력<br/>
```bash
영희, 22살, 163.2cm
```

&ensp;4. 구조체 vs 배열<br/>
* 배열: 같은 자료형만 모음 → 예: int score[5] = {90,85,70,95,100}; 
* 구조체:다른 자료형도 모음 → 예: 이름(문자), 나이(정수), 키(실수)

&ensp;즉<br/>
* 배열 = 물건 박스 안에 같은 물건만 잔뜩
* 구조체 = 한 사람의 신상 정보처럼 여러 가지 자료를 한데 묶음

&ensp;3. 구조체 + 배열, 구조체 + 포인터<br/>
&ensp;구조체 배열<br/>
&ensp;학생 여러 명을 관리하게 싶을 때<br/>
```c
struct Student students[3] = {
    {"철수", 20, 175.5},
    {"영희", 22, 163.2},
    {"민수", 21, 180.1}
};
```

&ensp;구조체 포인터<br/>
```c
struct Student *p = &s1;
printf("%d\n", p->age);  // s1.age와 같음
```

&ensp;→ -> 연산자는 포인터로 구조체 멤버 접근할 때 사용.<br/>

&ensp;정리<br/>
* 구조체는 여러 변수를 묶어서 하나의 자료형처럼 쓸 수 있게 해주는 것
* 현실 세계의 "객체"를 표현하기 좋음 (학생, 책, 자동차 등)
* . 연산자: 구조체 변수 안의 데이터 접근
* -> 연산자: 구조체 포인터 안의 데이터 접근

&ensp;1. struct stat<br/>
```c
int list(const char *name, const struct stat *status, int type)
```

&ensp;여기서 status가 바로 struct stat 구조체이다.<br/>
&ensp;👉 이건 파일(또는 디렉토리)의 속성을 담아두는 상자이다.<br/>
&ensp;안에는 이런 정보들이 들어 있다:<br/>
* st_size → 파일 크기 (바이트 단위)
* st_mode → 파일 권한 (읽기, 쓰기, 실행 가능 여부)
* st_uid → 파일 소유자 ID
* st_gid → 그룹 ID
* st_atime, st_mtime → 마지막 접근/수정 시간

&ensp;📌 우리가 사용한 부분은 st_size(크기)와 st_mode(실행 권한 확인) 였습니다.<br/>
```c
printf("%s : %ld\n", name, (long)status->st_size);
```

&ensp;2. struct dirent<br/>
```c
struct dirent *d;
DIR *dp;

dp = opendir(name);
while (d = readdir(dp)) {
    cnt++;
}
```

&ensp;👉 struct dirent는 디렉토리 안의 항목(파일 이름, 디렉토리 이름 등) 정보를 담는 구조체이다.<br/>

&ensp;대표 멤버:<br/>

* d_name → 항목 이름 (예: "empty1", "test1")
* d_ino → inode 번호 (파일 시스템 내부에서의 고유 번호)

&ensp;📌 우리가 사용한 부분은 d->d_name으로 파일/디렉토리 이름을 확인하는 거다.<br/>
&ensp;예를 들어:<br/>
```c
if (d->d_name[0] == '.' && d->d_name[1] == '\0') // 현재 디렉토리 "."
if (d->d_name[0] == '.' && d->d_name[1] == '.' && d->d_name[2] == '\0') // 부모 디렉토리 ".."
```

&ensp;3. 왜 구조체가 필요한가?<br/>
&ensp;만약 구조체가 없다면<br/>
* 파일 크기는 long size,
* 권한은 int perm,
* 이름은 char name[256],
* 소유자는 int uid ...

&ensp;이렇게 각각 따로 변수를 만들어야 한다. 파일이 많아지면? 변수가 수백 개... 관리 불가!<br/>

&ensp;구조체 덕분에:
```c
struct stat fileInfo;
printf("크기: %ld\n", fileInfo.st_size);
```

&ensp;처럼 한 덩어리(파일 정보)를 깔끔하게 다룰 수 있다.<br/>