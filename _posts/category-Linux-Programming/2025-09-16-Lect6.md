---
title: "Lect6. 프로세스 정보"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true
Sdate: 2025-09-14
last_modified_at: 2025-09-14
---

프로세스
====

&ensp;프로그램(program): 그냥 파일에 저장된 코드 묶음(예: a.out, python.exe)<br/>
&ensp;프로세스(process): 프로그램이 실제로 메모리에 올라가서 실행 중인 것<br/>
* 코드(명령어)
* 변수 값
* 스택(함수 호출 기록, 지역 변수)
* PCB(Process Control Block: 운영체제가 관리하는 프로세스 정보)

&ensp;비유:<br/>
* 프로그램 = 요리책
* 프로세스 = 요리사가 실제로 주방에서 그 요리책을 보고 요리하는 상황

&ensp;프로세스의 계층 구조<br/>
* 부모 프로세스 → 자식 프로세스
    - 새 프로세스는 기존 프로세스가 "fork"해서 만들어냄
* 리눅스의 모든 프로세스는 int(또는 systemd)의 후손

&ensp;비유:<br/>
* init은 “할아버지 프로세스”
* 모든 프로세스는 그 할아버지의 자식, 손자, 증손자 같은 계보를 가짐

&ensp;프로세스 목록 보기<br/>
* 현재 실행 중인 프로세스 목록 확인
```bash
$ ps
```

* 프로세스 종료
```bash
$ kill -9 프로세스번호
```

&ensp;비유:<br/>
* ps = “우리 집안 식구 명단 출력”
* kill = "특정 사람에게 즉시 나가라고 명령"

&ensp;프로세스 식별자 PID<br/>
* PID (Process ID): 프로세스를 구분하는 번호 (음이 아닌 정수)
    - 0번: swapper (커널 프로세스)
    - 1번: init (최초 부모 프로세스)
* 시스템 콜

```c
pid_t getpid(void);   // 내 PID 가져오기
pid_t getppid(void);  // 내 부모 PID 가져오기
```

&ensp;비유<br/>
* PID = 주민등록번호
* getpid() = 내 주민등록번호 보기
* getppid() = 아버지 주민등록번호 보기

Process Identifier (PID) — "사람 주민번호"
=======

* PID: 실행 중인 프로세스를 구별하는 번호표(음이 아닌 정수)
* 특별한 PID: 0(커널 스와퍼), 1(init/systemd)

&ensp;함수<br/>
```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);   // 내 PID
pid_t getppid(void);  // 내 부모 PID
```

&ensp;비유

* 프로그램=요리책, 프로세스=주방에서 실제 요리 중인 요리사.
* getpid()는 "내 주민번호 보기", getppid()는 "아버지 주민번호 보기"

&ensp;초간단 예<br/>
```c
printf("me=%d, parent=%d\n", getpid(), getppid());
```

&ensp;→ 실행할 때마다 me 값은 달라지고, parent는 보통 현재 셸의 PID<br/>

Process Group
=====

* 프로세스 그룹: 여러 프로세스를 하나의 팀으로 묶은 것(팀 번호=PGID).
한 번에 같은 시그널을 보내거나(예: Ctrl-C), 잡 제어(foreground/background)를 하려고 씀.
* 그룹 리더: PGID와 같은 PID를 가진 프로세스.
(보통 팀을 만들 때 리더의 PID로 PGID가 정해짐. 리더가 죽어도 팀은 남을 수 있음.)
* 현실 비유
    - PID=개인 번호, PGID=팀 번호.
    - 셸이 파이프라인 a | b | c 를 실행할 때, 셋을 한 팀으로 묶어 Ctrl-C를 팀 전체에 보내기 쉽게 함.

&ensp;내 팀 번호 확인<br/>
&ensp;함수<br/>
```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpgrp(void);        // 내 PGID
pid_t getpgid(pid_t pid);   // pid의 PGID (pid=0이면 자기 자신)
```

&ensp;예<br/>
```c
printf("pgid(me)=%d, pgid(parent)=%d\n", getpgrp(), getpgid(getppid()));
```

&ensp;팀 배정/팀 만들기<br/>
&ensp;함수<br/>
```c
#include <sys/types.h>
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);
```

* pid 프로세스의 그룹 ID를 pgid로 설정.
* pid==0이면 자기 자신, pgid==0이면 pid의 값을 PGID로 사용(=자신을 리더로 새 팀 만들기).

* 사용하는 곳
    - 보통 fork() 후 자식에서 일찍 호출해 새 그룹을 만들거나(자식 PID=PGID) 부모가 자식을 특정 그룹으로 묶을 때 사용. (잡 제어 구현의 핵심)
* 주의(감만 잡기)
    - 같은 세션 안에서만 가능, 보통 exec() 전에 해야 함(너무 늦으면 EPERM)

&ensp;짧은 흐름 예시 (감 잡기)<br/>
```c
pid_t pid = fork();
if (pid == 0) {               // child
    setpgid(0, 0);            // 자기를 리더로 새 그룹 생성 (PGID=child PID)
    /* exec... */
} else {
    setpgid(pid, pid);        // 부모가 자식의 PGID를 자식 PID로 보장
}
```

&ensp;요약<br/>
* PID: 개인 번호(프로세스 주민번호). getpid(), getppid()
* PGID: 팀 번호(프로세스 그룹). getpgrp(), getpgid(pid)
* 그룹 리더: PID == PGID
* 팀 만들기/배정: setpgid(pid, pgid) (보통 fork 직후)
* 전체 신호 보내기: kill(-PGID, SIG) / Ctrl-C는 foreground 그룹으로

Session
======

&ensp;비유<br/>
* PID = 개인 번호, PGID(프로세스 그룹) = 팀 번호였지?
* **Session(세션)**은 같은 터미널을 공유하며 일하는 팀들(여러 PGID)의 큰 묶음이다.
    - 한 세션에는 보통 foreground 팀 1개와 background 팀 여러 개가 같이 들어있다.
    - 각 프로세스 그룹은 딱 하나의 세션에만 속함.

&ensp;핵심
* 세션 ID(SID)는 "세션의 번호"다.
* 내 프로세스나 다른 프로세스가 어느 세션에 속했는지 알고 싶으면:

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getsid(pid_t pid);   // pid의 세션 ID 반환. pid=0이면 '나 자신'
```

&ensp;실습(터미널에서 눈으로 확인)<br/>
```bash
# 내 셸 프로세스의 pid/pgid/sid/tty를 한 번에 보기
$ ps -o pid,ppid,pgid,sid,tty,cmd -p $$
```

* 같은 TTY(터미널)에서 돌아가는 파이프라인 a|b|c는 보통 PGID가 같고, 그 PGID가 포함된 SID도 동일하다.

&ensp;setsid() : "나만의 새 세션 + 새 팀 만들기"<br/>
&ensp;한 줄 정의<br/>
* setsid()는 제어 터미널이 없는 새 세션을 만들고, 호출한 프로세스를 그 세션의 리더 + 새 프로세스 그룹의 리더로 만든다.

&ensp;→ 결과적으로 SID = PID, PGID = PID가 됨.<br/>
```c
#include <sys/types.h>
#include <unistd.h>
pid_t setsid(void);   // 성공: 새 세션 ID(=호출한 프로세스의 PID), 실패: -1
```

&ensp;주의<br/>
* 현재 "그룹 리더"인 프로세스는 setsid()가 실패(–1) 한다. 왜? “이미 팀 리더면 새 팀/세션을 바로 만들 수 없게” 하는 규칙 때문이다.
* 그래서 보통은 이렇게 한다.:
1. fork()로 자식을 만들고
2. 자식에서 setsid() 호출 (자식은 막 태어나서 그룹 리더가 아닐 가능성이 큼)

&ensp;짧은 예<br/>
```c
pid_t pid = fork();
if (pid == 0) {            // child
    pid_t sid = setsid();  // 새 세션 + 새 그룹, 리더가 됨
    // 여기서부터는 백그라운드 데몬 준비 등...
}
```

&ensp;main() 함수 인자<br/>
&ensp;개념<br/>
* 프로그램을 실행할 때 뒤에 붙이는 단어들(토큰)을 명령줄 인자라고 한다.
* C의 main은 이렇게 받는다:

```c
int main(int argc, char **argv)
```

* argc : 인자 개수(숫자)
* argv : 인자들의 문자열 배열
    - argv[0] : 보통 프로그램 이름
    - argv[1]부터 사용자가 넘긴 말들
    - 마지막은 NULL 포인터로 끝남

```c
int main(int argc, char **argv){
    int i;
    printf("%d\n", argc);  // 인자 개수 출력
    i = 0;
    while(argv[i] != NULL){ // argv[0]부터 NULL 나오기 전까지
        printf("%s\n", argv[i]);
        i++;
    }
    return 0;
}
```

* argv[0]도 찍으니 프로그램 이름까지 모두 줄줄이 출력된다.

&ensp;실행/출력 예시<br/>
```bash
$ ./a.out hello 123
```

&ensp;화면 예상<br/>
```bash
3
./a.out
hello
123
```

&ensp;(인자 3개: ./a.out, hello, 123)<br/>

&ensp;자주 하는 실수<br/>
* argv[argc]는 항상 NULL이니, while(i < argc) 또는 while(argv[i]!=NULL) 둘 중 하나 방식으로 도는 게 안전.
* 공백이 포함된 인자를 넘길 때는 따옴표 사용:

```bash
$ ./a.out "hello world"
```

&ensp;요약<br/>
* Session = 같은 터미널을 쓰는 여러 프로세스 그룹(PGID)의 큰 묶음(SID로 구분).
    - getsid(pid)로 세션 ID 확인.
* setsid() = 새 세션 + 새 그룹 만들고 내가 리더가 됨.
    - 그룹 리더 상태에서는 실패, 보통 fork 후 자식에서 호출.
* 명령줄 인자: argc(개수), argv(문자열 배열).
    - argv[0]은 프로그램 이름, 마지막은 NULL.