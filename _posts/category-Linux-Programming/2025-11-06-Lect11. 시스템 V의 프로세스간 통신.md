---
title: "Lect11. 시스템의 V의 프로세스간 통신"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-06
last_modified_at: 2025-11-09
---

IPC 기본 개념
=====

&ensp;IPD(Inter-Process-Communication): 서로 다른 프로세스들이 데이터를 주고받기 위한 방법<br/>
* Message Queue (메시지 큐)
* Shared Memory (공유 메모리)
* Semaphore (세마포어)

&ensp;이 세 가지는 전부 커널 공간에 생성되는 IPC 객체를 통해 작동한다. → 그래서 "key"값으로 각 객체를 구분해야 함<br/>

&ensp;IPC 설비— key 생성과 역할<br/>
&ensp;key란?<br/>
* `message_queue`, `semaphore`, `shared memory segment`를 식별하는 고유한 값
* IPC 객체의 파일 이름과 같은 역할
* 여러 프로세스가 동일한 key값을 쓰면 같은 IPC 객체를 공유

IPC 관련 함수 
====

&ensp;Key 생성 함수<br/>
```c
#include <sys/ipc.h>

key_t ftok(const char *path, int id);
```

&ensp;매커니즘<br/>
* `ftok()`는 특정 파일 경로(path)와 정수 id를 합쳐서 유니크한 key값을 만들어줌.
* 내부적으로 이 파일의 st_dev(디바이스 ID), st_ino(inode 번호) 그리고 id를 조합해서 key를 생성함
* 반환값은 key_t 타입
* 첫 번째 인자로 주는 파일은 반드시 실제 존재해야 함 → 존재하지 않으면 키 생성 실패

&ensp;예시<br/>
```c
key_t key = ftok("myfile", 1);
```

* myfile의 inode 번호와 디바이스 번호, 그리고 1이 합쳐져 unique key 생성
* 이 key로 message queue나 shared memory를 식별

&ensp;IPC 객체 상태 구조체<br/>
&ensp;ICP 객체(큐, 세그먼트 등)는 커널이 관리하고 그 상태를 나타내는 구조체가 있다.<br/>
```c
struct ipc_perm {
    uid_t cuid;  // 생성자의 UID
    gid_t cgid;  // 생성자의 GID
    uid_t uid;   // 소유자의 UID
    gid_t gid;   // 소유자의 GID
    mode_t mode; // 접근 권한 (rwx 중 x는 의미 없음)
};
```

* 파일의 접근 권한과 유사한 구조
* permission은 0666 같은 식으로 설정 가능 (read/write만 의미 있음)

&ensp;IPC 객체 확인 및 삭제 명령어<br/>
&ensp;IPC 정보 확인<br/>
```bash
$ ipcs
```

* 시스템 내의 모든 IPC 객체(message queue, shared memory, semaphore) 정보를 확인 가능

&ensp;IPC 객체 삭제<br/>
```bash
$ ipcrm -m shmid   # 공유 메모리 삭제
$ ipcrm -q msqid   # 메시지 큐 삭제
$ ipcrm -s semid   # 세마포어 삭제
```

* 각각의 IPC id를 이용해서 수동으로 제거할 수 있음

message passing (메시지 큐)
=====

&ensp;메시지 큐는 프로세스 간 메시지를 FIFO로 주고받는 방식(커널이 큐 형태로 메시지를 관리)<br/>

&ensp;주요 함수 3개<br/>

# `msgget()` — 메시지 큐 생성
```c
#include <sys/msg.h>

int msgget(key_t key, int permflags);
```

&ensp;인자 설명<br/>

| 인자          | 설명                                                     |
| ----------- | ------------------------------------------------------ |
| `key`       | message queue의 식별 key 값 (`ftok()`으로 생성)                |
| `permflags` | 접근 권한과 생성 옵션을 합친 값 (`IPC_CREAT`, `IPC_EXCL`, `0666` 등) |

&ensp;작동 메커니즘<br/>
1. 커널에 `key`로 식별되는 큐가 이미 있으면 → 그 큐의 식별자 반환
2. 없으면 → `IPC_CREAT` 플래그가 있을 때 새로 생성
3. `IPC_EXCL` 플래그가 추가되면, 큐가 이미 존재할 경우 오류(-1) 반환 → "첫 번째로 만든 프로세스"를 구분할 때 유용

* msgget(key, IPC_CREAT | 0666) → 존재하면 열기, 없으면 새로 생성

&ensp;예시<br/>
```c
key_t key = ftok("file", 1);
int msqid = msgget(key, IPC_CREAT | 0666);
```

&ensp;리턴값: 큐의 식별자(msqid, 음수가 아님)<br/>
&ensp;실패 시: -1(errno에 이유 저장)<br/>


# `msgsnd()` — 메시지 보내기
```c
#include <sys/msg.h>

int msgsnd(int msqid, const void *message, size_t size, int flags);
```

&ensp;인자 설명<br/>

| 인자        | 설명                           |
| --------- | ---------------------------- |
| `msqid`   | 메시지 큐 식별자 (`msgget`에서 반환된 값) |
| `message` | 보낼 메시지가 저장된 구조체의 주소          |
| `size`    | 메시지의 크기 (`mtext` 부분만)        |
| `flags`   | `IPC_NOWAIT` 설정 시 비동기 전송     |

&ensp;작동 메커니즘<br/>
* 큐가 꽉 찬 상태에서 
  - `IPC_NOWAIT` 설정 시 → 즉시 실패하고 -1 반환
  - 설정 안 했을 시 → 큐가 비워질 때까지 blocking

&ensp;메시지 구조체 예시<br/>
```c
struct mymsg {
    long mtype;          // 메시지 타입 (양의 정수)
    char mtext[100];     // 메시지 본문
};
```
* mtype은 양의 정수여야 함 (0 또는 음수면 실패)
* msgsnd(qid, &msg, sizeof(int), 0) → mtype은 포함하지 않음
* 메시지는 큐에 쌓이고, 프로세스 종료해도 데이터 유지됨 (파이프와 차이점)
* `mtype`은 수신자 구분용 (프로세스가 어떤 종류의 메시지만 받을지 결정)
* `mtext`는 실제 데이터

&ensp;예시<br/>
```c
struct mymsg msg;
msg.mtype = 1;
strcpy(msg.mtext, "hello");
msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
```

&ensp;리턴값: 0(성공)<br/>
&ensp;실패 시: -1<br/>

# `msgrcv()` — 메시지 받기

```c
#include <sys/msg.h>

int msgrcv(int msqid, void *message, size_t size, long msg_type, int flags);
```

&ensp;인자 설명<br/>

| 인자         | 설명                                     |
| ---------- | -------------------------------------- |
| `msqid`    | 큐 식별자                                  |
| `message`  | 수신된 메시지를 저장할 구조체 주소                    |
| `size`     | 저장할 버퍼 크기 (`mtext` 부분 크기)              |
| `msg_type` | 수신할 메시지 타입 지정                          |
| `flags`    | 수신 동작 제어 (`IPC_NOWAIT`, `MSG_NOERROR`) |

&ensp;`msg_type`의 의미<br/>

| msgtyp 값 | 의미                          |
| -------- | --------------------------- |
| 0        | 큐의 첫 번째 메시지 수신              |
| 양수 n     | mtype == n 인 메시지 수신         |
| 음수 -n    | mtype ≤ n 중 가장 작은 타입 메시지 수신 |

&ensp;필요한 타입만 골라서 받을 수 있다.<br/>

&ensp;`flags` 옵션<br/>

| flag          | 의미                                 |
| ------------- | ---------------------------------- |
| `IPC_NOWAIT`  | 메시지가 없으면 즉시 -1 반환 (`errno=EAGAIN`) |
| `MSG_NOERROR` | 수신 버퍼가 작으면 초과분을 잘라냄                |

&ensp;동작 원리<br/>
1. 큐에서 지정된 타입(msg_type)의 메시지를 검색
2. 없으면 → blocking 또는 즉시 리턴 (flag에 따라 다름)
3. 있으면 → 메시지를 복사 후 큐에서 삭제

&ensp;예시:<br/>
```c
struct mymsg msg;
msgrcv(msqid, &msg, sizeof(msg.mtext), 1, 0);
printf("Received: %s\n", msg.mtext);
```

&ensp;리턴값: 성공 시 받은 메시지 길이<br/>
&ensp;실패 시: -1(errno에 EACCESS, EAGAIN, ENOMSG 등 저장)<br/>

&ensp;전체 메시지 큐 동작 요약<br/>

| 단계 | 함수               | 역할         |
| -- | ---------------- | ---------- |
| 1  | `ftok()`         | 고유한 key 생성 |
| 2  | `msgget()`       | 큐 생성 또는 접근 |
| 3  | `msgsnd()`       | 메시지 전송     |
| 4  | `msgrcv()`       | 메시지 수신     |
| 5  | `ipcs` / `ipcrm` | 큐 확인 / 삭제  |

&ensp;message 송수신 예제 코드 설명<br/>
```c
struct q_entry {
    long mtype;
    int mnum;
};
struct q_entry msg;

qid = msgget(0111, 0600 | IPC_CREAT);

while (msgrcv(qid, &msg, sizeof(int), 1, 0) > 0) {
    msg.mtype = 2;
    msg.mnum = msg.mnum + 8;
    msgsnd(qid, &msg, sizeof(int), 0);
}
```

&ensp;코드 흐름 설명<br/>
&ensp;1. `struct q_entry` 정의<br/>
* 메시지 구조체는 항상 첫 필드가 long mtype 이어야 함. (커널이 메시지 타입을 구분하기 때문)
* int mnum은 실제 데이터

```c
struct q_entry {
    long mtype;  // 메시지 타입
    int mnum;    // 메시지 내용 (정수)
};
```

&ensp;2. 큐 생성<br/>
```c
qid = msgget(0111, 0600 | IPC_CREAT);
```

* key: `0111` (8진수)
* 권한: `0600` → 소유자만 read/write 가능
* `IPC_CREAT`: 큐가 없으면 생성

&ensp;반환값: 메시지 큐 식별자 (음수가 아니면 성공)<br/>

&ensp;메시지 수신 (`msgrcv`)<br/>
```c
msgrcv(qid, &msg, sizeof(int), 1, 0);
```

* `qid`: 큐 식별자
* `&msg`: 수신할 메시지 구조체 주소
* `sizeof(int)`: 데이터 크기 (mnum만 포함)
* `1`: 수신할 메시지 타입 (mtype = 1인 메시지만 받음)
* `0`: blocking 모드 (없으면 기다림)

&ensp;타입이 1인 메시지를 기다리며 큐에서 꺼냄<br/>

&ensp;4. 메시지 가공<br/>
```c
msg.mtype = 2;
msg.mnum = msg.mnum + 8;
```

&ensp;받은 메시지를 수정해서<br/>
&ensp;→ mnum에 +8<br/>
&ensp;→ mtype을 2로 바꿔 응답 타입으로 전송할 준비<br/>

&ensp;메시지 전송 (msgsnd)<br/>
```c
msgsnd(qid, &msg, sizeof(int), 0);
```

* 같은 큐(`qid`)로 다시 메시지를 보냄
* 이번엔 `mtype = 2` → 수신자는 `mtype = 2`를 받을 수 있음
* blocking 모드 (큐가 가득 차면 대기)

&ensp;전체 동작 정리<br/>
1. 타입 1 메시지를 받음
2. 데이터에 +8 한 뒤
3. 타입 2 메시지로 재전송

&ensp;받은 값을 8 더해서 되돌려주는 서버 역할을 하는 프로세스 예제이다.<br/>

# `msgctl()` — 메시지 큐 제어

```c
#include <sys/msg.h>

int msgctl(int msqid, int command, struct msqid_ds *buf);
```

&ensp;인자 설명<br/>

| 인자        | 설명                                         |
| --------- | ------------------------------------------ |
| `msqid`   | 메시지 큐 식별자                                  |
| `command` | 수행할 명령 (`IPC_STAT`, `IPC_RMID`, `IPC_SET`) |
| `buf`     | 큐의 상태 정보를 담거나 변경할 구조체 주소                   |

&ensp;주요 명령어<br/>

| 명령         | 설명                            |
| ---------- | ----------------------------- |
| `IPC_STAT` | 큐의 상태 정보를 얻음 (커널 → 사용자 영역 복사) |
| `IPC_RMID` | 큐를 커널에서 완전히 삭제                |
| `IPC_SET`  | 사용자가 수정한 권한(mode 등)을 커널에 반영   |

* IPC_STAT → 큐 상태 확인 (큐 안 메시지 개수, 최근 송수신 PID 등)
* IPC_RMID → 큐 삭제 (실습 중 ipcrm -q <id> 명령과 동일)

&ensp;예시<br/>
```c
struct msqid_ds info;
msgctl(msqid, IPC_STAT, &info);
printf("Number of messages: %ld\n", info.msg_qnum);
```

&ensp;`msqid_ds` 구조체 상세<br/>
```c
struct msqid_ds {
    struct ipc_perm msg_perm; // 접근 권한 정보
    msgqnum_t msg_qnum;       // 현재 큐에 저장된 메시지 개수
    msglen_t msg_qbytes;      // 큐에 허용된 최대 바이트 수
    pid_t msg_lspid;          // 마지막으로 보낸 프로세스의 PID
    pid_t msg_lrpid;          // 마지막으로 받은 프로세스의 PID
    time_t msg_stime;         // 마지막 송신 시각
    time_t msg_rtime;         // 마지막 수신 시각
    time_t msg_ctime;         // 마지막 변경 시각 (생성 또는 제어)
};
```

&ensp;각 필드 의미<br/>

| 필드           | 설명                         |
| ------------ | -------------------------- |
| `msg_perm`   | `ipc_perm` 구조체 (소유자/권한 정보) |
| `msg_qnum`   | 현재 큐 안의 메시지 개수             |
| `msg_qbytes` | 큐에 저장 가능한 최대 byte 수        |
| `msg_lspid`  | 마지막으로 메시지를 보낸 프로세스 PID     |
| `msg_lrpid`  | 마지막으로 메시지를 받은 프로세스 PID     |
| `msg_stime`  | 마지막 송신 시간                  |
| `msg_rtime`  | 마지막 수신 시간                  |
| `msg_ctime`  | 마지막으로 큐 속성이 바뀐 시간          |

| 함수         | 역할      | 주요 인자                          | 비고                  |
| ---------- | ------- | ------------------------------ | ------------------- |
| `msgget()` | 큐 생성/접근 | key, flags                     | IPC_CREAT, IPC_EXCL |
| `msgsnd()` | 메시지 전송  | msqid, struct msg*, size       | 큐에 메시지 push         |
| `msgrcv()` | 메시지 수신  | msqid, struct msg*, size, type | 큐에서 pop             |
| `msgctl()` | 큐 제어    | msqid, command, buf            | 상태확인/삭제             |

실습 3
=====

&ensp;1. server process는 세 개의 client process들과 데이터를 주고받기 위해 message queue를 만듭니다. 각 client는 message queue를 이용하여, 표준 입력으로 입력된 정수를 server process에게 전송합니다. server process는 client process로부터 전송된 정수값에 +8을 한 후, 해당 client에게 다시 보냅니다. client process는 돌려받은 정수값을 표준 출력으로 출력합니다. client process는 정수 데이터의 입/출력 작업을 5회 반복한 후 종료 합니다. 각 client process는 main() 함수의 arguments로 자신의 id
를 입력받습니다. <br/>

&ensp;전체 구조 개요<br/>
```scss
   ┌────────────┐        ┌────────────────┐        ┌────────────┐
   │ client(1)  │ <----> │                │ <----> │ client(2)  │
   │ id=1       │        │   message q    │        │ id=2       │
   └────────────┘        │   (kernel)     │        └────────────┘
                         │                │
                         └────────────────┘
                                 ▲
                                 │
                          ┌────────────┐
                          │  server    │
                          └────────────┘
```

&ensp;서버는 큐를 하나만 생성하고 모든 클라이언트는 그 큐를 공유하면서 통신한다.<br/>

&ensp;server.c<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct q_entry {
        long mtype;
        int data;
}; 

int main(void){
        int i, qid;
        key_t key;
        struct q_entry msg;

        key = ftok("key", 3);
        qid = msgget(key, IPC_CREAT | 0600);

        for(i = 0; i < 15; i++){
                msgrcv(qid, &msg, sizeof(int), 0, 0);
                msg.data += 8;
                msg.mtype += 100;
                msgsnd(qid, &msg, sizeof(int), 0);
        }
        return 0;
}
```

&ensp;client.c <br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct q_entry {
    long mtype;
    int data;
};

int main(int argc, char **argv) {
    int i, qid, in, id;
    key_t key;
    struct q_entry msg;

    id = atoi(argv[1]);
    
    key = ftok("key", 3);
    qid = msgget(key, 0600);

    for (i = 0; i < 5; i++) {
        scanf("%d", &in);
        msg.mtype = id;
        msg.data = in;
        msgsnd(qid, &msg, sizeof(int), 0);

        // 여기서 id+100 타입의 응답을 기다려야 함
        msgrcv(qid, &msg, sizeof(int), id + 100, 0);
        printf("%d\n", msg.data);
    }
    return 0;
}
```


&ensp;1. key와 큐 생성<br/>
&ensp;server.c<br/>
```c
key = ftok("key", 3);              // "key" 파일로부터 고유 키 생성
qid = msgget(key, IPC_CREAT | 0600);  // 없으면 새 큐 생성
```

* `ftok()` → 파일과 정수를 조합해 고유한 key_t 값 생성
* `msgget()` → 해당 키로 message queue 생성 또는 열기
* `0600` → owner만 읽고 쓸 수 있는 권한

&ensp;`ftok(const char *pathname, int proj_id)` → key 생성 함수<br/>

| 인자         | 설명                                       |
| ---------- | ---------------------------------------- |
| `pathname` | 실제 존재하는 파일 이름 (여기서는 `"key"`)             |
| `proj_id`  | 정수(0~255), 같은 파일이라도 이 값이 다르면 다른 key 생성   |
| **반환값**    | `key_t`형 고유 키값 (서버·클라이언트가 같은 키면 같은 큐 사용) |



&ensp;`msgget(key_t key, int msgflg)` → 메시지 큐 생성 또는 열기<br/>

| 인자       | 설명                                       |                                      |
| -------- | ---------------------------------------- | ------------------------------------ |
| `key`    | `ftok()`로 만든 key 값                       |                                      |
| `msgflg` | 동작 및 권한 지정. `IPC_CREAT                   | 0600`이면 없으면 만들고, 권한은 owner만 읽기/쓰기 가능 |
| **반환값**  | 큐의 식별자(ID) — 이후 `msgrcv` / `msgsnd`에서 사용 |                                      |

&ensp;커널에 메시지 큐를 만들거나, 이미 만들어진 큐를 열어서 사용할 수 있게 함<br/>


&ensp;이때 "key" 파일이 실제로 있어야 함<br/>

&ensp;2. client도 같은 큐 열기<br/>
```c
key = ftok("key", 3);
qid = msgget(key, 0600);  // 이미 서버가 만든 큐를 열기만 함
```

* 같은 "key", 같은 정수 3을 쓰므로 서버와 같은 큐에 접근 가능

&ensp;3. 메시지 구조 정의<br/>
```c
struct q_entry {
    long mtype;   // 메시지 타입 (메시지 구분용, 반드시 long)
    int  data;    // 실제 전송할 데이터
};
```

* mtype은 메시지의 주소표 역할
  - 클라이언트 → 서버 : mtype = id (1,2,3 등)
  - 서버 → 클라이언트 : mtype = id + 100 (101,102,103)

&ensp;4. client → server 전송<br/>
&ensp;client.c<br/>
```c
scanf("%d", &in);         // 사용자 입력
msg.mtype = id;           // 자기 ID를 타입으로 지정
msg.data = in;            // 입력한 값 저장
msgsnd(qid, &msg, sizeof(int), 0);  // 큐에 메시지 전송
```

&ensp;큐에 새 메시지를 추가함. 서버는 받은 메시지의 mtype을 +100해서 클라이언트에게 응답<br/>

&ensp;`msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)` → 큐에 메시지 전송<br/>

| 인자       | 설명                                  |
| -------- | ----------------------------------- |
| `msqid`  | 큐 ID (`msgget()` 반환값)               |
| `msgp`   | 전송할 메시지가 담긴 구조체 주소                  |
| `msgsz`  | `mtype`을 제외한 데이터 크기 (`sizeof(int)`) |
| `msgflg` | 전송 옵션 (0이면 큐가 꽉 차 있을 때까지 대기)        |
| **반환값**  | 성공 시 0                              |

&ensp;큐에 새 메시지를 추가함. 서버는 받은 메시지의 mtype을 +100해서 클라이언트에게 응답<br/>

&ensp;5. server 수신 및 처리<br/>
&ensp;server.c<br/>
```c
msgrcv(qid, &msg, sizeof(int), 0, 0);
msg.data += 8;        // 데이터 가공
msg.mtype += 100;     // 응답 타입 변경 (1→101)
msgsnd(qid, &msg, sizeof(int), 0);
```

* `msgrcv(..., type=0)` → 모든 타입 메시지를 받을 수 있음
* 받은 후 +8 처리 → 응답을 `(mtype=101, data=9)`로 다시 큐에 넣음

&ensp;`msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)` → 큐에서 메시지 읽기<br/>

| 인자       | 설명                                  |
| -------- | ----------------------------------- |
| `msqid`  | 큐 ID (`msgget()` 반환값)               |
| `msgp`   | 메시지를 저장할 구조체 주소                     |
| `msgsz`  | `mtype`을 제외한 데이터 크기 (`sizeof(int)`) |
| `msgtyp` | 받을 메시지 타입 (0이면 “가장 먼저 들어온 메시지” 수신)  |
| `msgflg` | 수신 옵션 (0이면 블로킹 방식 — 메시지 올 때까지 기다림)  |
| **반환값**  | 성공 시 받은 메시지의 크기                     |

&ensp;큐에 쌓인 메시지를 하나 꺼내서 msgp 구조체에 복사함. 서버에서는 0으로 지정 → 어떤 클라이언트의 메시지든 다 받음.<br/>

&ensp;6. client 응답 수신<br/>
```c
msgrcv(qid, &msg, sizeof(int), id+100, 0);
printf("%d\n", msg.data);
```

* 자신의 응답 타입(id+100)만 기다림 → id=1이면 101, id=2면 102 등
* 서버가 돌려준 메시지만 정확히 받음
* 받은 msg.data를 출력

&ensp;반복 흐름 요약<br/>

| 순서 | 동작                 | 큐 안 메시지 예시          |
| -- | ------------------ | ------------------- |
| 1  | client(1) 입력값 1 전송 | (mtype=1, data=1)   |
| 2  | server 수신 후 처리     | data=9, mtype=101   |
| 3  | server 응답 송신       | (mtype=101, data=9) |
| 4  | client(1) 수신 후 출력  | 9                   |
| 5  | 동일 패턴 5회 반복 × 3명   | 총 15회 처리            |

&ensp;8. 서버 종료 조건<br/>
```c
for(i = 0; i < 15; i++) {
    msgrcv(...);
    ...
    msgsnd(...);
}
```

* 3명의 클라이언트 × 5회씩 = 15회 처리 후 자동 종료
* 그전까지는 `msgrcv()` 가 다음 메시지 수신 대기 상태라 아무 출력 없이 쉘로 안 돌아오는 게 정상임.

&ensp;9. 프로그램 종료 후 메시지 큐 정리<br/>
```bash
ipcs -q           # 큐 목록 확인
ipcrm -q <msqid>  # 특정 큐 삭제
```

| 구분       | server                   | client                        |
| -------- | ------------------------ | ----------------------------- |
| 큐 생성     | `msgget(..., IPC_CREAT)` | `msgget(..., 0)`              |
| 송신       | `msgsnd(qid, ...)`       | `msgsnd(qid, ...)`            |
| 수신       | `msgrcv(qid, ..., 0, 0)` | `msgrcv(qid, ..., id+100, 0)` |
| 데이터 처리   | `data += 8`              | `printf()` 출력                 |
| mtype 규칙 | 요청 `id` → 응답 `id+100`    | 동일 규칙 적용                      |
| 반복 횟수    | 15회                      | 5회                            |

&ensp;클라이언트는 큐에 정수를 넣고 서버는 그 값을 +8 해서 같은 큐로 돌려준다. 서버는 15개의 요청을 처리할 때까지 계속 대기하며 각 클라이언트는 자신에게 맞는 응답(mtype=id+100)만 받아서 출력한다.<br/>