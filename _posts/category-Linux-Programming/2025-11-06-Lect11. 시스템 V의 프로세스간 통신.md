---
title: "Lect11. 시스템의 V의 프로세스간 통신"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-06
last_modified_at: 2025-11-10
---

IPC 기본 개념
=====

&ensp;IPC(Inter-Process-Communication): 서로 다른 프로세스들이 데이터를 주고받기 위한 방법<br/>
* Message Queue (메시지 큐)
* Shared Memory (공유 메모리)
* Semaphore (세마포어)

&ensp;이 세 가지는 전부 커널 공간에 생성되는 IPC 객체를 통해 작동한다. → 그래서 "key"값으로 각 객체를 구분해야 함<br/>

&ensp;IPC 설비— key 생성과 역할<br/>
&ensp;key란?<br/>
* `message_queue`, `semaphore`, `shared memory segment`를 식별하는 고유한 값
* IPC 객체의 파일 이름과 같은 역할
* 여러 프로세스가 동일한 key값을 쓰면 같은 IPC 객체를 공유

IPC 관련 함수 
====

&ensp;Key 생성 함수<br/>
```c
#include <sys/ipc.h>

key_t ftok(const char *path, int id);
```

&ensp;매커니즘<br/>
* `ftok()`는 특정 파일 경로(path)와 정수 id를 합쳐서 유니크한 key값을 만들어줌.
* 내부적으로 이 파일의 st_dev(디바이스 ID), st_ino(inode 번호) 그리고 id를 조합해서 key를 생성함
* 반환값은 key_t 타입
* 첫 번째 인자로 주는 파일은 반드시 실제 존재해야 함 → 존재하지 않으면 키 생성 실패

&ensp;예시<br/>
```c
key_t key = ftok("myfile", 1);
```

* myfile의 inode 번호와 디바이스 번호, 그리고 1이 합쳐져 unique key 생성
* 이 key로 message queue나 shared memory를 식별

&ensp;IPC 객체 상태 구조체<br/>
&ensp;ICP 객체(큐, 세그먼트 등)는 커널이 관리하고 그 상태를 나타내는 구조체가 있다.<br/>
```c
struct ipc_perm {
    uid_t cuid;  // 생성자의 UID
    gid_t cgid;  // 생성자의 GID
    uid_t uid;   // 소유자의 UID
    gid_t gid;   // 소유자의 GID
    mode_t mode; // 접근 권한 (rwx 중 x는 의미 없음)
};
```

* 파일의 접근 권한과 유사한 구조
* permission은 0666 같은 식으로 설정 가능 (read/write만 의미 있음)

&ensp;IPC 객체 확인 및 삭제 명령어<br/>
&ensp;IPC 정보 확인<br/>
```bash
$ ipcs
```

* 시스템 내의 모든 IPC 객체(message queue, shared memory, semaphore) 정보를 확인 가능

&ensp;IPC 객체 삭제<br/>
```bash
$ ipcrm -m shmid   # 공유 메모리 삭제
$ ipcrm -q msqid   # 메시지 큐 삭제
$ ipcrm -s semid   # 세마포어 삭제
```

* 각각의 IPC id를 이용해서 수동으로 제거할 수 있음

message passing (메시지 큐)
=====

&ensp;메시지 큐는 프로세스 간 메시지를 FIFO로 주고받는 방식(커널이 큐 형태로 메시지를 관리)<br/>

&ensp;주요 함수 3개<br/>

# `msgget()` — 메시지 큐 생성
```c
#include <sys/msg.h>

int msgget(key_t key, int permflags);
```

&ensp;인자 설명<br/>

| 인자          | 설명                                                     |
| ----------- | ------------------------------------------------------ |
| `key`       | message queue의 식별 key 값 (`ftok()`으로 생성)                |
| `permflags` | 접근 권한과 생성 옵션을 합친 값 (`IPC_CREAT`, `IPC_EXCL`, `0666` 등) |

&ensp;작동 메커니즘<br/>
1. 커널에 `key`로 식별되는 큐가 이미 있으면 → 그 큐의 식별자 반환
2. 없으면 → `IPC_CREAT` 플래그가 있을 때 새로 생성
3. `IPC_EXCL` 플래그가 추가되면, 큐가 이미 존재할 경우 오류(-1) 반환 → "첫 번째로 만든 프로세스"를 구분할 때 유용

* msgget(key, IPC_CREAT \| 0666) → 존재하면 열기, 없으면 새로 생성

&ensp;예시<br/>
```c
key_t key = ftok("file", 1);
int msqid = msgget(key, IPC_CREAT | 0666);
```

&ensp;리턴값: 큐의 식별자(msqid, 음수가 아님)<br/>
&ensp;실패 시: -1(errno에 이유 저장)<br/>


# `msgsnd()` — 메시지 보내기
```c
#include <sys/msg.h>

int msgsnd(int msqid, const void *message, size_t size, int flags);
```

&ensp;인자 설명<br/>

| 인자        | 설명                           |
| --------- | ---------------------------- |
| `msqid`   | 메시지 큐 식별자 (`msgget`에서 반환된 값) |
| `message` | 보낼 메시지가 저장된 구조체의 주소          |
| `size`    | 메시지의 크기 (`mtext` 부분만)        |
| `flags`   | `IPC_NOWAIT` 설정 시 비동기 전송     |

&ensp;작동 메커니즘<br/>
* 큐가 꽉 찬 상태에서 
  - `IPC_NOWAIT` 설정 시 → 즉시 실패하고 -1 반환
  - 설정 안 했을 시 → 큐가 비워질 때까지 blocking

&ensp;메시지 구조체 예시<br/>
```c
struct mymsg {
    long mtype;          // 메시지 타입 (양의 정수)
    char mtext[100];     // 메시지 본문
};
```
* mtype은 양의 정수여야 함 (0 또는 음수면 실패)
* msgsnd(qid, &msg, sizeof(int), 0) → mtype은 포함하지 않음
* 메시지는 큐에 쌓이고, 프로세스 종료해도 데이터 유지됨 (파이프와 차이점)
* `mtype`은 수신자 구분용 (프로세스가 어떤 종류의 메시지만 받을지 결정)
* `mtext`는 실제 데이터

&ensp;예시<br/>
```c
struct mymsg msg;
msg.mtype = 1;
strcpy(msg.mtext, "hello");
msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
```

&ensp;리턴값: 0(성공)<br/>
&ensp;실패 시: -1<br/>

# `msgrcv()` — 메시지 받기

```c
#include <sys/msg.h>

int msgrcv(int msqid, void *message, size_t size, long msg_type, int flags);
```

&ensp;인자 설명<br/>

| 인자         | 설명                                     |
| ---------- | -------------------------------------- |
| `msqid`    | 큐 식별자                                  |
| `message`  | 수신된 메시지를 저장할 구조체 주소                    |
| `size`     | 저장할 버퍼 크기 (`mtext` 부분 크기)              |
| `msg_type` | 수신할 메시지 타입 지정                          |
| `flags`    | 수신 동작 제어 (`IPC_NOWAIT`, `MSG_NOERROR`) |

&ensp;`msg_type`의 의미<br/>

| msgtyp 값 | 의미                          |
| -------- | --------------------------- |
| 0        | 큐의 첫 번째 메시지 수신              |
| 양수 n     | mtype == n 인 메시지 수신         |
| 음수 -n    | mtype ≤ n 중 가장 작은 타입 메시지 수신 |

&ensp;필요한 타입만 골라서 받을 수 있다.<br/>

&ensp;`flags` 옵션<br/>

| flag          | 의미                                 |
| ------------- | ---------------------------------- |
| `IPC_NOWAIT`  | 메시지가 없으면 즉시 -1 반환 (`errno=EAGAIN`) |
| `MSG_NOERROR` | 수신 버퍼가 작으면 초과분을 잘라냄                |

&ensp;동작 원리<br/>
1. 큐에서 지정된 타입(msg_type)의 메시지를 검색
2. 없으면 → blocking 또는 즉시 리턴 (flag에 따라 다름)
3. 있으면 → 메시지를 복사 후 큐에서 삭제

&ensp;예시:<br/>
```c
struct mymsg msg;
msgrcv(msqid, &msg, sizeof(msg.mtext), 1, 0);
printf("Received: %s\n", msg.mtext);
```

&ensp;리턴값: 성공 시 받은 메시지 길이<br/>
&ensp;실패 시: -1(errno에 EACCESS, EAGAIN, ENOMSG 등 저장)<br/>

&ensp;전체 메시지 큐 동작 요약<br/>

| 단계 | 함수               | 역할         |
| -- | ---------------- | ---------- |
| 1  | `ftok()`         | 고유한 key 생성 |
| 2  | `msgget()`       | 큐 생성 또는 접근 |
| 3  | `msgsnd()`       | 메시지 전송     |
| 4  | `msgrcv()`       | 메시지 수신     |
| 5  | `ipcs` / `ipcrm` | 큐 확인 / 삭제  |

&ensp;message 송수신 예제 코드 설명<br/>
```c
struct q_entry {
    long mtype;
    int mnum;
};
struct q_entry msg;

qid = msgget(0111, 0600 | IPC_CREAT);

while (msgrcv(qid, &msg, sizeof(int), 1, 0) > 0) {
    msg.mtype = 2;
    msg.mnum = msg.mnum + 8;
    msgsnd(qid, &msg, sizeof(int), 0);
}
```

&ensp;코드 흐름 설명<br/>
&ensp;1. `struct q_entry` 정의<br/>
* 메시지 구조체는 항상 첫 필드가 long mtype 이어야 함. (커널이 메시지 타입을 구분하기 때문)
* int mnum은 실제 데이터

```c
struct q_entry {
    long mtype;  // 메시지 타입
    int mnum;    // 메시지 내용 (정수)
};
```

&ensp;2. 큐 생성<br/>
```c
qid = msgget(0111, 0600 | IPC_CREAT);
```

* key: `0111` (8진수)
* 권한: `0600` → 소유자만 read/write 가능
* `IPC_CREAT`: 큐가 없으면 생성

&ensp;반환값: 메시지 큐 식별자 (음수가 아니면 성공)<br/>

&ensp;메시지 수신 (`msgrcv`)<br/>
```c
msgrcv(qid, &msg, sizeof(int), 1, 0);
```

* `qid`: 큐 식별자
* `&msg`: 수신할 메시지 구조체 주소
* `sizeof(int)`: 데이터 크기 (mnum만 포함)
* `1`: 수신할 메시지 타입 (mtype = 1인 메시지만 받음)
* `0`: blocking 모드 (없으면 기다림)

&ensp;타입이 1인 메시지를 기다리며 큐에서 꺼냄<br/>

&ensp;4. 메시지 가공<br/>
```c
msg.mtype = 2;
msg.mnum = msg.mnum + 8;
```

&ensp;받은 메시지를 수정해서<br/>
&ensp;→ mnum에 +8<br/>
&ensp;→ mtype을 2로 바꿔 응답 타입으로 전송할 준비<br/>

&ensp;메시지 전송 (msgsnd)<br/>
```c
msgsnd(qid, &msg, sizeof(int), 0);
```

* 같은 큐(`qid`)로 다시 메시지를 보냄
* 이번엔 `mtype = 2` → 수신자는 `mtype = 2`를 받을 수 있음
* blocking 모드 (큐가 가득 차면 대기)

&ensp;전체 동작 정리<br/>
1. 타입 1 메시지를 받음
2. 데이터에 +8 한 뒤
3. 타입 2 메시지로 재전송

&ensp;받은 값을 8 더해서 되돌려주는 서버 역할을 하는 프로세스 예제이다.<br/>

# `msgctl()` — 메시지 큐 제어

```c
#include <sys/msg.h>

int msgctl(int msqid, int command, struct msqid_ds *buf);
```

&ensp;인자 설명<br/>

| 인자        | 설명                                         |
| --------- | ------------------------------------------ |
| `msqid`   | 메시지 큐 식별자                                  |
| `command` | 수행할 명령 (`IPC_STAT`, `IPC_RMID`, `IPC_SET`) |
| `buf`     | 큐의 상태 정보를 담거나 변경할 구조체 주소                   |

&ensp;주요 명령어<br/>

| 명령         | 설명                            |
| ---------- | ----------------------------- |
| `IPC_STAT` | 큐의 상태 정보를 얻음 (커널 → 사용자 영역 복사) |
| `IPC_RMID` | 큐를 커널에서 완전히 삭제                |
| `IPC_SET`  | 사용자가 수정한 권한(mode 등)을 커널에 반영   |

* IPC_STAT → 큐 상태 확인 (큐 안 메시지 개수, 최근 송수신 PID 등)
* IPC_RMID → 큐 삭제 (실습 중 ipcrm -q <id> 명령과 동일)

&ensp;예시<br/>
```c
struct msqid_ds info;
msgctl(msqid, IPC_STAT, &info);
printf("Number of messages: %ld\n", info.msg_qnum);
```

&ensp;`msqid_ds` 구조체 상세<br/>
```c
struct msqid_ds {
    struct ipc_perm msg_perm; // 접근 권한 정보
    msgqnum_t msg_qnum;       // 현재 큐에 저장된 메시지 개수
    msglen_t msg_qbytes;      // 큐에 허용된 최대 바이트 수
    pid_t msg_lspid;          // 마지막으로 보낸 프로세스의 PID
    pid_t msg_lrpid;          // 마지막으로 받은 프로세스의 PID
    time_t msg_stime;         // 마지막 송신 시각
    time_t msg_rtime;         // 마지막 수신 시각
    time_t msg_ctime;         // 마지막 변경 시각 (생성 또는 제어)
};
```

&ensp;각 필드 의미<br/>

| 필드           | 설명                         |
| ------------ | -------------------------- |
| `msg_perm`   | `ipc_perm` 구조체 (소유자/권한 정보) |
| `msg_qnum`   | 현재 큐 안의 메시지 개수             |
| `msg_qbytes` | 큐에 저장 가능한 최대 byte 수        |
| `msg_lspid`  | 마지막으로 메시지를 보낸 프로세스 PID     |
| `msg_lrpid`  | 마지막으로 메시지를 받은 프로세스 PID     |
| `msg_stime`  | 마지막 송신 시간                  |
| `msg_rtime`  | 마지막 수신 시간                  |
| `msg_ctime`  | 마지막으로 큐 속성이 바뀐 시간          |

| 함수         | 역할      | 주요 인자                          | 비고                  |
| ---------- | ------- | ------------------------------ | ------------------- |
| `msgget()` | 큐 생성/접근 | key, flags                     | IPC_CREAT, IPC_EXCL |
| `msgsnd()` | 메시지 전송  | msqid, struct msg*, size       | 큐에 메시지 push         |
| `msgrcv()` | 메시지 수신  | msqid, struct msg*, size, type | 큐에서 pop             |
| `msgctl()` | 큐 제어    | msqid, command, buf            | 상태확인/삭제             |

실습 3
=====

&ensp;1. server process는 세 개의 client process들과 데이터를 주고받기 위해 message queue를 만듭니다. 각 client는 message queue를 이용하여, 표준 입력으로 입력된 정수를 server process에게 전송합니다. server process는 client process로부터 전송된 정수값에 +8을 한 후, 해당 client에게 다시 보냅니다. client process는 돌려받은 정수값을 표준 출력으로 출력합니다. client process는 정수 데이터의 입/출력 작업을 5회 반복한 후 종료 합니다. 각 client process는 main() 함수의 arguments로 자신의 id
를 입력받습니다. <br/>

&ensp;전체 구조 개요<br/>
```scss
   ┌────────────┐        ┌────────────────┐        ┌────────────┐
   │ client(1)  │ <----> │                │ <----> │ client(2)  │
   │ id=1       │        │   message q    │        │ id=2       │
   └────────────┘        │   (kernel)     │        └────────────┘
                         │                │
                         └────────────────┘
                                 ▲
                                 │
                          ┌────────────┐
                          │  server    │
                          └────────────┘
```

&ensp;서버는 큐를 하나만 생성하고 모든 클라이언트는 그 큐를 공유하면서 통신한다.<br/>

&ensp;server.c<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct q_entry {
        long mtype;
        int data;
}; 

int main(void){
        int i, qid;
        key_t key;
        struct q_entry msg;

        key = ftok("key", 3);
        qid = msgget(key, IPC_CREAT | 0600);

        for(i = 0; i < 15; i++){
                msgrcv(qid, &msg, sizeof(int), 0, 0);
                msg.data += 8;
                msg.mtype += 100;
                msgsnd(qid, &msg, sizeof(int), 0);
        }
        return 0;
}
```

&ensp;client.c <br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct q_entry {
    long mtype;
    int data;
};

int main(int argc, char **argv) {
    int i, qid, in, id;
    key_t key;
    struct q_entry msg;

    id = atoi(argv[1]);
    
    key = ftok("key", 3);
    qid = msgget(key, 0600);

    for (i = 0; i < 5; i++) {
        scanf("%d", &in);
        msg.mtype = id;
        msg.data = in;
        msgsnd(qid, &msg, sizeof(int), 0);

        // 여기서 id+100 타입의 응답을 기다려야 함
        msgrcv(qid, &msg, sizeof(int), id + 100, 0);
        printf("%d\n", msg.data);
    }
    return 0;
}
```


&ensp;1. key와 큐 생성<br/>
&ensp;server.c<br/>
```c
key = ftok("key", 3);              // "key" 파일로부터 고유 키 생성
qid = msgget(key, IPC_CREAT | 0600);  // 없으면 새 큐 생성
```

* `ftok()` → 파일과 정수를 조합해 고유한 key_t 값 생성
* `msgget()` → 해당 키로 message queue 생성 또는 열기
* `0600` → owner만 읽고 쓸 수 있는 권한

&ensp;`ftok(const char *pathname, int proj_id)` → key 생성 함수<br/>

| 인자         | 설명                                       |
| ---------- | ---------------------------------------- |
| `pathname` | 실제 존재하는 파일 이름 (여기서는 `"key"`)             |
| `proj_id`  | 정수(0~255), 같은 파일이라도 이 값이 다르면 다른 key 생성   |
| **반환값**    | `key_t`형 고유 키값 (서버·클라이언트가 같은 키면 같은 큐 사용) |



&ensp;`msgget(key_t key, int msgflg)` → 메시지 큐 생성 또는 열기<br/>

| 인자       | 설명                                       |                                      |
| -------- | ---------------------------------------- | ------------------------------------ |
| `key`    | `ftok()`로 만든 key 값                       |                                      |
| `msgflg` | 동작 및 권한 지정. `IPC_CREAT                   | 0600`이면 없으면 만들고, 권한은 owner만 읽기/쓰기 가능 |
| **반환값**  | 큐의 식별자(ID) — 이후 `msgrcv` / `msgsnd`에서 사용 |                                      |

&ensp;커널에 메시지 큐를 만들거나, 이미 만들어진 큐를 열어서 사용할 수 있게 함<br/>


&ensp;이때 "key" 파일이 실제로 있어야 함<br/>

&ensp;2. client도 같은 큐 열기<br/>
```c
key = ftok("key", 3);
qid = msgget(key, 0600);  // 이미 서버가 만든 큐를 열기만 함
```

* 같은 "key", 같은 정수 3을 쓰므로 서버와 같은 큐에 접근 가능

&ensp;3. 메시지 구조 정의<br/>
```c
struct q_entry {
    long mtype;   // 메시지 타입 (메시지 구분용, 반드시 long)
    int  data;    // 실제 전송할 데이터
};
```

* mtype은 메시지의 주소표 역할
  - 클라이언트 → 서버 : mtype = id (1,2,3 등)
  - 서버 → 클라이언트 : mtype = id + 100 (101,102,103)

&ensp;4. client → server 전송<br/>
&ensp;client.c<br/>
```c
scanf("%d", &in);         // 사용자 입력
msg.mtype = id;           // 자기 ID를 타입으로 지정
msg.data = in;            // 입력한 값 저장
msgsnd(qid, &msg, sizeof(int), 0);  // 큐에 메시지 전송
```

&ensp;큐에 새 메시지를 추가함. 서버는 받은 메시지의 mtype을 +100해서 클라이언트에게 응답<br/>

&ensp;`msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)` → 큐에 메시지 전송<br/>

| 인자       | 설명                                  |
| -------- | ----------------------------------- |
| `msqid`  | 큐 ID (`msgget()` 반환값)               |
| `msgp`   | 전송할 메시지가 담긴 구조체 주소                  |
| `msgsz`  | `mtype`을 제외한 데이터 크기 (`sizeof(int)`) |
| `msgflg` | 전송 옵션 (0이면 큐가 꽉 차 있을 때까지 대기)        |
| **반환값**  | 성공 시 0                              |

&ensp;큐에 새 메시지를 추가함. 서버는 받은 메시지의 mtype을 +100해서 클라이언트에게 응답<br/>

&ensp;5. server 수신 및 처리<br/>
&ensp;server.c<br/>
```c
msgrcv(qid, &msg, sizeof(int), 0, 0);
msg.data += 8;        // 데이터 가공
msg.mtype += 100;     // 응답 타입 변경 (1→101)
msgsnd(qid, &msg, sizeof(int), 0);
```

* `msgrcv(..., type=0)` → 모든 타입 메시지를 받을 수 있음
* 받은 후 +8 처리 → 응답을 `(mtype=101, data=9)`로 다시 큐에 넣음

&ensp;`msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)` → 큐에서 메시지 읽기<br/>

| 인자       | 설명                                  |
| -------- | ----------------------------------- |
| `msqid`  | 큐 ID (`msgget()` 반환값)               |
| `msgp`   | 메시지를 저장할 구조체 주소                     |
| `msgsz`  | `mtype`을 제외한 데이터 크기 (`sizeof(int)`) |
| `msgtyp` | 받을 메시지 타입 (0이면 “가장 먼저 들어온 메시지” 수신)  |
| `msgflg` | 수신 옵션 (0이면 블로킹 방식 — 메시지 올 때까지 기다림)  |
| **반환값**  | 성공 시 받은 메시지의 크기                     |

&ensp;큐에 쌓인 메시지를 하나 꺼내서 msgp 구조체에 복사함. 서버에서는 0으로 지정 → 어떤 클라이언트의 메시지든 다 받음.<br/>

&ensp;6. client 응답 수신<br/>
```c
msgrcv(qid, &msg, sizeof(int), id+100, 0);
printf("%d\n", msg.data);
```

* 자신의 응답 타입(id+100)만 기다림 → id=1이면 101, id=2면 102 등
* 서버가 돌려준 메시지만 정확히 받음
* 받은 msg.data를 출력

&ensp;반복 흐름 요약<br/>

| 순서 | 동작                 | 큐 안 메시지 예시          |
| -- | ------------------ | ------------------- |
| 1  | client(1) 입력값 1 전송 | (mtype=1, data=1)   |
| 2  | server 수신 후 처리     | data=9, mtype=101   |
| 3  | server 응답 송신       | (mtype=101, data=9) |
| 4  | client(1) 수신 후 출력  | 9                   |
| 5  | 동일 패턴 5회 반복 × 3명   | 총 15회 처리            |

&ensp;8. 서버 종료 조건<br/>
```c
for(i = 0; i < 15; i++) {
    msgrcv(...);
    ...
    msgsnd(...);
}
```

* 3명의 클라이언트 × 5회씩 = 15회 처리 후 자동 종료
* 그전까지는 `msgrcv()` 가 다음 메시지 수신 대기 상태라 아무 출력 없이 쉘로 안 돌아오는 게 정상임.

&ensp;9. 프로그램 종료 후 메시지 큐 정리<br/>
```bash
ipcs -q           # 큐 목록 확인
ipcrm -q <msqid>  # 특정 큐 삭제
```

| 구분       | server                   | client                        |
| -------- | ------------------------ | ----------------------------- |
| 큐 생성     | `msgget(..., IPC_CREAT)` | `msgget(..., 0)`              |
| 송신       | `msgsnd(qid, ...)`       | `msgsnd(qid, ...)`            |
| 수신       | `msgrcv(qid, ..., 0, 0)` | `msgrcv(qid, ..., id+100, 0)` |
| 데이터 처리   | `data += 8`              | `printf()` 출력                 |
| mtype 규칙 | 요청 `id` → 응답 `id+100`    | 동일 규칙 적용                      |
| 반복 횟수    | 15회                      | 5회                            |

&ensp;클라이언트는 큐에 정수를 넣고 서버는 그 값을 +8 해서 같은 큐로 돌려준다. 서버는 15개의 요청을 처리할 때까지 계속 대기하며 각 클라이언트는 자신에게 맞는 응답(mtype=id+100)만 받아서 출력한다.<br/>

&ensp;실행 결과 예시<br/>

&ensp;1. 서버 실행<br/>
```bash
./p3-1-s
```

&ensp;→ 아무 출력 없이 대기 (모든 클라이언트의 15개 요청을 다 처리하면 자동 종료)<br/>

&ensp;2. 클라이언트 1 실행<br/>
```bash
./p3-1-c 1

# 입력
1
2
3
4
5

# 출력
9
10
11
12
13
```

&ensp;클라이언트 2 실행<br/>
```bash
./p3-1-c 2

# 입력
10
20
30
40
50

# 출력
18
28
38
48
58
```

&ensp;클라이언트 3 실행<br/>
```bash
./p3-1-c 3

# 입력
5
6
7
8
9

# 출력
13
14
15
16
17
```

shared memory
======

사전 개념
-----

&ensp;프로세스 간 통신(IPC, Inter-Process Communication)<br/>
&ensp;운영체제는 각 프로세스가 독립된 메모리 공간을 가지고 동작하도록 보호한다. 하지만 여러 프로세스가 데이터를 주고받아야 할 때는 IPC 기법이 필요하다.<br/>
&ensp;대표적인 IPC 방법<br/>

| 방식                         | 특징                          |
| -------------------------- | --------------------------- |
| **Pipe/FIFO**              | 단방향 스트림. 부모-자식 간 통신에 주로 사용  |
| **Message Queue**          | 커널이 관리하는 메시지 버퍼. 메시지 단위 송수신 |
| **Shared Memory (공유 메모리)** | **물리적 메모리를 여러 프로세스가 직접 공유** |
| **Semaphore / Mutex**      | 공유자원 접근 제어 (동기화용)           |
| **Socket**                 | 네트워크 기반 프로세스 통신             |

&ensp;이 중 공유 메모리(shared memory)는 가장 빠르고 효율적인 IPC 방식이다. 커널이 데이터를 복사하지 않고 모든 프로세스가 동일한 메모리 주소 공간 일부를 직접 접근하기 때문이다.<br/>

# shared memory 개념

&ensp; 둘 이상의 프로세스가 물리적 메모리의 일부를 공유. 가장 효율적인 IPC 기법<br/>

* 각 프로세스는 원래 고유의 논리적 주소 공간을 가지지만 공유 메모리는 여러 프로세스가 하나의 물리적 메모리 블록을 함께 사용한다.
* 한 프로세스가 메모리에 쓴 내용을 다른 프로세스가 바로 읽을 수 있으므로 데이터 복사가 필요없음 → 속도 빠름.
* 단 동기화 문제(동시에 접근 시 데이터 충돌)가 생길 수 있으므로 보통 세마포어와 함께 사용한다.

주요 생성 함수
----

# shmget() — 공유 메모리 생성

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int shmget(key_t key, size_t size, int permflag);
```

| 매개변수         | 설명                             |             |
| ------------ | ------------------------------ | ----------- |
| **key**      | 공유 메모리 식별용 키 (`ftok()` 등으로 생성) |             |
| **size**     | 메모리 크기 (바이트 단위)                |             |
| **permflag** | 접근 권한 및 생성 플래그 (예: `0600       | IPC_CREAT`) |
| **반환값**      | 공유 메모리 ID (실패 시 -1)            |             |

&ensp;반환값<br/>
&ensp;`IPC_CREAT` : 존재하지 않으면 새로 생성<br/>
&ensp;`IPC_EXCL` : 이미 존재하면 오류<br/>

&ensp;shmget() 예시<br/>
```c
shmid1=shmget(0111, 512, 0600|IPC_CREAT);  // 512byte의 문자를 저장 할 공유 메모리 생성
shmid2=shmget(0112, 10*sizeof(int), 0600|IPC_CREAT); // 10개의 정수를 저장 할 공유 메모리 생성
shmid3=shmget(0113, 5*sizeof(struct databuf), 0600|IPC_CREAT);  // struct databuf의 데이터 5개를 저장 할 공유 메모리 생성
```

# shmat() — 공유 메모리 부착

```c
void *shmat(int shmid, const void *daddr, int shmflag);
```

* shmget()으로 만든 공유 메모리를 프로세스의 주소공간에 연결하는 함수
* 커널이 관리하는 공유 영역을 프로세스의 논리적 주소공간에 붙이는 역할이다.

| 매개변수        | 설명                                |
| ----------- | --------------------------------- |
| **shmid**   | shmget()으로 얻은 공유 메모리 ID           |
| **daddr**   | 프로세스 내 부착할 주소 (NULL이면 OS가 자동 지정)  |
| **shmflag** | 읽기 전용(`SHM_RDONLY`) 또는 읽기/쓰기(`0`) |

* 반환값: 부착된 메모리의 시작 주소 포인터(실패 시 `(void *)-1` 반환)

# shmdt() — 공유 메모리 분리

```c
int shmdt(void *memptr);
```

* `shmat()` 으로 붙인 공유 메모리를 프로세스 주소 공간에서 분리(detach)
* 실제 메모리는 커널에 남아 있고 모든 프로세스가 분리하면 해제 가능
* 반환값: 0(성공), -1(실패)

&ensp;shmat() 예시<br/>
```c
buf1 = (char *)shmat(shmid1, 0, 0);  // 512byte의 문자를 저장 할 공유 메모리 생성 후 부착
buf2 = (int  *)shmat(shmid2, 0, 0);  // 10개의 정수를 저장 할 공유 메모리 생성 후 부착
buf3 = (struct databuf *)shmat(shmid3, 0, 0);  // struct databuf의 데이터 5개를 저장 할 공유 메모리 생성
```

* 각각 문자, 정수 배열, 구조체 배열용 공유 메모리를 생성하고 부착한다.
* 이후부터는 buf1, buf2, buf3 를 일반 배열처럼 사용할 수 있다.

# 공유 메모리 사용 예시

&ensp;문자 저장 예시<br/>
```c
n = read(0, buf1, 512);
write(1, buf1, n);
```

&ensp;→ 표준입력(stdin)에서 512 바이트 읽어와 공유 메모리에 쓰고, 다시 출력<br/>

&ensp;정수 배열 예시<br/>
```c
for(i=0; i<10; i++)
    scanf("%d", buf2+i);
for(i=0; i<10; i++)
    printf("%d\n", *(buf2+i));
```

&ensp;→ 입력받은 정수를 공유 메모리에 저장 후 출력<br/>

&ensp;구조체 예시<br/>
```c
for (i=0; i<5; i++)
    (buf3+i)->d_nread += 10;
for (i=0; i<5; i++)
    printf("%d ... %s", (buf3+i)->d_nread, (buf3+i)->d_buf);
```

&ensp;→ 구조체 멤버 값 수정 및 출력.<br/>
&ensp;→ 여러 프로세스가 동시에 접근 가능하므로 동기화가 중요.<br/>

# shmctl() — 제어 및 삭제

```c
int shmctl(int shmid, int command, struct shmid_ds *buf);
```

* 공유 메모리를 제어(정보 조회, 삭제 등)할 때 사용

| command      | 설명                  |
| ------------ | ------------------- |
| **IPC_STAT** | 공유 메모리 상태 조회        |
| **IPC_RMID** | 공유 메모리 제거 (커널에서 삭제) |

&ensp;예시<br/>
```c
shmctl(shmid, IPC_RMID, NULL);
```

&ensp;→ 공유 메모리를 커널에서 제거 (모든 프로세스 detach 이후 완전히 삭제)<br/>

&ensp;전체 흐름 요약<br/>
1. shmget() → 공유 메모리 영역 생성
2. shmat() → 프로세스에 연결
3. 데이터 읽기/쓰기 수행
4. shmdt() → 분리
5. shmctl(…, IPC_RMID) → 커널에서 삭제

실습 1
====

&ensp;1. 공유 메모리를 이용하는 두 개의 프로그램을 작성합니다. 프로그램 A는 scanf() 명령으로 10개의 정수를 입력받아 공유 메모리에 저장하는 작업을 10회 반복 실행합니다. 프로그램 B는 공유 메모리에 저장된 내용을 printf() 명령으로 출력하는 작업을 10회 반복 실행합니다. 이때, 프로그램 B는 프로그램 A가 정수를 쓴 후 읽어야 합니다. 이러한 동기화 작업은 signal를 사용합니다.<br/>

&ensp;프로그램 A (writer)<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <signal.h>
#include <unistd.h>

int main(void){
	int shmid1, shmid2, i, n, *buf, *pid;  // shmid1, shmid2: 공유 메모리 ID. buf,pid: 각각 정수 10개 버퍼와 상대 프로세스 PID 저장 영역에 붙은 포인터. 
	key_t key1, key2;  // key1, key2: ftok로 만든 키 값.

	key1 = ftok("key", 1);  //"key" 파일과 project-id 1로 PID용 공유메모리 키 생성
	shmid1 = shmget(key1, sizeof(int), 0600|IPC_CREAT);   // int 1개(=4바이트)짜리 세그먼트 생성/획득
	pid=(int *)shmat(shmid1, 0, 0);  // shmat으로 현재 주소공간에 attach → pid 포인터로 접근 가능

	key2 = ftok("key", 2);  // "key", project-id 2로 데이터 버퍼용 키 생성
	shmid2 = shmget(key2, 10 * sizeof(int), 0600 | IPC_CREAT);  // 정수 10개 (40바이트) 크기의 공유메모리 확보
	buf = (int *)shmat(shmid2, 0, 0);  // buf로 attach → buf[0]..buf[9]로 접근
	
	while(*pid == 0);  // 동기화(준비 대기): reader(B)가 아직 PID를 공유메모리에 쓰지 않았다면 0이다. B가 *pid=getpid(); 를 해줄 때까지 바쁜 대기로 기다린다.
	printf("writer id = %ld\n", *pid);  // 문제 요구 형식 그대로: writer id 뒤에 상대(B)의 PID 값 출력
	
	for(i=0;i<10;i++){
		scanf("%d", (buf+i));  // scanf로 A 터미널에서 정수를 입력받아 공유 버퍼의 i번째에 저장
		kill(*pid, SIGUSR1);  // 그 즉시 kill(*pid, SIGUSR1)로 B에게 신호 → B는 pause()에서 깨어나서 같은 인덱스를 출력
	}
	
	exit(0);
}
```

&ensp;프로그램 B<br/>
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <signal.h>
#include <unistd.h>

void catchsig(int n);  //빈 시그널 핸들러 선언(목적: pause() 깨우기)

int main(void){
	int shmid1, shmid2, i, n, *buf, *pid;
	key_t key1, key2;
	static struct sigaction act;   // act: sigaction 등록용 구조체
	
	act.sa_handler = catchsig;  // SIGUSR1 수신 시 동작을 catchsig로 등록
	sigaction(SIGUSR1, &act, NULL);  // 핸들러 내용은 비어 있어도 됨. 목적은 pause()를 깨우는 것
	
	key1 = ftok("key", 1); 
	shmid1 = shmget(key1, sizeof(int), 0600|IPC_CREAT);
	pid = (int *)shmat(shmid1, 0, 0);  // PID 공유메모리에 attach하고 
	
	*pid = getpid();  // 자신의 PID를 기록한다.
	
	key2 = ftok("key", 2);  
	shmid2 = shmget(key2, 10 * sizeof(int), 0600|IPC_CREAT);
	buf = (int *)shmat(shmid2, 0, 0);  // 데이터 버퍼 공유메모리에 attach → buf[0..9] 접근 가능
	
	for(i=0; i < 10; i++){
		pause();   // pause()로 시그널을 기다림(블록). A가 kill(SIGUSR1)을 보내면 catchsig가 호출되고 pause()가 즉시 반환
		printf("%d\n", buf[i]);  // 같은 인덱스 i의 값을 공유메모리에서 읽어 printf로 출력
	}
	
	shmctl(shmid1, IPC_RMID, 0);
	shmctl(shmid2, IPC_RMID, 0);
    //자원 정리: 두 공유메모리에 삭제 플래그(IPC_RMID) 설정. 다른 프로세스(예: A)가 아직 attach 중이면 상태가 dest로 보이고 마지막 attach가 해제되면 실제로 커널에서 제거됨

	exit(0);
}

void catchsig(int n){
}
```

&ensp;전체 동작 매커니즘<br/>
1. B 실행
* *pid = getpid() (PID 공유)
* SIGUSR1 핸들러 등록 + pause() 대기
2. A 실행
* `while (*pid == 0)`로 B가 PID 써주길 대기
* PID 확인 후 `writer id = ...` 출력
3. A 입력 루프(0..9)
* A: 정수 입력 → buf[i]에 저장 → kill(*pid, SIGUSR1) 보냄
* B: pause() 깨짐 → buf[i] 읽어 출력
4. 10회 완료
* B: shmctl(..., IPC_RMID)로 공유메모리 삭제 예약 → 종료
* A: 종료(커널이 detach) → 공유메모리 완전 제거

&ensp;단계별<br/>

&ensp;1) 공용 키와 공유메모리 준비<br/>
&ensp;키 생성(ftok)<br/>
* 두 프로그램 모두 같은 "key" 파일로부터 두 개의 key를 만든다.
    - `key1 = ftok("key", 1)` : PID 저장용 공유메모리(정수 1개 크기)
    - `key2 = ftok("key", 2)` : 데이터 버퍼용 공유메모리(정수 10개 크기)

&ensp;`ftok` 로 같은 경로 · 프로젝트ID를 쓰면 동일한 키 값이 나오므로 A와 B가 같은 세그먼트를 공유할 수 있다.<br/>

&ensp;공유메모리 생성/접속(shmget, shmat)<br/>
* B(reader)
    - `shmget(key1, sizeof(int), 0600|IPC_CREAT)` → PID용 4바이트 세그먼트 생성/접속
    - `pid = (int *)shmat(shmid1, 0, 0)` → 가상주소에 attach
    - `*pid = getpid();` → 자기 PID를 공유메모리에 기록 (A가 읽을 값)
    - `shmget(key2, 10*sizeof(int), ...)` / `buf = shmat(...)` → 정수 10개짜리 버퍼 attach
* A(writer)
    - 동일한 방식으로 `shmid1`, `shmid2` 에 attach해서 `pid`, `buf` 포인터를 얻는다.

&ensp;2) 동기화 전략: "공유 PID + 시그널"<br/>
&ensp;A의 준비 대기<br/>
```c
while (*pid == 0);
```

* A는 PID 공유메모리 값이 0이 아닌 시점(=B가 자신의 PID를 써 넣은 뒤)까지 바쁜 대기한다.
* 이로써 A는 시그널을 보낼 정확한 대상 PID를 확보한다.

&ensp;B의 시그널 대기<br/>
```c
act.sa_handler = catchsig;
sigaction(SIGUSR1, &act, NULL);
...
pause();
```

* B는 SIGUSR1 핸들러를 등록하고 `pause()` 로 블록된다.
* `catchsig()`는 비어 있지만, 시그널이 오면 `pause()`가 깨어난다는 게 핵심
    - 즉 핸들러는 작업이 아니라 잠에서 깨우는 트리커 역할

&ensp;3) 입출력 프로토콜(10회 루프)<br/>
&ensp;두 프로그램이 동시에 실행된 상태에서 한 사이클(반복)마다 일어나는 일:<br/>
&ensp;[A(writer) 쪽]<br/>
1. `scanf("%d", (buf+i));`
    * 사용자가 A 실행창에 입력한 정수를 공유 버퍼 `buf[i]`에 저장
2. `kill(*pid, SIGUSR1)`
    - B의 PID로 `SIGUSR1` 전송 → B의 `pause()`가 깨어남

&ensp;[B(reader) 쪽]<br/>
1. `pause()`가 SIGUSR1로 깨짐 → `catchsig()`가 호출되고 곧바로 복귀
2. `printf("%d\n", buf[i]);`
    - 같은 i 번째 인덱스의 값을 공유 버퍼에서 읽어 출력

&ensp;이렇게 해서 0~9까지 총 10회의 "쓰기→시그널→읽기→출력" 이 순서대로 진행된다. 동기화의 본질은 "A가 쓰고 나서 시그널을 보낸다. → B는 시그널을 받고 나서 읽는다" 는 점<br/>

&ensp;4) 출력 형식과 의미<br/>
&ensp;A<br/>
```c
printf("writer id = %ld\n", *pid);
```

* 문제 요구대로 writer id라는 문구 뒤에 B의 PID 값(= 공유메모리에 저장된 값)을 long 형식으로 출력한다.
* 실제로는 "리더의 PID가 누구냐"를 보여주는 디버그/확인 메시지의 느낌

&ensp;B<br/>
```c
printf("%d\n", buf[i]);
```

* 매 시그널마다 A가 방금 쓴 정수 값을 출력한다.

&ensp;5) 종료와 자원 정리<br/>
&ensp;B는 10번 출력 후<br/>
```c
shmctl(shmid1, IPC_RMID, 0);
shmctl(shmid2, IPC_RMID, 0);
```

* 두 공유메모리에 삭제 플래그(IPC_RMID)를 건다. 
* 이때 아직 프로세스가 attach 중이면 상태가 `dest`로 표시되고 전부 detach되면 커널에서 실제 해제된다.

&ensp;A는 입력/시그널 전송을 10번 마치면 `shmdt` 없이 `exit(0)` <br/>
* 커널이 프로세스 종료 시 자동 detach 처리
* B가 이미 IPC_RMID를 해놨다면 A가 종료되어 마지막 attach가 해제되는 순간 세그먼트가 완전히 제거된다.

&ensp;이 구조에서 중요한 포인트<br/>
* 반드시 B 먼저 실행: 그래야 A가 `while(*pid==0)`에서 멈추지 않는다.
* 과거에 잘못 만든 공유메모리가 남아 있으면(`ipcs -m` 에 나타남)
    - 크기가 틀린 세그먼트(예: key2를 sizeof(int)로 만든 것)가 남아 있으면 A/B가 `buf[0..9]` 접근 시 세그폴트 난다.
    - `ipcrm -m <shmid>`로 지우되 dest인 경우는 attach 중인 프로세스를 먼저 종료해야 완전히 사라진다. 
* `catchsig()`는 빈 함수여도 됨: 목적은 `pause()`를 깨우는 것

&ensp;한눈 요약<br/>
* key1(4바이트) : B가 자기 PID를 써놓고, A는 그 PID가 0이 아니게 될 때까지 대기.
* key2(40바이트) : 정수 10개 버퍼. A가 buf[i]에 쓰고 B는 시그널 받고 buf[i] 읽음.
* 동기화: "A가 kill(SIGUSR1) → B의 pause 해제 → B가 즉시 읽고 출력"
* 종료: B가 IPC_RMID 요청, 프로세스 detach 완료 시 커널이 세그먼리 완전 제거.