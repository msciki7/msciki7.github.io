---
title: "Lect11. 시스템의 V의 프로세스간 통신"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-06
last_modified_at: 2025-11-06
---

IPC 기본 개념
=====

&ensp;IPD(Inter-Process-Communication): 서로 다른 프로세스들이 데이터를 주고받기 위한 방법<br/>
* Message Queue (메시지 큐)
* Shared Memory (공유 메모리)
* Semaphore (세마포어)

&ensp;이 세 가지는 전부 커널 공간에 생성되는 IPC 객체를 통해 작동한다. → 그래서 "key"값으로 각 객체를 구분해야 함<br/>

&ensp;IPC 설비— key 생성과 역할<br/>
&ensp;key란?<br/>
* `message_queue`, `semaphore`, `shared memory segment`를 식별하는 고유한 값
* IPC 객체의 파일 이름과 같은 역할
* 여러 프로세스가 동일한 key값을 쓰면 같은 IPC 객체를 공유

IPC 관련 함수 
====

&ensp;Key 생성 함수<br/>
```c
#include <sys/ipc.h>

key_t ftok(const char *path, int id);
```

&ensp;매커니즘<br/>
* `ftok()`는 특정 파일 경로(path)와 정수 id를 합쳐서 유니크한 key값을 만들어줌.
* 내부적으로 이 파일의 st_dev(디바이스 ID), st_ino(inode 번호) 그리고 id를 조합해서 key를 생성함
* 반환값은 key_t 타입
* 첫 번째 인자로 주는 파일은 반드시 실제 존재해야 함 → 존재하지 않으면 키 생성 실패

&ensp;예시<br/>
```c
key_t key = ftok("myfile", 1);
```

* myfile의 inode 번호와 디바이스 번호, 그리고 1이 합쳐져 unique key 생성
* 이 key로 message queue나 shared memory를 식별

&ensp;IPC 객체 상태 구조체<br/>
&ensp;ICP 객체(큐, 세그먼트 등)는 커널이 관리하고 그 상태를 나타내는 구조체가 있다.<br/>
```c
struct ipc_perm {
    uid_t cuid;  // 생성자의 UID
    gid_t cgid;  // 생성자의 GID
    uid_t uid;   // 소유자의 UID
    gid_t gid;   // 소유자의 GID
    mode_t mode; // 접근 권한 (rwx 중 x는 의미 없음)
};
```

* 파일의 접근 권한과 유사한 구조
* permission은 0666 같은 식으로 설정 가능 (read/write만 의미 있음)

&ensp;IPC 객체 확인 및 삭제 명령어<br/>
&ensp;IPC 정보 확인<br/>
```bash
$ ipcs
```

* 시스템 내의 모든 IPC 객체(message queue, shared memory, semaphore) 정보를 확인 가능

&ensp;IPC 객체 삭제<br/>
```bash
$ ipcrm -m shmid   # 공유 메모리 삭제
$ ipcrm -q msqid   # 메시지 큐 삭제
$ ipcrm -s semid   # 세마포어 삭제
```

* 각각의 IPC id를 이용해서 수동으로 제거할 수 있음

message passing (메시지 큐)
=====

&ensp;메시지 큐는 프로세스 간 메시지를 FIFO로 주고받는 방식(커널이 큐 형태로 메시지를 관리)<br/>

&ensp;주요 함수 3개<br/>

# `msgget()` — 메시지 큐 생성
```c
#include <sys/msg.h>

int msgget(key_t key, int permflags);
```

&ensp;인자 설명<br/>

| 인자          | 설명                                                     |
| ----------- | ------------------------------------------------------ |
| `key`       | message queue의 식별 key 값 (`ftok()`으로 생성)                |
| `permflags` | 접근 권한과 생성 옵션을 합친 값 (`IPC_CREAT`, `IPC_EXCL`, `0666` 등) |

&ensp;작동 메커니즘<br/>
1. 커널에 `key`로 식별되는 큐가 이미 있으면 → 그 큐의 식별자 반환
2. 없으면 → `IPC_CREAT` 플래그가 있을 때 새로 생성
3. `IPC_EXCL` 플래그가 추가되면, 큐가 이미 존재할 경우 오류(-1) 반환 → "첫 번째로 만든 프로세스"를 구분할 때 유용

* msgget(key, IPC_CREAT | 0666) → 존재하면 열기, 없으면 새로 생성

&ensp;예시<br/>
```c
key_t key = ftok("file", 1);
int msqid = msgget(key, IPC_CREAT | 0666);
```

&ensp;리턴값: 큐의 식별자(msqid, 음수가 아님)<br/>
&ensp;실패 시: -1(errno에 이유 저장)<br/>


# `msgsnd()` — 메시지 보내기
```c
#include <sys/msg.h>

int msgsnd(int msqid, const void *message, size_t size, int flags);
```

&ensp;인자 설명<br/>

| 인자        | 설명                           |
| --------- | ---------------------------- |
| `msqid`   | 메시지 큐 식별자 (`msgget`에서 반환된 값) |
| `message` | 보낼 메시지가 저장된 구조체의 주소          |
| `size`    | 메시지의 크기 (`mtext` 부분만)        |
| `flags`   | `IPC_NOWAIT` 설정 시 비동기 전송     |

&ensp;작동 메커니즘<br/>
* 큐가 꽉 찬 상태에서 
  - `IPC_NOWAIT` 설정 시 → 즉시 실패하고 -1 반환
  - 설정 안 했을 시 → 큐가 비워질 때까지 blocking

&ensp;메시지 구조체 예시<br/>
```c
struct mymsg {
    long mtype;          // 메시지 타입 (양의 정수)
    char mtext[100];     // 메시지 본문
};
```
* mtype은 양의 정수여야 함 (0 또는 음수면 실패)
* msgsnd(qid, &msg, sizeof(int), 0) → mtype은 포함하지 않음
* 메시지는 큐에 쌓이고, 프로세스 종료해도 데이터 유지됨 (파이프와 차이점)
* `mtype`은 수신자 구분용 (프로세스가 어떤 종류의 메시지만 받을지 결정)
* `mtext`는 실제 데이터

&ensp;예시<br/>
```c
struct mymsg msg;
msg.mtype = 1;
strcpy(msg.mtext, "hello");
msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
```

&ensp;리턴값: 0(성공)<br/>
&ensp;실패 시: -1<br/>

# `msgrcv()` — 메시지 받기

```c
#include <sys/msg.h>

int msgrcv(int msqid, void *message, size_t size, long msg_type, int flags);
```

&ensp;인자 설명<br/>

| 인자         | 설명                                     |
| ---------- | -------------------------------------- |
| `msqid`    | 큐 식별자                                  |
| `message`  | 수신된 메시지를 저장할 구조체 주소                    |
| `size`     | 저장할 버퍼 크기 (`mtext` 부분 크기)              |
| `msg_type` | 수신할 메시지 타입 지정                          |
| `flags`    | 수신 동작 제어 (`IPC_NOWAIT`, `MSG_NOERROR`) |

&ensp;`msg_type`의 의미<br/>

| msgtyp 값 | 의미                          |
| -------- | --------------------------- |
| 0        | 큐의 첫 번째 메시지 수신              |
| 양수 n     | mtype == n 인 메시지 수신         |
| 음수 -n    | mtype ≤ n 중 가장 작은 타입 메시지 수신 |

&ensp;필요한 타입만 골라서 받을 수 있다.<br/>

&ensp;`flags` 옵션<br/>

| flag          | 의미                                 |
| ------------- | ---------------------------------- |
| `IPC_NOWAIT`  | 메시지가 없으면 즉시 -1 반환 (`errno=EAGAIN`) |
| `MSG_NOERROR` | 수신 버퍼가 작으면 초과분을 잘라냄                |

&ensp;동작 원리<br/>
1. 큐에서 지정된 타입(msg_type)의 메시지를 검색
2. 없으면 → blocking 또는 즉시 리턴 (flag에 따라 다름)
3. 있으면 → 메시지를 복사 후 큐에서 삭제

&ensp;예시:<br/>
```c
struct mymsg msg;
msgrcv(msqid, &msg, sizeof(msg.mtext), 1, 0);
printf("Received: %s\n", msg.mtext);
```

&ensp;리턴값: 성공 시 받은 메시지 길이<br/>
&ensp;실패 시: -1(errno에 EACCESS, EAGAIN, ENOMSG 등 저장)<br/>

&ensp;전체 메시지 큐 동작 요약<br/>

| 단계 | 함수               | 역할         |
| -- | ---------------- | ---------- |
| 1  | `ftok()`         | 고유한 key 생성 |
| 2  | `msgget()`       | 큐 생성 또는 접근 |
| 3  | `msgsnd()`       | 메시지 전송     |
| 4  | `msgrcv()`       | 메시지 수신     |
| 5  | `ipcs` / `ipcrm` | 큐 확인 / 삭제  |

&ensp;message 송수신 예제 코드 설명<br/>
```c
struct q_entry {
    long mtype;
    int mnum;
};
struct q_entry msg;

qid = msgget(0111, 0600 | IPC_CREAT);

while (msgrcv(qid, &msg, sizeof(int), 1, 0) > 0) {
    msg.mtype = 2;
    msg.mnum = msg.mnum + 8;
    msgsnd(qid, &msg, sizeof(int), 0);
}
```

&ensp;코드 흐름 설명<br/>
&ensp;1. `struct q_entry` 정의<br/>
* 메시지 구조체는 항상 첫 필드가 long mtype 이어야 함. (커널이 메시지 타입을 구분하기 때문)
* int mnum은 실제 데이터

```c
struct q_entry {
    long mtype;  // 메시지 타입
    int mnum;    // 메시지 내용 (정수)
};
```

&ensp;2. 큐 생성<br/>
```c
qid = msgget(0111, 0600 | IPC_CREAT);
```

* key: `0111` (8진수)
* 권한: `0600` → 소유자만 read/write 가능
* `IPC_CREAT`: 큐가 없으면 생성

&ensp;반환값: 메시지 큐 식별자 (음수가 아니면 성공)<br/>

&ensp;메시지 수신 (`msgrcv`)<br/>
```c
msgrcv(qid, &msg, sizeof(int), 1, 0);
```

* `qid`: 큐 식별자
* `&msg`: 수신할 메시지 구조체 주소
* `sizeof(int)`: 데이터 크기 (mnum만 포함)
* `1`: 수신할 메시지 타입 (mtype = 1인 메시지만 받음)
* `0`: blocking 모드 (없으면 기다림)

&ensp;타입이 1인 메시지를 기다리며 큐에서 꺼냄<br/>

&ensp;4. 메시지 가공<br/>
```c
msg.mtype = 2;
msg.mnum = msg.mnum + 8;
```

&ensp;받은 메시지를 수정해서<br/>
&ensp;→ mnum에 +8<br/>
&ensp;→ mtype을 2로 바꿔 응답 타입으로 전송할 준비<br/>

&ensp;메시지 전송 (msgsnd)<br/>
```c
msgsnd(qid, &msg, sizeof(int), 0);
```

* 같은 큐(`qid`)로 다시 메시지를 보냄
* 이번엔 `mtype = 2` → 수신자는 `mtype = 2`를 받을 수 있음
* blocking 모드 (큐가 가득 차면 대기)

&ensp;전체 동작 정리<br/>
1. 타입 1 메시지를 받음
2. 데이터에 +8 한 뒤
3. 타입 2 메시지로 재전송

&ensp;받은 값을 8 더해서 되돌려주는 서버 역할을 하는 프로세스 예제이다.<br/>

# `msgctl()` — 메시지 큐 제어

```c
#include <sys/msg.h>

int msgctl(int msqid, int command, struct msqid_ds *buf);
```

&ensp;인자 설명<br/>

| 인자        | 설명                                         |
| --------- | ------------------------------------------ |
| `msqid`   | 메시지 큐 식별자                                  |
| `command` | 수행할 명령 (`IPC_STAT`, `IPC_RMID`, `IPC_SET`) |
| `buf`     | 큐의 상태 정보를 담거나 변경할 구조체 주소                   |

&ensp;주요 명령어<br/>

| 명령         | 설명                            |
| ---------- | ----------------------------- |
| `IPC_STAT` | 큐의 상태 정보를 얻음 (커널 → 사용자 영역 복사) |
| `IPC_RMID` | 큐를 커널에서 완전히 삭제                |
| `IPC_SET`  | 사용자가 수정한 권한(mode 등)을 커널에 반영   |

* IPC_STAT → 큐 상태 확인 (큐 안 메시지 개수, 최근 송수신 PID 등)
* IPC_RMID → 큐 삭제 (실습 중 ipcrm -q <id> 명령과 동일)

&ensp;예시<br/>
```c
struct msqid_ds info;
msgctl(msqid, IPC_STAT, &info);
printf("Number of messages: %ld\n", info.msg_qnum);
```

&ensp;`msqid_ds` 구조체 상세<br/>
```c
struct msqid_ds {
    struct ipc_perm msg_perm; // 접근 권한 정보
    msgqnum_t msg_qnum;       // 현재 큐에 저장된 메시지 개수
    msglen_t msg_qbytes;      // 큐에 허용된 최대 바이트 수
    pid_t msg_lspid;          // 마지막으로 보낸 프로세스의 PID
    pid_t msg_lrpid;          // 마지막으로 받은 프로세스의 PID
    time_t msg_stime;         // 마지막 송신 시각
    time_t msg_rtime;         // 마지막 수신 시각
    time_t msg_ctime;         // 마지막 변경 시각 (생성 또는 제어)
};
```

&ensp;각 필드 의미<br/>

| 필드           | 설명                         |
| ------------ | -------------------------- |
| `msg_perm`   | `ipc_perm` 구조체 (소유자/권한 정보) |
| `msg_qnum`   | 현재 큐 안의 메시지 개수             |
| `msg_qbytes` | 큐에 저장 가능한 최대 byte 수        |
| `msg_lspid`  | 마지막으로 메시지를 보낸 프로세스 PID     |
| `msg_lrpid`  | 마지막으로 메시지를 받은 프로세스 PID     |
| `msg_stime`  | 마지막 송신 시간                  |
| `msg_rtime`  | 마지막 수신 시간                  |
| `msg_ctime`  | 마지막으로 큐 속성이 바뀐 시간          |

| 함수         | 역할      | 주요 인자                          | 비고                  |
| ---------- | ------- | ------------------------------ | ------------------- |
| `msgget()` | 큐 생성/접근 | key, flags                     | IPC_CREAT, IPC_EXCL |
| `msgsnd()` | 메시지 전송  | msqid, struct msg*, size       | 큐에 메시지 push         |
| `msgrcv()` | 메시지 수신  | msqid, struct msg*, size, type | 큐에서 pop             |
| `msgctl()` | 큐 제어    | msqid, command, buf            | 상태확인/삭제             |
