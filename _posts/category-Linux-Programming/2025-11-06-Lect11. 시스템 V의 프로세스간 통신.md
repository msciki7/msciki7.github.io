---
title: "Lect11. 시스템의 V의 프로세스간 통신"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-11-06
last_modified_at: 2025-11-06
---

IPC 기본 개념
=====

&ensp;IPD(Inter-Process-Communication): 서로 다른 프로세스들이 데이터를 주고받기 위한 방법<br/>
* Message Queue (메시지 큐)
* Shared Memory (공유 메모리)
* Semaphore (세마포어)

&ensp;이 세 가지는 전부 커널 공간에 생성되는 IPC 객체를 통해 작동한다. → 그래서 "key"값으로 각 객체를 구분해야 함<br/>

&ensp;IPC 설비— key 생성과 역할<br/>
&ensp;key란?<br/>
* `message_queue`, `semaphore`, `shared memory segment`를 식별하는 고유한 값
* IPC 객체의 파일 이름과 같은 역할
* 여러 프로세스가 동일한 key값을 쓰면 같은 IPC 객체를 공유

IPC 관련 함수 
====

&ensp;Key 생성 함수<br/>
```c
#include <sys/ipc.h>

key_t ftok(const char *path, int id);
```

&ensp;매커니즘<br/>
* `ftok()`는 특정 파일 경로(path)와 정수 id를 합쳐서 유니크한 key값을 만들어줌.
* 내부적으로 이 파일의 st_dev(디바이스 ID), st_ino(inode 번호) 그리고 id를 조합해서 key를 생성함
* 반환값은 key_t 타입

&ensp;예시<br/>
```c
key_t key = ftok("myfile", 1);
```

* myfile의 inode 번호와 디바이스 번호, 그리고 1이 합쳐져 unique key 생성
* 이 key로 message queue나 shared memory를 식별

&ensp;IPC 객체 상태 구조체<br/>
&ensp;ICP 객체(큐, 세그먼트 등)는 커널이 관리하고 그 상태를 나타내는 구조체가 있다.<br/>
```c
struct ipc_perm {
    uid_t cuid;  // 생성자의 UID
    gid_t cgid;  // 생성자의 GID
    uid_t uid;   // 소유자의 UID
    gid_t gid;   // 소유자의 GID
    mode_t mode; // 접근 권한 (rwx 중 x는 의미 없음)
};
```

* 파일의 접근 권한과 유사한 구조
* permission은 0666 같은 식으로 설정 가능 (read/write만 의미 있음)

&ensp;IPC 객체 확인 및 삭제 명령어<br/>
&ensp;IPC 정보 확인<br/>
```bash
$ ipcs
```

* 시스템 내의 모든 IPC 객체(message queue, shared memory, semaphore) 정보를 확인 가능

&ensp;IPC 객체 삭제<br/>
```bash
$ ipcrm -m shmid   # 공유 메모리 삭제
$ ipcrm -q msqid   # 메시지 큐 삭제
$ ipcrm -s semid   # 세마포어 삭제
```

* 각각의 IPC id를 이용해서 수동으로 제거할 수 있음

message passing (메시지 큐)
=====

&ensp;메시지 큐는 프로세스 간 메시지를 FIFO로 주고받는 방식(커널이 큐 형태로 메시지를 관리)<br/>

&ensp;주요 함수 3개<br/>
&ensp;1. `msgget()` - 메시지 큐 생성<br/>
```c
#include <sys/msg.h>

int msgget(key_t key, int permflags);
```

* key: ftok()로 생성한 키값
* permflags: 접근 권한과 생성 옵션을 합친 값 (IPC_CREAT, IPC_EXCL, 0666 등)
* 반환: 메시지 큐의 식별자(msqid)


&ensp;작동 매커니즘<br/>
1. 커널에 key로 식별되는 큐가 이미 있으면 → 그 큐의 식별자 반환
2. 없으면 → IPC_CREAT 플래그가 있을 때 새로 생성
3. `IPC_EXCL` 플래그가 추가되면 큐가 이미 존재할 경우 오류(-1) 반환

&ensp;예시<br/>
```c
key_t key = ftok("file", 1);
int msqid = msgget(key, IPC_CREAT | 0666);
```

&ensp;리턴값: 큐의 식별자(msqid, 음수가 아님)<br/>
&ensp;→ 없으면 새로 만들고, 있으면 기존 큐를 사용<br/>

&ensp;2. `msgsnd()` - 메시지 전송<br/>
```c
#include <sys/msg.h>

int msgsnd(int msqid, const void *message, size_t size, int flags);
```

* msqid: 메시지 큐 식별자
* message: 보낼 메시지 구조체의 포인터
* size: 메시지의 실제 크기 (type 제외)
* flags: 0 또는 IPC_NOWAIT

&ensp;메시지 구조체는 일반적으로 이렇게 정의됨<br/>
```c
struct msgbuf {
    long mtype;      // 메시지 타입 (1 이상)
    char mtext[100]; // 실제 메시지 내용
};
```

&ensp;작동 매커니즘<br/>
* 큐가 꽉 찬 상태에서
  - IPC_NOWAIT 설정 시 → 즉시 실패하고 -1 반환
  - 설정 안 했을 시 → 큐가 비워질 때까지 blocking


&ensp;예시<br/>
```c
struct msgbuf msg;
msg.mtype = 1;
strcpy(msg.mtext, "hello");
msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
```

&ensp;리턴값: 0(성공), -1(실패)<br/>

&ensp;3. `msgrcv()` - 메시지 수신<br/>
```c
#include <sys/msg.h>

int msgrcv(int msqid, void *message, size_t size, long msg_type, int flags);
```

* msqid: 큐 식별자
* message: 보낼 메시지가 저장된 구조체의 주소
* size: 보낼 버퍼 크기 (mtext 부분 크기)
* flags: 수신 동작 제어 (IPC NOWAIT, MSG_NOERROR)

&ensp;작동 매커니즘<br/>
* 큐가 꽉 찬 상태에서
  - IPC_NOWAIT 설정 시 → 즉시 실패하고 -1 반환



&ensp;예시<br/>
```c
struct msgbuf msg;
msgrcv(msqid, &msg, sizeof(msg.mtext), 1, 0);
printf("Received: %s\n", msg.mtext);
```

&ensp;전체 흐름 요약<br/>
1. key 생성: `key = ftok("파일이름", 정수id);`
2. 큐 생성: `msqid = msgget(key, IPC_CREAT | 0666);`
3. 보내기: `msgsnd(msqid, &msg, sizeof(msg.mtext), 0);`
4. 받기: `msgrcv(msqid, &msg, sizeof(msg.mtext), 1, 0);`
5. 확인/삭제 (shell): `$ ipcs, $ ipcrm -q msqid`

