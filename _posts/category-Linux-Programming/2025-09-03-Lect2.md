---
title: "2장 디렉터리 다루기"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true

date: 2025-09-03
last_modified_at: 2025-09-03
---

핵심
=======

* 리눅스에서 모든 것은 파일처럼 다룬다.(일반파일, 디렉터리, 장치, 링크...)
* 디렉터리는 "폴더" = 파일들의 목록/주소록
* 새 디럭터리는 mkdir, 빈 디렉터리 삭제는 rmdir, 내용이 있으면 rm -r
* C에서 만들 땐 mkdir(path, mode)/삭제는 rmdir(path)를 쓴다.
* 디렉터리는 자동으로 .(현재), ..(상위) 항목을 가진다.
* 권한 0755, 0644 같읕 숫자는 rwx 권한을 숫자로 적은 것

파일의 종류
=======

&ensp;일반 파일: 텍스트 파일(txt), 실행파일(a.out), 이미지 파일(jpg)<br/>
&ensp;특수 파일: 통신, 터미널, 디스크 등의 장치 사용에 연관된 특수 파일<br/>
&ensp;디렉터리 파일: 디렉터리도 파일 취급<br/>
&ensp;파일의 종류 식별 문자<br/>

<p align="center"><img src="/assets/img/Linux Programming/Lect2/2-1.png" width="600"></p>

* p: FIFO/파이프(프로그램끼리 데이터 주고받기 통로)
* s: 소켓(네트워크 통신용 "구멍")

<p align="center"><img src="/assets/img/Linux Programming/Lect2/2-2.png" width="600"></p>

directory 생성과 삭제
=======

&ensp;리눅스에서는 디렉터리를 직접 만들거나 삭제할 수 있다.<br/>

directory 생성
------

&ensp;directory file에 .과 ..을 넣어서 생성한다.<br/>
&ensp;리눅스에서 디렉터리(폴더)는 사실 이름표 목록(주소록)이다. 새 디렉터리를 만들면 파일시스템이 자동으로 두 개의 기본 항목을 넣는다.:<br/>
* . : 자기 자신(그 디렉터리 본인)을 가리키는 항목
* .. : 부모(상위)디렉터리를 가리키는 항목

&ensp;이 둘은 사용자가 만들거나 지우는 게 아니고 파일 시스템이 규칙상 항상 넣어 두는 길표시이다. 그래서 새로 만든 폴더를 자세히 보면 이렇게 보인다.<br/>'

```bash
mkdir demo
ls -la demo
# 출력 예시
# drwx------  2 me me  …  .
# drwxr-xr-x 20 me me  …  ..
```

* 첫 줄의 . 가 demo 본인
* 둘째 줄의 .. 가 demo의 부모 를 가리킵니다.

&ensp;왜 필요한가? > 상대경로 이동(cd ., cd ..), 내부 탐색(프로그램이 디렉터리 안을 순회) 등에 필수 기준점이다. 방을 만들면 “나가는 문(..)”과 “내 표지(.)”를 자동으로 붙여주는 느낌이라고 생각하면 된다.<br/>

directory 삭제
--------

&ensp;rmdir는 “폴더가 완전히 비어 있을 때만” 삭제되는 안전한 삭제 명령이에요.
여기서 비어 있음의 기준은 .와 ..만 존재한다는 뜻입니다. 즉, 그 외의 어떤 파일/폴더도 없어야 해요.<br/>

&ensp;왜 이렇게 제한할까?<br/>
* 실수로 내용물까지 통째로 날리는 사고를 막기 위한 보호장치이다.
* 그래서 내용이 조금이라도 있으면 rmdir는 실패하고 보통 이렇게 말한다.: rmdir: failed to remove 'demo': Directory not empty

```bash
mkdir demo
rmdir demo            # ✅ 성공 (아무것도 없으니까)

mkdir demo
touch demo/a.txt
rmdir demo            # ❌ 실패: Directory not empty
rm demo/a.txt
rmdir demo            # ✅ 성공
```

&ensp;참고: .으로 시작하는 숨김파일이 있어도 내용물로 간주된다. 정말 비었는지 빠르게 확인하려면<br/>

```bash
ls -A demo
# 아무것도 안 나오면 비어 있음( . 와 .. 은 -A 에서 표시되지 않음 )
```

&ensp;그럼 내용이 있는 폴더는 어떻게 지울까? > 정말로 폴더 안의 모든 것까지 지우려면 재귀 삭제를 써야 한다.<br/>
```bash
rm -r demo    # 하위까지 전부 삭제 (매우 주의!)
rm -rf demo   # 묻지 않고 강제 삭제 (더더욱 주의!!)
```

* rmdir는 안전하고 제한적
* rm -r는 강력하지만 위협 - 항상 pwd, ls로 위치를 다시 확인한 뒤 사용해야 한다.

&ensp;directory 삭제와 생성이 성공하면 return 값으로 0을 돌려주고 실패하면 -1로 돌려준다.<br/>
* 0(성공)
* -1(실패)

&ensp;C프로그램에서 사용<br/>
```bash
#include <sys/stat.h>
#include <sys/types.h>
int mkdir(const char *pathname, mode_t mode);  // 디렉터리 생성
#include <unistd.h>
int rmdir(const char *pathname);               // 디렉터리 삭제
```

&ensp;1) #include <sys/stat.h> / #include <sys/types.h><br/>
&ensp;이 헤더 파일들은 파일/디렉터리 관련 시스템 호출을 사용하기 위해 필요하다.<br/>
* sys/types.h: mode_t, pid_t, size_t 같은 자료형 정의
* sys/stat.h: mkdir(), chmod(), stat() 같은 파일 속성 관련 함수 원형 포함

&ensp;즉, mkdir() 같은 함수를 쓰려면 꼭 포함해야 하는 헤더예요.<br/>

&ensp;2) int mkdir(const char *pathname, mode_t mode);<br/>
&ensp;역할<br/>
* 디렉터리를 생성하는 함수
* 첫 번째 인자: pathname -> 새로 만들 디렉터리 이름(문자열, 경로 포함 가능)
* 두 번째 인자: mode -> 디렉터리 권한(퍼미션, 예: 0700, 0755)

&ensp;반환값<br/>
* 0 → 성공
* -1 → 실패 (이때 errno에 원인 저장됨: 이미 있음(EEXIST), 권한 없음(EACCES), 경로 없음(ENOENT) 등)

&ensp;3) #include <unistd.h><br/>
&ensp;이 헤더는 POSIX(유닉스 표준) API 함수들이 들어있다.<br/>
* 파일/디렉터리 조작: rmdir(), chdir(), getcwd()
* 프로세스 관련: fork(), exec()
* 저수준 입출력: read(), write() 등

&ensp;4) int rmdir(const char *pathname);<br/>
* 디렉터리를 삭제하는 함수
* 인자: pathname → 지울 디렉터리 이름

&ensp;반환값<br/>
* 0 → 성공
* -1 → 실패 (이때 errno에 원인 저장됨: 이미 있음(EEXIST), 권한 없음(EACCES), 경로 없음(ENOENT) 등)

&ensp;5) 실제 동작 흐름 정리<br/>
1. mkdir("demo", 0700) → demo라는 새 폴더 생성
  - 내부적으로 자동으로 .(자기 자신)과 ..(부모) 항목 추가됨
2. mdir("demo") → demo 삭제 시도
  - 내부가 .과 ..만 있으면 성공
  - 파일/폴더가 있으면 실패 (ENOTEMPTY)

<p align="center"><img src="/assets/img/Linux Programming/Lect2/2-3.png" width="600"></p>

파일/디렉터리 모드(퍼미션, 권한)
=======

&ensp;리눅스의 모든 파일과 디렉터리에는 접근 권한이 있다. 이 권한은 세 그룹으로 나눈다.<br/>
* 소유자(owner) → 파일을 만든 사람
* 그룹(group) → 같은 팀/조직에 속한 사용자
* 기타(others) → 나머지 모든 사용자

&ensp;각 그룹은 세 가지 권한을 가진다.<br/>
* 읽기(read) = 4
* 쓰기(write) = 2
* 실행(execute) = 1

&ensp;예시: 0764 = 0400 + 0200 + 0100 + 0040 + 0020 + 0004<br/> 
* 7 (소유자) = 4+2+1 = rwx (읽기/쓰기/실행 가능)
* 6 (그룹) = 4+2 = rw- (읽기/쓰기 가능)
* 4 (기타) = 4 = r-- (읽기만 가능)

&ensp;즉, chmod 764 파일명 하면 소유자는 모든 권한, 그룹은 읽기/쓰기, 나머지는 읽기만 가능하게 설정된다.<br/>

getcwd()-현재 작업 디렉터리 확인
======

&ensp;pwd 명령어와 같은 역할을 하는 C 함수이다.<br/>
```cpp
#include <unistd.h>
char *getcwd(char *buf, size_t size);
```

* buf : 경로 이름을 저장할 공간 (문자 배열)
* size: 공간 크기 (경로 길이 + 1)
* 반환값: 성공하면 현재 경로 문자열을 반환, 실패하면 NULL

&ensp;예제<br/>
```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
    char path[1024];
    if (getcwd(path, sizeof(path)) != NULL) {
        printf("현재 경로: %s\n", path);
    } else {
        perror("getcwd 실패");
    }
    return 0;
}
```

rename()-파일/디렉터리 이름 바꾸기
======

&ensp;mv 명령과 같은 기능을 C에서 제공한다.<br/>

```cpp
#include <stdio.h>
int rename(const char *oldpath, const char *newpath);
```

* file, directory 둘 다 rename 가능
* oldpath: 기존 이름
* newpath: 바꿀 이름
* 성공하면 0, 실패하면 -1
* newpath가 이미 있어도 에러가 아니라, 기존 파일을 지우고 새 이름을 붙여버린다.(그래서 기존 file을 제거하고 새 이름을 부여해야 한다.)

&ensp;예제<br/>
```cpp
#include <stdio.h>

int main() {
    if (rename("old.txt", "new.txt") == 0) {
        printf("파일 이름 변경 성공\n");
    } else {
        perror("rename 실패");
    }
    return 0;
}
```

chdir() — 작업 디렉터리 변경
======

&ensp;cd 명령어와 같은 기능이다.<br/>
```cpp
#include <unistd.h>
int chdir(const char *path);
```

* path: 이동할 경로
* 성공하면 0, 실패하면 -1

&ensp;예제<br/>
```cpp
fd1 = open("/usr/ben/abc", O_RDONLY);
fd2 = open("/usr/ben/xyz", O_RDWR);

chdir("/usr/ben");   // 작업 디렉터리를 /usr/ben 으로 변경

fd1 = open("abc", O_RDONLY);
fd2 = open("xyz", O_RDWR);
```

* 원래는 파일을 열 때 전체 경로(/usr/ben/abc)를 써야 했는데,
* hdir("/usr/ben")로 한 번 이동하면 앞으로는 상대경로(abc, xyz)만 써도 된다.

&ensp;즉 현재 위치를 옮겨서 경로를 더 간단히 쓸 수 있게 해주는 함수이다.<br/>

&ensp;정리<br/>
<p align="center"><img src="/assets/img/Linux Programming/Lect2/2-5.png" width="600"></p>

directory 열기와 닫기
=====

&ensp;opendir()<br/>
```cpp
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char *dirname);
```

* 역할: 디렉터리를 여는 함수 (책을 펼치는 것과 같음)
* 인자: dirname → 열고 싶은 디렉터리 이름
* 반환값: 성공하면 DIR* 포인터(책갈피), 실패하면 NULL

&ensp;closedir()<br/>
```cpp
#include <sys/types.h>
#include <dirent.h>

int closedir(DIR *dirptr);
```

* 역할: 디렉터리 닫기 (책을 덮는 것과 같음)
* 인자: opendir()로 얻은 DIR*
* 반환값: 성공 0, 실패 -1

디렉터리 읽기
======

&ensp;readdir()<br/>
```cpp
#include <sys/types.h>
#include <dirent.h>

struct dirent *readdir(DIR *dirptr);
```

* 역할: 디렉터리 안의 항목(파일/폴더) 하나를 읽음
* 반환값: 성공하면 struct dirent* (이 안에 파일 이름이 들어있음), 더 이상 없으면 NULL

&ensp;struct dirent 구조체 주요 필드:<br/>
```cpp
struct dirent {
    ino_t d_ino;        // 아이노드 번호 (파일 고유 번호)
    char  d_name[256];  // 파일/디렉터리 이름
};
```

* 반환값:
  - 성공 → 해당 항목 구조체 포인터
  - 끝까지 읽으면 → NULL

&ensp;readdir()는 한 번 호출할 때마다 다음 항목으로 자동 이동한다.<br/>
&ensp;반복문으로 호출하면 디렉터리 내용을 전부 읽을 수 있다.<br/>

&ensp;예제<br/>
```cpp
#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *dir;
    struct dirent *entry;

    dir = opendir(".");   // 현재 디렉터리 열기
    if (dir == NULL) {
        perror("opendir 실패");
        return 1;
    }

    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
    }

    closedir(dir);
    return 0;
}
```

<p align="center"><img src="/assets/img/Linux Programming/Lect2/2-4.png" width="600"></p>

directory file pointer 이동
======

&ensp;디렉터리도 책처럼 “읽는 위치”가 있어요. 이 위치를 옮기거나 확인할 수 있습니다.<br/>

&ensp;rewinddir()<br/>
```cpp
void rewinddir(DIR *dirptr);
```

* 읽기 위치를 맨 앞으로 되돌림
* 즉, 다시 처음부터 readdir()할 수 있음

&ensp;telldir()<br/>
```cpp
long telldir(DIR *dirptr);
```

* 현재 읽기 위치(오프셋)를 알려줌

&ensp;seekdir()<br/>
```cpp
void seekdir(DIR *dirptr, long loc);
```

* telldir()로 얻은 위치로 이동
* 원하는 지점부터 다시 읽을 수 있음

&ensp;rewinddir()은 책의 첫 페이지로 돌아가기, telldir()/seekdir()은 책갈피 꽂아두고 다시 찾기라고 이해하면 된다.<br/>

&ensp;정리<br/>
<p align="center"><img src="/assets/img/Linux Programming/Lect2/2-6.png" width="600"></p>

실습
======
&ensp;이 프로그램이 하는 일 — 큰 그림<br/>
&ensp;사용자가 mkdir 이름, cd 이름, ls, exit 같은 문자열을 입력하면, 그 문자열을 띄어쓰기 기준으로 쪼개서(토큰화), 맨 앞 단어가 어떤 명령인지 확인하고, 해당 명령 함수를 호출합니다. 즉, “한 줄 입력 → 단어로 나눔 → 명령에 맞는 함수를 실행”.<br/>
* $ mkdir NAME → NAME 디렉터리 생성(퍼미션 0700)
* $ cd NAME → 해당 디렉터리로 이동
* $ ls → 현재 작업 디렉터리의 항목 이름 출력
* exit 입력 시 종료(메인 함수는 수정하지 않음) 

```cpp
// LAB09-03.c
// 간이 shell: cd, mkdir, ls 명령 구현
// - mkdir: 권한 0700으로 디렉터리 생성
// - cd: 디렉터리 이동
// - ls: 현재 디렉터리의 항목 이름 출력
// 메인 루프(입력 파싱, exit 처리)는 과제 제시 코드 그대로 사용한다고 가정.

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>

// --- 선언부 (메인에서 함수 포인터로 호출) ---
void cd_m(char **res);
void mkdir_m(char **res);
void ls_m(char **res);

// --- 구현부 ---
void cd_m(char **res){
    // 사용법: cd DIR
    // 인자가 없으면(과제 지문에 명시X) 간단히 오류 메시지 출력
    if (res[1] == NULL) {
        fprintf(stderr, "usage: cd <directory>\n");
        return;
    }
    if (chdir(res[1]) == -1) {
        // 실패 시 시스템 에러 메시지 출력(권한/존재 여부 등)
        perror("cd");
    }
}

void mkdir_m(char **res){
    // 사용법: mkdir NAME
    if (res[1] == NULL) {
        fprintf(stderr, "usage: mkdir <directory>\n");
        return;
    }
    // 퍼미션은 과제 요구대로 0700 (소유자만 rwx)
    // 주의: 실제 생성 권한은 프로세스의 umask에 의해 일부 제한될 수 있음
    if (mkdir(res[1], 0700) == -1) {
        perror("mkdir");
    }
}

void ls_m(char **res){
    (void)res; // 인자 미사용 (옵션 처리 없음)

    DIR *dirp = opendir(".");
    if (!dirp) {
        perror("opendir");
        return;
    }

    struct dirent *ent;
    while ((ent = readdir(dirp)) != NULL) {
        // 과제에서 -a/-A 같은 옵션 요구가 없으므로
        // 기본 ls처럼 보이게 하려면 숨김항목(.)을 제외할 수도 있음.
        // 여기서는 과제 문장대로 "현재 디렉터리 내의 파일/디렉터리 이름"을
        // 단순 출력: 모두 출력하되 정렬/서식 없이 한 줄에 하나.
        // 필요 시 아래 주석 해제로 . , .. 건너뛰기 가능.
        //
        // if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0) continue;

        puts(ent->d_name);
    }

    if (closedir(dirp) == -1) {
        perror("closedir");
    }
}

// --- 아래 main은 과제에서 제공된 것을 그대로 붙였다고 가정 ---
// (문제 조건: main은 수정하지 말 것)
int main(void){
    char in[100], *res[20] = {0};
    char *inst[3] = {"cd", "mkdir", "ls"};
    void (*f[3])(char **) = {cd_m, mkdir_m, ls_m};
    int i;

    while (1) {
        // 현재 작업 디렉터리 이름을 프롬프트처럼 보여주고 싶다면
        // (지문 코멘트만 있고 실제 출력은 없음) 참고로 다음과 같이 할 수 있음:
        // char cwd[1024];
        // if (getcwd(cwd, sizeof(cwd))) printf("[%s]$ ", cwd);
        // fflush(stdout);

        if (fgets(in, sizeof(in), stdin) == NULL || strlen(in) == 1)
            continue;

        size_t len = strlen(in);
        if (in[len-1] == '\n') in[len-1] = '\0';

        i = 0;
        res[i] = strtok(in, " ");
        while (res[i] && i < 19) {
            i++;
            res[i] = strtok(NULL, " ");
        }

        if (res[0] == NULL) continue;
        if (!strcmp(res[0], "exit"))
            exit(0);

        for (i = 0; i < 3; i++) {
            if (!strcmp(res[0], inst[i])) {
                f[i](res);
                break;
            }
        }
    }
    return 0;
}
```

&ensp;🛠 컴파일 & 실행<br/>
```bash
# 컴파일
gcc -Wall -Wextra -o LAB09-03 LAB09-03.c

# 실행
./LAB09-03
```

<p align="center"><img src="/assets/img/Linux Programming/Lect2/2-7.png" width="600"></p>

&ensp;💡 구현 포인트 설명<br/>
* mkdir 권한 0700: 소유자만 읽기/쓰기/실행(rwx) 가능하도록 생성(과제 요구사항).
단, 실제 생성 권한은 umask에 의해 일부 비트가 지워질 수 있다.
* cd 에러 처리: 존재하지 않거나 권한이 없으면 perror("cd")로 시스템 메시지 출력
* ls 구현: opendir(".") → readdir() 반복 → closedir() 순서로 간단 출력.
숨김 파일 처리나 정렬은 과제 요구에 없으므로 그대로 나열만 수행.
* 입력 파싱: 과제 제공 main이 strtok로 공백 기준 분리해서 res[0]이 명령어, res[1]이 첫 인자

&ensp;⚠️ 흔한 실수/디버깅 팁<br/>
* mkdir에 인자가 없을 때: usage 메시지 출력 후 리턴.
* cd는 프로세스의 현재 작업 디렉터리를 바꾸므로, 반드시 현재 프로세스에서 호출되어야 효과가 있음(별도 하위 프로세스로 실행하면 부모에는 반영 안 됨).
* ls에서 opendir 실패: 디렉터리 권한/경로 문제 → perror로 원인 확인.

&ensp;핵심 변수 4개 이해하기<br/>

```cpp
char in[100];        // 한 줄 입력을 담는 '상자' (문자 배열)
char *res[20] = {0}; // 단어 조각들의 '주소'를 담는 상자들 (포인터 배열)
char *inst[3] = {"cd", "mkdir", "ls"};              // 명령어 표준답안집
void (*f[3])(char **) = {cd_m, mkdir_m, ls_m};      // 명령어별 실행 함수 주소표
```

* in: 사용자가 친 원문 한 줄이 저장됩니다. (예: "mkdir testdir\n")
* strtok()가 in을 잘라서(띄어쓰기에 따라) 각각의 단어 시작 위치(주소) 를 리턴합니다.
* res: 그 단어들의 시작 주소들을 차례대로 담아둡니다.
  - res[0] = "mkdir"
  - res[1] = "testdir"
  - res[2] = NULL (단어 끝 표시)
* inst: 우리가 지원하는 명령어 이름 목록.
* f: 각 명령어와 같은 순서로 놓인 “함수 주소 목록”.
  - inst[0] == "cd" ↔ f[0] == cd_m
  - inst[1] == "mkdir" ↔ f[1] == mkdir_m
  - inst[2] == "ls" ↔ f[2] == ls_m

&ensp;비유<br/>
* "inst는 “메뉴판”, f는 “메뉴별 조리사 주소”.
* "입력을 보고 메뉴 이름을 찾으면, 같은 인덱스의 조리사를 호출!"
