---
title: "Lect4. 파일 입출력"
excerpt: ""

wirter: sohee Kim
categories:
  - Linux Programming
tags:
  - Linux

toc: true
toc_sticky: true
Sdate: 2025-09-13
last_modified_at: 2025-09-13
---

file 접근 primitives
======

&ensp;파일은 무엇일까? -> 컴퓨터가 차곡차곡 줄 세워 둔 바이트(글자 조각)들의 줄(linear sequence)이다.<br/>
&ensp;이 파일을 읽고/쓰는 방법은 두 종류가 있다.<br/>
1. 저수준 I/O: open, close, read, write, dup, dup2, fcntl, lseek, fsync 같은 맑은 원액 도구들. 번호표(파일 디스크립터)를 직접 다룬다.
2. 고수준 I/O: fopen, fclose, fread, fwrite, fgets, fputs, fprintf, fscanf, freopen, fseek 같은 "음료수" 도구들. 편하게 쓰라고 컵과 빨대를 챙겨 주는 느낌(버퍼링, FILE*).

&ensp;비유<br/>
* 저수준 I/O = 수도관 밸브를 직접 돌려서 물(데이터)을 틀고 잠그기
* 고수준 I/O = 정수기 버튼을 눌러서 컵에 따라 마시기 (안에 물탱크=버퍼가 있어 더 편함)

file descriptor
====

&ensp;파일 디스크립터는 "지금 열려 있는 파일에 붙인 번호표"이다. 프로세스(프로그램)가 파일을 열면, 운영체제가 0, 1, 2, 3… 같은 작은 정수를 준다.<br/>
* 특별히 처음부터 예약된 번호표가 있다:
    - 0 = 표준 입력(키보드에서 들어오는 것)
    - 1 = 표준 출력(화면으로 나가는 것)
    - 2 = 표준 오류(에러 메시지용 통로)
* 프로그램이 너무 많이 파일을 열면 번호표가 모자랄 수 있다. 다 썼으면 **close()**로 반납해야 한다.

&ensp;예시<br/>
* write(1, "Hello\n", 6); → “1번 통로(표준 출력)”로 글자를 보냄 = 화면에 보이게 됨
* close(fd); → 번호표 fd 반납

open 시스템 호출
====

* 이미 있는 파일을 열거나, 없으면 새로 만들어 열게 해 주는 시스템 콜이야.
* 기본 모양(프로토타입):

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *filename, int oflag, [mode_t mode]/* mode_t mode (옵션) */);
```

* filename : 파일 이름
* oflag : 어떻게 열 건지(읽기/쓰기/만들기…) 옵션
* mode : 새 파일을 만들 때만 필요(권한 설정용, 예: 0644)

&ensp;성공하면 번호표(fd)(0이상의 정수)를 돌려주고 실패하면 -1을 준다.<br/>

&ensp;oflag는 문 여는 방법을 고르는 스위치야. 자주 쓰는 것만 쉬운 말로 정리한다.<br/>
* 읽기/쓰기 방식
    - O_RDONLY : 읽기 전용(책을 보기만 함)
    - O_WRONLY : 쓰기 전용(공책에 쓰기만 함)
    - O_RDWR : 읽고 쓰기 둘 다
* 파일을 만들거나 모양을 바꾸는 옵션
    - O_CREAT : 파일이 없으면 새로 만든다 (있으면 그냥 연다) 이때 새 파일의 기본 권한을 mode로 함께 줘야 한다.(예: 0644).
    - O_EXCL : O_CREAT와 같이 쓰면 이미 있으면 실패(덮어쓰지 않음, “중복 금지”)
    - O_TRUNC : 파일을 열 때 내용을 싹 비움(길이를 0으로)
    - O_APPEND : 항상 맨 끝에 덧붙여 쓰기(일지/로그 파일에 딱 좋음)

<p align="center"><img src="/assets/img/Linux Programming/Lect4/4-1.png" width="600"></p>

* 시험 포인트
    - O_RDONLY | O_CREAT ❌ (쓰기 권한이 없어서 새 파일 생성 불가)
    - O_WRONLY | O_CREAT | O_TRUNC → 없으면 새로, 있으면 내용 비움
    - O_CREAT | O_EXCL → 이미 존재하면 실패(-1)
    - O_APPEND → 쓰기 시 항상 파일 끝으로 이동

&ensp;상황별 예시<br/>
```c
// 1) 읽기 전용으로 열기
int fd = open("data.txt", O_RDONLY);

// 2) 없으면 만들고(0644), 있으면 내용 싹 비우고 새로 쓰기
int fd = open("out.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);

// 3) 새 파일을 '꼭' 새로 만들기(이미 있으면 에러)
int fd = open("unique.txt", O_WRONLY | O_CREAT | O_EXCL, 0644);

// 4) 항상 뒤에 덧붙여 쓰기(로그)
int fd = open("app.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
```

creat 시스템 호출
=====

&ensp;파일이 없으면 새로 만들고 있으면 내용을 싹 비운 뒤 쓰기 모드로 연다.<br/>
&ensp;모양(프로토타입)<br/>
```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int creat(const char *filename, mode_t mode);
```

* filename : 만들(열) 파일 이름
* mode : 새로 만들 때의 기본 권한(예: 0644) — 이미 있으면 무시됨(권한 안 바뀜)
* 중요한 두 가지 성격
1. 항상 쓰기 전용으로 열린다. (읽기만은 안 됨)
2. 파일이 이미 있으면 길이를 0으로 만든다. (내용을 다 지우고 새 공책처럼 시작)

&ensp;비유<br/>
* 빈 공책이 없으면 새 공책을 사 오고
* 이미 쓰던 공책이면 지우개로 전부 지우고 새로 쓰기 시작하는 느낌!

close 시스템 호출
=====

&ensp;열어둔 파일을 닫고 그 파일에 붙어 있던 번호표(fd)를 운영체제에 돌려준다.<br/>
&ensp;모양<br/>
```c
#include <unistd.h>

int close(int filedes);  // 성공 0, 실패 -1
```

&ensp;필요한 이유<br/>
* 프로그램이 한 번에 열 수 있는 **파일 개수(번호표)**에는 한계가 있다.
* 다 쓰면 꼭 반납해야 다음 파일을 또 열 수 있다.
* 프로그램이 끝나면 운영체제가 자동으로 닫아주지만, 도중에는 직접 닫는 습관이 중요!

&ensp;비유<br/>
* 도서관에서 책을 빌릴 때 대출번호표를 받는다. 책을 다 봤으면 카운터에 반납해야 다음 책을 또 빌릴 수 있다.

read 시스템 호출
=====

&ensp;열린 파일에서 최대 nbytes 만큼 자료를 빨아와서 **내 컵(버퍼)**에 채워 준다.<br/>
&ensp;모양<br/>
```c
#include <unistd.h>

ssize_t read(int filedes, void *buffer, size_t nbytes);
```

* filedes : 어떤 파일에서 읽을지(번호표)
* buffer : 읽은 내용을 담아둘 컵(메모리 주소)
* nbytes : 최대 몇 바이트까지 옮겨 담을지

&ensp;읽는 위치(파일 오프셋)<br/>
&ensp;파일 안에는 책갈피(파일 포인터)가 있어서 read를 한 번 하면 그 만큼 자동으로 앞으로 이동한다.<br/>

&ensp;비유<br/>
* 큰 물탱크(파일)에서 빨대로 최대 nbytes만큼 물을 컵(buffer)에 옮겨 담는 느낌!

&ensp;read는 항상 요청한 만큼(nbytes) 채워준다는 보장이 없어. 결과(리턴값)를 보고 판단해야 한다.<br/>

* 리턴값 규칙
    - 양수 N: 실제로 읽힌 바이트 수가 N
        + 예) 파일에 남은 물이 적으면 N < nbytes일 수 있어(반 컵만 담긴 셈)
    - 0: 더 이상 읽을 게 없음(= 파일 끝, EOF)
    - -1: 읽기 실패(오류)
* 왜 N이 nbytes보다 작을 수 있지?
    - 파일 끝 근처라 남은 양이 적어서
    - (네트워크/단말 등에서는) 한 번에 다 못 받아서(부분 읽기)

&ensp;안전한 읽기 패턴(필수 습관)<br/>
```c
ssize_t n, total = 0;
while ((n = read(fd, buf + total, want - total)) > 0) {
    total += n;              // 지금까지 받은 양을 누적
    if (total == want) break; // 원하던 만큼 채웠으면 멈춤
}
if (n == 0)  /* EOF */
if (n < 0)   /* 오류 처리 */
```

write 시스템 호출
=====

&ensp;하는 일<br/>
&ensp;열린 파일에 메모리(buffer) 안에 데이터를 쓴다.<br/>
* 쓰여질 위치는 "파일 포인터"가 가리키는 곳부터 시작한다.
* 쓰고 나면 파일 포인터는 자동으로 앞으로 이동한다.

&ensp;형태<br/>
```c
#include <unistd.h>

ssize_t write(int fd, const void *buffer, size_t nbytes);
```

* fd : 어떤 파일에 쓸 건지 (open으로 받은 번호표)
* buffer : 쓸 데이터가 들어있는 메모리 주소
* nbytes : 몇 바이트를 쓸지
* 반환값
    - 정상: 실제로 쓴 바이트 수 (=보통 nbytes)
    - 실패: -1
    - 특수: nbytes보다 작으면 저장매체 꽉 참 등 특수 상황 -> -1 반환


&ensp;주의사항<br/>
* O_APPEND로 열면:
    - open 하는 순간 파일 포인터가 파일 끝으로 이동한다.
    - 그래서 write를 하면 무조건 뒤에 덧붙여진다.

&ensp;예시<br/>
```c
int fd = open("data", O_WRONLY | O_APPEND);
write(fd, "hi", 2);
```

&ensp;→ 기존 내용이 "ABC"였다면 결과는 "ABChi"<br/>

read/write 효율성
=====

* 파일 복사 프로그램을 생각하면 → 작은 단위로 read/write를 많이 하면 비효율적.
* BUF_SIZE를 512의 배수로 설정하면 효율적. (디스크 블록 크기와 맞추기 때문)
* system call(커널로 갔다 오는 호출) 횟수는 적을수록 빠르다.

&ensp;비유: 컵으로 물을 한 숟가락씩 계속 옮기는 것보다 양동이로 한 번에 많이 퍼오는 게 더 빠르다.<br/>

lseek와 임의 접근
=====

&ensp;기능<br/>
&ensp;파일 포인터(책갈피)를 원하는 위치로 점프시킨다.<br/>
&ensp;읽고/쓰기를 원하는 곳에서 다시 시작할 수 있다.<br/>

&ensp;형태<br/>
```c
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

* fd: 파일 번호
* offset: 얼마나 움직일지
* whence: 기준점
    - SEEK_SET (파일 시작 기준)
    - SEEK_CUR (현재 위치 기준)
    - SEEK_END (파일 끝 기준)

&ensp;예시<br/>
```c
lseek(fd, 0, SEEK_SET);  // 파일 맨 앞으로
lseek(fd, -10, SEEK_END); // 파일 끝에서 10바이트 전으로
```

&ensp;lseek(fd, 11, SEEK_SET) 와 lseek(fd, 0, SEEK_END) 의 차이 (파일 크기가 10일때)<br/>
&ensp;상황 1: 파일 크기 = 11바이트일 때<br/>
```makefile
데이터:  Y Z X Z X Z X Z X X Y
인덱스:  0 1 2 3 4 5 6 7 8 9 10
포인터:                        |
                              ↑ current = 11
```

* lseek(fd, 11, SEEK_SET) → current = 11
* lseek(fd, 0, SEEK_END) → current = 11

&ensp;👉 두 방법이 같음 (= EOF 위치)<br/>

&ensp;📌 상황 2: 파일 크기 = 15바이트일 때<br/>
```makefile
데이터:  Y Z X Z X Z X Z X X Y . W S T
인덱스:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
포인터:                                   |
                                         ↑ current = 15
```

* lseek(fd, 11, SEEK_SET) → current = 11 (EOF 아님! 중간 구멍 자리)
* lseek(fd, 0, SEEK_END) → current = 15 (정확히 EOF 위치)

&ensp;👉 차이가 발생!<br/>

* SEEK_SET 11 은 파일이 11바이트일 때는 EOF였지만, 크기가 15바이트로 늘어나면 단순히 “11번 인덱스”로만 이동합니다.<br/>
* SEEK_END 0 은 언제나 “파일 끝”으로 이동합니다.

&ensp;비유: 책갈피를 앞으로/뒤로 옮기는 것과 같다. → “다음에 읽거나 쓸 위치”를 바꾸는 도구<br/>

&ensp;인수 사용법<br/>
* filedes: 열린 파일 번호표(fd)
* whence: 기준점
    - SEEK_SET : 파일 시작에서 몇 칸 이동
    - SEEK_CUR : 파일 지금 위치에서 몇 칸 이동
    - SEEK_END : 파일 끝(EOF) 에서 몇 칸 이동
* offset: 얼마만큼 이동할지(+면 앞으로, -면 뒤로)

&ensp;결국 현재 포인터= 기준점 + offset이라고 생각하면 된다.<br/>

&ensp;반환값: 이동 후 파일 시작점으로부터의 새 위치. 실패 시 -1, 성공 시 0<br/>

&ensp;비유: 책에서 whence는 "어디를 기준으로?" → 처음, 현재, 끝. offset은 “몇 장을 넘길까?” → +3장, -2장 이런 식.<br/>

파일의 제거
=====

&ensp;형태<br/>
```c
#include <unistd.h>
int unlink(const char *filename);

#include <stdio.h>
int remove(const char *filename)
```

&ensp;차이점<br/>
* unlink : 파일만 삭제 (링크 카운트 -1).
* remove : 파일뿐 아니라 빈 디렉토리도 삭제 가능

&ensp;주의<br/>
* fd(번호표)가 아니라 파일 이름으로 지운다.
* 이미 열려 있는 파일을 unlink하면? 이름표는 사라지지만, 프로그램이 닫을 때까지는 내용은 살아 있음

&ensp;비유<br/>
* unlink는 현관문 이름표만 뗀 것. 안에 사람(fd)이 있으면 나올 때까지 집은 안 없어짐.
* remove는 빈 집 자체를 철거하는 것도 가능

표준 입력/출력/오류
=====

&ensp;예약된 파일 descriptor 번호 3개:<br/>
* 0: 표준 입력 (키보드)
* 1: 표준 출력 (화면)
* 2: 표준 오류 (에러 메시지 → 화면)

표준 입출력의 변경
======

* 리다이렉션(redirection)
    - ./a.out < infile → infile이 표준 입력(fd=0)으로 연결됨
    - ./a.out > outfile → outfile이 표준 출력(fd=1)으로 연결됨
    - ./a.out < infile > outfile → infile에서 읽고 outfile로 쓰기
* 파이프(pipe)
    - ./a.out1 | ./a.out2
    - a.out1의 표준 출력 → a.out2의 표준 입력으로 연결됨

&ensp;비유: 수도꼭지 파이프 배관 바꾸기. 원래 싱크대로 가던 물줄기를 호스로 다른 통으로 연결하는 것<br/>

오류 메시지 출력
=====

&ensp;perror함수 사용:<br/>
```c
perror("error ...");
```

&ensp;결과: "error ... : No such file or directory"(작전에 실패한 시스템콜의 오류 이유를 알려줌)<br/>

시험 포인터
=====

&ensp;1. open의 옵션 조합과 결과<br/>
&ensp;(1) 기본 모드<br/>
```c
int fd = open("a.txt", O_RDONLY);
```

&ensp;읽기 전용. 파일이 없으면 ❌ 오류(-1).<br/>
&ensp;쓰려고 하면 ❌ 에러(EBADF).<br/>

```c
int fd = open("a.txt", O_WRONLY);
```

&ensp;쓰기 전용. 파일이 없으면 ❌ 오류.<br/>
&ensp;읽으려고 하면 ❌ 에러.<br/>

```c
int fd = open("a.txt", O_RDWR);
```

&ensp;읽기/쓰기 둘 다. 파일이 없으면 ❌ 오류.<br/>

&ensp;(2) O_CREAT (없으면 새로 만들기)<br/>
```c
int fd = open("a.txt", O_WRONLY | O_CREAT, 0644);
```

&ensp;a.txt가 없으면 새로 생성하고, 있으면 그냥 열기.<br/>
&ensp;권한은 0644(rw-r--r--).<br/>
&ensp;mode 인자는 새로 만들 때만 의미 있고, 이미 있는 파일은 권한이 변하지 않음.<br/>

&ensp;(3) O_CREAT | O_EXCL<br/>
```c
int fd = open("a.txt", O_WRONLY | O_CREAT | O_EXCL, 0644);
```

&ensp;a.txt가 없으면 새로 만들고 성공.<br/>
&ensp;a.txt가 이미 있으면 ❌ 오류(-1).<br/>

&ensp;(4) O_TRUNC (내용 지우기)<br/>
```c
int fd = open("a.txt", O_WRONLY | O_TRUNC);
```

&ensp;파일이 이미 있으면, 내용(크기)을 0으로 만든 뒤 쓰기 전용으로 연다.<br/>
&ensp;파일이 없으면 ❌ 오류.<br/>
&ensp;보통 O_CREAT랑 같이 씀 → 없으면 만들고, 있으면 내용 비움.<br/>

&ensp;(5) O_APPEND (항상 뒤에 쓰기)<br/>
```c
int fd = open("log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
write(fd, "hello\n", 6);
```

&ensp;파일 끝에 무조건 이어붙여짐.<br/>
&ensp;원래 내용이 "abc\n" 이라면 결과는 "abc\nhello\n".<br/>

&ensp;📌 2. creat와의 차이<br/>
```c
int fd = creat("a.txt", 0644);
```

&ensp;사실상 open("a.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644)와 똑같다.<br/>
&ensp;항상 쓰기 전용이고, 있으면 지움.<br/>

&ensp;📌 3. close 결과<br/>
```c
close(fd);
```

&ensp;성공하면 0. 실패하면 -1.<br/>
&ensp;실패하는 경우: 이미 닫힌 fd를 다시 닫으려고 할 때.<br/>
&ensp;중요: close하지 않으면 OS가 자동으로 닫아주긴 하지만, 시험에선 “열 수 있는 파일 개수 제한” 때문에 닫아야 한다는 걸 강조할 수 있음.<br/>

&ensp;📌 4. read 결과<br/>
```c
char buf[10];
int n = read(fd, buf, 10);
```

&ensp;파일 포인터(책갈피) 위치부터 최대 10바이트를 읽어서 buf에 넣음.<br/>
&ensp;반환값 n:<br/>
&ensp;>0 : 실제 읽은 바이트 수 (EOF 이전이면 n < 요청한 값일 수도 있음)<br/>
&ensp;0 : EOF (더 읽을 게 없음)<br/>
&ensp;-1 : 오류<br/>

&ensp;📖 예시<br/>
&ensp;파일 내용이 "Hello\n" (6바이트)이고, read(fd, buf, 10) 실행 시:<br/>
&ensp;첫 번째 호출 → n=6, buf="Hello\n", 다음 오프셋=끝<br/>
&ensp;두 번째 호출 → n=0 (EOF)<br/>

&ensp;📌 5. 시험에 잘 나오는 시나리오 예제<br/>
&ensp;Q1.<br/>
```c
int fd = open("data.txt", O_RDONLY | O_CREAT, 0644);
```

&ensp;👉 결과: ❌ 오류.
&ensp;이유: O_CREAT를 썼지만 O_RDONLY는 모순. 쓰기 권한이 없는 모드로는 새 파일을 만들 수 없음.<br/>

&ensp;Q2.<br/>
```c
int fd = open("out.txt", O_WRONLY | O_CREAT | O_EXCL, 0644);
```

&ensp;out.txt가 없으면? → fd>=0, 성공.<br/>
&ensp;out.txt가 있으면? → fd=-1, 실패.<br/>
&ensp;Q3.<br/>
```c
int fd = open("log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
write(fd, "hi", 2);
```

&ensp;log.txt 내용이 "1234"라면? → "1234hi"가 됨.<br/>
&ensp;쓰기 위치는 무조건 끝!<br/>

&ensp;Q4.<br/>
```c
int fd = creat("note.txt", 0644);
write(fd, "ABC", 3);
close(fd);
```

&ensp;note.txt가 없었다면? → "ABC" 내용이 들어있는 파일 생성.<br/>
&ensp;note.txt가 있었다면? → 기존 내용 싹 지워지고 "ABC"만 남음.<br/>

&ensp;정리<br/>
* O_RDONLY + O_CREAT = ❌ 불가능
* O_CREAT | O_EXCL = 있으면 오류
* O_TRUNC = 기존 내용 0으로
* O_APPEND = 항상 뒤에 덧붙임
* creat() = 항상 쓰기 전용 + 내용 비움

실습 1
=====

&ensp;먼저, 꼭 알아야 할 3가지<br/>
&ensp;1. 파일은 "바이트 줄"이다.<br/>
&ensp;컴퓨터는 파일을 글자/숫자처럼 보지 않고 0과 1(바이트)의 줄로 본다.
X 하나도, 3과 5도 결국 바이트이다. 우리가 "쓰기(write)"를 하면 이 바이트 줄의 현재 위치에 바이트들이 들어간다.<br/>

&ensp;2. "파일 디스크립터" = 파일 번호표
&ensp;open()을 호출하면 운영체제가 "이 파일을 가리키는 번호표"를 준다.(예: 3)
이 번호표로 write(번호표, 데이터, 크기)처럼 읽고/쓴다. 마치 도서관에서 대출번호표를 받아서 그 번호로 책을 다루는 것과 같다.<br/>

&ensp;3. 권한 숫자 0600, 0640 등
&ensp;리눅스 권한은 u(나)/g(같은 그룹)/o(다른 사람) 순서로 r(읽기) w(쓰기) x(실행)을 준다.<br/>
* 0600 = rw------- : 나만 읽기/쓰기 가능
* 0640 = rw-r----- : 나는 읽기/쓰기, 같은 그룹은 읽기만, 다른 사람은 불가

&ensp;ls -l 결과로 확인: 예) -rw------- (0600), -rw-r----- (0640)<br/>

문제 1
-------

&ensp;(a) “test1" file을 나만 읽기쓰기 가능하게 생성하여 쓰기용으로 open 한 후, “test1" file에 문자 변수ch에 저장된 문자를 10번 반복하여 씁니다. ch은 ‘X'로 초기화 합니다. 프로그램 종료 후 shell 상에서 cat 명령을 사용하여 ”test1" file에 문자 ’X'가 10개 쓰여 있는지 확인합니다.<br/>

&ensp;test1.c<br/>
&ensp;X 10개 쓰기, 권한 0600<br/>
```c
#include "common.h"

int main(void){
    int fd;              // 파일 번호표를 저장할 변수
    char ch = 'X';       // 파일에 쓸 문자
    int i;

    // test1을 쓰기 전용(O_WRONLY), 없으면 새로 만들고(O_CREAT),
    // 있으면 내용 지우고(O_TRUNC), 권한은 0600으로 열기
    fd = open("test1", O_WRONLY | O_CREAT | O_TRUNC, 0600);

    // X를 10번 파일에 씀
    for(i = 0; i < 10; i++){
        write(fd, &ch, 1);   // &ch : 변수 ch의 주소, 1바이트만 쓰기
    }

    close(fd);   // 다 쓰면 파일 닫기
    return 0;
}
```

* open → 파일을 열어서 번호표(fd)를 줌
* write → 번호표가 가리키는 파일에 한 글자 기록
* close → 대출번호표 반납

&ensp;한 일<br/>
1. test1을 쓰기 전용으로 엶. 없으면 새로 만들고, 기존에 있으면 내용을 싹 지움
2. 문자 X를 10번 연속으로 씀

&ensp;O_CREAT → 없으면 새로 생성<br/>
&ensp;O_TRUNC → 있던 내용은 지우고 빈 파일부터 시작<br/>
&ensp;그래서 결과는 항상 XXXXXXXXXX<br/>

&ensp;결과<br/>
* cat test1 → XXXXXXXXXX
* wc -c test1 → 10 (바이트 수)
* ls -l test1 → -rw------- (0600)

문제 2
-----

&ensp;(b) “test2" file을 나는 읽기쓰기 가능하고, 나와 같은 그룹의 사용자들은 읽기만 가능하게 생성하여 쓰기용으로 open 합니다. “test2" file에 정수 변수 data에 저장된 정수를 10번 반복하여 씁니다. data는 35로 초기화 합니다. 프로그램 종료 후 shell 상에서 cat 명령을 사용하여 ”test2" file에 35가 10번 쓰여 있는지 확인합니다. shell 상에서 ls -l 명령을 사용하여 “test2" file의 크기를 확인합니다.<br/>

&ensp;test2.c<br/>
&ensp;"35" 10번 쓰기, 권한 0640<br/>
```c
#include "common.h"

int main(void){
    int data = 35;   // 문제에서 준 값 (실제로는 안 씀)
    int fd, i;

    // test2를 쓰기 전용, 없으면 새로 만들고, 내용 지우고, 권한 0640으로 열기
    fd = open("test2", O_WRONLY | O_CREAT | O_TRUNC, 0640);

    // 문자열 "35"를 10번 쓰기
    for (i = 0; i < 10; i++) {
        write(fd, "35", 2);   // "35" 두 글자를 2바이트로 씀
    }

    close(fd);
    return 0;
}
```

* "35"는 사실 문자 '3' '5' 두 개 → 크기 2바이트
* 10번 쓰면 총 20바이트 = "3535353535..."

&ensp;한 일<br/>
1. test2를 쓰기 전용으로 열고, 없으면 만들고, 내용은 비우고 시작(append 아님)
2. 문자열 "35"(두 글자)를 10번 씀 → 353535...

&ensp;결과<br/>
* cat test2 → 3535353535 (총 10번)
* wc -c test2 → 20 (두 글자 × 10)
* ls -l test2 → -rw-r----- (0640)

문제 3
-----

&ensp;(c) 이미 존재하는 “test1" file을 쓰기 가능하게 open 합니다. “test1" file에 문자 변수 ch에 저장된 문자를 5번 반복하여 씁니다. ch은 ‘Y'로 초기화 합니다. 프로그램 종료 후 shell 상에서 cat 명령을 사용하여 ”test1" file에 문자 ’Y'가 5개, 이어서 문자 ‘X'가 5개 쓰여 있는지 확인합니다.<br/>

&ensp;test3.c<br/>
&ensp;test1의 앞 5글자만 Y로 덮어쓰기<br/>
```c
#include "common.h"

int main(void){
    int fd, i;
    char ch = 'Y';

    // test1을 쓰기 전용으로 열기 (O_CREAT, O_TRUNC, O_APPEND 없음!)
    fd = open("test1", O_WRONLY);

    // 앞에서부터 5바이트 덮어쓰기
    for (i = 0; i < 5; i++) {
        write(fd, &ch, 1);
    }

    close(fd);
    return 0;
}
```

* 새로 만들지도 않고, 내용도 지우지 않고 → 처음 위치(0번)에서 쓰기 시작
* 그래서 XXXXXXXXXX → YYYYYXXXXX

&ensp;한 일<br/>
1. test1을 쓰기 전용으로 “그대로” 열음 (생성/지우기/이어붙이기 옵션 X)
2. Y를 5번 씀

&ensp;파일의 현재 위치는 시작(0번 바이트)이라서 앞에서부터 5바이트가 Y로 덮어써진다.<br/>
&ensp;뒤 5바이트는 손대지 않았으니 그대로 XXXXX 유지<br/>
&ensp;결과: YYYYYXXXXX, 길이는 그대로 10<br/>

&ensp;결과<br/>
* cat test1 → YYYYYXXXXX
* wc -c test1 → 10

문제 4
-----

&ensp;(d) 이미 존재하는 “test1" file 내용을 보존하고, file의 가장 마지막 위치부터 쓰기 가능하게 open 합니다. “test1" file에 문자 변수 ch에 저장된 문자를 5번 반복하여 씁니다. ch은 ‘Z'로 초기화 합니다. 프로그램 종료 후 shell 상에서 cat 명령을 사용하여 ”test1" file에 문자 ’Y'가 5개, 이어서 문자 ‘X'가 5개, 그리고 마지막으로 문자 ’Z'가 5개 쓰여 있는지 확인합니다.<br/>

&ensp;test1은 YYYYYXXXXX (길이 10)<br/>

&ensp;test4.c<br/>
&ensp;test1 끝에 Z 5개 이어붙이기<br/>
```c
#include "common.h"

int main(void){
    int fd;              // 파일 번호표를 저장할 변수
    char ch = 'X';       // 파일에 쓸 문자
    int i;

    // test1을 쓰기 전용(O_WRONLY), 없으면 새로 만들고(O_CREAT),
    // 있으면 내용 지우고(O_TRUNC), 권한은 0600으로 열기
    fd = open("test1", O_WRONLY | O_CREAT | O_TRUNC, 0600);

    // X를 10번 파일에 씀
    for(i = 0; i < 10; i++){
        write(fd, &ch, 1);   // &ch : 변수 ch의 주소, 1바이트만 쓰기
    }

    close(fd);   // 다 쓰면 파일 닫기
    return 0;
}
```

* O_APPEND 덕분에 매번 write할 때마다 파일 끝에 붙음
* 결과: YYYYYXXXXXZZZZZ

&ensp;한 일<br/>
1. test1을 O_TRUNC로 열어 내용을 싹 지움(파일은 유지, 권한도 유지)
2. K를 3번 씀 → KKK

&ensp;O_TRUNC는 “길이를 0으로” 만든 뒤 쓰게 한다. 그래서 결과는 딱 KKK (길이 3)<br/>

&ensp;결과<br/>
* cat test1 → KKK (줄바꿈 없으면 cat test1; echo로 보기 좋게)
* wc -c test1 → 3

문제 5
-----

&ensp;(e) 이미 존재하는 “test1" file의 기존 내용을 전부 지우고, 쓰기 가능하게 open 합니다. “test1" file에 문자 변수 ch에 저장된 문자를 3번 반복하여 씁니다. ch은 ‘K'로 초기화 합니다. 프로그램 종료 후 shell 상에서 cat 명령을 사용하여 ”test1" file에 문자 ’K'만 3개가 쓰여 있는지 확인합니다.<br/>

&ensp;test2에는 "35"가 10번 → 3535353535<br/>

&ensp;test5.c<br/>
&ensp;test1 내용 지우고 K 3개 쓰기<br/>
```c
#include "common.h"

int main(void){
    int fd, i;
    char ch = 'K';

    // test1을 쓰기 전용으로 열면서, O_TRUNC로 내용 싹 지움
    fd = open("test1", O_WRONLY | O_TRUNC);

    for (i = 0; i < 3; i++) {
        write(fd, &ch, 1);
    }

    close(fd);
    return 0;
}
```

* O_TRUNC → 파일 크기를 0으로 만들어서 내용 다 날림
* 이후 KKK만 남음 (3바이트)

&ensp;한 일<br/>
1. test1을 O_TRUNC로 열어 내용을 싹 지움(파일은 유지, 권한도 유지)
2. K를 3번 씀 → KKK

&ensp;O_TRUNC는 길이 0으로 만든 뒤 쓰게 한다. 그래서 결과는 딱 KKK(길이 3)<br/>

&ensp;결과<br/>
* cat test1 → KKK (줄바꿈 없으면 cat test1; echo로 보기 좋게)
* wc -c test1 → 3

문제 6
------

&ensp;(f) “test2" file을 읽기 가능하게 open하고, 정수 5개를 읽어 정수 배열 data[10]의 0번부터 4번 원소에 저장합니다. data[10] 배열은 0으로 초기화 합니다. printf() 명령을 사용하여 data 배열의 내용을 출력합니다.<br/>

&ensp;test2에는 "35"가 10번 → 3535353535<br/>

&ensp;test6.c<br/>
&ensp;test2에서 정수 5개 읽어 data[0..4]에 저장, 나머진 0<br/>

```c
#include "common.h"

int main(void){
    int data[10] = {0};   // 처음엔 전부 0
    int fd, i;

    fd = open("test2", O_RDONLY);   // 읽기 전용으로 열기

    for (i = 0; i < 5; i++) {
        char buf[3];                // "35" + 끝표시
        int len = read(fd, buf, 2); // 두 글자 읽기
        buf[len] = '\0';            // 문자열 끝 표시
        data[i] = atoi(buf);        // "35" → 35 정수 변환
    }

    close(fd);

    // 배열 전체 출력
    for (i = 0; i < 10; i++) {
        printf("%d ", data[i]);
    }
    printf("\n");

    return 0;
}
```

* read(fd, buf, 2) → "35" 두 글자 읽기
* atoi("35") → 35 정수 변환
* data[0..4] = 35, 나머지 = 0 → 출력 결과: 35 35 35 35 35 0 0 0 0 0

&ensp;한 일<br/>
1. test2를 읽기 전용으로 열고
2. 앞에서부터 두 글자씩 5번 읽어 "35" → atoi로 정수 35로 바꾸어 data[0..4]에 저장
3. data[5..9]는 0으로 유지(처음에 {0}으로 초기화했기 때문)
4. 배열 전체 출력

&ensp;파일 안의 35는 숫자 35가 아니라 문자 '3', '5' 두 글자(바이트)이다. 그래서 두 글자씩 읽은 뒤 문자열 → 정수 변환을 해주면 된다.<br/>

&ensp;결과<br/>
&ensp;35 35 35 35 35 0 0 0 0 0<br/>

&ensp;실습을 통해 배운 핵심 포인트<br/>
1. 열기 모드가 결과를 좌우한다.
* O_CREAT : 없으면 만든다.
* O_TRUNC : 있으면 내용 싹 지우고 0부터
* O_APPEND: 항상 끝에서 이어쓰기
* 아무 옵션 없이 O_WRONLY : 처음 위치에서 덮어쓰기 (앞부분만 바뀜)
2. 권한 숫자(mode) 는 “처음 생성할 때” 적용
* 0600(나만 rw), 0640(나 rw, 그룹 r)
* 이미 파일이 있으면 O_TRUNC로 내용만 지우더라도 권한은 유지
* 가끔 umask 때문에 기대보다 권한이 깎여 보일 수 있음 → chmod 600 test1
3. cat은 줄바꿈이 없으면 착시가 생김
* cat test1 후 프롬프트가 붙어 보일 수 있어요 → cat test1; echo 또는 wc -c
4. 문자 vs 숫자
* 파일의 "35"는 진짜 숫자 35가 아니라 문자 '3'과 '5' 두 글자
* 숫자로 쓰고 싶다면 포맷팅을 하거나(예: snprintf), 직접 자리수 계산해 문자를 만든다.
* 오늘은 과제 취지에 맞춰 문자 "35"를 10번 써서 해결

실습 2
======

&ensp;1. 다음과 같이 실행하는 프로그램을 작성 한 후 실행시킵니다.<br/>

&ensp;(a) 읽기쓰기 가능한 "data1" file을 생성하고, 문자 ‘X'를 10개 씁니다.<br/> 
&ensp;(b) "data1" file의 첫 번째 위치로 file pointer를 옮긴 후 문자 ‘Y'를 하나 씁니다.<br/> 
&ensp;(c) "data1" file의 마지막 문자 다음 위치로 file pointer를 옮긴 후 문자 ‘Y'를 하나 씁니다.<br/> 
&ensp;(d) "data1" file의 2, 4, 6, 8번째 문자를 ‘Z'로 바꾸어 씁니다. (e) "data1" file의 15번째 위치에 문자 ‘T'를 씁니다.<br/> 
&ensp;(f) "data1" file의 뒤에서 2번째 위치에 문자 ‘S'를 씁니다. (g) 'S' 바로 앞에 문자 ‘W'를 씁니다.<br/> 
&ensp;(h) 프로그램 실행 후 cat 명령을 이용하여 "data1" file의 내용이 "YZXZXZXZXXYWST" 인지 확인합니다. vi 명령으로 "data1" file의 내용을 확인합니다. cat 명령으로 확인한 내용과 차이가 나는 이유를 생각해 봅니다.<br/>

```c
int main(void){
 char ch='X';
 int i, fd;
 // 1-(a)
 for (i=0;i<10;i++){
 write(fd, &ch, 1);
 }
 // 1-(b)
 write(fd, "Y", 1);
 // 1-(c)
 write(fd, "Y", 1);
 for (/* 1-(d)-1 */){
 // 1-(d)-2
 write(fd, "Z", 1);
 }
 // 1-(e)
 write(fd, "T", 1);
 // 1-(f)
 write(fd, "S", 1);
 // 1-(g)
 write(fd, "W", 1);
 return 0;
}
```

&ensp;최종 코드 정리<br/>
```c
#include "common.h"

int main(void){
    char ch = 'X';
    int i, fd;

    // (a) data1 생성 후 'X' 10개 쓰기
    fd = open("data1", O_RDWR | O_CREAT | O_TRUNC, 0644);

    for(i = 0; i < 10; i++){
        write(fd, &ch, 1);
    }

    // (b) 처음으로 이동 후 'Y'
    lseek(fd, 0, SEEK_SET);
    write(fd, "Y", 1);

    // (c) 끝으로 이동 후 'Y'
    lseek(fd, 0, SEEK_END);
    write(fd, "Y", 1);

    // (d) 2,4,6,8번째를 'Z'로 변경
    for(i = 1; i < 8; i += 2){
        lseek(fd, i, SEEK_SET);
        write(fd, "Z", 1);
    }

    // (e) 15번째 위치에 'T'
    lseek(fd, 14, SEEK_SET);
    write(fd, "T", 1);

    // (f) 끝에서 -2 위치에 'S'
    lseek(fd, -2, SEEK_END);
    write(fd, "S", 1);

    // (g) 'S' 바로 앞에 'W'
    lseek(fd, -2, SEEK_CUR);
    write(fd, "W", 1);

    return 0;
}
```

&ensp;이번에 쓴 주요 명령어(system call)<br/>
* open(filename, flags, mode)<br/>
&ensp; 파일을 열거나 생성
&ensp;O_RDWR | O_CREAT | O_TRUNC, 0644 → 읽기/쓰기 가능, 없으면 만들고, 있으면 비우고, 권한 rw-r--r--.<br/>

* write(fd, buf, size)<br/>
&ensp;현재 파일포인터(current position)위치에 데이터를 쓴다.<br/>
&ensp;쓰고 나면 파일포인터는 size만큼 앞으로 이동<br/>

* lseek(fd, offset, where)<br/>
&ensp;파일포인터를 원하는 위치로 이동<br/>
* SEEK_SET: 파일 시작 기준 offset
* SEEK_END: 파일 끝 기준 offset
* SEEK_CUR: 현재 위치 기준 offset

&ensp;current position(파일 포인터)이동 과정<br/>
&ensp;아래 그림에서 | = 파일 포인터(current)<br/>
&ensp;X,Y,Z,S,W,T = 실제 파일에 기록된 문자<br/>
&ensp;. = 아직 안 쓰인/널(0x00)<br/>

&ensp;(a)X 10개 쓰기<br/>
```makefile
파일: X X X X X X X X X X
위치:                     |
```

&ensp;(b) 처음으로 이동 후 'Y'<br/>
```makefile
파일: Y X X X X X X X X X
위치:   |
```

&ensp;(c) 끝으로 이동 후 'Y'<br/>
```makefile
파일: Y X X X X X X X X X Y
위치:                       |
```

&ensp;(d) 2, 4, 5, 8번째 'Z'<br/>
```makefile
파일: Y Z X Z X Z X Z X X Y
위치:                       |
```

&ensp;(e) 15번째 위치에 'T'<br/>
```makefile
파일: Y Z X Z X Z X Z X X Y . . . T
위치:                            |
```

&ensp;(f) 끝에서 -2 → 'S'<br/>
```makefile
파일: Y Z X Z X Z X Z X X Y . . S T
위치:                          |
```

&ensp;(g) 현재에서 -2 → 'W'<br/>
```makefile
파일: Y Z X Z X Z X Z X X Y . W S T
위치:                        |
```

&ensp;cat vs vi 차이<br/>
* cat data1 : 널(\0)을 그냥 무시 → YZXZXZXZXXYWST 처럼 보임
* vi data1 : 널(\0)을 눈에 보이게 ^@ 등으로 표시 → YZXZXZXZXXY^@WST


&ensp;lseek의 예시<br/>
&ensp;1. lseek(fd, 0, SEEK_SET);<br/>
* 파일 시작(0번 인ㅌ덱스)으로 이동
* ex) 파일 길이가 11, current=11이였더라도 -> current=0으로 이동

```css
[시작]Y X X X X X X X X X Y
 ↑
 포인터
```

&ensp;2. lseek(fd, 0, SEEK_END);<br/>
* 파일 끝(마지막 다음 자리)으로 이동
* ex) 파일 길이가 11이면 -> current = 11위치로 이동

```makefile
Y X X X X X X X X X Y|
                      ↑ EOF (끝 다음)
```

&ensp;3. lseek(fd, n, SEEK_SET);<br/>
* 파일 시작(0)에서 n칸 떨어진 곳으로 이동
* ex) lseek(fd, 14, SEEK_SET); -> 파일 시작에서 14번 인덱스로 점프
* 만약 그 위치가 아직 파일 크기보다 크면 그 중간을 널(0)로 채워짐

```makefile
파일길이=11 → 14로 점프
Y Z X Z X Z X Z X X Y . . .T
                          ↑14
```

&ensp;4. lseek(fd, -2, SEEK_END);<br/>
* 파일 끝에서 거꾸로 2칸 이동
* 예: 파일 크기 = 15라면 EOF=15 -> 15-2 = 13 -> current=13

```makefile
Y Z X Z X Z X Z X X Y . . S T
                         ↑13
```

&ensp;5. lseek(fd, -2, SEEK_CUR);<br/>
* 현재 위치에서 거꾸로 2칸 이동
* ex) 방금 (f)에서 s를 쓰고 current=14 -> -2하면 current=12

```makefile
Y Z X Z X Z X Z X X Y . W S T
                       ↑12
```

&ensp;🚀 파일포인터 이동 원리 정리<br/>
<p align="center"><img src="/assets/img/Linux Programming/Lect4/4-2.png" width="600"></p>
