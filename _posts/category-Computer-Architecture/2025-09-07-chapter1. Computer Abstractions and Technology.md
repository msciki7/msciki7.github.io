---
title: "chapter1. 컴퓨터 추상화 및 관련 기술"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Architecture
tags:
  - CS

toc: true
toc_sticky: true

date: 2025-09-05
last_modified_at: 2025-09-05
---

Computer Architecture (컴퓨터 구조란?)
======

* ISA(Instruction Set Architecture, 명령어 집합 구조)

&ensp;-> 프로그래머가 사용할 수 있는 명령어들의 집합<br/>
&ensp;-> 하드웨어와 무관하게 컴퓨터가 무엇을 할 수 있는지 정의<br/>
* 역사적 배경
  - 1964년 IBM System/360에서 처음 Computer Architecture라는 용어 등장
  - System/360은 여러 모델이 있었지만 동일한 ISA를 공유
  - 덕분에 같은 프로그램을 여러 컴퓨터에서 실행 가능

&ensp;👉 핵심 요약: 컴퓨터 구조는 **“무엇을 할 수 있는가”**를 정의하는 약속<br/>

Architecture vs Implementation
======

&ensp;컴퓨터를 이해할 때 중요한 두 개념이 있다.<br/>
* Architecture(= ISA)
  - 소프트웨어와 하드웨어 사이의 인터페이스(약속)
  - 무엇(what)을 할지 정의
  - 예: 명령어, 레지스터, 메모리 접근 방식
  - 대표 사례: MIPS, IA-32, SPARC, PowerPC
* Implementation(= Microarchitecture)
  - 실제로 ISA를 실행하는 하드웨어 구현
  - 어떻게(how) 실행한지 정의
  - 대표사례: Intel 8086, Pentium 시리즈 등

&ensp;👉 비유:<br/>
* Architecture = 집 설계도
* Implementation = 실제로 집을 짓는 방식(자재, 공법 등)

Abstraction Layers in Modern Systems
======

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-1.png" width="600"></p>

&ensp;컴퓨터는 여러 추상화 계층으로 이루어진 피라미드 구조이다.<br/>
* 상위(사람이 직접 다루는 부분)
  - Application(앱: 게임, 카톡, 유튜브)
  - Algorithm(정렬, 검색, 추천 등)
  - Programming Language(C, Python, Java)
  - Operating System/Virtual Machine(윈도우, 리눅스, JVM)
* 중간(컴퓨터구조의 핵심)
  - ISA(명령어 집합 구조)
  - Microarchitecture(CPU 내부 설계)
  - RTL(레지스터 간 데이터 이동)
* 하위(물리적 세계)
  - Circuits(논리 회로)
  - Devices(트랜지스터)
  - Physics(물리학)
  - Chemistry(반도체 재료)

&ensp;👉 이 계층 덕분에 우리가 Python으로 코드를 작성해도, 결국 전자가 트랜지스터 안에서 움직여 계산이 되는 거다.<br/>

컴퓨터의 종류
======

&ensp;컴퓨터는 용도에 따라 네 가지로 나눌 수 있다.<br/>

1. PC(Personal Computer) 🖥️
* 범용(게임, 코딩, 문서 작업)
* 가격 대비 성능 고려
2. Server(서버 컴퓨터) 🗄️
* 네트워크 기반, 여러 사용자 지원
* 높은 성능과 안정성 필요
3. Supercomputer ⚡
* 고성능 과학/공학 계산(기상 예측, 시뮬레이션)
* 시장 점유율은 적지만 성능은 최고
4. Embedded Computer(임베디드 컴퓨터)📱
* 작고, 저전력, 저비용 설계가 핵심

Post-PC 시대
=====

&ensp;이제는 개인용 PC만으로는 부족한 시대이다. 사람들이 스마트폰과 클라우드를 더 많이 쓰기 시작했다.<br/>

* PMC(Personal Mobile Device, 개인용 모바일 기기)
  - 배터리로 작동
  - 인터넷 연결 필수
  - 수백 달러 가격대
  - 스마트폰, 태블릿, 전자안경 등이 대표

* 클라우드 컴퓨팅(Cloud Computing)
  - 대규모 데이터 센터(Warehose-Scale Computer, WSC)활용
  - SaaS(Software as a Service): 프로그램 일부는 클라우드에서 실행
  - 아마존, 구글이 대표적인 사례

&ensp;👉 정리: 스마트폰(개인 기기) + 클라우드(대형 서버) 조합이 현대 컴퓨팅의 핵심 구조<br/>

프로그램 성능을 이해하기
=====

&ensp;프로그램이 빨리/느리게 실행되는 이유는 여러 계층의 영향을 받는다.<br/>
* 알고리즘: 연산 횟수를 결정
* 프로그래밍 언어, 컴파일러, 아키텍처: 한 연산을 몇 개의 명령어로 바꿀지 결정
* 프로세서 & 메모리 시스템: 명령어 실행 속도 결정
* I/O 시스템(하드웨어 + 운영체제): 입력/출력 속도 결정

&ensp;👉 즉, 성능은 소프트웨어 + 하드웨어의 합작품<br/>

컴퓨터의 5가지 주요 구성 요소
======

&ensp;모든 컴퓨터는 크게 다섯 가지 구성요소로 나눌 수 있다.<br/>
1. 입력장치(Input) -> 키보드, 마우스, 센서
2. 출력장치(Output) -> 모니터, 프린터
3. 메모리(Memory) -> 데이터를 저장하는 공간
4. 데이터패스(Datapath) -> 연산 수행
5. 제어장치(Control) -> 명령어 해석 & 실행 흐름 제어

&ensp;👉 이 5가지가 협력해서 우리가 작성한 프로그램이 동작하게 됨<br/>

최신 프로세서의 예시
=====

&ensp;현대 CPU는 단순 계산기 수준을 넘어 다양한 기능을 담고 있다.<br/>
* 멀티코어(Multi-core): 하나의 칩에 여러 개의 CPU 탑재(예: AMD Barcelona, Intel i7)
* GPU(그래픽 처리 장치): 그래픽 & 병렬 계산 처리
* NPU(신명망 처리 장치): 인공지능 연산 가속기(예: Apple A12의 Neural Engine)
* 캐시 메모리(Cache): 속도를 높이기 위해 CPU 안에 위치한 초고속 메모리

&ensp;👉 최신 칩은 CPU + GPU + AI 가속기 + 메모리 인터페이스가 모두 들어있는 작은 "컴퓨터 공장" 같은 존재<br/>

핵심 요약
====

* 현대는 PC 중심이 아니라 스마트폰 + 클라우드 시대
* 프로그램 성능은 알고리즘, 언어/컴파일러, 하드웨어 모든 단계의 영향을 받음
* 모든 컴퓨터는 5가지 구성 요소(입출력, 메모리, 데이터패스, 제어)로 구성됨
* 최신 CPU는 멀티코어 + GPU + AI 가속기까지 포함한 초집적 시스템

컴퓨터구조의 7가지 위대한 아이디어
=====

&ensp;컴퓨터 설계에는 항상 따라오는 황금 법칙같은 아이디어가 있다.<br/>
1. 추상화(Abstraction) 활용 -> 복잡한 설계를 단순화
2. Common Case 빠르게 (Make the Common Case Fast) -> 자주 쓰는 경우를 최적화
3. 병렬성 (Parallelism) -> 동시에 여러 작업 실행
4. 파이프라이닝 (Pipelining) -> 작업을 나눠서 공장 라인처럼 처리
5. 예측 (Prediction) -> 미래를 미리 예측해서 성능 향상
6. 메모리 계층 (Hierarchy of Memories) -> 캐시 -> 메모리 -> 디스크 순으로 빠르게
7. 중복을 통한 신뢰성 (Dependability via Redundancy) -> 중요한 데이터는 여러 군데에 복사

&ensp;이 7가지는 이후 모든 성능 이야기의 핵심<br/>

Performance (성능)란?
====

&ensp;성능의 발전<br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-2.png" width="600"></p>

&ensp;Moore's Law(무어의 법칙)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-3.png" width="600"></p>

&ensp;→ 반도체 칩에 들어가는 트랜지스터 수는 약 18~24개월마다 2배로 증가한다는 경험 법칙<br/>
&ensp;→ 그만큼 성능도 크게 향상<br/>

&ensp;프로세서-메모리 성능 격차 (Processor-Memory Performance Gap)<br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-4.png" width="600"></p>

* CPU(프로세서)성능은 매년 약 1.5배 가까이 향상
* 반면 메모리 속도는 매년 1.07배 정도만 향상
* 결과적으로 CPU는 점점 더 빨라지는데 메모리는 따라가지 못해 병목(bottleneck) 발생

&ensp;이 격차를 줄이기 위해 캐시 메모리와 같은 계층적 메모리 구조가 사용된다.<br/>
&ensp;정리: CPU는 점점 빨라지느넫 메모리는 상대적으로 느려져 성능 차이가 점점 벌이진다.<br/>

Defining Performance
----

&ensp;성능이 좋은 컴퓨터는 상황에 따라 다르게 정의된다.<br/>

&ensp;✈️ 비행기 비유:<br/>

* 어떤 비행기가 성능이 가장 좋은가?
  - 좌석 수(승객 수용량)
  - 항속 거리(얼마나 멀리 가는지)
  - 속도(얼마나 빠른지)
  - 승객 처리량(좌석 수 x 속도)

&ensp;성능은 하나의 지표만으로 평가할 수 없다. 전체적인 처리 능력을 봐야 한다.<br/>

컴퓨터 성능의 기준 (Performance of a Computer)
----

&ensp;성능이 좋다는 건 더 빠르게 작업을 끝낸다는 뜻이다.<br/>
* Response Time(응답시간/실행시간)
  - 한 작업을 시작해서 끝날 때까지 걸린 시간
* Throughput(처리량/대역폭)
  - 일정 시간 동안 처리할 수 있는 작업의 총량

&ensp;즉 누가 빨리 끝내냐 vs 누가 더 많이 처리하냐 두 가지 관점<br/>

&ensp;수식으로 표현하면:<br/>
* 성능(Performance) = 1 / 실행시간
* X가 Y보다 n배 빠르다 = 

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-5.png" width="600"></p>

&ensp;즉 실행시간이 짧을수록 성능이 좋다.<br/>

성능 측정 방법 (Measuring Performance)
----

* 경과 시간(Elapsed Time, Wall-clock Time)
  - 실제 작업이 끝날 때까지 걸린 전체 시간
  - 디스크 접근, 입출력(I/O), 운영체제 처리까지 모두 포함
  - 시스템 전체 성능 평가에 적합
* CPU 시간(CPU Time)
  - CPU가 해당 작업에만 사용한 시간
  - I/O 대기나 다른 프로그램 실행 시간은 제외
  - CPU 성능 평가에 적합
  - CPU 시간 = 사용자 모드 시간 + 시스템 모드 시간

&ensp;보통 컴퓨터구조에서는 CPU 성능에 집중한다.<br/>

&ensp;CPU Clocking (클럭)<br/>
* 디지털 하드위에는 모두 클럭(clock)이라는 일정한 박자에 맞취 동작
* 클럭 주기(Clock Cycle Time) = 한 클럭이 걸리는 시간
* 클럭 속도(Clock Rate) = 1초에 몇 번 클럭이 반복되는지

&ensp;쉽게 말해 CPU는 초당 수십억 번의 박자에 맞춰 계산을 수행한다.<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-6.png" width="600"></p>

&ensp;CPU 성능의 세가지 요소<br/>
&ensp;CPU 성능을 결정하는 핵심 공식:<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-7.png" width="600"></p>

* IC(Instruction Count): 프로그램이 실행하는 명령어 개수
* CPI(Clock Cycles Per Instruction): 명령어 하나를 실행하는데 걸리는 평균 클럭 수
* Clock Cycle Time / Clock Rate: 클럭 속도

&ensp;성능 향상 방법<br/>
1. 명령어 개수 줄이기(컴파일러, 알고리즘 최적화)
2. CPI 줄이기(효율적인 CPU 설계)
3. 클럭 속도 높이기(더 빠른 회로)

&ensp;성능 비교 예제<br/>
* 컴퓨터 A: 2GHz, CPU 시간 10초
* 컴퓨터 B: 목표 CPU 시간 6초
  - 클럭 속도를 올리면 성능 향상 가능하지만, 그 대신 클럭 사이클 수가 1.2배 증가

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-8.png" width="600"></p>

&ensp;계산을 통해 필요한 클럭 속도를 구하면, 약 4GHz가 필요하다는 결과가 나온다.<br/>
&ensp;단순히 클럭만 올리는 게 아니라 사이클 수 증가와 CPI도 고려해야 한다.<br/>

Instruction Performance (명령어 성능)
-----

* 프로그램 실행 시간은 IC × CPI × CCT로 결정된다.
* IC는 프로그램/컴파일러/ISA에 따라 달라진다.
* CPI는 CPU 하드웨어 설계에 따라 달라진다.
* 따라서 같은 프로그램이라도 CPU마다 실행 속도가 달라질 수 있다.

&ensp;예제<br/>
* CPU A: 클럭 사이클 = 250ps, CPI = 2.0
* CPU B: 클럭 사이클 = 500ps, CPI = 1.2

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-9.png" width="600"></p>

&ensp;A와 B 비교하면, A가 1.2배 빠르다.<br/>

&ensp;고전적인 CPU 성능식<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-10.png" width="600"></p>

&ensp;예제: 코드의비교<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-11.png" width="600"></p>

&ensp;답<br/>
&ensp;실행 명령어 개수1 = 2 + 1 + 2 = 5<br/>
&ensp;실행 명령어 개수2 = 4 + 1 + 1 = 6
&ensp;코드 1이 더 적은 명령어를 실행한다.<br/>

&ensp;CPU 클럭 사이클 수1 = 2x1 + 1x2 + 2x3 = 10<br/>
&ensp;CPU 클럭 사이클 수2 = 4x1 + 1x2 + 1x3 = 9<br/>
&ensp;코드 2가 더 빠르다.<br/>

&ensp;CPI1 = CPU 클럭 사이클 수1 / 명령어 개수1 = 10 / 5 = 2.0<br/>
&ensp;CPI2 = 9/6 = 1.5<br/>
&ensp;코드2의 CPI가 더 작다.<br/>

&ensp;요점정리<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-12.png" width="600"></p>

* 알고리즘 -> 명령어 개수, CPI에 영향
* 프로그래밍 언어 -> 명령어 개수, CPI에 영향
* 컴파일러 -> 명령어 개수, CPI에 영향
* ISA -> 명령어 개수, CPI, 클럭 속도 모두에 영향

&ensp;성능은 소프트웨어 + 하드웨어 협력의 결과물<br/>

단일코어 → 멀티코어로의 전환 (The Sea Change)
=====

&ensp;과거에는 단일 프로세서(Uniprocessor)의 성능을 올리기 위해 클럭 속도와 ILP(Instruction-Level Paralleism, 명령어 수준 병렬성)를 높이는 방식으로 발전했다.<br/>

&ensp;하지만 2000년대 이후 발열, 전력, 메모리 지연(latency)때문에 성능 향상이 둔화되었고 단일 코어 향상만으로는 한계가 왔다.<br/>

&ensp;그래서 멀티코어(Multiprocessor)시대가 시작<br/>
* 여러 개의 코어가 동시에 작업을 분담 -> 병렬 처리

&ensp;멀티코어 트렌드 (Multicore Trends)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-13.png" width="600"></p>

* 트랜지스터 수(오렌지 ▲) → 꾸준히 기하급수적으로 증가 (Moore’s Law)
* 클럭 주파수(초록 ■) → 2000년대 이후 거의 정체
* 소비 전력(빨간 ▼) → 전력 증가가 한계에 다다름
* 싱글 스레드 성능(파랑 ●) → 증가율 둔화
* 코어 개수(검은 ◆) → 2000년대 이후 급격히 증가

&ensp;더 이상 클럭 속도를 못 올리니 코어 개수를 늘려 성능을 확보하는 방향으로 변화<br/>

결론 (Concluding Remarks)
=====

&ensp;1. 성능/비용은 지속적으로 개선<br/>
* 반도체 기술 발전 덕분에 같은 값으로 더 빠른 컴퓨터 사용 가능

&ensp;2. 추상화 계층 (Abstraction Layers)<br/>
* 하드웨어와 소프트웨어 인터페이스의 핵심

&ensp;3. ISA(Instruction Set Architecture)<br/>
* 여전히 하드웨어/소프트웨어 인터페이스의 핵심

&ensp;4. 실행 시간(Execution Time)<br/>
* 가장 좋은 성능 지표는 실행시간
* 수식으로 표현:

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-14.png" width="600"></p>

&ensp;5. 전력은 큰 제한 요소(Power Wall)<br/>
* 단일 코어로는 한개 -> 병렬성(Parallelism, Multicore) 활용해야 한다.

보충
=====

칩 제조 과정 (Chip Manufacturing Process)
----

1. 실리콘 주괴(Silicon ingot) -> 큰 원통형 결정체
2. 슬라이서(Slicer) -> 얇게 잘라 웨이퍼(Wafer) 제작
3. 가공 단계 (20~40 단계) -> 회로 패턴을 웨이퍼 위에 인쇄
4. 웨이퍼 테스트(Wafer tester) -> 웨이퍼 상태 점검
5. 다이 분리(Dicer) -> 웨이퍼를 잘라 작은 칩(Die)으로 분리
6. 패키징(Bonding & Packaging) -> 외부와 연결 가능한 형태로 포장
7. 최종 테스트 -> 불량 여부 검사 후 출하

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-15.png" width="600"></p>

칩 제조 비용 구조 (Cost Analysis)
-----

&ensp;칩 하나(Die)의 단가는 단순히 웨어퍼 면적에 비례하지 않는다.<br/>

* Die당 비용 (Cost per die)

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-16.png" width="600"></p>

* 웨이퍼당 다이 개수 (Dies per wafer)

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-17.png" width="600"></p>

* 수율 (Yield)

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-18.png" width="600"></p>

&ensp;요약<br/>
* 웨이퍼 크기와 비용은 고정
* 결함률과 Die 면적이 커질수록 수율이 떨어지고 비용 증가
* 따라서 칩 크기가 작게 설계할수록 더 많은 다이를 얻고 단가도 낮출 수 있다.

Power Wall (전력의 벽)
----

&ensp;CPU 속도를 올리는 가장 전통적인 방법은 클럭 속도 증가였다. 하지만 2000년대 들어 전력 소모와 발열 문제 때문에 한계에 도달했다.<br/>

* 전력 소모 공식

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-19.png" width="600"></p>

* Capacitive Load: 회로의 크기(트랜지스터 수)
* Voltage (전압): 공급 전압
* Frequency (주파수): 클럭 속도

&ensp;전압을 5V → 1V로 줄이고, 회로 효율을 개선하면서 전력은 크게 줄었지만, 더 이상 줄이기 어려운 지점에 도달했다.<br/>

&ensp;전력 예제 (Relative Power)<br/>
* 기존 CPU 대비 85%의 회로 용량, 전압과 주파수를 각각 15% 줄였다면?

&ensp;계산: <br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-20.png" width="600"></p>

&ensp;새로운 CPU는 이전보다 약 절반(52%)의 전력만 사용<br/>

&ensp;하지만<br/>
* 전압은 더 이상 줄이기 어려움
* 발열(열 제거)문제도 해결 불가

&ensp;결국 Power Wall(전력의 벽)때문에 CPU 성능 향상 방식이 바뀌게 된다.<br/>

성능 평가: 벤치마크 (Benchmarking)
-----

&ensp;성능을 비교할 때 단순히 클럭 속도만 보면 안 된다. 그래서 벤치마크 프로그램을 활용한다.<br/>
* Benchmark 정의
  - 성능 비교를 위해 선택된 프로그램 모음ㅁ
  - 실제 사용자가 실행할 작업을 대표하도록 설계
* SPEC (Standard Performance Evaluation Corporation)
  - 1988년 설립
  - 컴퓨터 성능 평가 국제 표준 단체
* SPEC CPU2017
  - SPECspeed2017 Integer → 정수 연산 벤치마크 (10개 프로그램)
  - SPECspeed2017 Floating Point → 부동소수점 연산 벤치마크 (13개 프로그램)
  - SPECration → 기준(reference) CPU와 비교해 얼마나 빠른지 계산한 값

&ensp;즉, SPEC 점수는 클럭 속도가 아니라 실제 프로그램 실행 성능을 보여주는 지표<br/>

SPEC Power Benchmark
-----

&ensp;데이터센터 서버는 항상 100%로만 일하지 않는다. 그래서 부하(load)를 0%→100%까지 10% 간격으로 바꾸며 성능과 전력을 동시에 재는 벤치마크가 SPECpower이다. 성능 단위는 ssj_ops/sec, 전력은 와트(=줄/초)로 측정한다. 최종 지표는 모든 구간의 성능 합을 모든 구간의 전력 합으로 나눈 “Overall ssj_ops per Watt” 이다.<br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-21.png" width="600"></p>

&ensp;(부하 0%, 10%, …, 100%에서의 측정치를 모두 더해 계산)<br/>

&ensp;성능의 함정들(Fallacies & Pitfalls)<br/>
&ensp;(1) 암달의 법칙을 무시함<br/>
&ensp;일부만 빨라져도 전체 성능 향상은 제한적이다.<br/>
* 공식

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-22.png" width="600"></p>

&ensp;예: 전체 100초 중 곱셈이 80초를 차지할 때, 전체 4배 빨라지려면 곱셈을 16배 빨라져야 한다. 결론은 항상 “자주 일어나는 공통 경우를 빠르게(Make the common case fast)”.<br/>

&ensp;(2) 서버는 낮은 부하에서 전력 거의 안 쓴다는 착각<br/>
&ensp;구글의 대규모 데이터센터 서버는 대부분 10~50% 부하로 운영되고, 100%는 1% 미만의 시간만 사용한다. 그런데 **부하 10%에서도 최대 전력의 약 33%**를 쓰는 결과가 보고되었다. 그래서 부하에 비례해 전력이 줄어드는 하드웨어(에너지-비례 컴퓨팅) 가 필요한다.<br/>

&ensp;(3) MIPS 같은 부분 지표로 성능을 판단함<br/>
&ensp;성능은 IC × CPI × 클럭의 함수인데, MIPS(초당 백만 명령)만 보면 ISA 차이나 명령의 복잡도를 반영하지 못한다. 따라서 실행시간 기반 혹은 SPEC 같은 실제 워크로드 기반 지표를 사용해야 정확하다.<br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter1. computer abstractions and technology/1-23.png" width="600"></p>