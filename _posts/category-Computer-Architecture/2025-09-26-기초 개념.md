---
title: "기초 개념"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Architecture
tags:
  - CS

toc: true
toc_sticky: true

date: 2025-09-26
last_modified_at: 2025-09-26
---

&ensp;10진수 → 2진수 변환<br/>
```markdown
45 ÷ 2 = 22 …1  
22 ÷ 2 = 11 …0  
11 ÷ 2 = 5  …1  
5 ÷ 2  = 2  …1  
2 ÷ 2  = 1  …0  
1 ÷ 2  = 0  …1  
```

&ensp;(101101)₂<br/>

&ensp;2진수 → 10진수 변환<br/>
&ensp;방법: 각 자리 x 2의 거듭제곱<br/>
* 예시: (1101)₂ = 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8 + 4 + 0 + 1 = 13

&ensp;2진수 덧셈<br/>
&ensp;규칙<br/>
* 0 + 0 = 0
* 0 + 1 = 1
* 1 + 1 = 0 (올림 1)
* 1 + 1 + 1 = 1 (올림 1)

&ensp;예시: (1011)₂ + (1101)₂<br/>
```markdown
   1011
+  1101
-------
 11000
```

&ensp;(24)₁₀<br/>

&ensp;16진수 ↔ 2진수 변환<br/>
&ensp;규칙: 2진수 4자리 = 16진수 1자리<br/>

<p align="center"><img src="/assets/img/Computer Architecture/기본 개념/0-1.png" width="600"></p>

&ensp;예시: (2F)₁₆ → (0010 1111)₂ → (47)₁₀<br/>

&ensp;2진수 뺄셈<br/>
&ensp;규칙은 10진수 뺄셈과 동일 단 0에서 1을 빼야 할 때 -> 앞에서 1을 빌려옴<br/>
&ensp;예시: (1011)₂ − (110)₂<br/>
```markdown
  1011 (11)
- 0110 (6)
=  0101 (5)
```

&ensp;논리 연산자 & 진리표<br/>
* AND(그리고), OR(또는), NOT(아니)
* 예: 1 AND 1 = 1, 나머지는 0

&ensp;기본 게이트 → 조합 논리 회로<br/>
* 게이트(Gate) = AND, OR, NOT을 전기회로로 만든 것
* 이걸 조합해서 반가산기(Half Adder), 전가산기(Full Adder)를 만들 수 있다.
* 결국 2진수 덧셈기계를 전기로 만든 게 가산기

&ensp;데이터 표현 방식<br/>
* 정수 표현: 2의 보수(Two's complement) → 음수 표현 방식
* 실수 표현: 부동소수점(Floating Point) → 32비트(IEEE 754) 표준

&ensp;CPU 기본 구조<br/>
* 레지스터(Register): 초고속 임시 저장소
* ALU: 덧셈/뺄셈 같은 산술연산 담당
* 제어장치(Control Unit): 명령어 해석 후 신호 전달
* 메모리 구조: 계층구조(레지스터 → 캐시 → RAM → 디스크)

&ensp;명령어 집합 & 어셈블리<br/>
* MIPS, ARM 같은 명령어 집합 구조(ISA) 학습
* add $t0, $t1, $t2 같은 간단한 어셈블리 코드 해석
* 고수준 언어(C, Java) → 어셈블리 → 기계어(0과1) 연결 이해

&ensp;논리 게이트와 가산기<br/>
&ensp;기본 논리 게이트<br/>
&ensp;컴퓨터 회로 0(전기 OFF), 1(전기 ON) 두 가지 신호를 다룬다.<br/>
&ensp;이를 조합하는 기본 단위가 게이트(Gate)이다.<br/>
<p align="center"><img src="/assets/img/Computer Architecture/기본 개념/0-2.png" width="600"></p>

&ensp;반가산기(Half Adder)<br/>
&ensp;목표: 2진구 한 자리 + 한 자리 = 합과 올임을 계산하는 회로<br/>
* 입력: A, B(0 또는 1)
* 출력: 합(sum), 올림(carry)

&ensp;회로 구성:<br/>
* 합(S) = A ⊕ B (XOR 게이트)
* 올림(C) = A · B (AND 게이트)

<p align="center"><img src="/assets/img/Computer Architecture/기본 개념/0-3.png" width="600"></p>

&ensp;전가산기(Full Adder)<br/>
&ensp;문제: 반가산기는 올림(Carry-in)을 고려 못 함<br/>
&ensp;그래서 “Carry-in”을 입력으로 받는 전가산기 필요<br/>
* 입력: A, B, Cin (들어온 올림)
* 출력: 합(sum), 올림(Cont)

&ensp;회로 구성:<br/>
* 합(S) = (A ⊕ B) ⊕ Cin
* 올림(Cout) = (A · B) + (Cin · (A ⊕ B))

&ensp;진리표:<br/>
<p align="center"><img src="/assets/img/Computer Architecture/기본 개념/0-4.png" width="600"></p>

&ensp;CPU와의 연결<br/>
* 반가산기/전가산기를 여러 개 연결하면 n비트 가산기(예: 32비트 덧셈기)가 됨
* 이게 바로 CPU 안에 있는 ALU(산술논리연산장치)의 기초 구조이다.
* 덧셈, 뺄셈, 비교 연산 전부 이런 회로 기반

&ensp;가산기에서 CPU로 확장되는 과정<br/>
&ensp;1비트 전가산기<br/>
* 입력: A, B, Cin
* 출력: Sum, Cout

&ensp;4비트 리플 캐리 가산기 (Ripple Carry Adder)<br/>
* 전가산기를 4개 직렬로 연결한 구조
* 각 자리의 Cout(올림)이 다음 자리의 Cin으로 전달됨
* 예: (1011)₂ + (0101)₂ 계산 시
    - 0번째 비트 → Cout 발생 → 1번째 비트로 전달 → … 이런 식으로 ripple(물결처럼) 퍼져감

&ensp;32비트 덧셈기<br/>
* 똑같이 전가산기 32개를 일렬로 연결하면 32비트 정수 덧셈 가능
* CPU의 레지스터(32비트, 64비트)에 있는 값들을 이렇게 더함
* 이게 바로 ALU의 핵심 가능

&ensp;리플 캐리 가산기의 단점<br/>
* 모든 자리의 계산이 앞자리의 Cout에 의존 → 느림 (전파 지연 propagation delay 발생)
* 32비트, 64비트 덧셈 시 속도가 매우 느려질 수 있음

&ensp;해결 방법<br/>
&ensp;그래서 실제 CPU는 더 빠른 가산기 구조를 쓴다:<br/>
* Carry Lookahead Adder (CLA) : 올림을 미리 계산해 속도를 높임
* Carry Select Adder : 경우의 수를 미리 계산해 선택
* 병렬 Prefix Adder : 현대 CPU에서 자주 사용

&ensp;CPU와 연결<br/>
* ALU는 단순히 덧셈만 하는 게 아니라, 뺄셈(2의 보수), AND/OR/XOR 같은 논리 연산까지 담당
* 결국 전가산기를 기반으로 확장해서 산술·논리 연산을 모두 수행하게 만든 것이 ALU

&ensp;정리<br/>
* 반가산기 → 전가산기 → 여러 개 연결 → n비트 리플 캐리 가산기
* 리플 캐리 가산기 → 더 빠른 가산기(캐리 룩어헤드 등)로 발전
* 이것이 ALU의 덧셈기 역할을 담당
* 나중에 배우는 CPU 파이프라인, 명령어 실행의 기본 바탕이 됨

&ensp;명령어 사이클<br/>
1. Fetch (인출)
    - PC(Program Counter)가 가리키는 주소에서 명령어를 메모리에서 가져옴
2. Decode (해석)
    - 제어장치가 명령어를 해석 → 연산 종류, 사용 레지스터, 메모리 주소 확인
3. Execute (실행)
    - ALU가 실제 연산 수행 (덧셈, 뺄셈, 비교, 논리연산 등)
4. Memory Access (메모리 접근)
    - 명령어가 메모리를 필요로 하면 접근 (예: load, store)
5. Write Back (결과 저장)
    - 연산 결과를 레지스터에 저장
    - 상태 플래그(Zero, Carry, Overflow 등) 업데이트
6. PC 증가 → 다음 명령어로 이동
    - 사이클이 반복되며 프로그램이 실행됨

메모리 계층 구조 (Memory Hierarchy)
=====

&ensp;왜 계층 구조가 필요할까?<br/>
* CPU는 매우 빠름 (나노초 단위 연산)
* 메모리는 상대적으로 느림 (RAM: 나노~마이크로초, 디스크: 밀리초) → CPU가 항상 기다리지 않게 하려고 빠르지만 작은 메모리 ↔ 느리지만 큰 메모리를 계층 구조로 둠

&ensp;계층 구조의 레벨<br/>
`CPU 레지스터 (Register) → 캐시 (Cache) → 주기억장치 (RAM) → 보조기억장치 (HDD/SSD)`

&ensp;레지스터<br/>
* CPU 내부에 있는 초고속 저장소
* 수십~수백 개, 용량 매우 작음
* 한 번 접근하는데 1 CPU 사이클

&ensp;캐시(Cache Memory)<br/>
* CPU와 RAM사이 속도 차이를 줄이기 위해 존재
* L1, L2, L3 단계로 나눔
    - L1: 가장 빠르고 작음 (몇 KB)
    - L2: 좀 더 크고 느림 (MB 단위)
    - L3: 여러 코어가 공유, 더 큼(수 MB, 수십 MB)

&ensp;원리: 지역성(Locality)<br/>
* 시간 지역성: 최근에 쓴 데이터는 곧 쓴다.
* 공간 지역성: 어떤 데이터를 쓰면 근처 데이터도 곧 쓴다.

&ensp;RAM (주기억장치)<br/>
* 실행 중인 프로그램과 데이터 저장
* CPU가 직접 접근 가능
* 속도는 느리지만(나노초~마이크로초), 크기는 큼 (GB 단위)

&ensp;보조기억장치(디스크: HDD/SSD)<br/>
* SSD: 전자식, 빠름(마이크로초)
* HDD: 기계식, 느림(밀리초)
* 저장 용량은 큼(TB 단위)

&ensp;구조 그림<br/>
```markdown
빠르다 / 작다 / 비싸다
▼
CPU 레지스터
L1 캐시
L2 캐시
L3 캐시
RAM
SSD
HDD
▲
느리다 / 크다 / 싸다
```

&ensp;연결 포인트<br/>
* CPU가 연산할 때 → 레지스터에서 가져옴
* 필요 데이터 없으면 → 캐시 확인
* 캐시에도 없으면 → RAM 접근
* RAM에도 없으면 → 디스크에서 가져옴 (페이지 교체, 가상메모리 등장)

&ensp;이렇게 해야 속도와 용량 사이 균형을 맞출 수 있음<br/>

&ensp;요약<br/>
* 레지스터: 빠르고 작음,CPU 내부
* 캐시: CPU↔RAM 속도 차이 줄이는 완충지대
* RAM: 실행 중인 프로그램 저장
* 디스크: 영구 저장소

&ensp;0과 1에서 CPU까지<br/>
&ensp;편입생이거나 비전공자라면, 컴퓨터구조 수업에서 처음 나오는 개념들이 너무 낯설 수 있다. 저도 처음엔 2진수조차 생소했는데, 하나씩 차근차근 연결하면 "CPU가 어떻게 동작하는가" 큰 그림이 보인다.<br/>

&ensp;진수(2진수·16진수)<br/>
* 컴퓨터는 0과 1(전기 OFF/ON) 만 이해한다.
* 10진수(사람이 쓰는 숫자) ↔ 2진수(컴퓨터 숫자) 변환이 기본

&ensp;논리 게이트<br/>
* AND: 둘 다 1일 때만 1
* OR: 하나라도 1이면 1
* NOT: 반전 (0→1, 1→0)
* XOR: 서로 다르면 1

&ensp;이 게이트들이 전기회로로 만들어져 0과 1을 계산할 수 있다.<br/>

&ensp;가산기(Adder)<br/>
* 반가산기(Half Adder): 1비트 덧셈 (합 = XOR, 올림 = AND)
* 전가산기(Full Adder): 올림(Cin)까지 포함하는 덧셈

&ensp;여러 개 전가산기를 직렬로 연결하면 4비트, 8비트, 32비트 가산기가 된다.<br/>
&ensp;→ CPU의 ALU(산술논리연산장치) 가 바로 이 원리로 만들어진다.<br/>

&ensp;ALU (산술 논리 연산 장치)<br/>
* 덧셈/뺄셈
* 논리 연산 (AND, OR, XOR, NOT)
* 비교 연산 (==, <, >)

&ensp;연산 결과는 상태 플래그(Zero, Carry, Overflow, Negative) 로 기록된다.<br/>
&ensp;→ 이후 분기 명령어(if, while 같은 동작)를 가능하게 함<br/>

&ensp;명령어 사이클 (Instruction Cycle)<br/>
&ensp;CPU가 프로그램을 실행하는 순서:<br/>
1. Fetch: 메모리에서 명령어 읽기(PC가 가리킴)
2. Decode: 제어장치가 해석(무슨 연산인지)
3. Execute: ALU 실행(계산)
4. Memory Access: 필요 시 메모리 읽기/쓰기
5. Write Back: 결과를 레지스터에 저장

&ensp;이 사이클이 반복되며 프로그램이 실행된다.<br/>

&ensp;메모리 계층 구조<br/>
&ensp;CPU는 빠르고, 메모리는 상대적으로 느려진다.<br/>
&ensp;그래서 계층적으로 배치합니다:<br/>
* 레지스터: CPU 내부, 가장 빠름
* 캐시: CPU와 RAM 사이 속도차 완충 (L1/L2/L3)
* RAM: 실행 중인 프로그램 저장
* 보조기억장치(SSD/HDD): 영구 저장소

&ensp;원리: 지역성(Locality)<br/>
* 시간 지역성: 최근에 쓴 건 곧 또 쓴다.
* 공간 지역성: 어떤 데이터를 쓰면, 그 주변도 곧 쓴다.

&ensp;전체 흐름 요약<br/>
```markdown
0과 1 (이진수)
   ↓
논리 게이트 (AND, OR, XOR, NOT)
   ↓
가산기 (Adder)
   ↓
ALU (산술·논리 연산)
   ↓
명령어 사이클 (Fetch → Decode → Execute → Memory → Write Back)
   ↓
메모리 계층 (레지스터 → 캐시 → RAM → 디스크)
```

