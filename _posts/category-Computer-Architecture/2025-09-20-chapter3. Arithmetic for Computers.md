---
title: "chapter3. Arithmetic for Computers"
excerpt: ""

writer: sohee Kim
categories:
  - Computer Architecture
tags:
  - CS

toc: true
use_math: true 
toc_sticky: true

date: 2025-09-20
last_modified_at: 2025-10-10
---

기본 개념
=====

&ensp;<b>이진수(Binary Number)</b><br/>
* 우리가 일상에서 쓰는 수는 10진수(Decimal) → 0~9까지의 숫자로 구성
* 컴퓨터는 전기 신호(ON = 1, OFF = 0) 만 이해 → 그래서 이진수(0과 1만 사용) 를 씀

&ensp;예시:<br/>
&ensp;10진수 13 → 2진수 1101(왜냐면 13 = 8 + 4 + 1 = 2³ + 2² + 2⁰)<br/>
&ensp;👉 즉, 자리값이 2의 거듭제곱으로 늘어난다고 생각하면 된다.<br/>

&ensp;이진수의 자리값 (MSB, LSB)<br/>
`01011000 00010101 00101110 11100111`

* LSB (Least Significant Bit) → 제일 오른쪽 (가장 작은 값, 2⁰ 자리)
* MSB (Most Significant Bit) → 제일 왼쪽 (가장 큰 값, 2³¹ 자리)

&ensp;비유하자면:<br/>
* LSB = 일의 자리
* MSB = 가장 큰 자리(억, 조 자리 같은 느낌)

&ensp;<b>Unsigned Integer (부호 없는 정수)</b><br/>
* “항상 양수”만 표현한다고 가정
* 32비트라면, 0부터 2³² - 1 까지 가능 → 즉, 0 ~ 4,294,967,295

&ensp;비유: 주민번호 뒷자리처럼 음수는 없고, 그냥 번호표라고 생각하면 된다.<br/>

&ensp;<b>Signed Integer (부호 있는 정수)</b><br/>
* 컴퓨터는 음수도 표현해야 함 → 가장 왼쪽(MSB)을 부호 비트(Sign Bit) 로 사용
    - 0 → 양수
    - 1 → 음수

&ensp;예: 8비트 signed 정수 → -128 ~ +127 까지 표현 가능<br/>
&ensp;👉 왜냐면 한 자리를 부호 표시로 쓰니까, 표현 범위가 절반으로 줄어듦<br/>

&ensp;<b>Overflow (넘침 현상)</b><br/>
* 4자리 십진수에서 9999 + 1 = 0000 되는 것처럼 컴퓨터도 자리수(비트 수)를 초과하면 다시 0으로 돌아감

&ensp;예시: 8비트 unsigned: 11111111 (255) + 1 → 00000000 (0) (넘침)<br/>

&ensp;<b>16진수(Hexadecimal) 왜 쓰나?</b><br/>
* 2진수는 너무 길고 헷갈림 → 4비트(2진수 4자리)를 16진수 1자리로 표현
* 16진수는 0~9 + A~F 사용 (A=10, B=11, ... F=15)

&ensp;예:<br/>
* 2진수 1111 1111 = 16진수 FF

&ensp;👉 그래서 메모리 주소, 색상 코드 등에 16진수가 자주 쓰인다.<br/>

&ensp;왜 음수를 표현해야 하는 이유<br/>
&ensp;컴퓨터는 0과 1만 알 수 있다. 그런데 우리가 다루는 숫자는 -5, +3 같은 음수와 양수가 다 있다.그래서 이진수로 음수를 표현하는 규칙이 필요하다. 그 규칙들이 바로 Signed Magnitude, 1의 보수(1’s complement), 2의 보수(2’s complement) 방식이다.<br/>

&ensp;<b>Signed Magnitude (부호와 크기 방식)</b><br/>
* 제일 왼쪽 비트(MSB)를 부호 비트로 씀
    - 0 → 양수
    - 1 → 음수
* 나머지 비트는 숫자의 크기를 표현

&ensp;예시 (8비트):<br/>
* 0000 0101 → +5
* 1000 0101 → -5

&ensp;👉 단점: +0 (0000 0000), -0 (1000 0000) 두 가지 0이 존재 → 헷갈림<br/>

&ensp;1의 보수 (1’s Complement)<br/>
* 규칙: 양수의 음수를 구할 때 모든 비트를 반전(0↔1)
* 즉, X의 음수 = X의 1의 보수

&ensp;예시 (8비트):<br/>
* +5 = 0000 0101
* -5 = 1111 1010 (모든 비트를 반전)

&ensp;👉 단점:<br/>
* 여전히 +0 (0000 0000), -0 (1111 1111) 두 가지 0이 존재.
* 덧셈할 때 자리 올림(End-around carry) 을 다시 더해야 하는 불편함.

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-1.png" width="600"></p>

&ensp;<b>2의 보수 (2’s Complement) → 오늘날 표준</b><br/>
* 규칙: 1의 보수를 구한 뒤 +1을 더하기
* 즉, X의 음수 = ~X + 1 (비트 반전 후 1 더함)

&ensp;예시 (8비트):<br/>
* +5 = 0000 0101
* 1의 보수 → 1111 1010
* +1 → 1111 1011 = -5

&ensp;👉 장점:<br/>
* 0이 하나만 존재
* 덧셈/뺄셈 회로가 단순해짐 → 하드웨어에서 효율적
* 지금 우리가 쓰는 컴퓨터는 모두 2의 보수 방식 사용

&ensp;왜 2의 보수가 좋은가?<br/>
* 어떤 수 X와 -X를 더하면 항상 0이 나오고, carry(자리올림)는 버림.
* 예시: 5 + (-5)
    - 0000 0101 (5) + 1111 1011 (-5) = 0000 0000 (0)

&ensp;👉 그래서 뺄셈을 “덧셈”으로 처리 가능 (예: 7 - 5 → 7 + (-5))<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-2.png" width="600"></p>

&ensp;Unsigned vs Signed<br/>
* Unsigned: 음수 없음. 0 ~ 2^n - 1 표현 가능.
* Signed (2의 보수): 음수 포함. -2^(n-1) ~ +2^(n-1) - 1 표현 가능.

&ensp;예 (8비트):<br/>
* Unsigned: 0 ~ 255
* Signed: -128 ~ +127

&ensp;직관적인 비유<br/>
* Signed Magnitude = “앞에 + 또는 - 붙이는 방식”
* 1의 보수 = “모든 전구(0,1)를 반대로 켬”
* 2의 보수 = “전구를 반대로 켠 다음에 +1 전구 하나 더 켬”

&ensp;👉 2의 보수가 제일 깔끔하고, 그래서 현대 CPU가 모두 채택!<br/>

MIPS Arithmetic Instructions (MIPS 산술 명령어)
-----

&ensp;MIPS는 CPU 명령어 집합이다.<br/>
&ensp;예시<br/>
```nginx
slt  $t0, $t1, $zero
```

* slt = Set if Less Than (작으면 1, 아니면 0 저장)
* $t1 값이 $zero (0 레지스터)보다 작으면 $t0 ← 1
* 그렇지 않으면 $t0 ← 0

&ensp;중요한 점: $t1을 부호 있는(signed) 수로 해석할지 부호 없는(unsigned) 수로 해석할지에 따라 결과가 달라진다.<br/>
&ensp;예:<br/>
* $t1 = 1111…01 (32비트)
    - Signed 해석 → 음수 → 0보다 작다 → $t0 = 1
    - Unsigned 해석 → 아주 큰 양수 → 0보다 크다 → $t0 = 0

숫자 값(Value of X)
----

* Unsigned: 그냥 자리값대로 (모두 양수)
* Signed Magnitude: 맨 앞(부호 비트)이 0이면 양수, 1이면 음수
* 1’s Complement: 음수는 모든 비트를 반전
* 2’s Complement: 음수는 반전 + 1 (현대 표준)

&ensp;정리: 같은 비트 패턴이라도 해석 방법에 따라 값이 달라진다.<br/>

덧셈과 뺄셈 (Addition & Subtraction)
====

* 덧셈: 10진수랑 똑같이, 오른쪽부터 더하면서 자리올림(carry)을 왼쪽으로 넘김
* 뺄셈: 사실상 음수를 더하는 것
    - 예: A - B = A + (-B)
    - 그래서 뺄셈 회로를 따로 만들 필요 없음 → 덧셈기로 처리 가능

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-3.png" width="600"></p> 

&ensp;그림에 나온 것처럼<br/>
&ensp;1 + 1 = 0 (자리올림 1 발생)<br/>
&ensp;1 + 1 + 1 = 1 (자리올림 1 발생)<br/>

오버플로우 (Overflow)
-----

&ensp;컴퓨터는 비트 개수 제한이 있다. 예를 들어 8비트면 -128 ~ +127까지만 표현 가능하다. 이 범위를 벗어나면 오버플로우가 발생한다.<br/>
* 양수 + 양수 → 결과가 음수로 보이면 오버플로우
* 음수 + 음수 → 결과가 양수로 보이면 오버플로우
* 양수 + 음수 → 범위를 벗어나지 않음 → 오버플로우 없음

&ensp;예<br/>
* 7 + 7 = 0111 + 0111 = 1110 → 10진수로 보면 -2 → 오버플로우 발생!

&ensp;오버플로우 판정 (Overflow Detection)<br/>
* 방법: MSB(부호 비트)에 들어온 자리올림(carry-in)과 MSB에서 나간 자리올림(carry-out)비교
* 같으면 정상, 다르면 오버플로우

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-4.png" width="600"></p> 

&ensp;Dealing with Overflow (오버플로우 처리 방법)<br/>
&ensp;① Unsigned number (부호 없는 정수)<br/>
* 조건: MSB(최상위 비트)에서 CarryOut = 1 → Overflow
* 예: 8비트 unsigned에서 255 + 1 = 0 → Carry 발생 → Overflow

&ensp;② Signed number (부호 있는 정수)<br/>
* 조건: CarryIn ≠ CarryOut → Overflow
* 예: +127 + 1 = -128 (범위를 벗어나 부호가 뒤집힘)

&ensp;👉 비유:<br/>
* 계산기 자릿수보다 큰 숫자를 넣으면 “E” 뜨는 것처럼 컴퓨터도 비트 자릿수를 넘으면 이상한 값이 나옴 → 오버플로우

&ensp;언어별 처리<br/>
* C 같은 언어: 오버플로우 무시 (그냥 이상한 값 나옴)
* Ada, Fortran 같은 언어: 오버플로우 → 예외(Exception) 발생
* CPU(MIPS)도 특별한 명령어(add, addu, sub)로 제어할 수 있음

&ensp;ALU(Arithmetic Logic Unit)<br/>

* CPU 안에서 계산기 역할을 하는 부분
* 숫자 더하기, 빼기, 곱하기, 나누기, 비교, 논리연산(AND, OR 등)을 전부 담당
* 입력(operand) 두 개를 받아서 → 결과(result) 하나를 출력
* 추가로 Carry, Zero, Overflow 같은 상태 신호도 만들어냄

&ensp;👉 비유: ALU = 똑똑한 계산기. CPU가 “이거 계산해!”라고 명령하면 ALU가 대신 계산해준다.<br/>

&ensp;ALU가 지원해야 하는 연산들 (MIPS 기준)<br/>
&ensp;MIPS ISA(Instruction Set Architecture) 명령어를 실행할 수 있도록 ALU는 다양한 연산을 지원해야 함<br/>

&ensp;① 산술 연산 (Arithmetic)<br/>
* add, addi, addu, addiu → 덧셈
* sub, subu → 뺄셈
* mult, multu → 곱셈
* div, divu → 나눗셈
* sqrt → 제곱근

&ensp;② 논리 연산 (Logic)<br/>
* and, andi
* or, ori
* xor, xori
* nor

&ensp;③ 비교/분기 연산 (Comparison / Branch)<br/>
* slt, slti, sltu, sltiu → 작은지 비교 (Set Less Than)
* beq, bne → 같으면 분기 / 다르면 분기

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-5.png" width="600"></p> 

* A (32비트 입력)
* B (32비트 입력)
* m (4비트): 어떤 연산을 할지 지정하는 "명령 선택 스위치"
    - 예: m=0000 → 덧셈, m=0001 → 뺄셈, m=0010 → AND …
* result (32비트 출력): 실제 연산 결과
* zero (1비트): 결과가 0이면 1로 표시 → 분기 명령에 사용
* ovf (1비트): 오버플로우 발생 여부 표시
* Carry (1비트): 자리올림 발생 여부 표시

&ensp;정리: ALU는 입력 두 개(A, B)와 "연산 종류 코드(m)"를 받아서 결과와 상태 플래그를 뱉어냄.<br/>

&ensp;특별히 처리해야 하는 부분 (Special Handling)<br/>
1. Sign Extension (부호 확장)
* 작은 크기의 수(예: 16비트)를 큰 크기(32비트)로 바꿀 때 맨 앞 부호 비트를 그대로 확장해 줌
* 예: 16비트 1111 1111 1111 1111 (-1) → 32비트 1111 … 1111 (-1) → addi, addiu, slti 같은 명령어에서 필요
2. Zero Extension (제로 확장)
* 확장할 때 무조건 앞자리를 0으로 채움
* 부호 개념 필요 없음 (항상 양수)
* andi, ori, xori, sltiu 등에서 사용
3. Overflow Detection (오버플로우 검출)
* add, addi, sub 같은 연산에서 결과가 범위를 벗어났는지 검사
* 예: +2147483647 + 1 = -2147483648 → 오버플로우 발생

보충 개념
-----

&ensp;<b>Bit ALU with ADD, OR, AND</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-6.png" width="600"></p> 

* ALU는 한 비트씩 계산하는 기본 블록으로 시작해요.
* 입력: a, b (각각 1비트)
* 가능한 연산: AND, OR, ADD

&ensp;👉 ALU 안에 세 가지 “작은 계산기”가 들어있고 마지막에 **Multiplexer (선택기)**가 있어서 Operation 코드에 따라 어떤 결과를 내보낼지 고르는 구조이다.<br/>
* Operation=0 → AND 결과 출력
* Operation=1 → OR 결과 출력
* Operation=2 → ADD 결과 출력

&ensp;비유: 레스토랑 주방에 “튀김기(AND)”, “오븐(OR)”, “냄비(ADD)”가 있고 손님이 메뉴(Operation code)를 고르면 셰프가 그 기계에서 요리한 결과를 내보내는 구조<br/>

&ensp;<b>32-bit Ripple Carry Adder</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-7.png" width="600"></p> 

&ensp;실제 CPU는 32비트나 64비트 숫자를 다룬다. 그래서 1비트 ALU를 32개 연결해서 32비트 연산을 처리한다.<br/>

* 각 ALU는 1비트만 처리하고, **Carry(자리올림)**을 다음 ALU로 넘겨준다.
* 이렇게 연쇄적으로 carry가 “파도처럼(ripple)” 전달되기 때문에 이름이 Ripple Carry Adder

&ensp;단점: carry가 0번 비트에서 31번 비트까지 차례대로 전달되므로 계산 속도가 느려짐<br/>

&ensp;비유: 32명이 줄 서서 덧셈을 하는데, 앞사람이 자리올림(carry)을 계산해야 뒤사람이 계산을 이어갈 수 있는 구조<br/>

&ensp;<b>Incorporating Subtraction (뺄셈 구현하기)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-8.png" width="600"></p> 

* 뺄셈 A - B를 ALU가 어떻게 하냐? -> 사실 뺄셈은 A + (-B)로 바꿔서 덧셈으로 처리 가능
* 음수 -B는 2의 보수로 구함 = B 비트 반전 + 1

&ensp;그래서 ALU에 **B 입력을 반전시킬 수 있는 회로(Inverter)**를 추가하고 첫 번째 자리의 CarryIn을 1로 주면 +1 효과까지 포함된다.<br/>
&ensp;즉:<br/>
* Binvert=0 → 정상적인 B 사용 (덧셈)
* Binvert=1 → B를 반전하고 CarryIn=1로 설정 (뺄셈)

&ensp;👉 이렇게 하면 ALU가 덧셈과 뺄셈을 같은 회로로 처리 가능!<br/>

&ensp;비유: "마이너스" 버튼이 따로 있는 게 아니라 "빚진 돈"을 더하는 방식으로 처리하는 계산기라고 생각하면 된다.<br/>

&ensp;Incorporating NOR (NOR 연산 추가)<br/>
&ensp;NOR = NOT (A OR B)
&ensp;즉 OR 결과를 뒤집은 것<br/>
&ensp;ALU에서는 이미 OR 회로가 있으므로, 입력을 반전(Ainvert, Binvert)시키거나 결과를 반전해서 NOR을 구현 가능<br/>

&ensp;👉 핵심: 새로운 회로를 안 만들고 기존 OR 회로에 "부정"만 추가해서 NOR을 구현<br/>
&ensp;👉 비유: TV 리모컨에 "끄기 버튼(NOT)"만 하나 더 붙인 것<br/>

&ensp;<b>Incorporating SLT (Set Less Than)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-9.png" width="600"></p> 

* MIPS 명령어 slt $t0, $t1, $t2 → "$t0 = ($t1 < $t2) ? 1 : 0"
* 즉 A가 B보다 작은지 비교

&ensp;구현 방법:<br/>
1. ALU가 A - B를 계산
2. 결과의 부호(Sign bit)를 확인
    - 결과가 음수 → A < B
    - 결과가 양수/0 → A ≥ B
3. 이 값(부호 비트)을 Less 신호로 출력.

&ensp;👉 특별히, 마지막(31번째 비트) ALU가 부호와 오버플로우를 감지해서 맨 처음 비트(ALU0)에 “Less=1 or 0” 신호를 넣어줌<br/>
&ensp;👉 비유: 시험 점수(A-B)를 뺀 결과가 “음수(빚)”라면 A가 작다는 뜻<br/>

&ensp;<b>Incorporating BEQ (Branch if Equal)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-10.png" width="600"></p> 

* MIPS 명령어 beq $t1, $t2, label → "$t1 == $t2 이면 분기"
* 즉 두 값이 같은지 비교

&ensp;구현 방법:<br/>
1. ALU가 A - B 수행
2. 결과가 전부 0인지 확인
3. 결과가 0 → Equal → 분기

&ensp;각 ALU의 결과(Result0, Result1, …)를 OR 게이트에 연결해서 “하나라도 1이 있으면 다르다”고 판단<br/>
&ensp;최종 결과가 0 → Equal<br/>

&ensp;<b>A MIPS ALU Implementation (최종 ALU 구현)</b><br/>
&ensp;앞의 기능들을 전부 모아 완성된 MIPS ALU 구조를 보여준다.<br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-11.png" width="600"></p> 

* 입력: A, B (32비트)
* 연산 선택(op): ADD, SUB, AND, OR, NOR, SLT, …
* 출력: result (32비트), Zero, Overflow

&ensp;특징:<br/>
1. Zero detect: 결과가 전부 0인지 확인 (beq, bne, slt 등에 필요).
2. Overflow detect: 덧셈/뺄셈에서 범위를 넘는지 확인.
3. Set signal: SLT 연산용.

&ensp;비유: 이제 ALU는 “스위스 군용 칼”처럼 다용도 도구가 됐다. 칼(덧셈), 가위(뺄셈), 드라이버(AND/OR), 줄자(SLT), 센서(BEQ) 등 다양한 기능이 하나로 통합됨<br/>

Multiplication
=====

&ensp;컴퓨터에서 곱셈이란?<br/>
&ensp;우리가 아는 곱셈(예: 8 × 9 = 72)도 결국은 덧셈 여러 번으로 할 수 있다.<br/>
* 8 × 9 = 8 + 8 + 8 + … (9번 더함)

&ensp;컴퓨터도 똑같다.<br/>
&ensp;하지만 컴퓨터는 이진수(0 또는 1)만 쓰기 때문에 곱셈은 왼쪽으로 밀기(shift)와 더하기(add)로만 해결할 수 있다.<br/>

&ensp;<b>곱셈의 구조</b><br/>
* Multiplicand: 곱해지는 수 (예: 8)
* Multiplier: 곱하는 수 (예: 9)
* Partial product array: 중간 곱셈 결과들
* Product: 최종 결과

&ensp;곱셈은 곱셈표 쓰듯이, 각 자리마다 부분 곱(Partial Product)을 구해서 다 더하는 과정이다.<br/>
&ensp;비유: 우리가 종이에 곱셈할 때, 아래에 중간 곱들을 쓰고 마지막에 전부 더하는 방식과 똑같음<br/>

&ensp;Pencil and Paper Algorithm (종이와 연필 곱셈법)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-12.png" width="600"></p> 

&ensp;그림은 우리가 초등학교 때 배운 세로 곱셈 방식을 그대로 이진수에 적용한 모습이다.<br/>

```markdown
  A3 A2 A1 A0
× B3 B2 B1 B0
--------------
  B0×A3 B0×A2 B0×A1 B0×A0
  B1×A3 B1×A2 B1×A1 B1×A0
  B2×A3 B2×A2 B2×A1 B2×A0
  B3×A3 B3×A2 B3×A1 B3×A0
--------------
   결과 M7 M6 M5 … M0
```

&ensp;각 자리마다 곱하고, 자리 수에 맞게 밀어서 더하면 최종 결과가 나옴<br/>


&ensp;<b>Array Multiplier (배열 곱셈기)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-13.png" width="600"></p> 

* 컴퓨터 회로에서는 이 과정을 격자 모양(array)으로 구성
* 각 칸에서 `Ai x Bj` (즉 한 자리 곱셈)을 하고 그 결과를 더하는 회로를 배치

&ensp;장점: 여러 자리 곱셈을 동시에(parallel)할 수 있어서 빠름<br/>
&ensp;비유: 여러 명이 동시에 구구단을 풀고 마지막에 결과만 합치는 것<br/>

&ensp;Binary Multiplication Example (8 × 9)<br/>
* 8 = 1000 (2진수)
* 9 = 1001 (2진수)

```markdown
   1000   (8)
×  1001   (9)
--------
   1000   (8×1)
  0000    (8×0)
 0000     (8×0)
1000      (8×1, 왼쪽으로 세 칸 밀림)
--------
1001000   (= 72)
```

&ensp;최종 결과 1001000 (2진수) = 72 (10진수)<br/>

&ensp;중요한 규칙<br/>
* 곱하기 1 → 그대로 더함
* 곱하기 0 → 더할 게 없음 (무시)
* 결과 비트 수 = 두 수의 비트 수 합
    - n비트 × m비트 = (n+m)비트 결과

&ensp;10진수 vs 2진수 곱셈 비교<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-14.png" width="600"></p> 

&ensp;예제: 6 (0110) × 3 (0011) = 18 (10010)<br/>
&ensp;1. 이진수 곱셈 과정<br/>
```markdown
   0110   (6)
×  0011   (3)
---------
   0110   (6 × 1, 첫 번째 비트)
  0110    (6 × 1, 두 번째 비트 → 왼쪽으로 한 칸 이동)
---------
 10010    (18, 최종 결과)
```

&ensp;2️. Carry(자리올림) 추적<br/>
&ensp;덧셈을 할 때 1+1=10 (2) 이므로 결과는 0이고 자리올림(carry)=1이 왼쪽으로 전달된다.<br/>
&ensp;중간 덧셈<br/>
```markdown
   0110
+  0110   (왼쪽으로 한 칸 밀린 상태)
---------
  1100   (여기서 1+1=10 → carry 발생)
```

&ensp;맨 오른쪽 두 자리(1+1)에서 carry 발생 → 왼쪽으로 전달됨<br/>
&ensp;carry가 ripple(파도처럼) 옆 자리로 전해져서 최종 결과가 10010이 됨<br/>

&ensp;3️. 그림으로 표현<br/>
```markdown
비트 자리:   4 3 2 1 0
값:         0 1 1 0
곱셈 shift:   0 1 1 0  (한 칸 밀림)
--------------------------------
덧셈:        10010
```

* 자리 1: 1+1=0 (carry=1)
* 자리 2: 1+1+carry=1 (carry=1)
* 자리 3: 0+0+carry=1 (carry=0)

&ensp;이렇게 carry가 한 칸씩 “전염”되면서 ripple처럼 퍼져나감<br/>

&ensp;정리<br/>
* 이진수 곱셈은 Shift + Add 방식
* Add 과정에서 1+1=10 이 되어 carry가 발생
* carry는 다음 비트로 전달되며, 최종 결과값에 반영됨
* 이 원리를 32비트, 64비트로 확장한 것이 실제 CPU 곱셈기

Sequential Multiplication의 아이디어(First Version)
-----

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-15.png" width="600"></p> 

* 우리가 곱셈할 때는 부분 곱(partial product)을 하나씩 구해서 더한다.
* 컴퓨터가 똑같이 한 비트씩 확인하면서 곱하고 더하는 방식을 사용
* 차이는 컴퓨터는 회로가 자동으로 왼쪽으로 밀기(shift left)와 오른쪽으로 밀기(shift right)를 해준다는 점이다.

&ensp;덧셈기(Adder) 하나와 Shift 회로만 있으면 곱셈이 가능하다.<br/>

&ensp;하드웨어 구조<br/>
1. Multiplicand (곱해지는 수, 예: 6) → 왼쪽으로 밀림 (shift left)
2. Multiplier (곱하는 수, 예: 3) → 오른쪽으로 밀림 (shift right)
3. Product(결과)는 처음엔 0으로 시작
4. Multiplier의 맨 끝 비트가 1이면 → Multiplicand를 Product에 더함
5. 이 과정을 Multiplier의 비트 수만큼 반복

&ensp;First Version 알고리즘 흐름도<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-16.png" width="600"></p> 

&ensp;순서로 설명하면:<br/>
1. Multiplier의 가장 오른쪽 비트 확인.
    - 1이면 → Product에 Multiplicand 더함.
    - 0이면 → 아무것도 안 함.
2. Multiplicand를 왼쪽으로 1비트 Shift. (자릿수가 커짐, 10진수로 따지면 ×10 하는 것과 비슷)
3. Multiplier를 오른쪽으로 1비트 Shift. (다음 비트를 보기 위해 자리를 옮김)
4. 모든 비트(예: 32비트) 확인할 때까지 반복.

&ensp;결과적으로 Product에는 곱셈 결과가 완성됨<br/>

&ensp;예제 (슬라이드 8-8: 0010₂ × 0011₂ = 2 × 3)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-17.png" width="600"></p> 

* Multiplicand = 0010 (2)
* Multiplier = 0011 (3)
* Product = 0000 (초기값)

&ensp;Iteration 1 (Multiplier = 0011, 맨 끝 비트 = 1)<br/>
* 규칙: Multiplier의 맨 끝 비트가 1 → Product에 Multiplicand를 더함.
* Product = 0000 + 0010 = 0010 (십진수 2)
* 이제 Multiplicand를 왼쪽으로 한 칸 Shift → 0100 (십진수 4) (10진수라면 “×10” 해주는 것과 같은 효과)
* Multiplier를 오른쪽으로 Shift → 0001 (다음 비트 확인 준비)


&ensp;Iteration 2(Multiplier = 0001, 맨 끝 비트 = 1)<br/>
* Multiplier 끝 비트가 또 1 → Product에 Multiplicand 더함.
* Product = 0010 + 0100 = 0110 (십진수 6)
* Multiplicand 왼쪽 Shift → 1000 (십진수 8)
* Multiplier 오른쪽 Shift → 0000 (더 이상 1 없음)

&ensp;Iteration 3, 4 (Multiplier = 0000, 끝 비트 = 0)<br/>
* 끝 비트가 0이므로 Product에 아무 것도 안 더함
* Shift만 진행하다가 종료

&ensp;최종 Product = 0110 (십진수 6)<br/>
* 즉, 2 × 3 = 6이 올바르게 계산됨

&ensp;특징<br/>
* 이 방식은 한 단계씩 차례로 진행되므로 “Sequential Version(순차적 곱셈)”이라고 불린다.
* 장점: 하드웨어가 단순함 (Adder + Shifter만 필요).
* 단점: 시간이 오래 걸림 (32비트 곱셈 → 32번 반복).

&ensp;정리<br/>
1. Multiplier의 각 비트를 하나씩 검사
    - 1 → Product에 현재 Multiplicand를 더함
    - 0 → 무시
2. Multiplicand는 매 단계마다 왼쪽으로 Shift (자리값 커짐)
3. Multiplier는 오른쪽으로 Shift (다음 비트 확인)
4. 마지막에 Product에 모든 부분곱이 합쳐져서 최종 곱셈 결과가 됨

Second Version
----

&ensp;구조<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-18.png" width="600"></p> 

&ensp;차이는 Multiplicand(곱해지는 수)를 계속 Shift하지 않고, Product 쪽을 오른쪽으로 Shift하는 방식이다.<br/>
&ensp;Multiplier와 Product가 한 쌍으로 묶여서 같이 움직이는 구조<br/>

&ensp;과정 예제 (2 × 3)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-19.png" width="600"></p> 

* Multiplicand = 0010 (2)
* Multiplier = 0011 (3 = 2⁰ + 2¹)
* Product = 0000 (처음에는 0)

&ensp;Iteration 1<br/>
* Multiplier = 0011, LSB = 1
* 규칙: 1이면 Product += Multiplicand → Product = 0000 + 0010 = 0010 (2)
* 이제 Multiplier 오른쪽 Shift → 0001 (다음 비트 보려고 한 칸 당김)
* Product도 오른쪽 Shift (자리 정렬 맞추려고)

&ensp;Iteration 2<br/>
* Multiplier = 0001, LSB = 1
* Product += Multiplicand = 0010 + 0100 = 0110 (6) (여기서 Multiplicand는 한 번 더 왼쪽 자리 올라감, 즉 “십의 자리”로 간 효과)
* Multiplier 오른쪽 Shift → 0000

&ensp;Iteration 3, 4<br/>
* Multiplier = 0000 → 끝 비트가 0 → Product 변화 없음
* 반복 종료


* Multiplier의 LSB(맨 오른쪽 비트) 확인 = 현재 자리에서 곱해야 하는지(1) 말아야 하는지(0)를 알려줌
* 1이면 Product += Multiplicand
* 그 다음 Product를 오른쪽으로 Shift
* Multiplier도 오른쪽으로 Shift
* 반복

&ensp;결과는 똑같이 나오지만 하드웨어가 단순해진다. (Multiplicand는 그대로 두고 Product만 움직이면 됨)<br/>

Refined Version
-----

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-20.png" width="600"></p> 

* Second Version에서는 Product와 Multiplier를 따로 관리했다.
* Refined Version에서는 **Product와 Multiplier를 아예 하나의 큰 레지스터(64비트 Product 안에 32비트 Multiplier 포함)**로 묶어서 관리한다.
* 즉 Product의 하위 32비트에 Multiplier를 같이 넣어버리고 한 번에 Shift

&ensp;덕분에 회로가 더 간단해지고 속도도 빨라짐<br/>

&ensp;Refined Version 알고리즘<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-21.png" width="600"></p> 

1. Product의 LSB(가장 오른쪽 비트) 확인
    - 1이면 → Multiplicand를 Product의 상위 부분에 더함
    - 0이면 → 아무것도 안 함
2. Product 전체를 오른쪽으로 1비트 Shift
3. 이걸 32번 반복

&ensp;마지막에 Product에는 최종 곱셈 결과가 들어있다.<br/>

&ensp;예제 1: 0010 (2) × 0011 (3)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-22.png" width="600"></p> 

&ensp;핵심은 Product 레지스터 안에 Multiplier까지 함께 넣고 관리한다는 점<br/>

&ensp;초기 상태<br/>
* Multiplicand = 0010 (2)
* Multiplier = 0011 (3)
* Product = 0000 0011 (8비트로 표현하면, 왼쪽은 4비트 Product, 오른쪽은 4비트 Multiplier)

&ensp;Product 레지스터:<br/>
```scss
0000 0011
↑↑↑↑ ↑↑↑↑
상위(곱셈 누적)   하위(Multiplier 자리)
```

&ensp;Iteration 1<br/>
* Product의 맨 끝 비트 = 1 → 규칙: 1이면 Multiplicand를 Product의 상위 부분에 더함

&ensp;계산:<br/>
```yaml
상위 0000 + 0010 (Multiplicand) = 0010
```

&ensp;→ Product = 0010 0011<br/>
&ensp;그다음 Product 전체를 오른쪽으로 Shift<br/>
```yaml
0010 0011 → 0001 0001
```

&ensp;Iteration 2<br/>
* Product의 맨 끝 비트 = 1 → 다시 Multiplicand(0010)를 상위에 더함

&ensp;계산:<br/>
```yaml
상위 0001 + 0010 = 0011
```

&ensp;→ Product = 0011 0001<br/>
&ensp;다시 오른쪽 Shift:<br/>
```yaml
0011 0001 → 0001 1000
```

&ensp;Iteration 3<br/>
* Product의 맨 끝 비트 = 0 → 아무것도 안 함 (Multiplicand 더하지 않음)

&ensp;그냥 오른쪽 Shift:<br/>
```yaml
0001 1000 → 0000 1100
```

&ensp;Iteration 4<br/>
* Product의 맨 끝 비트 = 0 → 아무것도 안 함

&ensp;오른쪽 Shift:<br/>
```yaml
0000 1100 → 0000 0110
```

&ensp;최종 Product<br/>
* Product = 0000 0110 (십진수 6)
* 따라서 2 × 3 = 6이 올바르게 계산됨

&ensp;왜 이렇게 간단해졌을까?<br/>
* 이전 방식: Multiplicand와 Multiplier를 따로 Shift → 제어가 복잡함
* Refined 방식: Product 하나에 Multiplier까지 포함 → Product 하나만 Shift하면 됨
* 따라서 계산이 단순하고 하드웨어 회로도 훨씬 간단해짐

&ensp;예제 2: 0110 (6) × 0101 (5)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-23.png" width="600"></p> 

* Multiplier = 0101 = (2⁰ + 2²)
* 즉, 자리 0과 자리 2에서만 Multiplicand를 더함.
* Product에 부분곱을 더하고 매번 Shift → 최종 Product = 30 (011110)

&ensp;정리<br/>
* First Version: Multiplicand를 계속 왼쪽 Shift, Multiplier는 오른쪽 Shift → 구현 복잡
* Second Version: Multiplicand는 그대로, Product를 오른쪽 Shift → 좀 더 단순.
* Refined Version: Product와 Multiplier를 하나로 묶어서 Shift → 가장 단순하고 효율적.

&ensp;즉 점점 회로를 줄이고, 같은 연산을 더 효율적으로 하도록 발전시킨 거이다.<br/>

Signed Multiplication
-----

&ensp;<b>Booth’s Algorithm</b><br/>
&ensp;signed number(부호 있는 정수, 2의 보수 표현)에서는 음수까지 고려해야 한다. 예를 들어 -3x2 같은 것도 계산할 수 있어야 한다.<br/>
&ensp;Booth's 알고리즘은 연속된 1들을 더 효율적으로 처리하면서 동시에 음수도 다룰 수 있게 해준다.<br/>

&ensp;key idea<br/>
* 예: 30 = 16 + 8 + 4 + 2 = 32 -2
* 연속된 1들의 덧셈을 큰 수 하나 빼기 작은 수 하나로 단순화할 수 있다는 것이다.

```bash
011110₂ (30) = 0100000₂ - 0000010₂
```

&ensp;11110(연속된 1들) → “큰 1(=32)에서 작은 1(=2)을 빼는 것으로 바꿀 수 있다.<br/>

&ensp;알고리즘 규칙<br/>
&ensp;이제 Multiplier의 "현재 비트 + 이전 비트" 두 개를 묶어서 보고 규칙을 적용<br/>
* 00 또는 11 → 아무 것도 안 함 (No operation)
* 01 → 덧셈 (연속된 1이 끝나는 지점 → 부분곱 더하기)
* 10 → 뺄셈 (연속된 1이 시작되는 지점 → 부분곱 빼기)

&ensp;그리고 매번 Product를 Arithmetic Shift Right (부호 유지하면서 오른쪽 Shift)<br/>

&ensp;Flowchart<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-24.png" width="600"></p> 

1. Multiplier의 마지막 비트와 이전 비트 확인(2비트 패턴)
2. 패턴에 따라 Add/Sub/No-op 결정
3. Product를 Arithmetic Shift Right
4. 모든 비트 처리할 때까지 반복

&ensp;예제: 0010₂ (2) × 1101₂ (-3)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-25.png" width="600"></p> 

&ensp;규칙<br/>
* 00 또는 11 → 아무 것도 안 함 (No operation)
* 01 → Product = Product + Multiplicand
* 10 → Product = Product - Multiplicand

&ensp;그 후 항상 Arthmetic Shift Right(부호 유지한 채 오른쪽 Shift)<br/>

&ensp;Iteration 0<br/>
* Multiplicand = 0010 (2)
* Multiplier = 1101 (-3 in 2’s complement, 4비트 표현)
* Product = 상위(곱 결과 저장) + 하위(Multiplier 저장) → 초기 Product = 0000 1101

&ensp;Booth 알고리즘은 **Multiplier의 현재 비트 + “이전 비트(Q-1)”**를 함께 보고 동작한다.<br/>
* Q-1은 처음에 0으로 시작

&ensp;Iteration 1<br/>
* 패턴 = 10 → 뺄셈
* 규칙: Subtraction → Product 상위(0000) - Multiplicand(0010) = 1110 (즉, -2)
* Product = Product - Multiplicand
* Product Shift Right

```yaml
Product 상위 = 0000
Multiplicand = 0010
```

&ensp;뺄셈<br/>
```yaml
0000 - 0010 = 0000 + (0010의 2의 보수)
            = 0000 + 1110
            = 1110
```


&ensp;Iteration 2<br/>
* Q₀ = 0, Q-1 = 1 → 패턴 = 01
* 규칙: Addition → Product 상위(1111) + Multiplicand(0010) = 0001 (즉, -2+2=0)
* Product = 0001 0110
* Arithmetic Shift Right → 0000 1011

&ensp;Iteration 3<br/>
* Q₀ = 1, Q-1 = 0 → 패턴 = 10
* 규칙: Subtraction → Product 상위(0000) - Multiplicand(0010) = 1110 (-2)
* Product = 1110 1011
* Arithmetic Shift Right → 1111 0101

&ensp;Iteration 4<br/>
* Q₀ = 1, Q-1 = 1 → 패턴 = 11
* 규칙: No operation
* Product 그대로 → 1111 0101
* Arithmetic Shift Right → 1111 1010

&ensp;최종 결과<br/>
* Product = 1111 1010
* 이 값은 2’s complement로 해석하면 -6
* 정답: 2 × -3 = -6

&ensp;Comparison<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-26.png" width="600"></p> 

* Original Algorithm: 단순히 비트가 1일 때마다 곱하고 더하는 방식
* Booth’s Algorithm: 연속된 1을 “Add → Shift → Subtract” 식으로 묶어서 효율적으로 처리

&ensp;장점:<br/>
* 덧셈/뺄셈 횟수 줄어듦 (빠름)
* 음수도 처리 가능

MIPS Multiply Instruction
----

&ensp;곱셈 결과 크기 문제<br/>
* MIPS는 32비트 CPU예요. 즉, 한 레지스터에 32비트 숫자를 담을 수 있음
* 그런데 32비트 × 32비트 곱셈 = 64비트 결과가 나온다. 예: 100,000 × 100,000 = 10,000,000,000 → 32비트로는 못 담음

&ensp;그래서 MIPS는 결과를 두 개의 32비트 레지스터에 나눠 저장<br/>
* Lo: 하위 32비트 (low word)
* Hi: 상위 32비트 (high word)

&ensp;곱셈 명령어<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-27.png" width="600"></p> 

&ensp;기본 명령어<br/>
* mult $s0, $s1
  - signed(부호 있는 수) 곱셈
  - 결과 = $s0 * $s1
  - Lo에 하위 32비트, Hi에 상위 32비트 저장
* multu $s0, $s1
  - unsigned(부호 없는 수) 곱셈

&ensp;결과 일기<br/>
* mflo $t0 → Lo에서 값 가져오기
* mfhi $t1 → Hi에서 값 가져오기

&ensp;곱셈 결과를 쓰려면 mult하고 그 다음 mflo, mfhi로 꺼내 써야 한다.<br/>

&ensp;예시<br/>
```bash
mult $s2, $s3   # $s2 * $s3 → Hi, Lo에 저장
mflo $t0        # Lo 값 → $t0
mfhi $t1        # Hi 값 → $t1
```

&ensp;만약 $s2 = 20, $s3 = 30이라면<br/>
* 결과 = 600 (0x00000258)
* 상위 Hi = 0
* 하위 Lo = 0x00000258

&ensp;오버플로 체크<br/>
&ensp;오버플로는 32비트 범위를 넘는 값이 나왔을 때 발생<br/>

&ensp;Signed multiply (부호 있는 곱셈)<br/>
* 만약 결과의 하위 32비트(Lo)의 부호 비트와, 상위 32비트(Hi)가 모순되면 오버플로.
* 조건:
  - Lo의 최상위 비트 = 0 (즉, 양수) 인데, Hi ≠ 0000...0 → 오버플로
  - Lo의 최상위 비트 = 1 (즉, 음수) 인데, Hi ≠ 1111...1 → 오버플로

&ensp;Unsigned multiply (부호 없는 곱셈)<br/>
* Hi ≠ 0000...0 → 오버플로

Division
=====

&ensp;나눗셈은 결국 뺄셈과 이동(shift)으로 이루어진 연산이다.<br/>
&ensp;수학적으로 나눗셈은 이렇게 표현된다.<br/>
&ensp;$dividend = quotient × divisor + remainder$<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-28.png" width="600"></p> 

* 용어 정리
  - dividend (피제수) → 나누어지는 수
  - divisor (제수) → 나누는 수
  - quotient (몫) → 결과의 몫
  - remainder (나머지) → 나누고 남은 값

&ensp;Division 계산 과정<br/>
&ensp;곱셈에서 부분곱(Partial Product)을 더했듯이 나눗셈에서는 부분 나머지(Partial Remainder Array)를 뺀다고 생각하면 된다.<br/>

1. Divisor(제수)를 Dividend(피제수) 위에서 맞추고
2. 뺄 수 있으면 뺀다(몫에 1 기록)
3. 뺄 수 없으면 그대로 두고(몫에 0 기록)
4. 다음 자리로 이동해서 반복한다.

&ensp;예제<br/>
&ensp;1001010₂ ÷ 1000₂<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-29.png" width="600"></p> 

&ensp;1. Dividend = 1001010₂ (10진수 74), Divisor = 1000₂ (10진수 8)<br/>
&ensp;2. Pencil-and-Paper 방식:<br/>
* 첫 단계:
  - 상위 비트 1001 (10진수 9)에서 Divisor(1000=8)를 뺀다.
  - 결과 = 0001 (1), 몫의 첫 비트는 1.
* 다음 단계:
- 나머지 0001에 다음 비트(0)를 내려와서 0010으로 만든다.
  - 0010(2)는 1000(8)보다 작으므로 뺄 수 없음 → 몫 비트 0.
* 다음 단계:
  - 다시 비트를 내려와 0101 (5).
  - 역시 1000(8)보다 작다 → 몫 비트 0.
* 다음 단계:
  - 다시 비트를 내려와 1010 (10).
  - 이제 1000(8)보다 크거나 같으므로 뺀다.
  - 1010 - 1000 = 0010 (2), 몫 비트 1.

&ensp;최종 결과<br/>
* 몫(quotient) = 1001₂ (10진수 9)
* 나머지 (remainder) = 0010₂ (10진수 2)

&ensp;10010102 ÷ 1000 ​= 1001 ​몫, 0010 ​나머지<br/>

First Version
----

&ensp;<b>Division의 기본 아이디어</b><br/>
&ensp;곱셈이 Shift + Add 라면 나눗셈은 Shift + Subtract이다.<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-30.png" width="600"></p> 

&ensp;공식<br/>
```markdown
피제수(dividend) = 몫(quotient) × 제수(divisor) + 나머지(remainder)
```

&ensp;즉 몫을 구하기 위해서는 제수를 여러 번 빼면서 얼마나 뺄수 있는지를 확인하는 과정이다.<br/>

&ensp;<b>Hardware 구조</b><br/>
*  Divisor (제수): 처음에는 왼쪽(상위) 절반에 놓이고, 매 단계에서 오른쪽으로 1비트씩 쉬프트
* Dividend (피제수): 처음에 Remainder에 저장
* ALU(연산기): 빼기(subtract) 수행
* Quotient (몫): 매 단계에서 1비트씩 채워짐

&ensp;매 단계<br/>
1. Remainder – Divisor 연산
2. 결과가 **양수(≥0)**이면: 나눗셈이 가능하므로 Quotient 비트 = 1
3. 결과가 **음수(<0)**이면: 너무 많이 뺀 것이므로 Divisor를 다시 더해 복원, Quotient 비트 = 0
4. Divisor는 오른쪽으로 1비트 쉬프트
5. 이 과정을 n번 반복 (비트 수만큼) 

&ensp;<b>Algorithm</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-31.png" width="600"></p> 

1. 빼기: R = R – Divisor
2. 검사: R ≥ 0 ?
  - Yes → 몫에 1 기록
  - No → R에 Divisor 다시 더하고, 몫에 0 기록
3. Divisor를 오른쪽 쉬프트
4. 반복 (32비트라면 32번)

&ensp;Example<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-32.png" width="600"></p> 

&ensp;0000 0111 (7) ÷ 0010 (2)<br/>
* Quotient = 0000
* Divisor = 0010 0000 (제수를 왼쪽에 배치)
* Remainder = 0000 0111

&ensp;Iteration 1<br/>
* R – Divisor = 0000 0111(7) – 0010 0000(32) = 음수 → 너무 크게 뺀 것. 뺄 수 없음
* 따라서 복원 Quotient = 0000
* Divisor → 오른쪽 shift = 0001 0000

&ensp;Iteration 2<br/>
* R – Divisor = 0000 0111(7) – 0001 0000(16) = 음수 → 너무 크게 뺀 것. 뺄 수 없음
* 복원, Quotient = 0000
* Divisor → 오른쪽 shift = 0000 1000

&ensp;Iteration 3<br/>
* R – Divisor = 0000 0111(7) – 0000 1000(8) = 음수 → 역시 뺄 수 없음. 다시 복원
* 복원 Quotient = 0000
* Divisor → 오른쪽 shift = 0000 0100

&ensp;Iteration 4<br/>
* R – Divisor = 0000 0111(7) – 0000 0100(4) = 0011 (양수) → 이번엔 뺄 수 있음!, R = 3 (7에서 4를 뺀 값)
* Quotient = 0001
* Divisor → 오른쪽 shift = 0000 0010

&ensp;Iteration 5<br/>
* R – Divisor = 0011(3) – 0010(2) = 0001 (양수)
* Quotient = 0011
* Divisor → 오른쪽 shift = 0000 0001

&ensp;결과<br/>
* Quotient = 0011 (3)
* Remainder = 0001 (1)

```markdown
7 ÷ 2 = 3 … 나머지 1
```

&ensp;핵심 포인트<br/>
* 나누는 수를 왼쪽에 크게 놓고 → 오른쪽으로 하나씩 줄여가며(shift right)
뺄 수 있는지 확인하는 것
* 뺄 수 있다 → 나머지에서 나누는 수를 빼고, 몫에 1 기록
* 뺄 수 없다 → 복원(다시 원래 값으로), 몫에 0 기록
* 끝까지 반복 → 최종 몫과 나머지 구해짐

Second Version
-----

&ensp;<b>기본 아이디어</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-33.png" width="600"></p> 

&ensp;First Version은 Divisor를 계속 오른쪽으로 shift 해 가면서 뺄 수 있는지 확인했다. 그런데 Improved Version에서는 반대로 Remainder를 왼쪽으로 shift 하면서 계산한다.<br/>
* First Version: Divisor ↓ (오른쪽 shift)
* Improved Version: Remainder ↑ (왼쪽 shift)

&ensp;<b>하드웨어 구조</b><br>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-34.png" width="600"></p> 

* Remainder 레지스터 (64bit): Dividend를 넣고, 나중에 나머지가 남음
* Divisor 레지스터 (32bit): 제수 저장
* Quotient 레지스터 (32bit): 몫 저장
* ALU: Remainder – Divisor 연산 수행
* Control Logic: 결과가 음수인지 확인해서 몫 비트를 0/1로 결정

&ensp;<b>알고리즘 단계</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-35.png" width="600"></p> 

1. Remainder 왼쪽 shift (Shift left) → Dividend의 비트를 하나씩 꺼내서 검사하는 효과.
2. Remainder – Divisor 수행
  - 결과 ≥ 0 → 성공적으로 뺄 수 있다 → 나머지 갱신
  - 결과 < 0 → 너무 많이 뺐다 → 복원(다시 더함)
3. 몫 비트(Q) 설정
  - 뺄 수 있었으면 Q = 1
  - 뺄 수 없었으면 Q = 0
4. 위 과정을 n번(예: 32비트면 32번) 반복

&ensp;예제<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-36.png" width="600"></p> 

&ensp;0000 0111 (7) ÷ 0010 (2)<br/>

&ensp;초기<br/>
* Remainder = 0000 0111(7), Divisor = 0010(2)

&ensp;Iteration 1<br/>
* Remainder = 0000 0111 → 왼쪽 shift → 0000 1110 (= 14)
* 뺄셈: 14 – 2 = 12 (1100₂) → 여기서 슬라이드에서는 "음수"라고 썼지만 사실은 비교 실패 상황(즉, 아직 몫을 세울 수 없음)
* 그래서 복원 (원래 값 유지)
* 몫 비트 Q0 = 0

&ensp;핵심 개념<br/>
&ensp;이 알고리즘은 그냥 단순히 Remainder – Divisor 계산을 하는 게 아니라 정렬(Shift)된 자리수끼리 비교를 한다.<br/>
* Iteration 1에서 Divisor는 이미 왼쪽으로 크게 Shift 되어 있다.(0010이 아니라 0010 0000, 더 큰 수처럼 자리 이동된 상태)
* 그러니까 사실은 계산이

```markdown
Remainder(14) – Shifted Divisor(32) = -18
```

&ensp;그래서 결과가 음수 → "아직 이 자리에서는 나눌 수 없음"이라는 뜻<br/>

&ensp;이 알고리즘은 가장 큰 자리부터 몫을 정하기 위해 Divisor를 Remainder와 같은 자리까지 밀어놓고 그 상태에서 뺄 수 있는지 없는지 확인한다.<br/>
* 뺄 수 있으면 그 자리 몫은 1
* 못 빼면(음수 나오면) 복원하고 그 자리 몫은 0

&ensp;Iteration 2<br/>
* Remainder shift left → 0001 1100 (= 28)
* 28 – 2 = 26 → 여전히 나눌 수 없음 → 복원.
* 몫 비트 Q1 = 0

&ensp;Iteration 3<br/>
* Remainder shift left → 0011 1000 (= 56)
* 56 – 2 = 54 → 이제 뺄 수 있음 
* 그래서 Remainder = 54(0110₂ 부분이 남음, 슬라이드 표현)
* 몫 비트 Q2 = 1

&ensp;Iteration 4<br/>
* Remainder shift left → 0001 0010 (= 18)
* 18 – 2 = 16 → 뺄 수 있음
* Remainder = 0 (0000₂)
* 몫 비트 Q3 = 1

&ensp;최종 결과<br/>
* 몫 비트들이 0011 → 몫 = 3
* Remainder = 0001 → 나머지 = 1

&ensp;중요한 포인트<br/>
1. Shift Left → 큰 자리수부터 검사 → 초등학교 긴 나눗셈에서 "가장 왼쪽 숫자부터 나눠지는지 확인"하는 것과 같음
2. 뺄 수 없으면 복원하고 몫 비트 = 0 → 그 자리에서는 몫이 세워지지 않음
3. 뺄 수 있으면 나머지 갱신하고 몫 비트 = 1 → 그 자리에서는 몫 1을 세운 것
4. 마지막까지 반복하면 → Quotient(몫) + Remainder(나머지) 완성됨

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-37.png" width="600"></p> 

Signed Division
-----

* **몫(Quotient)**의 부호:
  - dividend(나눠지는 수)와 divisor(나누는 수)의 부호가 같으면 → 몫은 양수
  - 부호가 다르면 → 몫은 음수
* **나머지(Remainder)**의 부호:
  - dividend의 부호와 동일

&ensp;예시<br/>
* +7 ÷ +2 → 몫 = +3, 나머지 = +1
* −7 ÷ +2 → 몫 = -3, 나머지 = -1
* +7 ÷ −2 → 몫 = -3, 나머지 = +1
* −7 ÷ −2 → 몫 = +3, 나머지 = -1

&ensp;나머지는 항상 나눠지는 수의 방향을 따라간다.<br/>

&ensp;<b>Divide in MIPS</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-38.png" width="600"></p> 

&ensp;MIPS에서는 곱셈과 마찬가지로 HI, LO 두 개의 레지스터를 사용한다.<br/>
* div \$s0, \$s1<br/>
&ensp;→ lo = s0 ÷ s1 (몫)<br/>
&ensp;hi = s0 mod s1 (나머지)<br/>
* mflo \$rd → lo(몫)을 일반 레지스터로 가져옴
* mfhi \$rd → hi(나머지)를 일반 레지스터로 가져옴

&ensp;주의<br/>
* 0으로 나누면 안 됨 (division by zero error)
* 몫이 너무 클 경우 오버플로우 가능 (하지만 MIPS 하드웨어는 체크하지 않고 소프트웨어에서 확인해야 함)

&ensp;<b>Non-restoring Division (복원 안 하는 방식)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-39.png" width="600"></p> 

* 기존 방식(Restoring Division): 뺄셈 결과가 음수면 다시 더해서 "복원"하는 과정 필요
* Non-restoring Division: 복원 대신 다음 단계에서 보정하는 방식 → 더 빠름

&ensp;핵심 아이디어:<br/>
1. Remainder를 왼쪽으로 shift
2. Divisor를 빼거나 더함:
  - Rem ≥ 0 → Rem = Rem – Div
  - Rem < 0 → Rem = Rem + Div
3. 몫 비트(Q0) 설정:
  - Rem ≥ 0 → Q0 = 1
  - Rem < 0 → Q0 = 0
4. 반복 (32비트면 32번)

&ensp;예제<br/>
&ensp;00001 10001(49) ÷ 00101(5)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-40.png" width="600"></p> 

* A = 현재 나머지 상자(5칸)
* Q = 몫을 쌓는 상자(5칸)
* M = 제수(5) = 00101₂

&ensp;초기값(표 첫 줄):<br/>
* 49를 10칸으로 펼쳐 놓으면 [A\|Q] = 00001 10001 → A=00001(1), Q=10001(17)

&ensp;라운드마다 하는 일(항상 같은 규칙)<br/>
1. [A\|Q] 통째로 왼쪽으로 1칸 밀기(Shift Left). Q의 맨 앞 비트가 A의 맨 뒤 칸으로 "넘어와요".
2. A의 부호 확인 →
  - A ≥ 0이면 A = A − M(빼보기)
  - A < 0이면 A = A + M(너무 뺐으면 되돌리기)
3. 그 결과가
  - A ≥ 0이면 Q의 마지막 비트 = 1
  - A < 0이면 Q의 마지막 비트 = 0

&ensp;라운드 1<br/>
&ensp;(1) 쉬프트 : 00001 10001 → 00011 00010<br/>
&ensp;A=00011(3), Q=00010<br/>

&ensp;(2) A≥0? 예(3≥0) → A = A − M = 3 − 5 = −2<br/>
&ensp;5비트 음수표현(2의 보수)로 −2 = 11110 → A=11110(−2)<br/>

&ensp;(3) A<0 → Q의 마지막 비트 = 0 (Q는 그대로 00010)<br/>

&ensp;요약: A=11110(−2), Q=00010<br/>

&ensp;라운드 2<br/>
&ensp;(1) 쉬프트 : [11110 00010] → 11100 00100<br/>
&ensp;A=11100(−4), Q=00100<br/>

&ensp;(2) A<0 → A = A + M = −4 + 5 = 1 → A=00001<br/>

&ensp;(3) A≥0 → Q의 마지막 비트 = 1 → Q=00101<br/>

&ensp;요약: A=00001(1), Q=00101<br/>

&ensp;라운드 3<br/>
&ensp;(1) 쉬프트 : [00001 00101] → 00010 01010<br/>
&ensp;A=00010(2), Q=01010<br/>

&ensp;(2) A≥0 → A = A − M = 2 − 5 = −3 → A=11101<br/>

&ensp;(3) A<0 → Q의 마지막 비트 = 0 → Q 그대로 01010<br/>

&ensp;요약: A=11101(−3), Q=01010<br/>

&ensp;라운드 4<br/>
&ensp;(1) 쉬프트 : [11101 01010] → 11010 10100<br/>
&ensp;A=11010(−6), Q=10100<br/>

&ensp;(2) A<0 → A = A + M = −6 + 5 = −1 → A=11111<br/>

&ensp;(3) A<0 → Q의 마지막 비트 = 0 → Q 그대로 10100<br/>

&ensp;요약: A=11111(−1), Q=10100<br/>

&ensp;라운드 5 (마지막)<br/>
&ensp;(1) 쉬프트 : [11111 10100] → 11111 01000<br/>
&ensp;(설명: Q의 맨 앞 1이 A로 넘어와서 A는 여전히 11111, Q는 왼쪽으로 밀려 01000)<br/>

&ensp;(2) A<0 → A = A + M = −1 + 5 = 4 → A=00100<br/>

&ensp;(3) A≥0 → Q의 마지막 비트 = 1 → Q=01001<br/>
&ensp;끝!<br/>

* 몫 Q = 01001₂ = 9
* 나머지 A = 00100₂ = 4

&ensp;즉 49 ÷ 5 = 9 … 4<br/>

&ensp;왜 중간에 11110, 11101 같은 값이 나오나요?<br/>
* 5칸(5비트)에서 맨 왼쪽이 1이면 음수예요(2의 보수).
  - 11110 = −2, 11101 = −3, 11111 = −1 처럼 읽습니다.


&ensp;MIPS Arithmetic Instructions<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-41.png" width="600"></p> 
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-42.png" width="600"></p> 

* Signed Division: 몫의 부호는 두 수의 부호 비교, 나머지는 dividend 부호 따라감
* MIPS Division: 결과는 HI/LO 레지스터에 저장
* Non-restoring Division: 복원 과정을 줄여 빠른 나눗셈 수행

Floating Point-실수 표현
=====

&ensp;컴퓨터는 정수뿐 아니라 실수(소수점이 있는 수)도 표현해야 한다. 예를 들어 3.14, 0.0001 등과 같은 수들이다. 이런 수를 표현하기 위해 사용되는 것이 바로 부동소수점(Floating Point)이다.<br/>

&ensp;1. 실수(Real Numbers)<br/>
&ensp;C언어에서 실수는 float 또는 double로 선언한다.<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-43.png" width="600"></p> 

&ensp;2. 과학적 표기법(Scientific Notation)<br/>
&ensp;실수를 다루기 편하게 하기 위해 과학적 표기법을 사용한다.<br/>
&ensp;$a \times 10^b$ <br/>
* a: 가수(Significand, 또는 Mantissa)
* b: 지수(Exponent, 10의 몇 제곱인가)

&ensp;소수점 왼쪽에 한 자리 숫자만 있도록 정리한 표현이다.<br/>

&ensp;3. 정규화된 수(Normalized Number)<br/>
&ensp;정규화된 수란 앞에 불필요한 0이 없는 수를 말한다.<br/>
&ensp;1≤ ∣ a ∣ < 10<br/>
&ensp;예<br/>
* 정규화된 수: 3.14 × 10²
* 비정규화된 수: 0.0314 × 10⁴ (앞에 0이 있음)

&ensp;Floating Point Representation(부도소수점 표현 방식)<br/>
&ensp;컴퓨터는 10진수가 아니라 2진수를 사용하기 때문에 실수도 2진 과학적 표기법으로 표현된다.<br/>
&ensp;$\pm 1.xxxxxxxx_2 \times 2^yyy$ <br/>

&ensp;구성요소<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-44.png" width="600"></p> 

&ensp;총 32비트 = 1 + 8 = 23(이게 바로 IEEE 754 Single Precision 형식)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-45.png" width="600"></p> 

&ensp;Floating Point Numbers(부동소수점 수의 형태)<br/>
&ensp;일반적인 표현식은 다음과 같다.<br/>
&ensp;$\left ( -1 \right )^S \times F \times 2^E$ <br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-46.png" width="600"></p> 

&ensp;정확도와 범위의 트레이드오프<br/>
* 가수(Fraction)가 크면 → 정확도↑ (더 많은 소수점 자리를 표현 가능)
* 지수(Exponent)가 크면 → 표현 범위 ↑ (더 큰 수나 더 작은 수를 표현 가능)

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-47.png" width="600"></p> 

&ensp;<b>IEEE 754 표준</b><br/>
&ensp;ANSI/IEEE Std 754-1985<br/>
&ensp;현대의 거의 모든 컴퓨터는 이 표준을 따른다.<br/>
&ensp;Hidden-bit Scheme (숨은 비트 방식)<br/>
&ensp;IEEE 754에서는 가수 부분에서 맨 앞의 1은 저장하지 않는다.(항상 1이기 때문이다.)<br/>

&ensp;$\left ( -1 \right )^S \times (1+fraction) \times 2^E$ <br/>

&ensp;단정밀도(Single Precision, 32-bit)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-49.png" width="600"></p> 

&ensp;배정밀도(Double Precision, 64-bit)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-50.png" width="600"></p> 

&ensp;비트 구조 예시<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-48.png" width="600"></p> 

&ensp;IEEE 754-2008 (= ISO/IEC/IEEE 60559:2011)<br/>
&ensp;이 버전에서는 다양한 정밀도(precision)형식이 정의되어 있다.<br/>
* Half Precision(반정밀도, binary16)
  - 총 16비트
  - Sign(부호): 1비트
  - Exponent(지수): 5비트
  - Fraction(가수): 10비트
  - Bias = 15 → 지수를 표현할 때 음수를 없애기 위해 더하는 상수

* Quad Precision (4배정밀도, binary128)
  - 총 128비트
  - Sign: 1비트
  - Exponent: 15비트
  - Fraction: 112비트
  - Bias = 262143 

&ensp;매우 큰 수와 작은 수를 모두 정밀하게 표현 가능 (고성능 과학 계산 등에서 사용)<br/>

* Decimal Floating-Point Formats
  - decimal32, decimal64, decimal128
  - 금융, 회계처럼 소수점 오차가 치명적인 분야에서 사용 (10진법 기반 계산)

&ensp;IEEE 754-2019 (= ISO/IEC 60559:2020)<br/>
&ensp;최신 개정판 (2019년 7월)<br/>
&ensp;다양한 하드웨어, 언어에서의 부동소수점 일관성 강화<br/>

&ensp;IEEE 754 Encoding (인코딩 규칙)<br/>
&ensp;이 표는 지수(Exponent)와 가수(Fraction)값 조합에 따라 각 숫자가 어떤 의미를 가지는지 보여준다.<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-51.png" width="600"></p> 

&ensp;각 상태의 의미<br/>
* 0.0 → 모든 비트가 0
* 비정규화 수 (Denormalized number)
  - 지수가 0이지만, 가수는 0이 아닌 경우
  - 매우 작은 수를 표현 (0에 가까운 실수)
* 정규화 수 (Normalized number)
  - 일반적인 실수 표현 (가장 많이 사용)
* ±∞ (무한대)
  - 너무 큰 수 계산 시 오버플로 발생
* NaN (Not a Number)
  - 0으로 나누기, 루트 음수 등 "정의되지 않은 수"

&ensp;<b>Sorting Floating Point Numbers(정렬 시 문제)</b><br/>
&ensp;부동소수점을 정렬할 때는 2의 보수(2's complement) 표현과 비슷한 원리를 사용한다.<br/>
* 예를 들어 정수 0은 2의 보수에서도 0이고 실수 0.0도 부동소수점에서 0이다.
* 따라서 부호 비트(Sign bit)를 가장 왼쪽에 두면 양수와 음수를 쉽게 비교할 수 있다.

&ensp;하지만 문제가 있다.<br/>
&ensp;음수 지수(Negative Exponent)가 있으면 단순 비교 시 실제 크기와 정렬 순서가 뒤바뀔 수 있다.<br/>

&ensp;예시: 2의 보수 지수의 문제<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-52.png" width="600"></p> 

&ensp;2의 보수 표현에서는 이렇게 저장된다.<br/>
```markdown
1.0₂ × 2⁻¹ → 0 11111111 ...
1.0₂ × 2⁺¹ → 0 00000001 ...
```

&ensp;결과적으로 **작은 수(0.5)가 큰 수(2.0)보다 더 크게 보이는 현상이 생긴다.<br/>
&ensp;즉 2의 보수로 음의 지수를 표현하면 정렬이 꼬여버린다.<br/>

&ensp;해결방법: Biased Notation(지수 편향 표현)<br/>
&ensp;$\left ( -1\right )^{Sign} \times (1 + Fraction) \times 2^{(Exponent-Bias)}$ <br/>

&ensp;IEEE 754에서의 Bias 값<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-53.png" width="600"></p> 

* 저장된 값 127 → 실제 지수 0
* 저장된 값 126 → 실제 지수 -1
* 저장된 값 128 → 실제 지수 +1

&ensp;Example: Floating-Point Representation<br/>
&ensp;IEEE 754 형식으로 -0.75₁₀ 을 표현하라.<br/>

&ensp;step1. 10진수를 2진수로 변환<br/>
&ensp;$-0.75_{10} = -0.11_2 = -1.1 \times 2^{-1}$ <br/>

&ensp;step2. Single Precision(32 bit)<br/>
* Sign = 1(음수)
* Exponent = -1 + 127 = 126 → 01111110
* Fraction = .1 → 10000000000000000000000

&ensp;1 01111110 10000000000000000000000 → BF400000 (16진수)<br/>

&ensp;step3. Double Precision(64bit)<br/>
* Exponent = -1 + 1023 = 1022 → 01111111110
* Fraction = 동일 (.1)

&ensp;1 01111111110 1000000000000000000000000000000000000000000000000000 → BFE8000000000000 (16진수)<br/>

&ensp;Example: Binary → Decimal 변환<br/>
&ensp;`1 10000001 01000000000000000000000` 이진 부동소수점을 10진수로 바꿔라.<br/>

&ensp;step1. 비트 분해<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-54.png" width="600"></p> 

&ensp;step2. Bias 보정<br/>
&ensp;E = 129 -127 = 2<br/>

&ensp;step3. 계산<br/>
&ensp;$(-1)^1 \times (1+0.25) \times 2^2 = -1.25 \times 4 = -5.0$ <br/>

&ensp;<b>Floating-Point Addition(부동소수점 덧셈)<br/>
&ensp;부동소수점 덧셈은 단순한 정수 덧셈보다 훨씬 복잡하다. 왜냐하면 지수(Exponent)가 다를 수 있기 때문이다.<br/>

&ensp;덧셈 절차 flowchart<br/>
1. 지수 비교
* 두 수의 지수를 비교해 더 작은 쪽을 오른쪽으로 시프트 → 지수를 맞춤
2. 가수 덧셈
* 두 가수를 더함 (Sign 고려)
3. 정규화 (Normalize)
* 결과가 1.XXXX 형태가 되도록 조정
* Overflow/Underflow 발생 시 처리
4. 반올림 (Rounding)
* 가수의 비트를 주어진 범위(예: 23비트)에 맞게 반올림
5. 결과 저장
* 다시 Hidden Bit(맨 앞의 1) 숨기고 저장

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-55.png" width="600"></p> 

&ensp;Floating-Point Addition Step by Step<br/>
&ensp;예제: $(0.5 = 1.0000 \times 2 ^{-1} ) + (-0.4375 = -1.1100 \times 2^{-2} )$ <br/>

&ensp;step 0. Hidden Bit 복원<br/>
* 0.5 → 1.0000 × 2⁻¹
* -0.4375 → -1.1100 × 2⁻²

&ensp;step 1. 지수 맞추기(Align)<br/> 
* 지수가 작은 쪽(-2)을 오른쪽으로 한 번 이동 → -0.4375 → -0.11100 × 2⁻¹

&ensp;step 2. 가수 더하기<br/>
&ensp;1.0000 + (−0.1110) = 0.0010<br/>

&ensp;step 3. 정규화<br/>
&ensp;$0.0010×2^{−1} = 1.0000 × 2^{−4}$ (왼쪽으로 3비트 이동 → 지수 -3 감소)<br/>

&ensp;step 4. 반올림(필요 없음)<br/>

&ensp;step 5. 저장<br/>
```ini
Sign = 0
Exponent = 01111011 (Bias 127 → 실제 지수 -4)
Fraction = 00000000000000000000000
```

&ensp;결과: `0 01111011 00000000000000000000000` <br/>

&ensp;Floating-Point Adder (하드웨어 구조)<br/>
&ensp;이 모든 연산은 하드웨어 내부의 부동소수점 연산기(FPU)에서 이루어진다.<br/>

&ensp;구성 단계<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-56.png" width="600"></p> 
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-57.png" width="600"></p> 

&ensp;<b>Floating-Point Multiplication (부동소수점 곱셈)</b><br/>
&ensp;부동소수점 곱셈은 다음 수식을 계산하는 과정이다.<br/>
&ensp;$\left ( \pm F_1 \times 2^{E_{1}} \right ) \times \left ( \pm F_2 \times 2^{E_{1}} \right ) = \pm F_3 \times 2^{E_{3}}$ <br/>

&ensp;전체 절차(Flowchart 개요)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-58.png" width="600"></p> 

1. 지수 더하기(Add exponents)
* 두 지수의 합에서 bias를 한 번 빼서 새로운 지수를 구함
2. 가수 곱하기(Multiply significands)
* 두 수의 가수를 곱함(숨겨진 1 포함)
3. 정규화 (Normalize)
* 결과가 1.XXX 형태가 되도록 조정.
* 필요하면 지수를 1 증가 또는 감소.
4. 반올림 (Round)
* 정밀도를 유지하기 위해 23비트(또는 52비트)에 맞춰 반올림.
5. 부호 결정 (Set sign)
* 두 입력의 부호가 같으면 → 결과 양수
* 다르면 → 결과 음수

&ensp;결과 저장 후 종료<br/>

&ensp;상세 단계<br/>
&ensp;Step 0. Hidden Bit 복원<br/>
&ensp;IEEE 754에서는 가수 맨 앞의 1이 저장되어 있지 않는다.<br/>
&ensp;연산 시에는 (1 + Fraction) 형태로 복원해야 한다.<br/>

&ensp;Step 1. 지수 계산<br/>
&ensp;두 지수의 합에서 bias(127) 를 한 번 빼준다.<br/>
&ensp;$E_3 = (E_1 + E_2) -127$ <br/>

&ensp;또한, 두 수의 부호(Sign bit)를 확인해서 결과 부호를 결정한다.<br/>

&ensp;Step 2. 가수(Fraction) 곱하기<br/>
&ensp;두 정규화된 가수를 곱하여 새로운 가수를 얻는다.<br/>
&ensp;$(1.F_1) \times (1.F_2) = F_3$ <br/>	​

&ensp;Step 3. 정규화 (Normalize)<br/>
* 결과가 1.XXXX 형태가 아니면 오른쪽 또는 왼쪽으로 시프트
* 시프트에 따라 지수를 증가(+1) 또는 감소(-1) 시킨다.
* Overflow 또는 Underflow 발생 시 예외 처리

&ensp;Step 4. 반올림 (Round)<br/>
&ensp;가수의 유효 비트를 반올림하여 정밀도를 유지한다.<br/>

&ensp;Step 5. 저장<br/>
&ensp;Hidden Bit(맨 앞의 1)는 다시 숨기고 Sign / Exponent / Fraction을 각각 저장한다.<br/>

&ensp;Example: Floating Point Multiplication<br/>
&ensp;$(0.5 = 1.0000 × 2^{−1}) × (−0.4375 = −1.1100 × 2^{−2})$

&ensp;Step 0. Hidden Bit 복원<br/>
* 0.5 → 1.0000 × 2⁻¹
* -0.4375 → -1.1100 × 2⁻²

&ensp;Step 1. 지수 계산<br/>
&ensp;(−1 + 127) + (−2 + 127) − 127 = 124<br/>
&ensp;지수 = 124 (01111100₂)<br/>

&ensp;Step 2. 가수 곱하기<br/>
&ensp;1.0000 × 1.1100 = 1.1100<br/>

&ensp;Step 3. 정규화<br/>
&ensp;결과는 이미 1.XXXX 형태 → 정규화 불필요<br/>

&ensp;Step 4. 반올림<br/>
&ensp;이미 반올림된 상태<br/>

&ensp;Step 5. 저장<br/>
```markdown
Sign = 1 (음수)
Exponent = 01111100 (124)
Fraction = 11000000000000000000000
```

&ensp;결과: `1 01111100 11000000000000000000000` <br/>

&ensp;Floating-Point Instructions (부동소수점 명령어)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-59.png" width="600"></p> 
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-60.png" width="600"></p> 

추가
======

accurate Arithmetic
----

&ensp;부동소수점은 가수비트가 고정된 길이(예: 단정밀도 23비트)라서 덧셈/뺄셈/나눗셈 뒤에 정규화(normalize)하거나 지수 맞추기(alignment)때문에 오른쪽으로 시프트하면서 잘려나가는 비트가 생긴다.<br/>
&ensp;그 비트들을 그냥 버리면 반올림이 부정확해진다. 그래서 추가로 세 개의 보조 비트를 둔다.<br/>
* Guard bit (G): LSB(가수의 마지막 비트) 바로 다음의 1비트
  - 예: 정규화/정렬 과정에서 오른쪽으로 한 칸 밀려나간 첫 번째 비트
* Round bit (R): Guard 다음 비트
* Sticky bit (S): 그 뒤로 모두 OR 한 값 (이후에 오른쪽으로 밀려나간 비트 중 하나라도 1이면 S=1)

```markdown
저장될 가수: 1 . x x x x x x x x x x x  |  G  R  S
                                     (LSB)  (보조 비트)
```

&ensp;목적: 가장 가까운 수로 동률이면 짝수(LSB=0)가 되게 정확히 반올림하기 위함<br/>

&ensp;G/R/S가 쓰이는 순간들<br/>
* 정규화 시 왼쪽/오른쪽 시프트 (나눗셈, 뺄셈 후 결과를 1.xxxx 형태로 만드는 과정)
* 덧셈/뺄셈에서 지수 맞추기(Alignment): 지수가 작은 쪽 가수를 오른쪽으로 여러 비트 시프트할 때 밀려나간 모든 비트를 정확히 요약하려면 S가 필요

&ensp;"Round to nearest, ties to even"을 GRS로 구현하는 법<br/>
&ensp;IEEE 754의 기본 반올림은 가장 가까운 값으로 동률(.5 ULP)일 땐 짝수(LSB=0) 가 되게 고른다.<br/>

&ensp;결정 규칙(가수의 LSB를 보관할 마지막 비트라 둘 때):<br/>
* g = 0 → 그냥 버림(내림): 변화 없음 (0.5 ULP 미만)
* g = 1 이면
  - (r=1 or s=1) → 무조건 올림 (0.5 ULP 초과)
  - r=0 and s=0 → 정확히 0.5 ULP 상황(타이)

&ensp;이때 LSB가 1이면 올림(올리면 LSB가 0이 되어 짝수가 됨), LSB가 0이면 그대로<br/>

&ensp;예제: Guard/Round가 있을 때와 없을 때<br/>
&ensp;$2.56 \times 10^{0}$ 를 $2.34_{10} \times 10^{2}$ 에 더해라<br/>
&ensp;유효 자릿수(significant digit) = 소수 3자리<br/>
&ensp;"가장 가까운 수(최근접, ties-to-even)"로 반올림<br/>

&ensp;1) G/R 없이(그냥 잘라서 계산)<br/>
* 지수를 맞추면 $2.56 \times 10^{0} = 0.0256 \times 10 ^{2}$ 이고 이를 두 자리만 보며 더하면 $2.34 \times 10^{2} = 0.0256 \times 10^{2}$ 이고 이를 두 자리만 보며 더하면 $2.34 \times 10^{2} + 0.02 \times 10^{2} = 2.36 \times 10^{2}$

&ensp;2) G/R 포함(정확히 추적 후 반올림)<br/>
* $2.56 \times 10^{2} = 0.0256 \times 10^{2}$ → 가드=5, 라운드=6가 보이는 셈
* $2.3400 \times 10^{2} + 0.0256 \times 10^{2} = 2.3656 \times 10^{2}$
& 유효 3자리 반올림 ⇒ $$2.37 × 10^2$

&ensp;차이점: G/R를 쓰면 $2.37×10^2$, 안 쓰면 $2.36×10^2$ <br/>
&ensp;보조 비트가 반올림 정확도를 올려준다는 걸 보여주는 대표 예시이다.<br/>

&ensp;IEEE 754 반올림 모드 4가지<br/>
1. Round up (toward +∞)
* 항상 큰 쪽으로
* +7.3→8, +7.5→8 / -7.3→-7, -7.5→-7
2. Round down (toward −∞)
* 항상 작은 쪽으로(바닥)
* +7.3→7, +7.5→7 / -7.3→-8, -7.5→-8
3. Truncate (toward 0)
* 0쪽으로 자르기(버림)
* +7.3→7, +7.5→7 / -7.3→-7, -7.5→-7
4. Round to nearest even (기본값)
* 가장 가까운 정수로, .5 동률이면 짝수 선택
* 7.3→7, 7.5→8, 8.5→8 / -7.3→-7, -7.5→-8

&ensp;포인트: 부호가 음수일 때 +∞/−∞/0 방향이 어떻게 작용하는지 꼭 기억하기<br/>