---
title: "chapter3. Arithmetic for Computers"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Architecture
tags:
  - CS

toc: true
toc_sticky: true

date: 2025-09-20
last_modified_at: 2025-09-20
---

기본 개념
=====

&ensp;<b>이진수(Binary Number)</b><br/>
* 우리가 일상에서 쓰는 수는 10진수(Decimal) → 0~9까지의 숫자로 구성
* 컴퓨터는 전기 신호(ON = 1, OFF = 0) 만 이해 → 그래서 이진수(0과 1만 사용) 를 씀

&ensp;예시:<br/>
&ensp;10진수 13 → 2진수 1101(왜냐면 13 = 8 + 4 + 1 = 2³ + 2² + 2⁰)<br/>
&ensp;👉 즉, 자리값이 2의 거듭제곱으로 늘어난다고 생각하면 된다.<br/>

&ensp;이진수의 자리값 (MSB, LSB)<br/>
`01011000 00010101 00101110 11100111`

* LSB (Least Significant Bit) → 제일 오른쪽 (가장 작은 값, 2⁰ 자리)
* MSB (Most Significant Bit) → 제일 왼쪽 (가장 큰 값, 2³¹ 자리)

&ensp;비유하자면:<br/>
* LSB = 일의 자리
* MSB = 가장 큰 자리(억, 조 자리 같은 느낌)

&ensp;<b>Unsigned Integer (부호 없는 정수)</b><br/>
* “항상 양수”만 표현한다고 가정
* 32비트라면, 0부터 2³² - 1 까지 가능 → 즉, 0 ~ 4,294,967,295

&ensp;비유: 주민번호 뒷자리처럼 음수는 없고, 그냥 번호표라고 생각하면 된다.<br/>

&ensp;<b>Signed Integer (부호 있는 정수)</b><br/>
* 컴퓨터는 음수도 표현해야 함 → 가장 왼쪽(MSB)을 부호 비트(Sign Bit) 로 사용
    - 0 → 양수
    - 1 → 음수

&ensp;예: 8비트 signed 정수 → -128 ~ +127 까지 표현 가능<br/>
&ensp;👉 왜냐면 한 자리를 부호 표시로 쓰니까, 표현 범위가 절반으로 줄어듦<br/>

&ensp;<b>Overflow (넘침 현상)</b><br/>
* 4자리 십진수에서 9999 + 1 = 0000 되는 것처럼 컴퓨터도 자리수(비트 수)를 초과하면 다시 0으로 돌아감

&ensp;예시: 8비트 unsigned: 11111111 (255) + 1 → 00000000 (0) (넘침)<br/>

&ensp;<b>16진수(Hexadecimal) 왜 쓰나?</b><br/>
* 2진수는 너무 길고 헷갈림 → 4비트(2진수 4자리)를 16진수 1자리로 표현
* 16진수는 0~9 + A~F 사용 (A=10, B=11, ... F=15)

&ensp;예:<br/>
* 2진수 1111 1111 = 16진수 FF

&ensp;👉 그래서 메모리 주소, 색상 코드 등에 16진수가 자주 쓰인다.<br/>

&ensp;왜 음수를 표현해야 하는 이유<br/>
&ensp;컴퓨터는 0과 1만 알 수 있다. 그런데 우리가 다루는 숫자는 -5, +3 같은 음수와 양수가 다 있다.그래서 이진수로 음수를 표현하는 규칙이 필요하다. 그 규칙들이 바로 Signed Magnitude, 1의 보수(1’s complement), 2의 보수(2’s complement) 방식이다.<br/>

&ensp;<b>Signed Magnitude (부호와 크기 방식)</b><br/>
* 제일 왼쪽 비트(MSB)를 부호 비트로 씀
    - 0 → 양수
    - 1 → 음수
* 나머지 비트는 숫자의 크기를 표현

&ensp;예시 (8비트):<br/>
* 0000 0101 → +5
* 1000 0101 → -5

&ensp;👉 단점: +0 (0000 0000), -0 (1000 0000) 두 가지 0이 존재 → 헷갈림<br/>

&ensp;1의 보수 (1’s Complement)<br/>
* 규칙: 양수의 음수를 구할 때 모든 비트를 반전(0↔1)
* 즉, X의 음수 = X의 1의 보수

&ensp;예시 (8비트):<br/>
* +5 = 0000 0101
* -5 = 1111 1010 (모든 비트를 반전)

&ensp;👉 단점:<br/>
* 여전히 +0 (0000 0000), -0 (1111 1111) 두 가지 0이 존재.
* 덧셈할 때 자리 올림(End-around carry) 을 다시 더해야 하는 불편함.

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-1.png" width="600"></p>

&ensp;<b>2의 보수 (2’s Complement) → 오늘날 표준</b><br/>
* 규칙: 1의 보수를 구한 뒤 +1을 더하기
* 즉, X의 음수 = ~X + 1 (비트 반전 후 1 더함)

&ensp;예시 (8비트):<br/>
* +5 = 0000 0101
* 1의 보수 → 1111 1010
* +1 → 1111 1011 = -5

&ensp;👉 장점:<br/>
* 0이 하나만 존재
* 덧셈/뺄셈 회로가 단순해짐 → 하드웨어에서 효율적
* 지금 우리가 쓰는 컴퓨터는 모두 2의 보수 방식 사용

&ensp;왜 2의 보수가 좋은가?<br/>
* 어떤 수 X와 -X를 더하면 항상 0이 나오고, carry(자리올림)는 버림.
* 예시: 5 + (-5)
    - 0000 0101 (5) + 1111 1011 (-5) = 0000 0000 (0)

&ensp;👉 그래서 뺄셈을 “덧셈”으로 처리 가능 (예: 7 - 5 → 7 + (-5))<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-2.png" width="600"></p>

&ensp;Unsigned vs Signed<br/>
* Unsigned: 음수 없음. 0 ~ 2^n - 1 표현 가능.
* Signed (2의 보수): 음수 포함. -2^(n-1) ~ +2^(n-1) - 1 표현 가능.

&ensp;예 (8비트):<br/>
* Unsigned: 0 ~ 255
* Signed: -128 ~ +127

&ensp;직관적인 비유<br/>
* Signed Magnitude = “앞에 + 또는 - 붙이는 방식”
* 1의 보수 = “모든 전구(0,1)를 반대로 켬”
* 2의 보수 = “전구를 반대로 켠 다음에 +1 전구 하나 더 켬”

&ensp;👉 2의 보수가 제일 깔끔하고, 그래서 현대 CPU가 모두 채택!<br/>

MIPS Arithmetic Instructions (MIPS 산술 명령어)
-----

&ensp;MIPS는 CPU 명령어 집합이다.<br/>
&ensp;예시<br/>
```nginx
slt  $t0, $t1, $zero
```

* slt = Set if Less Than (작으면 1, 아니면 0 저장)
* $t1 값이 $zero (0 레지스터)보다 작으면 $t0 ← 1
* 그렇지 않으면 $t0 ← 0

&ensp;중요한 점: $t1을 부호 있는(signed) 수로 해석할지 부호 없는(unsigned) 수로 해석할지에 따라 결과가 달라진다.<br/>
&ensp;예:<br/>
* $t1 = 1111…01 (32비트)
    - Signed 해석 → 음수 → 0보다 작다 → $t0 = 1
    - Unsigned 해석 → 아주 큰 양수 → 0보다 크다 → $t0 = 0

숫자 값(Value of X)
----

* Unsigned: 그냥 자리값대로 (모두 양수)
* Signed Magnitude: 맨 앞(부호 비트)이 0이면 양수, 1이면 음수
* 1’s Complement: 음수는 모든 비트를 반전
* 2’s Complement: 음수는 반전 + 1 (현대 표준)

&ensp;정리: 같은 비트 패턴이라도 해석 방법에 따라 값이 달라진다.<br/>

덧셈과 뺄셈 (Addition & Subtraction)
====

* 덧셈: 10진수랑 똑같이, 오른쪽부터 더하면서 자리올림(carry)을 왼쪽으로 넘김
* 뺄셈: 사실상 음수를 더하는 것
    - 예: A - B = A + (-B)
    - 그래서 뺄셈 회로를 따로 만들 필요 없음 → 덧셈기로 처리 가능

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-3.png" width="600"></p> 

&ensp;그림에 나온 것처럼<br/>
&ensp;1 + 1 = 0 (자리올림 1 발생)<br/>
&ensp;1 + 1 + 1 = 1 (자리올림 1 발생)<br/>

오버플로우 (Overflow)
-----

&ensp;컴퓨터는 비트 개수 제한이 있다. 예를 들어 8비트면 -128 ~ +127까지만 표현 가능하다. 이 범위를 벗어나면 오버플로우가 발생한다.<br/>
* 양수 + 양수 → 결과가 음수로 보이면 오버플로우
* 음수 + 음수 → 결과가 양수로 보이면 오버플로우
* 양수 + 음수 → 범위를 벗어나지 않음 → 오버플로우 없음

&ensp;예<br/>
* 7 + 7 = 0111 + 0111 = 1110 → 10진수로 보면 -2 → 오버플로우 발생!

&ensp;오버플로우 판정 (Overflow Detection)<br/>
* 방법: MSB(부호 비트)에 들어온 자리올림(carry-in)과 MSB에서 나간 자리올림(carry-out)비교
* 같으면 정상, 다르면 오버플로우

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-4.png" width="600"></p> 

&ensp;Dealing with Overflow (오버플로우 처리 방법)<br/>
&ensp;① Unsigned number (부호 없는 정수)<br/>
* 조건: MSB(최상위 비트)에서 CarryOut = 1 → Overflow
* 예: 8비트 unsigned에서 255 + 1 = 0 → Carry 발생 → Overflow

&ensp;② Signed number (부호 있는 정수)<br/>
* 조건: CarryIn ≠ CarryOut → Overflow
* 예: +127 + 1 = -128 (범위를 벗어나 부호가 뒤집힘)

&ensp;👉 비유:<br/>
* 계산기 자릿수보다 큰 숫자를 넣으면 “E” 뜨는 것처럼 컴퓨터도 비트 자릿수를 넘으면 이상한 값이 나옴 → 오버플로우

&ensp;언어별 처리<br/>
* C 같은 언어: 오버플로우 무시 (그냥 이상한 값 나옴)
* Ada, Fortran 같은 언어: 오버플로우 → 예외(Exception) 발생
* CPU(MIPS)도 특별한 명령어(add, addu, sub)로 제어할 수 있음

&ensp;ALU(Arithmetic Logic Unit)<br/>

* CPU 안에서 계산기 역할을 하는 부분
* 숫자 더하기, 빼기, 곱하기, 나누기, 비교, 논리연산(AND, OR 등)을 전부 담당
* 입력(operand) 두 개를 받아서 → 결과(result) 하나를 출력
* 추가로 Carry, Zero, Overflow 같은 상태 신호도 만들어냄

&ensp;👉 비유: ALU = 똑똑한 계산기. CPU가 “이거 계산해!”라고 명령하면 ALU가 대신 계산해준다.<br/>

&ensp;ALU가 지원해야 하는 연산들 (MIPS 기준)<br/>
&ensp;MIPS ISA(Instruction Set Architecture) 명령어를 실행할 수 있도록 ALU는 다양한 연산을 지원해야 함<br/>

&ensp;① 산술 연산 (Arithmetic)<br/>
* add, addi, addu, addiu → 덧셈
* sub, subu → 뺄셈
* mult, multu → 곱셈
* div, divu → 나눗셈
* sqrt → 제곱근

&ensp;② 논리 연산 (Logic)<br/>
* and, andi
* or, ori
* xor, xori
* nor

&ensp;③ 비교/분기 연산 (Comparison / Branch)<br/>
* slt, slti, sltu, sltiu → 작은지 비교 (Set Less Than)
* beq, bne → 같으면 분기 / 다르면 분기

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-5.png" width="600"></p> 

* A (32비트 입력)
* B (32비트 입력)
* m (4비트): 어떤 연산을 할지 지정하는 "명령 선택 스위치"
    - 예: m=0000 → 덧셈, m=0001 → 뺄셈, m=0010 → AND …
* result (32비트 출력): 실제 연산 결과
* zero (1비트): 결과가 0이면 1로 표시 → 분기 명령에 사용
* ovf (1비트): 오버플로우 발생 여부 표시
* Carry (1비트): 자리올림 발생 여부 표시

&ensp;정리: ALU는 입력 두 개(A, B)와 "연산 종류 코드(m)"를 받아서 결과와 상태 플래그를 뱉어냄.<br/>

&ensp;특별히 처리해야 하는 부분 (Special Handling)<br/>
1. Sign Extension (부호 확장)
* 작은 크기의 수(예: 16비트)를 큰 크기(32비트)로 바꿀 때 맨 앞 부호 비트를 그대로 확장해 줌
* 예: 16비트 1111 1111 1111 1111 (-1) → 32비트 1111 … 1111 (-1) → addi, addiu, slti 같은 명령어에서 필요
2. Zero Extension (제로 확장)
* 확장할 때 무조건 앞자리를 0으로 채움
* 부호 개념 필요 없음 (항상 양수)
* andi, ori, xori, sltiu 등에서 사용
3. Overflow Detection (오버플로우 검출)
* add, addi, sub 같은 연산에서 결과가 범위를 벗어났는지 검사
* 예: +2147483647 + 1 = -2147483648 → 오버플로우 발생

보충 개념
-----

&ensp;<b>Bit ALU with ADD, OR, AND</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-6.png" width="600"></p> 

* ALU는 한 비트씩 계산하는 기본 블록으로 시작해요.
* 입력: a, b (각각 1비트)
* 가능한 연산: AND, OR, ADD

&ensp;👉 ALU 안에 세 가지 “작은 계산기”가 들어있고 마지막에 **Multiplexer (선택기)**가 있어서 Operation 코드에 따라 어떤 결과를 내보낼지 고르는 구조이다.<br/>
* Operation=0 → AND 결과 출력
* Operation=1 → OR 결과 출력
* Operation=2 → ADD 결과 출력

&ensp;비유: 레스토랑 주방에 “튀김기(AND)”, “오븐(OR)”, “냄비(ADD)”가 있고 손님이 메뉴(Operation code)를 고르면 셰프가 그 기계에서 요리한 결과를 내보내는 구조<br/>

&ensp;<b>32-bit Ripple Carry Adder</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-7.png" width="600"></p> 

&ensp;실제 CPU는 32비트나 64비트 숫자를 다룬다. 그래서 1비트 ALU를 32개 연결해서 32비트 연산을 처리한다.<br/>

* 각 ALU는 1비트만 처리하고, **Carry(자리올림)**을 다음 ALU로 넘겨준다.
* 이렇게 연쇄적으로 carry가 “파도처럼(ripple)” 전달되기 때문에 이름이 Ripple Carry Adder

&ensp;단점: carry가 0번 비트에서 31번 비트까지 차례대로 전달되므로 계산 속도가 느려짐<br/>

&ensp;비유: 32명이 줄 서서 덧셈을 하는데, 앞사람이 자리올림(carry)을 계산해야 뒤사람이 계산을 이어갈 수 있는 구조<br/>

&ensp;<b>Incorporating Subtraction (뺄셈 구현하기)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-8.png" width="600"></p> 

* 뺄셈 A - B를 ALU가 어떻게 하냐? -> 사실 뺄셈은 A + (-B)로 바꿔서 덧셈으로 처리 가능
* 음수 -B는 2의 보수로 구함 = B 비트 반전 + 1

&ensp;그래서 ALU에 **B 입력을 반전시킬 수 있는 회로(Inverter)**를 추가하고 첫 번째 자리의 CarryIn을 1로 주면 +1 효과까지 포함된다.<br/>
&ensp;즉:<br/>
* Binvert=0 → 정상적인 B 사용 (덧셈)
* Binvert=1 → B를 반전하고 CarryIn=1로 설정 (뺄셈)

&ensp;👉 이렇게 하면 ALU가 덧셈과 뺄셈을 같은 회로로 처리 가능!<br/>

&ensp;비유: "마이너스" 버튼이 따로 있는 게 아니라 "빚진 돈"을 더하는 방식으로 처리하는 계산기라고 생각하면 된다.<br/>

&ensp;Incorporating NOR (NOR 연산 추가)<br/>
&ensp;NOR = NOT (A OR B)
&ensp;즉 OR 결과를 뒤집은 것<br/>
&ensp;ALU에서는 이미 OR 회로가 있으므로, 입력을 반전(Ainvert, Binvert)시키거나 결과를 반전해서 NOR을 구현 가능<br/>

&ensp;👉 핵심: 새로운 회로를 안 만들고 기존 OR 회로에 "부정"만 추가해서 NOR을 구현<br/>
&ensp;👉 비유: TV 리모컨에 "끄기 버튼(NOT)"만 하나 더 붙인 것<br/>

&ensp;<b>Incorporating SLT (Set Less Than)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-9.png" width="600"></p> 

* MIPS 명령어 slt $t0, $t1, $t2 → "$t0 = ($t1 < $t2) ? 1 : 0"
* 즉 A가 B보다 작은지 비교

&ensp;구현 방법:<br/>
1. ALU가 A - B를 계산
2. 결과의 부호(Sign bit)를 확인
    - 결과가 음수 → A < B
    - 결과가 양수/0 → A ≥ B
3. 이 값(부호 비트)을 Less 신호로 출력.

&ensp;👉 특별히, 마지막(31번째 비트) ALU가 부호와 오버플로우를 감지해서 맨 처음 비트(ALU0)에 “Less=1 or 0” 신호를 넣어줌<br/>
&ensp;👉 비유: 시험 점수(A-B)를 뺀 결과가 “음수(빚)”라면 A가 작다는 뜻<br/>

&ensp;<b>Incorporating BEQ (Branch if Equal)</b><br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-10.png" width="600"></p> 

* MIPS 명령어 beq $t1, $t2, label → "$t1 == $t2 이면 분기"
* 즉 두 값이 같은지 비교

&ensp;구현 방법:<br/>
1. ALU가 A - B 수행
2. 결과가 전부 0인지 확인
3. 결과가 0 → Equal → 분기

&ensp;각 ALU의 결과(Result0, Result1, …)를 OR 게이트에 연결해서 “하나라도 1이 있으면 다르다”고 판단<br/>
&ensp;최종 결과가 0 → Equal<br/>

&ensp;<b>A MIPS ALU Implementation (최종 ALU 구현)</b><br/>
&ensp;앞의 기능들을 전부 모아 완성된 MIPS ALU 구조를 보여준다.<br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter3. Arithmetic for Computers/3-11.png" width="600"></p> 

* 입력: A, B (32비트)
* 연산 선택(op): ADD, SUB, AND, OR, NOR, SLT, …
* 출력: result (32비트), Zero, Overflow

&ensp;특징:<br/>
1. Zero detect: 결과가 전부 0인지 확인 (beq, bne, slt 등에 필요).
2. Overflow detect: 덧셈/뺄셈에서 범위를 넘는지 확인.
3. Set signal: SLT 연산용.

&ensp;비유: 이제 ALU는 “스위스 군용 칼”처럼 다용도 도구가 됐다. 칼(덧셈), 가위(뺄셈), 드라이버(AND/OR), 줄자(SLT), 센서(BEQ) 등 다양한 기능이 하나로 통합됨<br/>