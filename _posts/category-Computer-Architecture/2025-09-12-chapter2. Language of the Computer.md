---
title: "chapter2. Language of the Computer"
excerpt: ""

wirter: sohee Kim
categories:
  - Computer Architecture
tags:
  - CS

toc: true
toc_sticky: true

date: 2025-09-12
last_modified_at: 2025-09-12
---


Introduction
======

&ensp;<b>Instruction(명령어)</b><br/>
&ensp;한 줄 끼리 컴퓨터의 동작 지시문이다.<br/>
&ensp;사람에게 불 켜가 동사 + 대상(전등)이라면 컴퓨터에겐:<br/>
* Opcode(동사): 무엇을 할지 — 예) ADD(더해라), LOAD(메모리에서 가져와라), STORE, JUMP
* Operand specifiers(목적어): 무엇을 대상으로 — 예) 어떤 레지스터/메모리 주소

&ensp;예시(자연어 → 컴퓨터어): A와 B를 더해 C에 넣어 → ADD C, A, B
&ensp;레지스터 한 줄 설명<br/>
&ensp;CPU 안의 초고속 메모장. 자주 쓰는 값을 잠깐 담아두는 칸. 대부분의 명령어는 레지스터를 읽고/쓰며 끝난다.<br/>

&ensp;<b>Instruction Set(명령어 집합, ISA)</b><br/>
&ensp;컴퓨터가 이해하는 모든 명령어의 어휘집<br/>
&ensp;프로그래머·컴파일러는 이 사전에 있는 말(명령)만 써야 하고, 하드웨어(CPU)는 그 말을 정확히 수행해야 한다.<br/>
* 같은 ISA면, 다른 회사의 CPU라도 같은 프로그램을 돌릴 수 있다.
* ISA가 바로 하드웨어/소프트웨어 인터페이스의 표준 언어.

&ensp;핵심 구분:<br/>
* ISA: 무엇을 할 수 있는가(What)의 약속
* 마이크로아키텍처: 어떻게 빠르고 효율적으로 할 것인가(How)의 구현

&ensp;<b>RISC vs. CISC — 메뉴판 크기의 차이</b><br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-1.png" width="600"></p>

&ensp;비유<br/>
* RISC = 메뉴는 단출하지만 조합해서 빨리 많이 만들어낸다.(주방 동선 최적화)
* CISC = 메뉴가 다양해서 웬만한 주문은 한 번에 처리하지만 주방이 복잡해진다.

Common Goal of Computer Designers — 설계자들의 공통 목표
-------

1. 컴파일러와 하드웨어가 만들기 쉬운 언어(ISA) 찾기
2. 성능 최대화 + 비용/전력 최소화
3. 그래서 나온 모토가 KISS: Keep It Short and Simple (간단할수록 빠르고, 실수도 적다)

MIPS - 단순함을 밀어붙인 교과서 같은 RISC
------

* 약자: Microprocessor without Interlocked Pipeline Stages
    - 초창기 MIPS는 하드웨어가 파이프라인 충돌(interlock)으로 자동 멈추는 장치를 최소화했다는 뜻
    - 대신 컴파일러가 명령 순서를 재배치하거나 **지연 슬롯(delay slot)**을 활용해 병목을 피했다 → 장비 단순화가 목표.
* 중요한 이유
    - 구조가 깔끔해서 교육·연구용 표준처럼 사랑받음
    - RISC철학(간단한 명령 + 강력한 컴파일러 + 파이프라인 친화성)을 널리 퍼뜨림
    - ARM, RISC-V 같은 현대 ISA 설계에도 큰 영향을 줌

MIPS 아키텍처 변천
------

* MIPS I (R2000, 1985)
    - 8~16 MHz, 약 11만 트랜지스터. 초기 RISC 구현
* MIPS II (R6000, 1989)
    - 지연 분기를 줄이려는 시도 등 분기 처리 변화. 상업적 성공은 제한적(슬라이드 코멘트)
* MIPS III (R4000, 1991)
    - 100MHx, 135만 트랜지스터, 64-bit 정수 도입
* MIPS IV (R8000, 1994)
    - 90 MHz, 240만 트랜지스터. 고성능 변형(R10000, R5000, R7000 등).
* MIPS V / MIPS32 & MIPS64 (1999~)
    - 32/64비트 라인 정리, 임베디드·네트워크 장비에서 긴 생명력

&ensp;포인트: 클럭↑·트랜지스터↑·64비트 지원으로 진화하면서도, 단순한 규칙성은 유지 → 파이프라인·캐시·분기예측 같은 구현을 깔끔하게 만들기 쉬움.<br/>

&ensp;아주 쉬운 MIPS 스타일 예시<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-2.png" width="600"></p>

* 명령 길이와 형식이 규칙적이라 읽고 쓰기 쉽다.
* 한 명령이 한 가지 일을 단순하게 한다.(Load는 일기만, Add는 더하기만)

Operations of the Computer Hardware
=====

&ensp;MIPS의 산술 연산 기본형<br/>
* add a, b, c → a = b + c
* sub a, b, c → a = b - c

&ensp;MIPS는 결과 레지스터, 피연산자1, 피연산자2 순서(=목적지 먼저)라는 점을 꼭 기억<br/>

&ensp;왜 항상 3개의 피연산자일까?<br/>
* 형식이 항상 동일하면 하드웨어가 해석하기 쉽다.(디코딩·배선 단순)
* 연산에 메모리 접근을 섞지 않는다.(연산은 레지스터끼리만) → 빠르고 파이프라인 친화적
* 컴파일러도 예측 가능해서 코드 만들기 쉽다.

&ensp;Design Principle 1 — Simplicity favors regularity.<br/>
&ensp;단순함은 규칙성을 낳고, 규칙성은 구현을 쉽게 하고 성능/비용도 좋아진다.<br/>

Operands of the Computer Hardware
=====

&ensp;연산은 피연산자는 레지스터여야 한다.<br/>
* RISC의 공통 특성: 산술 명령은 레지스터만 다룬다.
    - 메모리에서 값ㅇ르 읽고/쓰는 일은 별도 명령(LW/SW)로 분리
* 컴파일러는 소스코드의 변수들을 레지스터에 배치한다.
* 이렇게 하면 명령 형식이 단순·규칙적이라 하드웨어가 빨라진다.

&ensp;레지스터<br/>
* CPU 칩 안에 있는 초고속 임시 저장칸(scratchpad)
* 자주 쓰는 데이터를 보관 → 메모리보다 훨씬 빠름
* MIPS는 32개 × 32비트 레지스터(= 32비트 워드)를 가진다.
* 번호 표기: $0 ~ $31 (의미 있는 별칭도 있음)

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-3.png" width="600"></p>

* 총 32개
* saved($s0 ~ $s7): 함수 호출 이후에도 값을 보존해야 하는 변수용(고정 변수 느낌)
* Temporary($t0 ~ $t9): 임시 계산용. 다른 함수가 덮어써도 됨

&ensp;Design Principle 2 — Smaller is faster<br/>
&ensp;레지스터가 너무 많아지면 회로와 배선이 길어져 접근 시간이 늘고, 한 사이클 시간(클럭 주기)이 길어진다. 적당한 크기가 빠르다.<br/>
&ensp;실제로는 $zero, $a0~$a3, $v0~$v1, $sp, $ra 등 여러 역할이 더 있지만, 이 장에서는 $s=변수, $t=임시 로만 기억해도 충분!<br/>

&ensp;예제 해설: f = (g + h) - (i + j)<br/>
&ensp;가정<br/>
* f, g, h, i, j → $s0, $s1, $s2, $s3, $s4 에 들어 있음

```mips
add  $t0, $s1, $s2   # t0 = g + h
add  $t1, $s3, $s4   # t1 = i + j
sub  $s0, $t0, $t1   # f  = t0 - t1 = (g+h) - (i+j)
```

* 첫 줄: g와 h를 더해 임시(t0)에 저장
* 둘째 줄: i와 j를 더해 임시(t1)에 저장
* 셋째 줄: 두 임시의 차를 f($s0)에 저장

&ensp;왜 임시 레지스터를 쓸까?<br/>
* 중간 결괄르 담을 자리가 있어야 마지막 계산을 할 수 있다.
* $t는 덮어써도 되는 용도라 이런 중간값 보관에 딱 맞다.

Memory Operands
------

&ensp;메모리 피연산자의 필요성<br/>
&ensp;레지스터는 32개뿐(빠르지만 작음).<br/>
&ensp;배열/구조체처럼 데이터가 많아지면 전부 레지스터에 둘 수 없어서 메모리(주기억장치) 에 둔다.<br/>
* 메모리의 핵심 속성
    - 주소(Address): 몇 번 칸인지
    - 데이터(Data): 그 칸에 든 값
* 데이터 전송 명령(Data transfer)
    - lw(load word): 메모리 → 레지스터 (한 “워드”= 4바이트 읽기)
    - sw (store word): 레지스터 → 메모리 (4바이트 쓰기)
    - 참고: 바이트 단위는 1b/sb, 하프워드는 1h/sh

&ensp;RISC 철학: 연산은 레지스터끼리만, 메모리 접근은 별도 명령으로!⇒ 명령 형식이 단순/규칙적이라 하드웨어가 빠름<br/>

&ensp;C에서의 배열 접근 두 스타일<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-4.png" width="600"></p>

* 포인터 산술(direct addressing)

```c
char B[100], x, *p = B;
p += 3;      // B의 3칸 뒤
x = *p;      // B[3]과 동일
```

* 인덱싱(base + offset)

```c
char B[100], x;
x = B[3];
```

&ensp;둘 다 결국 “기준 주소(base) + 오프셋(offset)” 계산이다. MIPS 같은 RISC는 실제로 base + offset 주소 모드로 구현된다.<br/>

&ensp;MIPS의 주소 모드: lw rt, offset(base)<br/>
* base 레지스터: 배열/변수의 시작 주소
* offset: 그 시작점에서 몇 바이트 떨어졌는지(바이트 단위)

&ensp;예) lw $t0, 12($s3)<br/>
&ensp;→ $s3가 가리키는 곳에서 12바이트 뒤의 4바이트를 읽어 $t0에 넣어라 (워드 단위가 아니라 항상 바이트 기준으로 오프셋을 센다는 점 주의)<br/>

&ensp;예제: g = h + A[8];<br/>
* 가정: int g, h, A[100]
* A의 베이스 주소가 $s3 에 있고, h는 $s2, g는 $s1 에 있다고 하자
* int는 4바이트이므로 A[8]의 바이트 오프셋은 8 * 4 = 32

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-5.png" width="600"></p>

```mips
lw   $t0, 32($s3)      # $t0 ← A[8]  (정답: 32바이트 오프셋)
add  $s1, $s2, $t0     # g  ← h + A[8]
```

&ensp;자주 하는 실수: lw $t0, 8($s3)<br/>
&ensp;바이트 주소 체계에서 워드(4B) 배열의 A[i]는 4*i 오프셋이다.<br/>
* char 배열이면 요소 크기가 1B라서 B[3]은 오프셋 3이 맞음
* double(8B)면 A[8]은 오프셋 64가 됨

&ensp;메모리 & 처리 서브시스템 한눈에 보기<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-6.png" width="600"></p>

&ensp;CPU 내부는 보통 이렇게 나뉜다:<br/>
* 정수 실행 유닛(EIU): ALU(덧셈/뺄셈 등), 정수 곱·나눗셈기, 정수 레지스터 파일
* 부동소수점 유닛(FPU): 실수 연산기, FP 레지스터 파일
* 예외/트랩·메모리 유닛(TMU): 예외 처리, 메모리 접근 관련 제어
* 이 유닛들이 메모리(주기억장치)와 버스/캐시를 통해 연결

&ensp;레지스터 ↔ 메모리 사이를 lw/sw 같은 로드/스토어로 왕복시키며, 연산은 유닛(정수/실수)이 레지스터에 든 값을 가지고 실행한다는 것.<br/>

하드웨어/소프트웨어 인터페이스의 3가지 포인트
----

&ensp;Byte addressing (바이트 주소 체계)<br/>
* 주소 1칸 = 1바이트
* 위드(4B)를 다루더라도 주소는 바이트 단위로 움직인다.
* 그래서 A[i] 주소 = base + (i * 요소크기)가 되는 것

&ensp;메모리 정렬(Alignment)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-7.png" width="600"></p>

* 데이터 크기의 배수 주소에 두면 정렬(aligned)이라고 한다.
    - 예) 4바이트 워드는 주소가 4의 배수여야 정렬됨
* 정렬이 깨지면(Not aligned) CPU가 두 번 읽거나 예외가 나서 느려지거나 오류가 날 수 있다.
    - 성능/호환을 위해 정렬 지키기가 기본 습관!

&ensp;엔디언(Endianness)<br/>
* 멀티바이트(예: 32비트 = 4바이트)값을 메모리에 어떤 순서로 나열할까?<br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-8.png" width="600"></p>

* x86/ARM(대부분)은 리틀 엔디언(ARM은 바이엔디언 지원 모델도 있음)
* 네트워크(“network byte order”)는 전통적으로 빅 엔디언

&ensp;포인터/바이트 단위 접근(char*)으로 값을 해석할 때 엔디언 차이가 드러난다. 반면 정수 연산 자체에는 보통 영향이 없다.(레지스터 안에서는 “숫자”로 다뤄지니까)<br/>

&ensp;✅ 실무 감각 팁 & 체크리스트<br/>
&ensp;(1) 배열/구조체 주소 계산법<br/>
* 주소 = 베이스 + (인덱스 × 요소크기)
* 요소가 int(4B)면 항상 ×4를 잊지 말 것!
* 구조체는 필드 오프셋으로 주소를 계산한다(컴파일러가 정렬 규칙에 맞춰 패딩을 넣기도 함).

&ensp;(2) 어떤 명령을 써야 하지?<br/>
* 4B 정수: lw/sw
* 1B 문자: lb/sb
* 8B 실수(double): l.d/s.d(부동소수점 레지스터 사용; 교재·ISA 버전에 따라 표기는 다를 수 있음)

&ensp;(3) 정렬과 캐시<br/>
* 정렬을 지키면 보통 한 번의 메모리 접근으로 끝남 → 캐시/버스 효율 ↑
* 구조체 필드 순서를 큰 것 → 작은 것 순으로 배치하면 패딩이 줄어드는 경우가 많다.

&ensp;미니 연습문제(정답 바로 아래)<br/>
&ensp;Q1. int A[100]; 의 베이스가 $s3. A[7]을 $t0로 읽는 MIPS?<br/>
```mips
lw  $t0, 28($s3)    # 7 * 4 = 28
```

&ensp;Q2. char B[100];의 B[3]을 $t1로 읽고 $s0에 더하라.<br/>
```mips
lb  $t1, 3($s3)     # 요소가 1B → 오프셋 3
add $s0, $s0, $t1
```

&ensp;Q3. double D[50];의 D[i] 주소는? (베이스 $s4, i는 $t2)<br/>
* double은 8B → 오프셋 = i * 8
* 주소 계산은 보통 sll(왼쪽 시프트)로 곱셈을 대체: i<<3

```mips
sll $t3, $t2, 3     # t3 = i * 8
add $t3, $t3, $s4   # t3 = base + i*8
# l.d  $f0, 0($t3)  # 부동소수점 로드(표기는 ISA/교재에 따라)
```

엔디언(Endianness) — 바이트를 어떤 순서로 놓을까
-----

&ensp;멀티바이트(예: 32비트 = 4바이트)값을 메모리에 저장할 때 바이트를 나열하는 두 방식<br/>
* Little endian: “작은 쪽(LSB)” 바이트가 낮은 주소에 먼저

&ensp;예) 값 0x81 C5 3B 02 → 메모리[낮→높] = 02 3B C5 81<br/>

* Big endian: “큰 쪽(MSB)” 바이트가 낮은 주소에 먼저

&ensp;예) 값 0x81 C5 3B 02 → 메모리[낮→높] = 81 C5 3B 02<br/>

&ensp;숫자 자체(레지스터 안에서의 값)는 똑같아. 메모리에 놓는 순서만 다르다. 네트워크 표준은 보통 빅 엔디언, x86/대부분 ARM은 리틀 엔디언(ARM은 바이엔디언 모델도 있음)<br/>

&ensp;📥 Load와 엔디언<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-9.png" width="600"></p>

&ensp;lw $s1, 200($zero) (절대주소 200에서 워드 하나 읽기)<br/>

&ensp;메모리(주소 200~203) 값이 다음과 같다고 하자:<br/>
```makefile
Addr:   200   201   202   203
Byte:   81    C5    3B    02
```

* 리틀 엔디언: 레지스터 $s1 안의 워드 = 0x02 3B C5 81 (MSB→LSB로 적어 보면 023BC581)
* 빅 엔디언: 레지스터 $s1 안의 워드 = 0x81 C5 3B 02 (MSB→LSB로 81C53B02)

&ensp;즉, 같은 4바이트를 읽어도 레지스터에 들어온 값의 바이트 배열이 반대로 해석된다.<br/>
&ensp;참고: lw 주소는 보통 4의 배수 정렬(aligned)이어야 한다. 200은 4의 배수라 정상.<br/>

&ensp;📤 Store와 엔디언<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-10.png" width="600"></p>

&ensp;sw $s2, 100($zero) (절대주소 100에 $s2의 4바이트 저장)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-11.png" width="600"></p>

* $s2 값이 0x02 3B C5 81라고 하면…
    - 리틀 엔디언 메모리[100..103] = 81 C5 3B 02
    - 빅 엔디언 메모리[100..103] = 02 3B C5 81

&ensp;Load의 반대 방향으로 생각하면 외우기 쉽다.<br/>

&ensp;🧮 배열 예제: A[12] = h + A[8];<br/>
* 가정: int A[100], base(A) → $s3, h → $s2
* int는 4바이트 → A[i]의 바이트 오프셋은 4*i

&ensp;정답:<br/>
```mips
lw   $t0, 32($s3)      # A[8] 읽기: 8*4 = 32
add  $t0, $s2, $t0     # t0 ← h + A[8]
sw   $t0, 48($s3)      # A[12]에 저장: 12*4 = 48
```

&ensp;포인트<br/>
* base + offset(바이트) 주소 모드: lw rt, offset(base)
* **중간값은 임시 레지스터 $t**에 담아 연산하고 결과를 다시 저장
* 슬라이드 하단의 “Register spilling”: 레지스터가 모자라면 **임시값을 메모리(보통 스택)**에 잠깐 내보내는 일. 레지스터는 빠르지만 수가 제한적이라 컴파일러가 필요할 때 spill/fill을 한다.

즉시수(Immediate) 피연산자 — 상수는 자주 쓴다
-----

&ensp;프로그램엔 상수가 정말 많이 등장한다(예: x = x + 7;). 상수를 메모리에서 읽어 와 더하는 대신, 즉시수를 명령 안에 바로 넣는 명령이 있다.<br/>

&ensp;느린 버전(메모리 한 번, 연산 한 번)<br/>
```mips
lw   $t0, AddrOfConstant4($zero)   # $t0 ← 4
add  $s3, $s3, $t0                 # $s3 ← $s3 + 4
```

&ensp;빠른 버전(메모리 접근 없음)<br/>
```mips
addi $s3, $s3, 4                   # $s3 ← $s3 + 4
```

&ensp;왜 빠를까?<br/>
* 명령 수 ↓ (1개로 끝)
* 메모리 접근 X → 캐시 미스/대기시간 리스크 없음
* 파이프라인 끊김도 줄어듦

&ensp;Make the common case fast. 상수 연산은 흔하니, addi, ori, andi 같은 immediate 명령을 적극 활용한다. (참고: 순수 MIPS에선 addi가 부호 있는 즉시수 덧셈이고, 오버플로우 동작이 ISA에 따라 다를 수 있다. 교육용 단계에선 “상수 더하기”로 이해하면 충분.)<br/>

&ensp;🧷 정렬(Alignment)과 바이트 주소(Byte addressing) 다시 한 번<br/>
* Byte addressing: 주소 1칸 = 1바이트. 오프셋은 항상 바이트 단위.
* Alignment: 4바이트 정수는 4의 배수 주소에 두자.
    - 정렬이 깨지면 ISA에 따라 예외 발생 혹은 내부적으로 두 번 접근 → 성능 저하/버그 위험.

&ensp;✅ 미니 체크<br/>
&ensp;1. int A[100]; base(A)=$s3에서 A[i] 주소는? <br/>
&ensp;→ $s3 + 4*i (바이트 단위)<br/>
&ensp;2. lw $t0, 8($s3)가 A[8]을 읽지 못하는 이유?<br/>
&ensp;→ 오프셋은 바이트 기준. A[8]은 32바이트(8*4) 뒤.<br/>
&ensp;3. 리틀엔디언에서 sw $s2, 100($zero)를 하면 바이트가 어떤 순서로 저장?<br/>
&ensp;→ LSB가 낮은 주소(100)에, MSB가 높은 주소로 간다.<br/>

컴퓨터 속의 명령어 표현(MIPS 기준)
=====

R-type (Register 형식) — 레지스터끼리 연산
-----

&ensp;비트 배치는 다음과 같다.(총 32비트):<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-12.png" width="600"></p>

* op: 기본 동작(Opcode). R-type 연산은 대개 000000(10진 0)
* rs, rt: 두 입력 레지스터(소스)
* rd: 결과가 들어갈 레지스터(목적지)
* shamt: 쉬프트 양(shift amount). 쉬프트 연산에서만 사용, 나머지는 0
* funct: 같은 op 안에서 정확히 어떤 연산인지를 구분(예: add=32, sub=34).

&ensp;5비트 필드(rs/rt/rd) → 0~31까지 표기 가능 → MIPS가 32개 레지스터를 갖는 이유와 딱 맞물림<br/>

&ensp;예제: add $t0, $s1, $s2<br/>
* 레지스터 번호: $t0=8, $s1=17, $s2=18
* 필드 값(10진 → 2진)
    - op=0 → 000000
    - rs=17 → 10001
    - rt=18 → 10010
    - rd=8 → 01000
    - shamt=0 → 00000
    - funct=32(add) → 100000

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-13.png" width="600"></p>

&ensp;따라서 비트열은<br/>
&ensp;000000 10001 10010 01000 00000 100000 = 0x02324020<br/>
&ensp;(= 실제 기계어 한 줄)<br/>

I-type (Immediate/Load/Store/Branch 형식)
-----

&ensp;상수나 메모리 주소 오프셋처럼 즉시수(상수) 16비트가 필요한 형식.<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-14.png" width="600"></p>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-15.png" width="600"></p>

* rs: 보통 베이스/첫 번째 피연산자 (예: lw에서 베이스, addi에서 입력)
* rt: 레지스터 목적지 또는 소스
    - lw: rt가 목적지(메모리→레지스터)
    - sw: rt가 소스 (레지스터→메모리)
    - addi: rt가 목적지
* constant/address(16b): 상수 또는 오프셋(바이트 단위).
    - 대부분 부호 확장해서 씀(lw/sw/addi 등).
    - andi/ori 같은 논리 즉시수는 제로 확장.

&ensp;Design Principle 3: Good design demands good compromises.<br/>
&ensp;MIPS는 명령 길이는 동일(32b) 로 유지해 페치/디코드 단순화를 얻고 대신 필드 배치는 서로 다른 형식(R/I) 으로 나눠 표현력을 확보한 절충안<br/>

&ensp;예제 — 비어셈블: add $t0, $s1, $s2를 기계어로<br/>
&ensp;위 R-type 설명 그대로 조립하면 0x02324020.<br/>
&ensp;(필드별 값: op=0, rs=17, rt=18, rd=8, shamt=0, funct=32)<br/>

&ensp;예제 — A[300] = h + A[300];<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-16.png" width="600"></p>

&ensp;가정: int A[ ]의 베이스 주소가 $t1(=9)에 있고, h → $s2(=18)<br/>

&ensp;1. 로드: A[300] 읽기
* int = 4B → 바이트 오프셋 = 300 * 4 = 1200
* lw $t0, 1200($t1)
* I-type 필드: op=35(lw), rs=$t1=9, rt=$t0=8, imm=1200(0x04B0)
* 기계어: 0x8D28_04B0

&ensp;2. 덧셈: h + A[300]<br/>
* add $t0, $s2, $t0 (결과를 $t0에)
* R-type: op=0, rs=18, rt=8, rd=8, shamt=0, funct=32
* 기계어: 0x0248_4020

&ensp;3. 스토어: 결과를 A[300]에 쓰기<br/>
* sw $t0, 1200($t1)
* I-type: op=43(sw), rs=9, rt=8, imm=1200
* 기계어: 0xAD28_04B0

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-17.png" width="600"></p>

&ensp;체크 포인트<br/>
* 오프셋은 바이트 단위! A[i](int)는 4*i를 꼭 곱해줘야 함.
* lw는 rt=목적지, sw는 rt=소스라는 점이 헷갈리기 쉽다.
* 즉시수 16비트는 내부에서 부호 확장되어 주소 계산(rs + imm)에 쓰인다.

&ensp;자주 쓰는 코드표(외우면 편함)<br/>
* add: op=0, funct = 32(0b100000)
* sub : op=0, funct=34(0b100010)
* lw : op=35(0b100011)
* sw : op=43(0b101011)
* addi: op=8

&ensp;이런 형식이 빠른 이유<br/>
* 고정 길이(32b) → 인스트럭션 페치·분기 타겟 계산이 단순
* 필드 폭 고정(특히 5b 레지스터) → 디코더 배선이 규칙적
* R/I 나눔 → 레지스터 연산/즉시수·메모리 접근 모두 깔끔히 표현

&ensp;미니 퀴즈<br/>
1. sub $s0, $t1, $t2의 funct 값은? → 34
2. lw $t3, -16($sp)에서 rs, rt, imm는? → rs=$sp(29), rt=$t3(11), imm=-16
3. sw에서 rt는 목적지일까 소스일까? → 소스(저장할 레지스터)

MIPS Machine Language
-----

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-18.png" width="600"></p>

&ensp;MIPS의 모든 명령은 32비트 고정 길이. 쓰임에 따라 대표적으로 두 형식을 쓴다.<br/>
&ensp;<b>R-type(레지스터↔레지스터 연산)</b><br/>
&ensp;\| op(6) \| rs(5) \| rt(5) \| rd(5) \| shamt(5) \| funct(6) \|<br/>
* add/sub처럼 연산 결과가 레지스터에 저장되는 명령
* op=0인 경우가 많고, 실제 연산 종류는 funct가 정함(예: add=32, sub=34)
* shamt는 쉬프트 양(shift amount) — 쉬프트 명령에서만 사용

&ensp;<b>I-type(immediate/메모리/분기)</b><br/>
&ensp;\| op(6) \| rs(5) \| rt(5) \| imm(16) \|<br/>
* lw/sw/addi/andi/ori/beq 등 즉시수(16비트) 또는 주소 오프셋이 필요한 명령
* lw: rt가 목적지(메모리→레지스터) / sw: rt가 소스(레지스터→메모리)

&ensp;레지스터 필드는 5비트 → 0~31 → 32개의 레지스터와 딱 맞음<br/>

&ensp;작은 예시<br/>
* add $s1,$s2,$s3 → R-type: op=0, rs=$s2, rt=$s3, rd=$s1, shamt=0, funct=32
* addi $s1,$s1,100 → I-type: op=8, rs=$s1, rt=$s1, imm=100
* lw $s1,100($s2) → I-type: op=35, rs=$s2(베이스), rt=$s1(목적지), imm=100

The BIG Picture — 명령어도 숫자다
-----

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-19.png" width="600"></p>

1. 명령어는 숫자(비트열) 로 표현된다.
2. 프로그램은 데이터처럼 메모리에 저장되어, CPU가 한 줄씩 읽어(페치) 해석(디코드)하고 실행한다.

&ensp;→ 이것을 저장식 프로그램(stored-program) 개념이라고 부른다.<br/>
&ensp;비유: 요리책(메모리)에 레시피(기계어 숫자들)가 저장되어 있고, 요리사(CPU)가 한 줄씩 읽어서 조리(실행)하는 느낌!<br/>

Logical Operations-비트 단위 도구 상자
-----

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-20.png" width="600"></p>

&ensp;포인터<br/>
* andi/ori의 즉시수는 제로 확장(0으로 채움)
* 특정 비트 켜기/끄기/검사는 ori/andi로 마스크를 쓰는 게 정석

&ensp;작은 예<br/>
```mips
# x의 3번째 비트를 켜기 (x |= 1<<3)
ori  $s0, $s0, 0x0008

# x의 하위 8비트만 남기기 (x &= 0xFF)
andi $s0, $s0, 0x00FF
```

Shift Operations — 논리/산술/회전
-----

&ensp;32비트 값을 X = x31 x30 … x0라 하자.<br/>

&ensp;<b>1) Logical shift (논리 시프트)</b><br/>
* 왼쪽: sll — 오른쪽에 0이 들어옴 → 대략 ×2 효과
* 오른쪽: srl — 왼쪽에 0이 들어옴 → 대략 ÷2 효과(양수 기준)

```mips
sll $t0, $t1, 3   # $t0 = $t1 << 3  (≈ *8)
srl $t0, $t1, 1   # $t0 = $t1 >> 1  (상위에 0 채움)
```

&ensp;<b>2) Arithmetic shift (산술 시프트, 2의 보수 부호 유지)</b><br/>
* 오른쪽 산술 sra: 왼쪽 빈자리를 부호비트(x31) 로 채운다 → 부호 유지, 대략 /2 

&ensp;(음수는 나눗셈 반올림 방향 주의: 구현마다 0쪽/마이너스 무한대쪽)<br/>
&ensp;왼쪽 산술은 논리와 동일(0 채움)이므로 따로 구분하지 않음<br/>
```mips
sra $t0, $t1, 1   # 음수였으면 1로 채워 부호 유지
```

&ensp;<b>3) Circular shift(rotate, 회전)</b><br/>
* 비트가 밀려나가면 반대편으로 돌아온다.
* 표준 MIPS에는 별도 rotate 명령이 없고(확장엔 rotr가 있기도), 보통 조합으로 만든다:
```mips
# rotate right k 비트: (x >> k) | (x << (32-k))
srl $t2, $t1, k
sll $t3, $t1, (32-k)
or  $t0, $t2, $t3
```

&ensp;예제로 감 잡기<br/>
&ensp;1 부호 유지 vs. 0 채움<br/>
```mips
# $t1 = 0xFFFF_FF80 (-128)
srl $t0, $t1, 1   # 0x7FFF_FFC0 (양수로 바뀜, 논리 시프트)
sra $t0, $t1, 1   # 0xFFFF_FFC0 (부호 유지, 여전히 음수)
```

&ensp;2. 빠른 곱/나눗셈<br/>
```mips
# y = x * 16
sll $t0, $t1, 4

# 양수 x에서 y = x / 8
srl $t0, $t1, 3
```

&ensp;3. 비트 마스킹 & 추출<br/>
```mips
# x의 상위 16비트만 남기기
srl  $t0, $s0, 16
# x의 하위 5비트 추출 (0~31 범위)
andi $t1, $s0, 0x1F
```

&ensp;<b>1) MIPS Shift Instructions(all/srl/sra)</b><br/>

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-21.png" width="600"></p>

* sll rd, rt, shamt : rt를 왼쪽으로 shamt비트 밀고 빈 자리를 0으로 채움. (대략 ×2ⁿ)
* srl rd, rt, shamt : rt를 오른쪽으로 shamt비트 밀고 왼쪽에 0 채움. (대략 /2ⁿ, 양수 기준)
* sra rd, rt, shamt : rt를 오른쪽으로 shamt비트 밀고 왼쪽을 부호비트로 채움. (음수 유지)

&ensp;형식(모두 R-type, 32비트 고정)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-22.png" width="600"></p>

* 쉬프트 양은 shamt(5비트) 에 직접 들어감 → 0~31비트까지.
* 변하는 쉬프트량을 레지스터로 주고 싶으면 sllv/srlv/srav(variable) 사용

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-23.png" width="600"></p>

&ensp;예<br/>
```mips
sll  $t2, $s0, 4     # t2 = s0 << 4  (×16)
srl  $t2, $s0, 1     # t2 = s0 >> 1  (상위 0 채움)
sra  $t2, $s0, 1     # t2 = s0 >> 1  (부호 유지)
sllv $t2, $s0, $s1   # t2 = s0 << s1
```

&ensp;헷갈림 방지: /2 효과가 필요할 때 부호 있는 값이면 sra, 무부호면 srl<br/>

&ensp;<b>2) MIPS Rotate Instructions (rotr / rotrv)</b><br/>
&ensp;일부 MIPS(예: MIPS32 Release 2)엔 회전(rotate) 이 추가돼 있다.<br/>
* rotr rd, rt, shamt : 오른쪽 회전. 오른쪽으로 밀려나간 비트가 왼쪽 끝으로 들어옴

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-24.png" width="600"></p>

* rotrv rd, rt, rs : 쉬프트량을 레지스터(rs)로 주는 회전

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-25.png" width="600"></p>

&ensp;표준 기본 MIPS에는 회전이 없어서 보통 아래처럼 조합했다.<br/>
```mips
# rotate right by k: (x >> k) | (x << (32-k))
srl $t2, $t1, k
sll $t3, $t1, (32-k)
or  $t0, $t2, $t3
```

&ensp;<b>3) MIPS Logical Instructions (비트 논리)</b><br/>
&ensp;레지스터-레지스터
```mips
and $t0, $t1, $t2    # 비트 AND
or  $t0, $t1, $t2    # 비트 OR
xor $t0, $t1, $t2    # 비트 XOR
nor $t0, $t1, $t2    # 비트 NOR (NOT은 nor $rd, $rs, $zero)
```

&ensp;즉시수 버전(16비트)<br/>
```mips
andi $s1, $s1, 100   # **제로 확장**(unsigned 마스크용)
ori  $s1, $s1, 100
xori $s1, $s1, 100
lui  $s1, 100        # 상위 16비트를 100으로 로드(하위 16비트는 0)
```

* 32비트 상수를 만들 땐 lui + ori 조합이 정석:

```mips
lui $t0, 0x1234       # $t0 = 0x1234_0000
ori $t0, $t0, 0x5678  # $t0 = 0x1234_5678
```

&ensp;주의: andi/ori/xori는 즉시수가 zero-extend. 반면 addi는 보통 sign-extend<br/>

Instructions for Making Decisions
======

Conditional branches(조건 분기)
----

&ensp;기본 패턴<br/>
* beq r1, r2, L : r1==r2면 레이블 L로 점프
* bne r1, r2, L : r1!=r2면 레이블 L로 점프
* j L : 무조건 점프

&ensp;if-else 번역 예시<br/>
&ensp;C: if (i==j) f=g+h; else f=g-h;<br/>
```mips
bne  $s3, $s4, Else   # i != j 이면 Else
add  $s0, $s1, $s2    # f = g + h
j    Exit
Else:
sub  $s0, $s1, $s2    # f = g - h
Exit:
```

* beq/bne의 분기 대상은 현재 위치에서 상대(PC-relative) 로 계산됨(상세 주소 계산은 하드웨어가 처리)

Loop(루프)
----

&ensp;C: while (save[i] == k) i += 1;<br/>
&ensp;가정: base(save) → $s6, i → $s3, k → $s5<br/>
```mips
Loop:
sll  $t1, $s3, 2     # t1 = i * 4 (int는 4B)
add  $t1, $t1, $s6   # t1 = &save[i]
lw   $t0, 0($t1)     # t0 = save[i]
bne  $t0, $s5, Exit  # save[i] != k 이면 루프 종료
addi $s3, $s3, 1     # i++
j    Loop
Exit:
```

* 인덱스 → 바이트 오프셋으로 바꾸려고 sll by 2(×4) 사용.
* lw는 base+offset 주소 모드, 오프셋은 바이트 단위

&ensp;형식/인코딩 감각 잡기 (쉬프트 예)<br/>
&ensp;sll $t2, $s0, 4의 R-type 필드<br/>
```ini
op=0, rs=0, rt=$s0(16), rd=$t2(10), shamt=4, funct=0
```

* 쉬프트 계열은 rs=0, 쉬프트 양은 shamt로, 실제 동작은 funct로 구분

slt(set on less than) Instruction
------

* slt rd, rs, rt (Set on Less Than): rs < rt이면 rd=1, 아니면 rd=0
* slti rt, rs, imm: rs < imm이면 rt=1, 아니면 rt=0
* 둘 다 “부호 있는(signed) 비교”.
* sltu/sltiu는 부호 없는(unsigned) 비교.

&ensp;즉, 음수/양수 해석이 다르다는 점이 포인트!<br/>

&ensp;즉시수 확장<br/>
* slti/sltiu의 즉시수(16비트)는 sign-extend(부호 확장) 된다.
    - sltiu $t0,$t1,32767 같은 양수 작은 상수는 OK.
    - 32768 이상을 비교하려면 lui/ori 등으로 32비트 상수를 만들어 sltu로 비교하자

&ensp;왜 blt(branch-on-less-than)가 없을까?<br/>
* MIPS 철학: 간단하고 규칙적(KISS)
* 하드웨어에 전용 비교+분기를 넣으면 디코딩/크리티컬패스가 길어지거나 사이클이 늘어남
* 대신 slt + beq/bne 조합으로 충분히 표현 가능

&ensp;어떻게(패턴)<br/>
```mips
# if (a < b) goto L;
slt  $at, $a, $b      # $at=1 if a<b
bne  $at, $zero, L    # 1이면 분기
# or: beq $at, $zero, NotL

# if (a >= b) goto L;  == !(a<b)
slt  $at, $a, $b
beq  $at, $zero, L

# 부호 없는 비교: a < b (unsigned)
sltu $at, $a, $b
bne  $at, $zero, L
```

다른 점프 명령 — jr, jal
------

&ensp;jr (jump register)<br/>
* 레지스터에 든 주소로 점프
* 간접 점프/함수 리턴에 사용

```mips
jr  $t0     # PC ← $t0
```

&ensp;jal (jump and link)<br/>
* 함수 호출(Call) 전용.
* 실행 흐름을 target으로 점프하면서, 돌아올 주소(PC+4) 를 $ra(=31)에 저장
```mips
jal  Proc         # $ra ← PC+4, PC ← Proc
# ...
jr   $ra          # 리턴 (Return from procedure)
```

&ensp;호출/리턴과 스택 팁<br/>
* 호출된 함수가 또 jal을 부르면 $ra가 덮어쓰기 되므로 스택에 저장해야 한다.

```mips
# prologue (callee)
addi $sp,$sp,-8
sw   $ra,4($sp)
sw   $s0,0($sp)   # 쓴 saved 레지스터도 저장

# ... 함수 본문 ...

# epilogue
lw   $s0,0($sp)
lw   $ra,4($sp)
addi $sp,$sp,8
jr   $ra
```

MIPS Register Convention — 누가 저장을 책임질까?
------

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-26.png" width="600"></p>

&ensp;관례를 지키면 서로 다른 컴파일러/라이브러리/어셈블리 코드가 안전하게 호환된다.<br/>

&ensp;비교/분기 예제 감 잡기<br/>
&ensp;if–else (복습)<br/>
```mips
# if (i==j) f=g+h; else f=g-h;
bne  $s3,$s4, Else
add  $s0,$s1,$s2
j    Exit
Else:
sub  $s0,$s1,$s2
Exit:
```

&ensp;while 루프 (인덱스+배열)<br/>
```mips
# while (save[i] == k) i++;
# base(save)=$s6, i=$s3, k=$s5
Loop:
sll  $t1,$s3,2         # i*4
add  $t1,$t1,$s6       # &save[i]
lw   $t0,0($t1)        # save[i]
bne  $t0,$s5,Exit
addi $s3,$s3,1         # i++
j    Loop
Exit:
```

&ensp;비교 연산자 전부 만들기 (signed)<br/>
```mips
# if (a <= b)  <=> !(b < a)
slt  $at, $b, $a
beq  $at, $zero, L

# if (a > b)   <=>  (b < a)
slt  $at, $b, $a
bne  $at, $zero, L

# if (a >= b)  <=> !(a < b)
slt  $at, $a, $b
beq  $at, $zero, L
```

&ensp;MIPS Registers<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-27.png" width="600"></p>

&ensp;한눈에 요약<br/>
* 비교: slt/slti(signed), sltu/sltiu(unsigned).
    - blt 없음 → slt + beq/bne 조합이 정석.
    - slti(u) 즉시수는 부호 확장.
* 점프: jr(레지스터로 점프), jal(리턴주소 $ra에 남기고 점프).
    - 리턴: jr $ra
    - 중첩 호출 시 $ra를 스택에 보관.
* 레지스터 관례: $t=caller-saved, $s=callee-saved, $a=인자, $v=반환.
* 형식: R/I 타입(32비트 고정).
* 데이터 이동: lw/sw/lh/sh/lb/sb — 오프셋은 바이트 단위.

MIPS Addressing for 32-Bit Immediates and Addresses
====

Addressing Modes
-----

&ensp;정의: 기계어 명령어가 피연산자(operand)의 위치(장소)를 결정하는 방법 즉 명령어 안에서 데이터를 어디서 가져올까? 를 정하는 규칙<br/>
&ensp;예: 레지스터에 있나? 메모리에 있나? 즉시값(상수)인가?<br/>
&ensp;CPU는 같은 add 명령이라도, 오퍼랜드의 주소 방식이 다르면 다른 계산 방법을 써야 한다.<br/>

&ensp;Addressing Modes의 종류 (MIPS 기준: 6개)<br/>
* MIPS는 단순성을 위해 주소 지정 모드가 적다.
* 비교
    - MIPS: 6개
    - ARMv7: 9개
    - IA-32(x86): 12개

&ensp;Program Counter (PC)<br/>
* PC는 현재 실행 중인 명령어의 주소를 저장하는 특별한 레지스터.
* 분기(branch), 점프(jump) 시 PC 값이 바뀌면서 실행 흐름이 이동.

32-bit Immediate Operands
----

* MIPS의 즉시값(immediate)은 16비트 제한이 있다.
* 그래서 32비트 상수를 만들려면 lui + ori 조합을 쓴다.

&ensp;lui가 하는 일 (Load Upper Immediate)<br/>
```bash
lui rd, imm16
```

* rd의 상위 16비트를 imm16으로 채우고, 하위 16비트는 0으로 만듭니다.
* 수식으로는: rd ← imm16 << 16

&ensp;예) lui $t0, 0x00FF → $t0 = 0x00FF0000<br/>

&ensp;ori로 하위 16비트 채우기<br/>
```bash
ori rd, rd, imm16
```

&ensp;imm16을 0-확장(zero-extend) 해서 하위 16비트에 OR로 끼워 넣는다. 상위 16비트는 그대로 보존된다.<br/>
&ensp;예) ori $t0, $t0, 0x0900 → $t0 = 0x00FF0000 | 0x0900 = 0x00FF0900<br/>

&ensp;왜 ori?<br/>
&ensp;addi는 즉시수를 부호 확장(sign-extend) 해서 더하므로 하위 16비트가 0x8000 이상일 때 덧셈 캐리가 생기거나 값이 바뀔 수 있어요. ori는 단순히 비트를 채워 넣으니 안전하다.<br/>

&ensp;예시:<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-28.png" width="600"></p>

&ensp;만들고 싶은 값:<br/>
```yaml
$t0 <= 0000 0000 1111 1111 0000 1001 0000 0000
         ↑↑↑↑ ↑↑↑↑ ↑↑↑↑ ↑↑↑↑  ↑↑↑↑ ↑↑↑↑ ↑↑↑↑ ↑↑↑↑
         upper 16 bits = 0000 0000 1111 1111  (0x00FF)
         lower 16 bits = 0000 1001 0000 0000  (0x0900)
```

&ensp;두 단계로 쪼갠다.:<br/>
```yaml
lui $t0, 0b0000000011111111      # $t0 = 0x00FF0000
ori $t0, $t0, 0b0000100100000000 # $t0 = 0x00FF0900 (완성)
```
&ensp;👉 결과적으로 $t0에는 32비트 상수가 완성됨.<br/>

&ensp;언제 무엇을 쓰나?<br/>
* 상수가 16비트 부호 범위(−32768..32767)에 들어간다. → addiu rd, $zero, imm16 (또는 ori/andi 등 목적에 맞는 즉시형)
* 상수의 상위 16비트가 0이고 하위만 필요 → ori rd, $zero, lower16
* 일반적인 32비트 상수 → lui rd, upper16 ➜ ori rd, rd, lower16
* 라벨/주소 → 보통 어셈블러가 lui rd, %hi(label) + ori rd, rd, %lo(label)로 만들어준다.

&ensp;예) 0xDEAD_BEEF 를 로드:<br/>
```mips
lui $t0, 0xDEAD
ori $t0, $t0, 0xBEEF
```

&ensp;요약<br/>
* lui = 상위 16비트 채우고 하위는 0
* ori = 하위 16비트 채우기(0-확장)
* 32비트 상수 = (upper << 16) | lower
* addi는 부호 확장이라 32비트 상수 조합에는 보통 쓰지 않는다.

Branch & Jump Addressing (J-type)
-----

&ensp;형식: opcode(6bit) + address(26bit)
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-29.png" width="600"></p>

* 즉 점프할 주소를 명령어 안에 포함

&ensp;Direct addressing<br/>
```mips
j 10000    # branch address = 10000
```

&ensp;Word addressing<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-30.png" width="600"></p>

* MIPS 명령어는 항상 워드(4바이트)단위 정렬
* 따라서 실제 주소 = (주어진 주소 x 4) → 즉 명령어 시작 주소는 항상 4의 배수
* 예: j 10000 → 실제 branch address = 40000

&ensp;LS 2 bits = 00 의미<br/>
* 주소를 2진수로 보면, **맨 끝 2비트(LSB 2 bits)**는 항상 00이다.
* 왜냐하면:
    - 4바이트 = 2² 바이트
    - 4의 배수 주소는 항상 끝 2비트가 00이 된다.

&ensp;이런 방식을 사용하는 이유<br/>
* MIPS의 j/jal(점프, 점프-앤-링크) J-type 명령에는 점프할 주소 전체(32비트) 를 다 넣기엔 공간이 부족하다.
* 그래서 주소의 중간 26비트만 명령어 안에 넣고, 나머지 6비트는 따로 채워 완성한다.

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-31.png" width="600"></p>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-32.png" width="600"></p>

&ensp;점프 주소를 만드는 공식<br/>
&ensp;점프 대상 32비트 주소는 이렇게 조립된다.:<br/>

```makefile
JumpAddr =  (PC[31:28])  ||  (instr[25:0])  ||  00
            ↑ 상위 4비트      ↑ 명령어에 들어있는 26비트  ↑ 정렬 때문에 항상 00
```

* PC[31:28]: 현재(정확히는 PC+4 의) 상위 4비트를 그대로 가져와.
* instr[25:0]: J-type 명령어에 들어있는 26비트 인덱스.
* 마지막 00: MIPS 명령은 4바이트 정렬 → 주소의 하위 2비트는 항상 0이므로 굳이 저장하지 않고 00을 덧붙여.

&ensp;한 줄 요약: “PC의 윗동네 번호 + 명령어의 집 번지 + 00” 를 붙여서 완전한 주소를 만든다.<br/>

&ensp;왜 256MB(=2²⁸B) 범위 제한일까?<br/>
* 상위 4비트를 PC에서 가져온다는 건, 현재 PC가 속한 256MB 블록(상위 4비트 동일) 안에서만 점프가 가능하다는 뜻이다.
* 이 블록을 벗어난 곳으로 가려면 j/jal만으로는 불가 → 레지스터에 32비트 주소를 만들어 jr/jalr로 점프해야 한다.

&ensp;숫자로 보는 빠른 예시 (디코딩: 명령 → 주소)<br/>
* 현재 PC = 0x0040_2000 (상위 4비트는 0x0)
* 기계어가 j로, instr[25:0] = 0x0010_D580 라고 한다.

&ensp;계산:<br/>
```bash
target = (PC & 0xF000_0000) | (instr << 2)
       = 0x0000_0000        | (0x0010_D580 << 2)
       = 0x0043_5600
```

&ensp;→ 최종 점프 주소는 0x0043_5600. (끝 00은 정렬 때문에 자동으로 붙음)<br/>

&ensp;반대로: 절대 주소 → J-type 인코딩(주소를 26비트로)<br/>
&ensp;목표 주소(target) = 0x0043_5600, 현재 PC 상위 4비트 = 0x0 (같은 256MB 블록)<br/>
```makefile
index = target >> 2  = 0x0010_D580
op(j) = 0b000010 (= 2)
machine = (op << 26) | index
```

&ensp;이렇게 26비트 인덱스만 넣으면, 실행 시 하드웨어가 상위 4비트는 PC에서, 하위 2비트는 00으로 채워 완성해 준다.<br/>

&ensp;반대로: 절대 주소 → J-type 인코딩(주소를 26비트로)<br/>
&ensp;목표 주소(target) = 0x0043_5600, 현재 PC 상위 4비트 = 0x0 (같은 256MB 블록)<br/>
```makefile
index = target >> 2  = 0x0010_D580
op(j) = 0b000010 (= 2)
machine = (op << 26) | index
```

&ensp;이렇게 26비트 인덱스만 넣으면, 실행 시 하드웨어가 상위 4비트는 PC에서, 하위 2비트는 00으로 채워 완성해 준다.<br/>

&ensp;자주 나오는 질문들<br/>
&ensp;Q1. 왜 하위 2비트는 항상 00이야?<br/>
* MIPS 명령은 4바이트(= 2²) 단위로만 시작 가능(정렬).
* 따라서 주소의 하위 2비트는 언제나 0 → 굳이 저장할 필요가 없다.

&ensp;Q2. 왜 PC의 “상위 4비트”를 쓰지, 전부를 안 쓸까?<br/>
* 명령어 한 줄에 26비트밖에 못 싣기 때문이다.
* 대안: 상위 4비트는 “현재 PC와 동일”하다고 가정해 붙이면, 근처 256MB 안은 간단히 점프 가능.

&ensp;Q3. 256MB 블록 밖으로는 어떻게 가?<br/>
* lui/ori로 풀 32비트 주소를 레지스터에 만들고 jr/jalr 사용:

```bash
lui  $t0, %hi(Target)   # 상위 16비트
ori  $t0, $t0, %lo(Target)   # 하위 16비트
jr   $t0                 # 또는 jalr $ra, $t0
```

&ensp;Q4. 분기(beq/bne)와 뭐가 달라?<br/>
* beq/bne는 PC+4 기준 상대(PC-relative) 로 16비트 오프셋을 써서 target = (PC+4) + (sign_extend(imm16) << 2) 로 계산한다.
* j/jal은 pseudo-direct(상위 4비트 PC, 중간 26비트 인덱스, 하위 00) 방식.

&ensp;기억 공식 (암기 카드)<br/>
* J-type 디코드: target = (PC & 0xF0000000) | (index << 2)
* J-type 인코드: index = (target >> 2) & 0x03FF_FFFF
* 범위: 같은 256MB 세그먼트만 가능 → 멀면 jr/jalr.
* 정렬: 하위 2비트는 항상 00.

PC-relative Addressing Mode
----

&ensp;핵심 공식(beq/bne 등 I-type 분기)<br/>
&ensp;분기 대상 주소(= 새로운 pc)는 
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-33.png" width="600"></p>

* PC+4: 분기 명령 “다음” 명령의 주소를 기준으로 계산(파이프라인/프리패치 때문).
* imm16: 분기 명령 안의 16비트 즉시수. 부호 확장(sign extension) 을 한다.
* << 2: 분기는 워드(4바이트) 단위로 뛰므로 바이트 주소로 바꾸려면 ×4.

&ensp;한 줄 요약: “다음 명령 주소” + “(분기 오프셋 × 4)”<br/>

&ensp;갈 수 있는 거리(범위)<br/>
&ensp;imm16은 부호 있는 16비트이므로<br/>
* 최소: −32768, 최대: +32767 (워드 단위)

&ensp;이를 바이트로 환산(+4 기준 포함):<br/>
* 최솟값: (PC+4) + (−32768 << 2) = PC − 131068
* 최댓값: (PC+4) + ( +32767 << 2) = PC + 131072

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-34.png" width="600"></p>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-35.png" width="600"></p>

&ensp;예제<br/>
```bash
Loop:                             # 80000
sll  $t1, $s3, 2                  # 80000
add  $t1, $t1, $s6                # 80004
lw   $t0, 0($t1)                  # 80008
bne  $t0, $s5, Exit               # 80012   ← 분기 명령
addi $s3, $s3, 1                  # 80016
j    Loop                         # 80020
Exit:                             # 80024   ← 레이블은 j 바로 뒤
```

&ensp;bne에서 Exit으로 가려면?<br/>
* 현재 분기 명령의 PC = 80012
* PC + 4 = 80016
* Exit 주소 = 80024

&ensp;오프셋 계산:<br/>
```bash
diff      = target - (PC+4) = 80024 - 80016 = 8
imm16     = diff >> 2       = 8 >> 2 = 2
```

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-36.png" width="600"></p>

&ensp;표에 즉시수 2다.<br/>
&ensp;실행 시 하드웨어가 BranchTarget = 80016 + (2<<2) = 80024로 이동<br/>

&ensp;팁: “분기 오프셋은 ‘명령어 개수’로 센다”라고 생각하면 쉽다. 여기선 ‘다음 명령에서 두 칸 앞으로’ → 2.<br/>

&ensp;인코딩/디코딩 암기법<br/>
&ensp;인코딩(라벨 → imm16)<br/>
```ini
imm16 = (target - (PC + 4)) >> 2
```

&ensp;디코딩(imm16 → 라벨 주소)<br/>
```ini
target = (PC + 4) + (sign_extend(imm16) << 2)
```

&ensp;너무 먼 곳으로 분기할 땐? (Branching far away)<br/>
&ensp;imm16 범위를 벗어나는 먼 라벨 L1로 가고 싶다:<br/>

&ensp;원래 의도<br/>
```mips
beq $s0, $s1, L1      # ❌ L1이 너무 멀다(imm16 범위 초과)
```

&ensp;해결(조건 뒤집어서 멀리 점프를 따로 수행)<br/>
```mips
bne $s0, $s1, L2      # 조건 불일치면 L2로 (가까운 곳)
j   L1                # 무조건 점프로 L1 (J-type은 넓은 범위)
L2:
```

* 가까운 곳(L2)까지는 짧은 분기로 이동
* 실제 먼 곳(L1)은 j(J-type)로 점프(동일 256MB 블록 안이라면 OK)
* 256MB 블록까지도 벗어나면 lui/ori로 32비트 주소를 레지스터에 만들고 jr/jalr 사용

MIPS Addressing Modes(5가지)
----

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-37.png" width="600"></p>

&ensp;<b>Immediate addressing (즉시 주소지정)</b><br/>
* 무엇: 피연산자 하나가 명령어 안의 16비트 상수.
* 형식: I-type | op | rs | rt | imm16 |

&ensp;예:<br/>
```mips
addi $t0, $t1, 5     # $t0 = $t1 + 5   (imm16은 보통 부호확장)
andi $t0, $t1, 0xFF  # mask (imm16은 제로확장)
```

* 주의: 32비트 상수는 lui + ori 조합으로 만든다.

&ensp;<b>Register addressing (레지스터 주소지정)</b><br/>
* 무엇: 피연산자들이 전부 레지스터.
* 형식: R-type | op(0) | rs | rt | rd | shamt | funct |

&ensp;예<br/>
```mips
add $s1, $s2, $s3     # $s1 = $s2 + $s3
sll $t0, $t1, 3       # shamt=3 (왼쪽 시프트)
jr  $ra               # 레지스터에 든 주소로 점프
```

&ensp;<b>Base addressing (베이스+오프셋)</b><br/>
* 무엇: 유효주소 = 레지스터(rs) + 오프셋(imm16) 오프셋은 바이트 단위(부호확장).
* 형식: I-type(load/store)

&ensp;예:<br/>
```mips
lw  $t0, 12($s1)   # $t0 = Mem[$s1 + 12]
sw  $t0, -8($sp)   # Mem[$sp - 8] = $t0
```

&ensp;팁: 배열 인덱스 i의 int 접근은 i<<1이 아니라 i<<2(×4)<br/>

&ensp;<b>PC-relative addressing (분기)</b><br/>
* 무엇: 분기 대상 = (PC+4) + (sign_extend(imm16) << 2) (오프셋은 “명령어 개수” 단위)
* 형식: I-type(branch)

&ensp;예<br/>
```mips
beq $s0, $s1, L     # 같으면 L로
bne $t0, $zero, L   # 0이 아니면 L로
```

&ensp;범위: 대략 ±128KB 주변. 너무 멀면 아래처럼:<br/>
```mips
bne $s0,$s1, Near
j   Far
```

&ensp;<b>Pseudodirect addressing (점프 J-type)</b><br/>
* 무엇: 명령어엔 **26비트 index**만 있고, 실제 32비트 주소는 JumpAddr = (PC[31:28]) || (index<<2)
* 형식: J-type `| op | index(26) |`

&ensp;범위: 현재 PC와 상위 4비트가 같은 256MB 블록 내<br/>
```mips
j   Target
jal Func          # $ra ← PC+4, PC ← Func
```

&ensp;바깥으로 가려면 주소를 레지스터로 만든 뒤 jr/jalr:<br/>
```mips
lui $t0, %hi(Target)
ori $t0, $t0, %lo(Target)
jr  $t0
```

&ensp;summary<br/>
* add $s1,$s2,$s3 → Register addressing (R-type)
* lw $s1,100($s2) → Base addressing (I-type)
* bne/beq → PC-relative
* j Label → Pseudodirect

&ensp;형식표<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-38.png" width="600"></p>

* R: op=0, 세부 동작은 funct로 구분
* I: op가 동작을 바로 결정(imm16 포함)
* J: op=2(j) / 3(jal), 26비트 index

MIPS Instruction Encoding
----

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-39.png" width="600"></p>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-40.png" width="600"></p>

Pseudoinstructions(의사 명령)
----

&ensp;CPU 하드웨어에 실제로 존재하지 않는 명령이지만 어셈블러가 편의상 만들어 주는 문법 슈거이다. 어셈블러가 1개 또는 여러 개의 실제 MIPS 명령으로 자동 변환해 준다. 이때 보조로 쓰는 임시 레지스터가 $at(register 1)이고 의사 명령을 쓰면 어셈블러가 $at를 마음대로 써도 된다고 가정한다.(직접 $at를 쓰면 충돌 가능)<br/>

&ensp;대표 예시와 실제 확장<br/>
```mips
# 1) move d,s   : 레지스터 복사
move  $t0, $t1        =>  addu $t0, $t1, $zero   # 또는 or $t0, $t1, $zero

# 2) clear d     : d를 0으로
clear $t0            =>  addu $t0, $zero, $zero  # 또는 or $t0, $zero, $zero

# 3) not d,s     : 비트 반전 (~s)
not   $t0, $t1       =>  nor  $t0, $t1, $zero

# 4) neg d,s     : 정수 부호반전 (-s)
neg   $t0, $t1       =>  subu $t0, $zero, $t1    # 또는 sub (signed)

# 5) li d, imm32 : 32비트 상수 로드
li    $t0, 0x12345678   =>
    lui  $t0, 0x1234
    ori  $t0, $t0, 0x5678
# (imm가 16비트 범위면 addi/ori 하나로 끝날 수도 있어)

# 6) la d, label : 라벨 주소 로드(재배치 적용)
la    $t0, label      =>
    lui  $t0, %hi(label)
    ori  $t0, $t0, %lo(label)

# 7) b label     : 무조건 분기(짧게)
b     L               =>  beq  $zero, $zero, L    # 보통 j L로도 표현 가능

# 8) 비교 기반 분기들 (blt, bgt, ble, bge 등)
blt   $t0, $t1, L     =>
    slt  $at, $t0, $t1
    bne  $at, $zero, L

bge   $t0, $t1, L     =>
    slt  $at, $t0, $t1
    beq  $at, $zero, L
# (unsigned 비교면 sltu 사용)
```

&ensp;$at는 어셈블러 전용. 의사 명령을 쓰면서 $at에 내 값을 보존하고 싶다면, 의사 명령을 피하거나 .set noat로 의사 명령 생성을 끄고 순수 실명령을 써야 한다.<br/>

Decoding Machine Language(기계어 → 어셈블리)
----

&ensp;32비트 이진으로 펼치기<br/>
```yaml
00 AF 80 20 (hex)
= 0000 0000 1010 1111 1000 0000 0010 0000 (bin)
  ^^^^^^ op(31..26)
```

&ensp;MIPS 필드 구간(항상 동일)<br/>
* op(31..26) 6비트
* rs(25..21) 5비트
* rt(20..16) 5비트
* rd(15..11) 5비트
* shamt(10..6) 5비트
* funct(5..0) 6비트

&ensp;슬라이드 분해 결과:<br/>
```ini
op    = 000000  → R-type
rs    = 00101   → 5  → $a1
rt    = 01111   → 15 → $t7
rd    = 10000   → 16 → $s0
shamt = 00000
funct = 100000  → 32 → add
```

&ensp;결론(어셈블리)<br/>
```ini
add $s0, $a1, $t7
```

<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-41.png" width="600"></p>

* op=0이면 R-format이고 무슨 연산이지는 funct가 결정
* op=2/3이면 j/jal(J-format)
* 나머지 많은 값들은 I-format(분기/로드/스토어/즉시논리/산술)

&ensp;어디서든 써먹는 디코드 레시피<br/>
1. 32비트를 이진으로(혹은 op만 마스크로) 본다.
2. p 확인 → R/I/J 형식 결정.
3. R이면 funct로 명령 확정(+필드 rd/rs/rt/shamt). I면 rs/rt/imm16을 해석(부호/제로 확장 주의). J면 26비트 index로 점프 주소 계산.
4. 레지스터 번호 ↔ 이름 표($0…$31 ↔ $zero,$at,$v0…$ra)로 치환.

Concluding Remarks — MIPS가 주는 세 가지 교훈
-----

1. Simplicity favors regularity (단순할수록 규칙적이다)
* 고정 길이 명령어: MIPS는 모두 32비트
* 적은 명령어 형식: 딱 R / I / J 3종
* opcode는 항상 상위 6비트(31:26). → 디코더/파이프라인이 단순해지고, 타이밍을 맞추기 쉽다.
2. Smaller is faster (작을수록 빠르다)
* 명령어 집합 규모 제한: 기능을 최소 필수로
* 레지스터 32개(5비트로 인코딩): 너무 많으면 포트/배선이 커져 레지스터 파일이 느려짐
* 주소 지정 모드 소수(5~6개): 하드웨어/컴파일러가 단순 → 단, 너무 작으면 spill/fill 증가 → 메모리 트래픽↑. 즉 속도·면적·소비전력의 균형이 중요
3. Good design demands good compromises (좋은 설계는 절충이다)
* 형식은 3개로 유지(하드웨어 간단) + **의사 명령(pseudo)**로 프로그래머 친화성 확보
* 32비트 즉시값은 lui+ori, 비교 분기는 slt + beq/bne로 표현

&ensp;MIPS Instructions<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-42.png" width="600"></p>

MIPS 명령어 형식
=====

&ensp;1. R-type (Register type)<br/>
&ensp;레지스터끼리 연산할 때 사용(예: add, sub, and, or, slt, sll 등)
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-43.png" width="600"></p>

&ensp;R-type 명령어의 레지스터 구조 (32bit)<br/>
```markdown
 ┌───────┬───────┬───────┬───────┬───────┬───────┐
 │  op   │  rs   │  rt   │  rd   │ shamt │ funct │
 └───────┴───────┴───────┴───────┴───────┴───────┘
   6bit    5bit    5bit    5bit    5bit     6bit
```

&ensp;각 필드 설명<br/>
* op(opcode, 6bit) → 연산 종류를 결정하는 코드, R-type은 보통 000000 (=0)
* rs (5bit) → 첫 번째 소스 레지스터 번호
* rt (5bit) → 두 번째 소스 레지스터 번호
* rd (5bit) → 결과가 저장될 목적지 레지스터 번호
* shamt (5bit)→ shift 연산 시 이동할 비트 수 (shift 아닌 연산은 항상 0)
* funct (6bit) → 같은 opcode 안에서 어떤 연산인지 더 구체적으로 지정 예: add(100000₂ = 32), sub(100010₂ = 34), and(100100₂ = 36)


* 특징: op=0이고 funct값으로 연산 종류가 정해짐
    - add: funct=32 (0x20)
    - sub: funct=34 (0x22)
    - and: funct=36 (0x24)
    - or: funct=37 (0x25)
    - slt: funct=42 (0x2A)
    - sll: funct=0 (0x00)
    - srl: funct=2 (0x02)

&ensp;R-type(레지스터 연산 명령어)<br/>
1. add rd, rs, rt
* 동작: rd ← rs + rt
* 예: add $t0, $t1, $t2 → $t0 = $t1 + $t2
2. sub rd, rs, rt
* 동작: rd ← rs - rt
* 예: sub $t0, $t1, $t2 → $t0 = $t1 - $t2
3. and rd, rs, rt
* 동작: rd ← rs AND rt (비트 단위 AND)
* 예: and $t0, $t1, $t2
4. or rd, rs, rt
* 동작: rd ← rs OR rt (비트 단위 OR)
5. slt rd, rs, rt
* 동작: rd ← (rs < rt) ? 1 : 0
* "set on less than" → 비교 결과를 1 또는 0으로 저장
6. sll rd, rt, shamt
* 동작: rd ← rt << shamt
* shamt(시프트 양)만큼 왼쪽으로 이동
* 예: sll $t0, $t1, 2 → $t0 = $t1 × 4


&ensp;2. I-type (Immediate type)<br/>
&ensp;상수(즉시값, immediate)또는 메모리 주소를 포함하는 연산(예: addi, lw, sw, beq, bne 등)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-44.png" width="600"></p>

* 특징: op 값이 명령어를 구분함.
    - addi: op=8 (0x08)
    - lw: op=35 (0x23)
    - sw: op=43 (0x2B)
    - beq: op=4 (0x04)
    - bne: op=5 (0x05)
    - lui: op=5(0x0F)
    - ori: op=13(0x0D)

```markdown
 ┌───────┬───────┬───────┬───────────────────────┐
 │  op   │  rs   │  rt   │       immediate       │
 └───────┴───────┴───────┴───────────────────────┘
   6bit    5bit    5bit             16bit
```

* op(opcode, 6bit) → 명령어 종류를 구분하는 코드 (예: addi=001000, lw=100011, sw=101011, beq=000100)
* rs (5bit) → 소스(Source) 레지스터 번호
* rt (5bit) → 결과가 저장될 레지스터 번호 (load는 목적지, store는 저장할 값)
* immediate(16 bit) → 상수 값, 메모리 주소 offset, 분기(branch) 거리 등으로 쓰임 부호 확장(Sign-extend)되어 32비트로 변환 후 연산에 사용됨

&ensp;I-type(즉시값/메모리/분기 명령어)<br/>
1. addi rt, rs, imm
* 동작: rt ← rs + imm
* rs와 즉시값(16비트)을 더함
* 예: addi $t0, $t1, 5 → $t0 = $t1 + 5
2. lw rt, offset(rs)
* 동작: rt ← Memory[rs + offset]
* 메모리에서 4바이트(워드)를 읽어 레지스터에 넣음
* 예: lw $t0, 4($t1) → $t0 = M[$t1+4]
3. sw rt, offset(rs)
* 동작: Memory[rs + offset] ← rt
* 레지스터 값을 메모리에 저장
* 예: sw $t0, 4($t1) → M[$t1+4] = $t0
4. beq rs, rt, label
* 동작: if (rs == rt) then PC ← label
* 두 레지스터가 같으면 지정한 주소로 분기 (branch)
5. bne rs, rt, label
* 동작: if (rs != rt) then PC ← label
* 두 레지스터가 다르면 분기
6. lui rt, immediate
* 동작: 즉시값을 레지스터의 상위 16비트에 채우고 하위 비트는 0으로 채운다.
7. ori rt, rs, immediate
* rt ← rs OR (zero-extended immediate)
* 레지스터 rs의 값과 즉시값(16비트)을 비트 OR 해서 rt에 저장

```bash
lui $t0, 0x1234       # $t0 = 0x12340000
ori $t0, $t0, 0x5678  # $t0 = 0x12345678
```


&ensp;J-type 명령어 구조 (32bit)<br/>
```markdown
 ┌───────┬───────────────────────────────┐
 │  op   │            address            │
 └───────┴───────────────────────────────┘
   6bit                  26bit
```

&ensp;각 필드 설명<br/>
* op (opcode, 6bit)n → 명령어 종류를 결정
    - j : 000010 (2)
    - jal: 000011 (3)
* address (26bit) → 점프할 대상 주소의 하위 26비트
    - 실제로는 address << 2 (마지막 2비트는 항상 00, 워드 정렬)
    - 상위 4비트는 현재 PC(프로그램 카운터)에서 가져옴
    - 따라서 점프 가능한 범위 = 현재 PC가 속한 256MB 블록 내부

&ensp;3. J-type (Jump type)<br/>
&ensp;점프 명령어(j, jar)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-45.png" width="600"></p>

* 특징: funct 필드 없음(주소만 사용)
    - j: op=2(0x02)
    - jal: op=3 (0x03)

&ensp;비교 표<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-46.png" width="600"></p>

&ensp;요약<br/>
* R-type: op=0, funct가 연산 종류 결정 (add, sub, …)
* I-type: op가 연산 종류 결정 (addi, lw, sw, beq, …)
* J-type: op만으로 명령어 결정 (j, jal)

&ensp;MIPS R-type/I-type 명령어 정리<br/>
* R-type 명령어 (op=000000 → funct로 구분)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-47.png" width="600"></p>


* I-type명령어(op으로 구분)<br/>
<p align="center"><img src="/assets/img/Computer Architecture/chapter2. Language of the Computer/2-48.png" width="600"></p>
