---
title: "Chapter 2 Operating-System Structure"
excerpt: "운영체제에서 제공하는 서비스를 식별한다. 운영체제 서비스를 제공하기 위해 시스템 콜을 사용하는 방법을 설명한다. 운영체제 부팅 프로세스를 설명한다. 운영체제 부팅 프로세스를 설명한다. 운영체제 성능을 모니터링하기 위한 도구를 적용한다."

wirter: sohee km
categories:
  - Operating System
tags:
  - operating system

toc: true
toc_sticky: true
  
date: 2025-03-12
last_modified_at: 2025-03-12
---

1\. 운영체제 서비스(Operating-System Services)
============

&ensp;운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다. <br/>

&middot; 사용자 인터페이스(user interface) : 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다. 인터페이스는 여러 형태로 제공될 수 있다. 그래픽 사용자 인터페이스(Graphics User Interface; GUI)는 윈도 시스템으로 I/O를 지시하고 메뉴에서 선택하고 화면을 선택하는 포인팅 장치인 마우스와 텍스트를 입력할 키보드를 가지고 있다. 모바일 시스템은 터치 스크린 인터페이스를 가지고 있다. 명령어 라인 인터페이스(Command-Line Interface; CLI)는 명령을 사용하며 이를 입력할 방법이 사용된다. <br/>
&middot; 프로그램 수행(program execution): 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다. <br/>
&middot; 입출력 연산(I/O operation): 수행 중인 프로그램은 입출력을 요구할 수 있다. 이러한 입출력에는 파일 혹은 입출력 장치가 연관될 수 있다.<br/>
&middot; 파일 시스템 조작(file system manipulation): 프로그램은 파일을 읽고 쓸 필요가 있다. 프로그램은 이름에 의해 파일을 생성하고 삭제할 수 있고 지정된 파일을 찾을 수 있어야 하고 파일의 정보를 열거할 수 있어야 한다.<br/>
&middot; 통신(communication): 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있다. 첫 번째는 동일한 컴퓨터에서 수행되고 있는 프로세스들 사이에서 일어나고 두 번째는 네트워크에 의해 함께 묶여 있는 서로 다른 컴퓨터 시스템상에서 수행되는 프로세스들 사이에서 일어난다. 통신은 공유 메모리를 통해서 구현될 수 있고 메시지 전달 기법을 사용하여 구현될 수 있다.<br/>
&middot; 오류 탐지(error detection): 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다. 오류는 CPU, 메모리 하드웨어, 입출력 장치, 사용자 프로그램에서 일어날 수 있다. 디버깅 설비(Debugging facilities)는 시스템을 효율적으로 사용할 수 있는 사용자와 프로그래머의 능력을 향상시킨다.<br/>
&middot; 자원 할당(resource allocation): 다수의 프로세스나 다수의 작업이 동시에 실행될 때 그들 각각에 자원을 할당해 주어야 한다. 
&middot; 기록 작성(logging): 어떤 프로그램이 어떤 종류의 컴퓨팅 자원을 얼마나 많이 사용하는지를 추적할 수 있길 원한다.<br/>
&middot; 보호와 보안(protection, security): 다중 사용자 컴퓨터 시스템 또는 네트워크로 연결된 컴퓨터 시스템에 저장된 정보의 소유자는 그 정보의 사용을 통제하길 원한다. 서로 다른 프로세스가 병행하게 수행될 때 한 프로세스가 다른 프로세스나 운영체제 자체를 방해서는 안된다. 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 한다. 보안은 각 사용자가 자원에 대한 접근을 원할 때 통상 패스워드를 사용해서 시스템에게 자기 자신을 인증하는 것으로부터 시작된다. <br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-1.jpg" width="600"></p>


2\. 사용자와 운영체제 인터페이스(User and Operating-System Interface)
=======

&middot; 명령 인터프리터(command interpreter): 운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나 사용자가 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급한다. 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서 이 해석기는 셸(shell)이라고 한다. 명령 인터프리터의 중요한 기능은 사용자가 지정한 명령을 가져와서 그것을 수행하는 것이다. 제공된 많은 명령은 파일을 조작한다. 이 명령어들은 두 가지 방식으로 구현될 수 있다. 한 가지 방법은 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우이다. 또 다른 방법은 시스템 프로그램에 의해 대부분의 명령을 구현하는 것이다.<br/>
&middot; 그래픽 기반 사용자 인터페이스(Graphical User Interface)<br/>
&ensp;운영체제와 접촉하는 두 번째 방식은 사용자 친화적인 그래픽 기반 사용자 인터페이스 또는 GUI를 통하는 방식이다. 이 방식에서는 명령어 라인 인터페이스를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 데스크톱이라고 특징지어지는 마우스를 기반으로 하는 윈도 메뉴 시스템을 사용한다. 그래픽 기반 사용자 인터페이스는 1970년대 초 Xerox PARC연구 센터에서 수행된 일부로부터 기안한다. 대부분의 시스템은 CLI와 GUI 인터페이스를 포함한다.<br/>
&ensp;터치스크린 인터페이스(Touch-Screen Interface): 대부분의 모바일 시스템에는 명령 라인 인터페이스나 마우스 및 키보드 시스템이 실용적이지 않기 때문에 스마트폰 및 휴대용 태블릿 컴퓨터는 일반적으로 터치스크린 인터페이스를 사용한다. <br/>
&ensp;인터페이스의 선택: 명령어 라인 또는 그래픽 기반 인터페이스를 사용할 것인지는 개인의 선호에 달려 있다. <br/>


3\. 시스템 콜(System calls)
======

&ensp;운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다. 일반적으로 C/C++ 언어로 작성되었다. <br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-2.jpg" width="600"></p>

&ensp;1_응용 프로그래밍 인터페이스(Application Programming Interface)<br/>
&ensp;API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다. 응용 프로그래머가 사용 가능한 가장 흔한 세 가지 API는 Window 시스템을 위한 Windows API, POSIX 기반 시스템을 위한 POSIX API JAVA 가상 기계에서 실행될 수 있는 프로그램을 위한 JAVA API이다. 프로그래머는 운영체제가 제공하는 코드의 라이브러리를 통하여 API를 활용한다. 응용 프로그래머가 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍 하는 것을 선호하는 이유는 프로그램의 호환성과 관련 있다. <br/>
&ensp;시스템 콜을 처리하는 데 있어 중요한 요소는 실행시간 환경(RTE)이다. 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킨다. RTE는 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 시스템 콜 인터페이스를 제공한다. 이 시스템 콜 인터페이스는 API함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부른다. 시스템 콜 인터페이스는 의도하는 시스템 콜을 부르고 시스템 콜의 상태와 반환 값을 돌려준다. 
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-3.jpg" width="600"></p>

&ensp;운영체제에 매개변수를 전달하기 위해서 세 가지 일반적인 방법을 사용한다. 가장 간단한 방법은 매개변수를 레지스터 내에 전달하는 것이다. 그러나 어떤 경우는 레지스터보다 더 많은 매개변수를 레지스터 내에 전달하는 것이다. 이러한 경우는 레지스터보다 더 많은 매개변수가 있을 수 있다. 이러한 경우에 매개변수는 메모리 내의 블록이나 테이블에 저장되고 블록의 주소가 레지스터 내에 매개변수로 전달된다. 매개변수는 프로그램에 의해 스택(stack)에 넣어질(push) 수 있고 운영체제에 의해 꺼내진다.(pop off). 일부 운영체제는 블록이나 스택 방법을 선호하는데 이들 접근법은 전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문이다.<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-4.jpg" width="600"></p>

&ensp;2_시스템 콜의 유형(Types of System Calls)<br/>
&ensp;시스템 콜은 다섯 가지의 중요한 범주 즉 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수와 통신과 보호 등으로 묶을 수 있다. <br/>

&middot; File management<br/>
&ensp; -create file, delete file<br/>
&ensp; -open, close file<br/>
&ensp; -read, write, reposition<br/>
&ensp; -get and set file attributes<br/>

&middot; Device management<br/>
&ensp; -request device, release device<br/>
&ensp; -read, write, reposition<br/>
&ensp; -get device attributes, set device attrivutes<br/>
&ensp; -logically attach or detach devices<br/>

&middot; Information maintenance<br/>
&ensp; -get time/date, set time/date<br/>
&ensp; -get system data, set system data<br/>
&ensp; -get and set process, file, or device attributes<br/>

&middot; Communications<br/>
&ensp; -create, delete communication connection<br/>
&ensp; -send, receive messages if message passing model to host name or process name<br/>
&ensp; -Shared-memory model create and gain access to memory regions<br/>
&ensp; -transfer status information<br/>
&ensp; -attach and detach remote devices<br/>

&middot; Protection<br/>
&ensp; -Control access to resources<br/>
&ensp; -Get and set permissions<br/>
&ensp; -Allow and deny user access<br/>

&ensp;프로세스 제어(Process Control)<br/>
&ensp;실행 중인 프로그램은 수행을 정상적으로(end()) 또는 비정상적으로(abort()) 멈출 수 있어야 한다. 만약 현재 실행 중인 프로그램을 비정상으로 중지하기 위해 시스템 콜이 호출되거나 프로그램에 문제가 발생해 오류 트랩(trap)을 유발할 경우 때때로 메모리 덤프가 행해지고 오류 메세지가 생성된다. 이 덤프는 특별한 로그 파일이나 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다.
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-5.jpg" width="600"></p>

&ensp;example_ MS-DOS<br/>
&middot; single-tasking<br/>
&middot; 시스템 부팅 시 쉘(shell) 실행 : 시스템이 부팅되면 쉘이 실행<br/>
&middot; 프로그램 실행 방식 : 새로운 프로세스를 생성하지 않고 프로그램을 직접 메모리에 로드하여 실행한한다.<br/>
&middot; 단일 메모리 공간 사용 : 모든 프로그램이 하나의 메모리 공간에서 실행된다.<br/>
&middot; 프로그램 로드 방식 : 새로운 프로그램을 실행하면 기존 프로그램이 덮어씌워지면 커널을 제외한 모든 것이 대체된다.<br/>
&middot; 프로그램 종료 시 쉘 재로딩 : 실행 중인 프로그램이 종료되면 쉘이 다시 로드된다.<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-6.jpg" width="600"></p>

&ensp;example_ FreeBSD<br/>
&middot; UNIX 계열 운영체제<br/>
&middot; 멀티태스킹(Multitasking)지원 : 여러 프로세스를 동시에 실행할 수 있다.<br/>
&middot; 사용자 로그인(User Login) : 사용자가 로그인하면 선택한 쉘(shell)이 실행된다.<br/>
&middot; 프로세스 생성 및 실행 : fork() : 시스템 호출을 통해 새로운 프로세스를 생성한다. / exec() : 시스템 호출을 사용하여 프로세스 안에 프로그램을 로드하여 실행된다. <br/>
&middot; 프로세스 종료 코드(Return Code) : code = 0 -> 정상 종료 / code > 0 -> 오류 발생<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-7.jpg" width="600"></p>


4\. 시스템 서비스(System Service)
======

&ensp;시스템 서비스는 시스템 유틸리티(system utility)로도 알려진 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다. 그들 중 몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스이며 반면에 나머지는 훨씬 더 복잡하다.<br/>
* 파일관리(File manipulation) : 이들 프로그램은 파일과 디렉터리를 생성, 삭제, 복사, 개명(rename), 인쇄, 열거하고, 그리고 일반적 조작한다.<br/>
* 상태 정보(Status information) :  어떤 프로그램은 단순히 시스템에게 날짜, 시간, 사용 가능한 메모리와 다시크 공간의 양, 사용자 수, 혹은 이와 비슷한 상태 정보를 묻는다. 다른 프로그램들은 더 복잡하여 상세한 성능, 로깅 및 디버깅 정보를 제공한다. <br/>
* 파일 변경(File modification) : 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 다수의 문장 편집기를 사용할 수 있다. 파일의 내용을 검색하거나 변환하기 위한 특수 명령어가 제공되기도 한다.<br/>
* 프로그래밍언어지원(Programming language support) : 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기가 종종 운영체제와 함께 사용자에게 제공되거나 별도로 다운로드 받을 수 있다.<br/>
* 프로그램 적재와 수행(Program loading and execution) : 프로그램이 어셈블되거나 컴파일된 후 그것이 수행되려면 반드시 메모리에 적재되어야 한다. 시스템은 절대 로더(absolute loader), 재배치 가능 로더(relocatable loader), 링키지 에디터(linkage editor)와 중첩 로더(overlay loader)등을 제공할 수 있다.<br/>
* 통신(Communications) : 이들 프로그램은 프로세스, 사용자, 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공한다. 이들 프로그램은 사용자가 다른 사용자 화면으로 메시지를 전송하거나 웹 페이지 이곳저곳을 읽거나 전자 우편 메시지를 보내거나 원거리에서 로그인하거나 한 기계에서 다른 기계로 파일을 전송할 수 있게 한다.<br/>
* 백그라운드 서비스(Background services) : 모든 범용 시스템은 부트할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 가지고 있다. 이러한 프로세스 중 일부는 자신들의 할 일을 환수하면 종료하는 반면에 일부는 시스템이 정지될 때까지 계속해서 실행되는 프로세스도 존재한다. 항상 실행되는 시스템 프로그램 프로세스는 서비스, 서비시스템, 디먼으로 알려져 있다.<br/>

&ensp;운영체제 대부분은 시스템 프로그램과 함께 일반적인 문제점을 해결하거나 일반적인 연산을 수행하는 데 유용한 프로그램들도 제공한다. 이러한 웅용 프로그램에는 웹브라우저, 워드프로세서, 텟스트 포맷터, 스프레드시트, 데이터베이스 시스템, 컴파일러, 도면 제작, 통계분석 패키지, 게임 등이 포함된다. 사용자 대부분이 보는 운영체제의 관점은 실제의 시스템 콜에 의해서보다는 시스템 프로그램과 응용에 의해 정의된다. <br/>


5\. 링커와 로더(Linkers and Loaders)
======

&ensp;일반적으로 프로그램은 디스크에 이진 실행 파일로 존재한다. CPU에서 실행하려면 프로그램을 메모리에 가져와 프로세스 형태로 배치되어야 한다. 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일 된다. 이러한 형식을 재배치 가능 오브젝트 파일이라고 한다. 다음으로 링커는 이러한 재배치 가능 오브젝트 파일을 하나의 이진 실행 파일로 결합한다. 로더는 이진 실행 파일을 메모리에 적재하는 데 사용되며 CPU 코어에서 실행할 수 있는 상태가 된다. 링크 및 로드와 관련되 활동은 재배치로 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정하여 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다.<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-8.jpg" width="600"></p>


6\. 응용 프로그램이 운영체제마다 다른 이유
========

&ensp;1. 응용 프로그램은 운영체제마다 인터프리터가 제공되는 인터프리터 언어로 작성될 수 있다. 인터프리터는 소스 프로그램의 각 라인을 읽고 상응하는 기계어 명령을 실행하고 해당 운영체제의 시스템 콜을 호출한다.<br/>
&ensp;2. 응용 프로그램은 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있다.<br/>
&ensp;3. 응용 프로그램 개발자는 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API를 사용할 수 있다.<br/>


7\. 운영체제 설계 및 구현(Operating System Design and Implementation)
======

&ensp;1_설계 목표(Design Goals)<br/>
&ensp;시스템을 설계하는 데에 첫째 문제점은 시스템의 목표와 명세를 정의하는 일이다. 시스템 설계는 최상위 수준에서는 하드웨어와 시스템 유형의 선택에 의해 영향을 받을 것이다. 이 최상위 설계 수준을 넘어서면 요구 조건들을 일일이 명시하는 것이 훨씬 어려워진다. 이러한 요구 조건은 근본적으로 **사용자 목젹**과 **시스템 목적**의 두가지 기본 그룹으로 나눌 수 있다. 사용자들이 시스템에 기대하는 특징들이 존재한다.시스템은 사용하기 쉽고 편리하게며 배우기 쉽고 믿을 수 있고 안전하고 신속해야 한다. 운영체제는 설계, 구현, 유지 보수가 쉬워야 하며 또한 적응성, 신뢰성, 무오류, 효율성을 가져야 한다. <br/>

&ensp;2_기법과 정책(Mechanisums and Policies)<br/>
&ensp;가장 중요한 원칙은 기법으로부터 정책을 분리하는 것이다. 기법은 어떤 일을 어떻게 할 것인가를 결정하는 것이고 정책은 무엇을 할 것인가를 결정하는 것이다. 정책과 기법의 분리는 융통성을 위해 아주 중요하다. 정책은 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있다. 정책 결정은 모든 자원 할당 문제에 있어 중요하다. 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야한다. 질문이 무엇이 아니라 어떻게 일 때마다 반드시 결정되어야 하는 것은 기법이다.<br/> 

&ensp;구현(Implementation)<br/>
&ensp;운영체제의 설계가 완료되면 구현되어야 한다. 운영체제는 C 또는 C++와 같은 고급언어로 작성된다. 코드를 빨리 작성할 수 있으며 더욱 간결하고 이해하기 쉽고 디버그하기도 쉽다. 컴파일러 기술의 향상은 단순한 재 컴파일에 의해 전체 운영체제를 위해 생성된 코드를 향상시킬 것이다. 운영체제가 고급 언어로 작성된 경우 다른 하드웨어로 이식하는 것이 훨씬 쉽다. 운영체제를 고급 언어로 구현하는 것에 대한 단점은 속도가 느리고 저장 장치가 많이 소요되는 것이다. 하지만 이것은 현재의 시스템에서는 주된 문제가 아니다. 전문적인 어셈블리어 프로그래머는 효율적인 작은 루틴을 생산할 수 있지만 현대의 컴파일러는 대규모 프로그램을 위해 복잡한 분석을 수행하고 정교한 최적화를 적용하여 우수한 코드를 생산할 수 있다. <br/>


8\. 운영체제 구조(Operating System Structures)
======

&ensp;현대의 운영체제와 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중히 제작되어야 한다. 일반적인 접근 방법은 한 개의 일관된 시스템보다는 태스크를 작은 구성요소로 분활하는 것이다. 이들 모듈 각각은 신중히 정의된 인터페이스와 기능들을 가진, 시스템의 잘 정의된 부분이여야 하다. main() 함수에 모든 코드를 배치하는 대신 로직을 여러 함수로 분리하고 매개변수와 반환 값을 명확하게 표현한 다음 main() 함수 에서 해당 함수를 호출한다. <br/>

&ensp;1_모놀리식 구조(Monolithic Structure)<br/>
&ensp;운영체제를 구성하는 가장 간단한 구조는 구조가 아예 없는 것이다. 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것이다. 모놀리식 구조라고 하는 이 방법은 운영체제를 설계하는 일반적인 기술이다. <br/>
제한적인 구조를 가진 운영체제의 예는 최조의 UNIX 운영체제로 커널과 시스템 프로그램의 두 부분으로 구성된다. 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리되는데 이들은 UNIX가 발전해 오면서 여러 해 동안 추가되고 확장된 것이다. 시스템 콜 인터페이스 아래와 물리적 하드웨어 위의 모든 것이 커널이다. 커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 그리고 다른 운영체제 기능을 제공한다. 모놀리식 커널의 명백한 단순성에도 불구하고 이 구조는 구현 및 확장하기 어렵다.<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-9.jpg" width="600"></p>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-10.jpg" width="600"></p>

&ensp;2_계층적 접근(Layered Approach)<br/>
&ensp;시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 줄 수 있으므로 모놀리식 접근법은 종종 밀접하게 결합된 시스템으로 불린다. 대안으로 느슨하게 결합된 시스템을 설계할 수 있다. 이러한 시스템은 기능이 특정 기능 및 한정된 기능을 가진 개별적이며 작은 구성요소로 나뉜다. 이 모든 구성요소가 합쳐서 커널을 구성한다. 이 모듈 방식의 장점은 한 구성요소의 변경이 해당 구성요소에만 영향을 미치고 다른 구성요소에는 영향을 미치지 않으므로 시스템 구현자가 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있다는 것이다.<br/>
시스템은 다양한 방식으로 모듈화 될 수 있다. 한 가지 방식이 계층적 접근 방식인데 이 방식에서는 운영체제가 여러 개의 층으로 나누어진다. 최하위 층(층 0)은 하드웨어이고 최상위 층(층 N)은 사용자 인터페이스이다. 운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상된 객체의 구현이다. 전형적인 운영체제 층은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합으로 구성된다. 층 M은 다시 최하위층에 대한 연산을 호출할 수 있다. 계층적 접근 방식의 주도니 장점은 구현과 디버깅의 간단함에 있다. 이러한 접근 방법은 시스템의 검증과 디버깅 작업을 단순화할 수 있다. 한 층은 이러한 연산들이 어떻게 구현되는지 알 필요가 없고 이러한 연산들이 무엇을 하는지만 알면 된다. 그러므로 각 층은 특정 데이터 구조, 연산 그리고 하드웨어의 존재를 상위층에 대해 숨기게 된다. 계층화된 시스템은 컴퓨터 네트위크 및 웹 응용 프로그램에서 성공적으로 사용됐다. 이러한 시스템은 더 많은 기능을 가진 더 적은 개수의 층을 가지므로 층 기능의 정의 및 상호작용의 문제를 피하면서 모듈화된 코드의 장점을 최대한 활용할 수 있다.<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-11.jpg" width="600"></p>

&ensp;3_마이크로커널(Micorkernels)<br/>
&ensp;대학교의 연구자들이 마이크로커널 접근 방식을 사용하여 커널을 모듈화한 Mach라 불리는 운영체제를 개발하였다. 모든 중요치 않은 구성요소를 커널로부터 제거하고 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다. 마이크로커널의 주 기능은 클라이언트 프로그램과 역시 사용자 공간에서 수행되는 다양한 서비스 간에 통신을 제공하는 것이다. 클라이언트 프로그램과 서비스는 결코 직접 상호 작용하지 않는다. 마이크로커널과 메시지를 교환함으로써 간접적으로 상호작용한다. 마이크로커널 접근법의 장점은 운영체제의 확장이 쉽다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되며 따라서 커널을 변경할 필요 없다. 마이크로커널은 서비스 대부분이 커널이 아니라 사용자 프로세스로 수행되기 때문에 높은 보안성과 신뢰성을 제공한다. 마이크로커널 운영체제에 대헤 가장 잘 알려진 실례는 macOS 및 iOS 운영체제의 커널 구성요소인 Darwin이다. 실제로 Darwin은 두 개의 커널로 구성되며 그 중 하나는 Mach마이크로커널이다.<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-12.jpg" width="600"></p>

&ensp;4_모듈(Modules)<br/>
&ensp;운영체제를 설계하는 데 이용되는 최근 기술 중 최선책은 적재가능 커널 모듈(loadable kernel modules, LKM)이다. 이 접근법에서는 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크할 수 있다. 설계의 주안점은 커널은 핵심 서비스를 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것이다. 서비스를 동적으로 링크하는 것은 새로운 기능을 직접 커널에 추가하는 것보다 바람직하다. 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았다. 그러나 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연하다.중심 모듈은 단지 핵심 기능만 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서는 마이크로 커널과 유사하다. <br/>

&ensp;5_하이브리드 시스템(Hybrid Systems)<br/>
&ensp;다양한 구조를 결합하여 성능, 보안, 편리성 문제를 해결하는 혼용 구조로 구성된다. 운영체제들은 모듈을 사용하기 때문에 새로운 기능을 동적으로 커널에 추가할 수 있다. <br/>

&ensp;macOS와 iOS<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-13.jpg" width="600"></p>

&middot; 사용자 경험 층 : 사용자가 컴퓨팅 장치와 상호 작용할 수 있는 소프트웨어 인터페이스를 정의한다. <br/>
&middot; 응용 프로그램 프레임위크 층 : Cocoa 및 Cocoa Touch 프레임워크가 포함되며 Objective-C 및 Swift 프로그래밍 언어에 대한 API를 제공한다. Cocoa와 Cocoa Touch의 주요 차이점은 전자 macOS응용 프로그램 개발에 사용되고 후자는 iOS가 터치스크린과 같은 모바일 장치에 고유한 하드웨어 기능을 지원하는 데 사용한다는 것이다.<br/>
&middot; 핵심 프레임워크 : 이 층은 Quicktime 및 OpenGL을 포함한 그래픽 및 미디어를 지원하는 프레임워크를 정의한다.<br/>
&middot; 커널 환경 : Darwin이라고 불리는 이 환경에는 Mach 마이크로커널과 BSD UNIX 커널이 포함된다. <br/>
&ensp;macOS는 데스크톱 및 랩톱 컴퓨터 시스템용이므로 Intel 아키텍처에서 실행되도록 컴파일된다. ios는 모바일 장치용으로 설계되었으므로 ARM 기반 아키텍처용으로 컴파일된다. <br/>

&ensp;Android<br/>
&ensp;Android 운영체제는 Open Handset Alliance가 설계하였으며 Android 스마트폰과 태블릿을 위해 개발되었다. Android는 다양한 모바일 플랫폼에서 실행되며 공개 소스이다. Android는 그래픽, 오디오 및 하드웨어 기능을 지원하는 다양한 프레임워크를 제공하는 계층화된 소프트웨어 스택이라는 점에서 iOS와 유사하다.<br/>
Linux 커널 기반이다. 프로세스, 메모리 장치 드라이버 관리를 제공하고 전원 관리(power management)기능 추가된다. <br/>
핵심 라이브러리 및 Dalivik 가상 머신(Dalvik virtual machine)이 포함되고 Java 및 Android API를 활용하여 앱 개발을 한다. Java 클래스 파일이 바이트코드로 컴파일된 후 Dalvik VM에서 실행 가능한 형태로 변환된다.<br/>
기본 라이브러리는 웹 브라우저 프레임워크(WebKit), 데이터베이스(SQLite), 멀티미디어 기능, 경량화된 C 라이브러리(libc)가 포함된다. <br/>
ART는 Android용으로 설계되어 메모리와 CPU처리 능력이 제한적인 모바일 장치에 최적화도니 가상머신이다. 많은 Java 가상 머신이 응용 프로그램 효율성을 향상시키기 위해 JIT(just-in-time)컴파일을 수행한는 반면 ART는 AOT(ahead-of-time)컴파일을 수행한다. AOT 컴파일은 모바일 시스템에 중요한 기능인 전력 소비를 줄이면서 더 효율적인 응용 프로그램 실행을 가능하게 한다.<br/>
<p align="center"><img src="/assets/img/Operating System//2. Operating-System Structure//2-14.jpg" width="600"></p>


9\.운영체제 빌딩과 부팅(Building and Booting an Operating System)
======

&ensp;하나의 특정 기기 구성에 맞게 운영체제를 설계, 코딩 및 구현할 수 있다. 일반적으로 운영체제는 다양한 주변장치 구성을 가진 모든 종류의 컴퓨터에서 실행되도록 설계된다. <br/>

&ensp;1_운영체제 생성(Operating System Generation)<br/>

&ensp;운영체제는 여러 종류의 기계에 맞춰 실행되도록 설계되지만 각 컴퓨터 환경에 맞게 구성(configure)되어야 한다. 이 과정을 돕기 위해 SYSGEN 프로그램이 사용된다. SYSGEN은 하드웨어 시스템의 구체적인 구성 정보를 수집한다. 수집한 후 시스템 맞춤형 커널을 컴파일하거나 시스템에 맞게 튜닝된 운영체제를 구성할 수 있다. SYSGEN의 장점은 하나의 일반적인 커널보다 더 효율적인 코드를 생성할 수 있다.<br/>
시스템을 구성하려면 어떤 기능을 포함되는지 명시해야 하며 이는 운영체제에 따라 다르다. 일반적으로 시스템 구성 방법을 설명하는 매개변수는 특정 유형의 구성 파일에 저장되며 이 파일을 만든 후에는 여러 가지 방법으로 사용할 수 있다. 시스템 관리자가 이를 사용하여 운영체제 소스 코드의 사본을 수정할 수 있다. 그런 다음 운영체제가 완전히 컴파일된다.(시스템 빌드라고 함) 컴파일 시 주어진 데이터 선언, 초기화 및 상수는 구성 파일에 설명된 시스템에 맞는 운영체제의 출력-오브젝트 버전을 생성한다. 상세한 조정을 할 수 없는 수준에서는 시스템 설명을 통하여 기존 라이브러리에서 사전 컴파일된 오브젝트 모듈을 선택할 수 있다. 이 모듈들이 서로 링크되어 새 운영체제가 생성된다. 이 과정을 통해 지원되는 모든 I/O 장치의 장치 드라이버를 포함한 라이브러리에서 필요한 것만 선택하여 운영체제에 링크할 수 있다. 시스템이 다시 컴파일되며 다른 하드웨어 구성을 지원하지 않을 수 있다.<br/>
&ensp;다른 경우는 완전히 모듈 방식으로 시스템을 구성할 수 있다. 여기서 선택은 컴파일 또는 링크 시간이 아닌 실행 시간에 일어난다. 시스템 생성은 단순히 시스템 구성을 설명하는 매개변수의 설정만 하면 된다. 이러한 접근 방식의 주용 차이점은 생성된 시스템의 크기 및 일반성과 하드웨어 구성이 변경될 때 변경이 얼마나 쉬운가에 있다. 운영체제는 여전히 특정 하드웨어 구성을 위해 생성되지만 적재가능 커널 모듈과 같은 기술을 사용하면 시스템 동적 변경을 위한 모듈 방식을 지원할 수 있다.<br/>

&ensp;Linux 가상 머신을 설치하여 기존 시스템을 수정할 수 있다. 그러면 호스트 운영체제가 Linux를 실행할 수 있다. Linux를 가상 머신으로 설치하기 위해 몇 가지 옵션이 있다. 한 가지 대안은 처음부터 가상머신을 빌드하는 것이다. 이 옵션은 Linux 시스템을 처음부터 빌드하는 것과 유사하다. 그러나 운영체제는 컴파일될 필요가 없다. 또 다른 방법은 이미 빌드 및 구성된 운영체제인 Linux 가상 머신 어플라이언스를 사용하는 것이다. 이 옵션을 사용하려면 단순히 어플라이언스를 다운로드하고 VirtualBox 또는 VMware와 같은 가상화 소프트웨어를 사용하여 설치하면 된다. <br/>

&ensp;2_시스템 부트(System Boot)<br/>

&ensp;커널을 적재하여 컴퓨터를 시작하는 과정을 시스템 부팅이라고 한다. 전원이 켜지면 시스템은 고정된 메모리 위치에서 실행을 시작한다. 이때 사용하는 것이 펨위어 ROM 즉 초기 부팅 코드를 담고 있는 읽기 전용 메모리이다. <br/>
1. 부트스트랩 프로그램 또는 부트스크랩 로더(bootstrap loader)라고 불리는 작은 코드가 커널의 위치를 찾는다.<br/>
2. 커널이 메모리에 적재되고 시작된다.(일반적으로 ROM 또는 EEPROM에 저장된다. ROM에 저장된 코드가 boot block을 로드하고 boot block이 디스크에서 bootstrap loader를 불러온다. 커널이 메모리에 로드되면 시스템이 실행상태(running)이 된다.)<br/>
3. 커널은 하드웨어를 초기화 한다.<br/>
4. 루트 파일 시스템이 마운트 된다.<br/>
&ensp;일부 컴퓨터 시스템은 다단계 부팅 사용한다. 컴퓨터 전원을 처음 켜면 BIOS라고 하는 비휘발성 펌웨어에 있는 소형 부트 로더가 실행된다. 이 초기 추트 로더는 일반적으로 부트 블럭이라고 하는 디스크의 정해진 위치에 있는 두 번째 부트 로더를 적재하는 작업만 한다. 부특 블럭이라고 하는 디스크의 정해진 위치에 있는 두 번째 부트로더를 적재하는 작업만 한다. 더 일반적으로 이 부트 로더는 간단한 코드로서 디스크의 주소와 부트스트랩 프로그램 나머지의 길이만 알고 있다.<br/>
&ensp;많은 최신 컴퓨터 시스템이 BIOS 기반 부팅 과정을 UEFI(Unified Extensible Firmware Interface)로 대체하였다. UEFI가 하나의 완전한 부팅 관리자이므로 다단계 BIOS부팅 과정보다 빠르다는 것이다. 부트스트랩 프로그램은 BIOS에서 부팅하든 UEFI에서 부팅하든 다양한 작업을 수행할 수 있다. 커널 프로그램이 포함된 파일을 메모리에 적재하는 것 외에도 진단을 실시하여 메모리와 CPU를 점검하고 장치 검색과 같은 시스템 상태를 확인한다. 진단을 통과하면 프로그램은 부팅 과정을 계속 진행할 수 있다. 부트스트랩은 CPU 레지스터에서 장치 컨트롤러 및 메인 메모리의 내용에 이르기까지 시스템의 모든 측면을 초기화 할 수 있다. <br/>



10\. 운영체제 디버깅(Operating-System Debugging)
======

&ensp;디버깅은 하드웨어와 소프트웨어에서의 시스템 오류를 발견하고 수정하는 행위이다. 성능 문제는 버그로 간주되므로 시스템에서 처리 중에 발생하는 병목 현상을 제거하여 성능을 향상시키는 성능조정(performace turning)도 디버깅에 포함된다. 

&ensp;1_장애 분석(Failure Analysis)<br/>

&ensp;운영체제 대부분은 시스템 관리자 또는 문제를 발생시킨 사용자에게 문제가 발생했다는 것을 경고하기 위해 오류 정보를 로그 파일에 기록한다. 운영체제는 또한 프로세스가 사용하던 메모리를 캡처한 코어 덤프(core dump)를 취하고 차후 분석을 위해 파일로 저장한다. 실행 중인 프로그램과 코어 덤프는 디버거에 의해 검사될 수 있으며 이는 장애 발생 시 프로그래머가 프로세스의 코드와 메모리를 분석할 수 있도록 한다. 커널 장애는 크래시(crash)라고 불린다. 프로세스 장애와 마찬가지로 오류 정보가 로그 파일에 저장되고 메모리의 상태가 크래시 덤프(crash dump)에 저장된다. <br/>
&ensp;운영체제 디버깅과 프로세스 디버깅은 종종 두 태스크의 근본적인 차이에 의해 서로 다른 도구와 기법을 사용한다. 파일 시스템 코드 때문에 발생한 커널 장애는 재부팅 전에 커널의 상태를 파일 시스템에 정장하려는 사도를 위험하게 한다. 일반적인 기법은 커널의 메모리 상태를 이 용도를 위해 예약된 파일 시스템을 가지지 않은 디스크의 특정부분에 저장하는 것이다. 커널이 복구 불가능한 오류를 탐지하면 메모리의 전체 내용 또는 시스템 메모리의 커널이 소유한 부분만이라도 디스크 영역에 저장한다. 시스템이 재부팅되면 프로세스는 이 영역으로부터 데이터를 수집하고 분석을 위해 파일 시스템의 크래시 덤프 파일에 기록한다. 

&ensp;2_성능 관찰 및 조정(Performance Monitoring and Tuning)<br/>

&ensp;성능 조정은 처리 병목 지점을 제거함으로써 성능을 향상시키려 한다고 언급하였다. 병목 지점을 발견하기 위하여 시스템 성능을 감시할 수 있다. 따라서 시스템 동작을 측정하고 표시할 수 있는 방법을 가지고 있어야 한다. 도구는 프로세스별 또는 시스쳄 전체의 관찰을 제공하느냐로 특징이 묘사될 수 있다. 이러한 관찰을 위해 도구는 카운터 또는 추적의 두 가지 접근 방식 중 하나를 사용할 수 있다. <br/>

&ensp;카운터(Counters)<br/>
&ensp;운영체제는 일련의 카운터를 통해 호출된 시스템 콜 횟수 또는 네트워크 장치 또는 디스크에 수행된 작업 수와 같은 시스템 활동을 추적한다.<br/>

&ensp;Performance Tuning<br/>
&ensp;1. 병목 현상 제거를 통한 성능 향상<br/>
&middot; 시스템 성능을 높이려면 병목 현상(bottlenecks)을 찾아 제거해야 한다. <br/>
&middot; 병목 현상이란 시스템에서 특정 자원이 부족하여 전체 성능이 저하되는 현상을 의미한다.<br/>
&ensp;2. 운영체제의 성능 측정 및 표시 기능<br/>
&middot; 운영체제는 시스템의 성능을 측정하고 이를 사용자에게 표시하는 기능을 제공해야 한다.<br/>
&middot; 사용자는 시스템 성능 문제를 진단하고 해결할 수 있다.<br/>
&middot; 이를 통해 사용자는 시스템 성능 문제를 진단하고 해결할 수 있다.<br/>
&ensp;3. 성능 모니터링 도구 예시<br/>
&middot; 대표적인 도구로 Linux의 top명령어 또는 Windows의 작업 관리자(Task Manager)가 있다. <br/>

&ensp;DTrace<br/>
&ensp;DTrace는 Solaris, FreeBSD, Mac OS X에서 사용 가능한 성능 분석 및 디버깅 도구이다.<br/>
&ensp;실시간 계측(live instrumentation) 기능을 제공항여 프로덕션 환경에서도 안전하게 코드 실행을 모니터링 할 수 있다.<br/>
&ensp;프로브(Probes) : 특정 코드가 실행될 때 자동으로 작동하는 트리거 역할을 하고 운영체제 및 애플리케이션의 다양한 이벤트를 추적할 수 있다.<br/>
&ensp;제공자와 소비자(Provider and Consumer) : 제공자: 프로브를 제공하는 역할, 소비자: 프로브에서 수집된 데이터를 받아 활용하는 프로그램이나 사용자<br/>
&ensp;활용 : 운영체제 및 애플리케이션의 성능 튜닝 및 디버깅에 사용되고 시스템 호출, 파일 입출력, 네트워크 활동 등 분석하여 병목 현상 제거 가능, 프로덕션 환경에서도 안전하게 사용 가능하여 실시간 문제 해결에 유용.<br/>
&ensp;DTrace 코드 목적 : 특정 사용자의 프로세스가 CPU에서 실행된 총 시간을 나노초(nanoseconds) 단위로 기록한다. UserID 101을 가진 프로세스만 추적한다.<br/>

&ensp;BCC<br/>
&ensp;BCC는 사용하지 않을 경우에는 성능에 전혀 영향을 주지 않고 사용 중일 때에는 그에 비례하게 성능에 영향을 주면서 동적이고 안전하며 낮은 영향력을 미치는 디버깅 환경을 제공한다. BCC(BPF Compiler Collection)는 Linux 시스템을 위한 추적 기능을 제공하는 풍부한 툴킷이다. BCC는 eBBPF도구에 대한 프런트-엔드 인터페이스이다. 

