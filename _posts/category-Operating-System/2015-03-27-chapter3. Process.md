---
title: "Chapter 3 Process"
excerpt: "프로세스의 개별 구성요소를 식별하고 운영체제에서 해당 구성요소가 어떻게 표현되고 스케줄 되는지 기술한다."

wirter: sohee km
categories:
  - Operating System
tags:
  - operating system

toc: true
toc_sticky: true
  
date: 2025-03-27
last_modified_at: 2025-03-27
---


&ensp;1. 프로세스 개념(Process Concept)<br/>
======

&ensp;1_개념<br/>
&ensp;초창기 컴퓨터는 작업(job)을 실행하는 일괄처리 시스템이였고 사용자 프로그램 또는 테스크(task)를 실행하는 시분활 시스템이 뒤를 이었다. 프로세스란 실행 중인 프로그램이다. 프로세스의 현재 활동의 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다. 프로세스의 메모리 배치는 일반적으로 여러 섹션으로 구분된다. <br/>
&middot; 텍스트 섹션 - 실행코드<br/>
&middot; 데이터 섹션 - 전역 변수<br/>
&middot; 힙 섹션 - 프로그램 실행 중에 동적으로 할당되는 메모리<br/>
&middot; 스택 섹션 - 함수를 호출할 때 임시 데이터 저장장소<br/>
<p align="center"><img src="/assets/img/Operating System//3. Process/3-1.jpg" width="600"></p>
&ensp;C Program 예시<br/>
<p align="center"><img src="/assets/img/Operating System//3. Process/3-2.jpg" width="600"></p>
&ensp;텍스트 및 데이터 섹션의 크기는 고정되기 때문에 프로그램 실행 시간 동안 크기가 변하지 않는다. 그러나 스택 밒 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있다. 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 활성화 레코드(activation record)가 스택에 푸시된다. 스택 및 힙 섹션이 서로의 방향으로 커지더라도 운영체제는 서로 겹치지 않도록 해야 한다. 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재(active entity)이다. 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다. (프로그램은 디스크에 저장된 파일과 같은 수동적인 존재) 실행파일을 메모리에 적재하는 일반적인 두 가지 방식은 실행 파일을 나타내는 아이콘을 더블 클릭하는 방법과 명령어 라인상에서 prog.exe 또는 a.out과 같이 파일 이름을 입력하는 방식이다. 두 프로세스들이 동일한 프로그램에 연관될 수 있지만 이들은 두 개의 별도의 실행 순서로 간주한다. 텍스트 섹션이 동등하다 할지라도 데이터, 힙, 스택 섹션은 다를 수 있다.<br/>

&ensp;2_프로세스 상태(Process State)<br/>
&ensp;프로세스는 실행되면서 그 상태가 변한다. 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다. 프로세스는 다음 상태 중 하나에 있게 된다. 
&middot; 새로운(new) : 프로세스가 생성 중이다.<br/>
&middot; 실행(running) : 명령어들이 실행되고 있다.<br/>
&middot; 대기(waiting) : 프로세스가 어떤 이벤트(입출력 완료 또는 신호의 수신 같은)가 일어나기를 기다린다.<br/>
&middot; 준비(ready) : 프로세스가 처리기에 할당되기를 기다린다<br/>
&middot; 종료(terminated) : 프로세스의 실행이 종료된다.
<p align="center"><img src="/assets/img/Operating System//3. Process/3-3.jpg" width="600"></p>

&ensp;3_프로세스 제어 블록(Process Control Block)<br/>
&ensp;각 프로세스는 운영체제에서 프로세스 제어 블록(process control block, PCB)(테스크 제어 블록이라고도 불린다.)에 의해 표현된다. <br/>
&middot; 프로세스 상태: 상태는 새로운(new), 준비(ready), 실행(running), 대기(waiting) 또는 정지(halted) 상태 등이다. <br/>
&middot; 프로그램 카운터 : 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.<br/>
&middot; CPU 레지스터들 : CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다. 레지스터는 누산기(accumulator), 인덱스 레지스터, 스택 레지스터, 범용 레지스터들(general-purpose)과 상태 코드(condition code) 정보가 포함된다. 프로그램 카운터가 함께 이 상태 정보는 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 저장되어야 한다.<br/>
&middot; CPU-스케줄링 정보 : 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함된다. <br/>
&middot; 메모리 관리 정보 : 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 기준(base) 레지스터와 한계(limit) 레지스터 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다. <br/>
&middot; 회계(accounting) 정보 : 이 정보는 CPU 사용 시간과 경과된 실시간, 시간 제한, 제정 번호, 잡 또는 프로세스 번호 등을 포함한다<br/>
&middot; 입출력 상태 정보 : 이 정보는 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다. <br/>
<p align="center"><img src="/assets/img/Operating System//3. Process/3-4.jpg" width="600"></p>

&ensp;4_스레드(Threads)<br/>
&ensp;단일 제어 스레드는 프로세스가 한 번에 한 가지 일만 실행하도록 허용한다. 사용자는 문자를 입력하면서 동시에 철자 검사기를 실행할 수 없다. 대부분의 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용한다. 이러한 특성은 특히 다중 처리기 시스템에서 이익을 얻을 수 있는데 여러 스레드가 병렬로 실행될 수 있다. 스레드를 지원하기 위해서는 시스템 전반을 걸친 다른 수정도 필요하다. <br/>

&ensp;2. 프로세스 스케줄링(Process Scheduling)<br/>
&ensp;다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행되도록 하는 데 있다. 시분활 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것이다. 이 목적을 달성하기 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다. 각 CPU 코어는 한 번에 하나의 프로세스를 실행할 수 있다. 단일 CPU코어가 있는 시스템의 경우 한 번에 2개 이상의 프로세스가 실행할 수 없지만 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다. 현재 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 한다. <br/>
&ensp;다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면 프로세스의 일반적인 동작을 고려해야 한다. 일반적으로 대부분의 프로세스는 I/O 바운드 또는 CPU 바운드로 설명할 수 있다. I/O 바운드 프로세스는 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스이다. 반대로 CPU 바운드 프로세스는 계산에 더 많은 시간을 사용하여 I/O요청을 자주 생성하지 않는다. <br/>
<p align="center"><img src="/assets/img/Operating System//3. Process/3-5.jpg" width="600"></p>
<p align="center"><img src="/assets/img/Operating System//3. Process/3-6.jpg" width="600"></p>
&middot; 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있다. <br/>
&middot; 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다. <br/>
&middot; 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 들어갈 수 있다.<br/>

&ensp;운영체제는 여러 큐(queue)를 관리하여 프로세스 상태를 추적한다. <br/>
&middot; Job Queue : 시스템 내 모든 프로세스가 포함된 큐<br/>
&middot; Ready Queue : 메인 메모리에 존재하며 실행 준비가 된 프로세스들의 집합<br/>
&middot; Device Queues :  I/O 장치 잡업을 기다리는 프로세스들의 집합<br/>

&ensp;CPU Scheduling<br/>
&ensp;프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다. CPU 스케줄링의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU코어를 힐당하는 것이다. CPU스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다. I/O 바운드 프로세스는 I/O 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다. CPU 바운드 프로세스에는 오랜 시간 동안 CPU 코어가 필요하지만 스케줄러는 프로세스에게 코어를 장기간 부여할 가능성이 없다. 대신 프로세스에서 CPU를 강제로 제거하고 실행될 다른 프로세스를 스케줄하도록 설계될 가능성이 높다. <br/>
&ensp;일부 운영체제는 스와핑으로 알려진 중간 형태의 스케줄링을 가지고 있는데 핵심 아이디어는 때로는 메모리에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시키는 것이 유리할 수도 있다. 나중에 프로세스를 메모리에 다시 적재될 수 있으며 중단된 위치에서 실행을 계속할 수 있다. 프로세스를 메모리에서 디스크로 스왑아웃하고 현재 상태를 저장하고 이후 디스크에서 메모리로 스왑인하여 상태를 복원할 수 있기 때문에 이 기법을 스와핑이라고 한다. <br/>
<p align="center"><img src="/assets/img/Operating System//3. Process/3-8.jpg" width="600"></p>

&ensp;문맥 교환(Context Switch)<br/>
&ensp;인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있게 한다. 이러한 연산은 범용 시스템에서는 자주 발생한다. 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다. 문맥은 프로세스 PCB에 표현된다.문맥은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다. 일반적으로 커널모드이건 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행하고 나중에 연산을 재개하기 위하여 상태 복귀 작업을 수행한다. 문맥 교환은 CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이다.<br/>
&ensp;문맥 교환이 일어나면 커널은 과거 프로세스의 문맥을 PCB에 저장하고 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다. 문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환 시간은 순수한 오버헤드이다. 교환 속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 수, 특수 명령어의 존재에 좌우되므로 기계마다 다르다. 문맥 교환 시간은 하드웨어 지원에 크게 좌우된다.
<p align="center"><img src="/assets/img/Operating System//3. Process/3-7.jpg" width="600"></p>

