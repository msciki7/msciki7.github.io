---
title: "Chapter 6. Synchronization Tools"
excerpt: "논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하여 이를 통해 데이터의 일관성을 유지하는 다양한 매커니즘을 논의한다."

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
use_math: true
toc_sticky: true
  
date: 2025-04-28
last_modified_at: 2025-04-07
---

1\. 배경(Background)
======

&ensp;프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지에 관해 설명한다. <br/>

&ensp;동시에 최대 BUFFER_SIZE - 1개 까지의 항복만을 버퍼에 저장할 수 있다. 이 단점을 없애기 위해서 알고리즘을 수정한다고 가정하자. 한 가지 가능성은 0으로 초기화되어 있는 count라는 정수형 변수를 추가하는 것이다. 버퍼에 새 항목을 추가할 때마다 count값을 증가시키고 버퍼에서 한 항목을 꺼낼 때마다 count 값을 감소시킨다.<br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-1.png" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-2.png" width="600"></p>

&ensp;위에 보인 생산자와 소비자 코드는 개별적으로 올바를지라도 그들을 병행적으로 수행시키면 올바르게 동작하지 않는다.<br/>

&ensp;count++는 다음과 같은 기계어로 구현할 수 있다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-3.png" width="600"></p>

&ensp;count--는 다음과 같이 구현할 수 있다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-4.png" width="600"></p>

&ensp;count++와 count-- 문장을 병행하게 실행하는 것은 앞에 제시한 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 동등하다. 그중 하나는 다음과 같은 순서를 가질 수 있다.(ex. 처음으로 count == 5를 가진 interleaving 실행을 고려)<br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-5.png" width="600"></p>

&ensp;동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 **경쟁 상황(race condition)**이라고 한다.<br/>

2\. 임게구역 문제(The Critical Section Problem)
======

&ensp;각 프로세스는 **임계구역**이라고 부르는 코드 부분을 포함하고 있고 그 안에서는 적어도 하나 이상의 다른 프로세스왁 공유하는 데이터에 접근하고 갱신할 수 있다. 이 시스템의 중요한 특징은 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다는 사실이다. 임계구역 문제는 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것이다. 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 한다. 이러한 요청을 구현하는 코드 부분을 **진입구역(entry section)** 이라고 부른다. 임계구역 뒤에는 **퇴출구역(exit section)** 이 따라올 수 있다. 코드 나머지 부분들은 총칭하여 나머지 구역(remainder section)이라고 부른다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-6.png" width="600"></p>

&ensp;임계구역 문제에 대한 해결안은 다음의 세 가지 요구 조건을 충족해야 한다.<br/>

1. 상호 배제(mutual exclusion): 프로세스 Pi가 자신의 임계구역에서 싱행된다면 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.
2. 진행(progress): 자신의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 누가 그 임계구역으로 진입할 수 있는지를 결정하는 데 참여할 수 있으며 이 선택은 무한정 연기될 수 없다.
3. 한정된 대기(bounded waiting): 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다. 
&ensp;각 프로세스가 0이 아닌 속도로 실행되는 것을 가정한다. 그러나 n개의 프로세스 간의 상대적인 속도에 대한 가정은 하지 않는다. <br/>

&ensp;운영체제 내에서 임계구역을 다루기 위해서 **선점형 커널**과 **비선점형 커널**의 두 가지 일반적인 접근법이 사용된다. 선점형 커널은 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다. 비선점형 커널은 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.<br/>
&ensp;비선점형 커널은 한 순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로 커널 자료구조에 대한 경쟁 조건을 염려할 필요는 없다. 선점형 커널에 대해서는 동일한 주장을 할 수 없기 때문에 공유되는 커널 자료구조에서 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 한다.<br/> 

3\. Peterson의 해결안(Peterson's Solution)
======

&ensp;현대 컴퓨터 구조가 load와 store 같은 기본적인 기계어를 수행하는 방식 때문에 Peterson의 해결안이 이러한 구조에서 올바르게 실행된다고 보장할 수는 없다.<br/>
&ensp;Peterson의 해결안은 임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다. 프로세스는 P0과 P1로 번호를 매긴다. 편의상 Pi라고 표현하면 Pj는 다른 프로세스를 가리키고 j는 1-i와 같게 된다. <br/>

&ensp;Peterson의 해결안은 두 프로세스가 두 개의 데이터 항목을을 공유하도록 하여 해결한다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-7.png" width="600"></p>

&ensp;변수 turn은 임계구역으로 진입할 순번을 나타낸다. 즉 만일 turn == i이면 프로세스 Pi가 임계구역에서 실행될 수 있다. flag 배열은 프로세스가 임계구역으로 진입할 준비가 되었다는  것을 나타낸다. <br/>
&ensp;임계구역으로 진입하기 위해서 Pi는 먼전 flag[i]를 참으로 만들고 turn을 j로 지정한다. 이렇게 함으로써 프로세스 j가 임계구역으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다. 만일 두 프로세스가 동시에 진입하기를 원한다면 turn은 거의 동시에 i와 j로 지정될 것이다. 그러나 둘 중 오직 한 배정만이 지속된다. 다른 배정은 발생하기는 하지만 곧바로 겹쳐 쓰이게 된다. turn의 궁극적인 값이 둘 중 누가 먼저 임계구역으로 진입할 것인가를 결정한다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-8.png" width="600"></p>

1. 진입준비
* flag[i] = ture: 지금 critical section에 들어가고 싶다고 표시(진입 의도 알림)
* turn = j: 상대방 프로세스(j)에게 양보하는 것처럼 "너 먼저 해도 돼"라고 말하는 거이다.

2. 기다리기
* while (flag[j] && turn == j)  ;
* 상대방 프로세스(j)가 critical section에 들어가고 싶어하고(flag[j] == true) 양보를 기다리고 있다면 (turn == j). Pi는 busy waiting 상태로 계속 기다려야 함(== 진입 불가)

3. Critical Section 실행
* 공유 자원에 대한 접근이 여기서 이루어진다. 
* 예를 들어 공유 변수 수정, 파일 접근 등 중요한 작업이 여기서 처리된다.

4. 나가기
* flag[i] = false;
* critical section 작업이 끝나면 flag[i]를 flase로 바꿔서 -> "나 이제 다 했어, 다른 프로세스도 들어와도 돼"라고 알린다.<br/>

5. 나머지 작업
* critical section과 무관한 다른 작업을 수행하는 구간이다.
* 예를 들어 개인적인 데이터 처리, 계산 등을 할 수 있다.

&ensp;이 알고리즘이 3가지를 보장해야 한다.<br/>
1. 상호 배제가 제대로 지켜진다는 사실
2. 진행에 대한 요구 조건을 만족한다는 사실(progress)
3. 대기 시간이 한없이 길어지지 않는다는 사실이다.(bounded waiting)

4\. 동기화를 위한 하드웨어 지원(Hardware Support for Synchronization)
======

&ensp;시스템은 critical section 문제를 해결하기 위해 하드웨어 지원을 제공한다. 
* 많은 운영체제나 컴퓨터 시스템은 critical section 문제를 해결하려고 하드웨어적 지원을 한다.
* 핵심 목표는 동시 접근을 막고(= 상호 배제 mutual exclusion) 안전하게 공유 자원을 사용하는 것이다.

&ensp;기본 아이디어는 Locking이다. "lock"을 사용해서 critical region을 보호한다. 누군가 먼저 lock을 획득하면 다른 사람은 기다려야 한다. 이게 동기화의 핵심 메커니즘이다.<br/>

&ensp;단일 프로세스(Uniprocessors)에서는 인터럽트(disable interrupts)를 비활성하는 방법을 쓸 수 있다. 그러면 현재 실행 중인 코드가 강제로 멈추지 않고 끝까지 실행할 수 있다. 하지만 멀티프로세스(multiprocessor)시스템에서는 이 방법이 비효율적이다. 그래서 이 방법은 확장성(scalability)이 떨어진다고 말할 수 있다.<br/>

&ensp;현대 시스템(멀티코어)에서는 특수한 원자적(atomic) 하드웨어 명령어를 제공한다. <br/>
* Atomic = 중단 불가능한(non-interruptible) 연산
&ensp;Atomic한 연산은 실행되는 동안 다른 프로세스나 스레드가 끼어들 수 없다. 이런 연산을 통해 critical section 보호를 더 정교하게 할 수 있다. <br/>
&ensp;대표적인 atomic 연산 : 1. 메모리 워드를 검사(test)하고 값을 설정(set) 2. 두개의 메모리 단어(word)를 교환(swap)<br/>

&ensp;1_하드웨어 명령어(Hardware Instructions)<br/>
&ensp;많은 현대 기계들은 한 워드(word)의 내용을 검사하고 변경하거나 두 워드의 내용을 원자적으로 교환(swap)할 수 있는 즉 인터럽트 되지 않는 하나의 단위로서 특별한 하드웨어 명령어들을 제공한다.<br/>

<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-9.png" width="600"></p>

1. acquire lock
* lock을 획득하는 과정이다. 공유 자원(critical section)에 들어가기 전에 lock을 반드시 획득해야 한다. 다른 프로세스나 스레드가 이미 lock을 가지고 있다면 기다려야 한다. -> "나 이거 사용할게"라고 표시하는 단계

2. critical section
* 공유 자원에 접근하는 코드이다. 여기서 두 개 이상의 프로세스가 동싱에 들어가면 안 된다. 

3. release lock
* lock을 해제해서 다른 대기하고 있던 프로세스나 스레드가 critical section에 들어갈 수 있도록 해준다. -> "나 다 썼어 다른 사람이 써도 돼"라고 알리는 단계

4. remainder section
* critical section이 끝난 뒤 공유 자원과 상관없는 작업이 수행하는 구간이다. 

5. 전체 구조: 무한 반복
* 이 흐름은 계속 반복된다. 즉 프로세스는 끊임없이 lock 시도 -> critical section접근 -> lock해제 -> 나머지 작업을 반복한다.

<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-10.png" width="600"></p>

&ensp;test_and_set()명령어는 원자적으로(atomically) 실행한다. 그러므로 만일 두 개의 test_and_set()명령어가 동시에 실행된다면(각각 다른 코어에서) 이들은 어떤 임의의 순서로 순차적으로 실행될 것이다. target이 원래 어떤 값이었는지를 알려준다. 그리고 항상 target을 ture로 강제 설정한다. test_and_set은 "현재 잠금 상태를 읽고 바로 잠그는 원자적 동작"이다.<br/>
&ensp;동작 과정<br/>
1. target 포인터가 가리키는 현재 값을 복사해서 지역변수 rv에 저장한다.
2. 그 다음 target 위치에 true를 저장한다.
3. 마지막으로 원래 있던 값(rv)을 리턴한다.

<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-11.png" width="600"></p>

&ensp;false로 초기화되는 lock이라는 boolean 변수를 선언하여 상호 배제를 구현할 수 있다.<br/>

<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-12.png" width="600"></p>

&ensp;compare_and_swap()명령어는 두 개의 워드에 대해 원자적인 연산을 하지만 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다. 원자적으로 실행된다. 이 함수는 항상 수정 전 의 값을 돌려준다. 현재 값이 기대값과 같을 때만 new_value로 바꾼다. 만약 기대값이 아니면 아무것도 하지 않고 넘어간다. <br/>

&ensp;동작 과정<br/>
1. 현재 메모리 값(*value)을 읽어서 temp에 저장한다.
2. 현재 메모리 값이 expected와 같으면 *value를 new_value로 바꾼다.(swap)
3. 언제나 temp(원래 값)을 리턴한다.
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-13.png" width="600"></p>

<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-14.png" width="600"></p>

&ensp;기본 전제<br/>
* 공유 변수 lock이 있다.
* lock은 처음에 0으로 초기화되어 있다.(0 = 아무도 critical section에 들어가 있지 않음, 1 = 누군가 critical section 사용 중)

1. while (compare_and_swap(&lock, 0, 1) != 0)
* compare_and_swap 호출: lock의 값이 0이면 1로 변경하고 원래 값을 반환
* 반환값이 0이면 while을 빠져나가 critical section에 들어간다.
* 반환값이 1이면 다른 프로세스가 critical section을 사용 중이므로 계속 기다린다.

2. /* critical section */
* lock이 성공적으로 걸렸으므로(lock == 1) 이제 공유 자원에 안전하게 접근할 수 있다.
* 다른 프로세스는 lock을 획득하지 못하니까 critical section에 동시에 접근할 수 없다. 

3. lock = 0
* critical section 작업이 끝났으면 lock을 0으로 되돌려서 다른 프로세스가 critical section에 들어올 수 있도록 해준다.

