---
title: "Chapter 6. Synchronization Tools"
excerpt: "논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하여 이를 통해 데이터의 일관성을 유지하는 다양한 매커니즘을 논의한다."

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
use_math: true
toc_sticky: true
  
date: 2025-04-28
last_modified_at: 2025-04-07
---

1\. 배경(Background)
======

&ensp;프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지에 관해 설명한다. <br/>

&ensp;동시에 최대 BUFFER_SIZE - 1개 까지의 항복만을 버퍼에 저장할 수 있다. 이 단점을 없애기 위해서 알고리즘을 수정한다고 가정하자. 한 가지 가능성은 0으로 초기화되어 있는 count라는 정수형 변수를 추가하는 것이다. 버퍼에 새 항목을 추가할 때마다 count값을 증가시키고 버퍼에서 한 항목을 꺼낼 때마다 count 값을 감소시킨다.<br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-1.png" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-2.png" width="600"></p>

&ensp;위에 보인 생산자와 소비자 코드는 개별적으로 올바를지라도 그들을 병행적으로 수행시키면 올바르게 동작하지 않는다.<br/>

&ensp;count++는 다음과 같은 기계어로 구현할 수 있다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-3.png" width="600"></p>

&ensp;count--는 다음과 같이 구현할 수 있다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-4.png" width="600"></p>

&ensp;count++와 count-- 문장을 병행하게 실행하는 것은 앞에 제시한 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 동등하다. 그중 하나는 다음과 같은 순서를 가질 수 있다.(ex. 처음으로 count == 5를 가진 interleaving 실행을 고려)<br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-5.png" width="600"></p>

&ensp;동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 **경쟁 상황(race condition)**이라고 한다.<br/>

2\. 임게구역 문제(The Critical Section Problem)
======

&ensp;각 프로세스는 **임계구역**이라고 부르는 코드 부분을 포함하고 있고 그 안에서는 적어도 하나 이상의 다른 프로세스왁 공유하는 데이터에 접근하고 갱신할 수 있다. 이 시스템의 중요한 특징은 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다는 사실이다. 임계구역 문제는 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것이다. 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 한다. 이러한 요청을 구현하는 코드 부분을 **진입구역(entry section)** 이라고 부른다. 임계구역 뒤에는 **퇴출구역(exit section)** 이 따라올 수 있다. 코드 나머지 부분들은 총칭하여 나머지 구역(remainder section)이라고 부른다. <br/>
<p align="center"><img src="/assets/img/Operating System/6. Synchronization Tools/6-6.png" width="600"></p>

&ensp;임계구역 문제에 대한 해결안은 다음의 세 가지 요구 조건을 충족해야 한다.<br/>

1. 상호 배제(mutual exclusion): 프로세스 Pi가 자신의 임계구역에서 싱행된다면 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.
2. 진행(progress): 자신의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 누가 그 임계구역으로 진입할 수 있는지를 결정하는 데 참여할 수 있으며 이 선택은 무한정 연기될 수 없다.
3. 한정된 대기(bounded waiting): 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다. 
&ensp;각 프로세스가 0이 아닌 속도로 실행되는 것을 가정한다. 그러나 n개의 프로세스 간의 상대적인 속도에 대한 가정은 하지 않는다. <br/>

&ensp;운영체제 내에서 임계구역을 다루기 위해서 **선점형 커널**과 **비선점형 커널**의 두 가지 일반적인 접근법이 사용된다. 선점형 커널은 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다. 비선점형 커널은 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.<br/>
&ensp;비선점형 커널은 한 순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로 커널 자료구조에 대한 경쟁 조건을 염려할 필요는 없다. 선점형 커널에 대해서는 동일한 주장을 할 수 없기 때문에 공유되는 커널 자료구조에서 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 한다.<br/> 