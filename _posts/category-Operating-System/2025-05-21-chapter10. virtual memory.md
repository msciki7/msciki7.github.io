---
title: "Chapter 10. Virtual Memory"
excerpt: ""

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
use_math: true
toc_sticky: true
  
date: 2025-05-21
last_modified_at: 2025-05-21
---

1\. 배경
=======

&ensp;코드는 메모리에 있어야 실행될 수 있지만, 전체 프로그램이 항상 동시에 필요하지는 않는다. <br/>
* 일부 코드(예. 에러 처리, 비정상 루틴 등)만 사용될 수 있다.
* 그래서 프로그램 전체를 한꺼번에 메모리에 올릴 필요가 없다. 
* 부분적으로 로드된 프로그램 실행이 가능하다.

&ensp;그에 인한 효과<br/>
* 물리적 메모리의 제한에 덜 구속된다.
* 각 프로그램이 메모리를 적게 차지 → 더 많은 프로그램을 동시에 실행 가능하다.
* I/O 작업 감소 → 프로그램을 메모리에 로드하거나 스왑할 필요 줄어든다. 
* CPU 활용률 증가.

virtual Memory
------

&ensp;사용자 논리 주소 공간(logical memory space)을 물리 주소 공간(physical memory)과 분리하여 더 유연하게 메모리를 사용하는 방식이다. 

* 이점
    - 프로그램의 일부만 메모리에 있어도 실행 가능.
    - 논리 주소 공간은 물리 주소 공간보다 훨씬 클 수 있음 (예: 64비트 시스템에서 2^64까지).
    - 주소 공간 공유 가능: 여러 프로세스가 코드 영역 등을 공유할 수 있음.
    - 프로세스 생성 효율 향상: 복사보다 매핑이 빠름.
    - 동시 실행 프로그램 수 증가
    - I/O 감소: 로딩과 스왑 빈도 증가


Virtual Address Space
------

&ensp;논리적인 주소 공간으로 프로세스가 메모리를 바라보는 방식이다.<br/>

* 구성
  - 보통 0번 주소부터 연속된 공간으로 시작(실제로는 페이지 단위로 관리)
  - 물리 메모리는 페이지 프레임(frame) 단위로 나뉘며 MMU가 논리 주소를 물리 주소로 변환

* 가상 메모리 구현 방식
  - **Demand Paging(요구 페이징)**
    + 실제로 필요한 페이지만 로드하는 방식
    + 처음에는 아무것도 메모리에 올리지 않는다.
    + 접근이 발생할 때 페이지 폴트(Page Fault)가 발생하면 그때서야 디스크에서 해당 페이지를 로드한다. 

* 예시
&ensp;한 프로그램이 1GB이고, 실제 자주 사용하는 부분은 100MB라고 해보죠.

* 기존 방식
  - 1GB 전체를 메모리에 올려야 실행됨.

* 가상 메모리 + 요구페이징
  - 100MB만 먼저 로드됨.
  - 나머지 900MB는 필요할 때만 점진적으로 로드됨.


Virtual Memory Larger Than Physical Memory
------

<p align="center"><img src="/assets/img/Operating System/10. virtual memory/10-1.png" width="600"></p>

&ensp;구성 요소 설명:<br/>
1. Virtual Memory
* page 0 ~ page v까지 존재하는 가상 메모리의 페이지들이다.
* 각 프로세스는 자신만의 가상 주소 공간을 갖고 있으며, 마치 연속적인 메모리를 쓰는 것처럼 프로그래밍할 수 있다.

2. Memory Map
* 페이지 테이블 또는 매핑 테이블을 의미한다.
* 가상 페이지를 실제 물리 메모리의 어떤 프레임에 매핑할지를 기록해둔 정보이다.
* 예를 들어, page 2 → 물리 메모리의 두 번째 칸으로 매핑됨을 의미한다.

3. Physical Memory
* 실제 컴퓨터의 RAM을 의미한다.
* 크기가 제한되어 있어 모든 가상 페이지를 동시에 담을 수는 없다.
* 자주 쓰는 페이지들만 올라와 있으며, 나머지는 디스크에 보관된다.

4. 디스크/보조 저장소
* 스왑 영역(swap area) 혹은 **백킹 스토어(backing store)**이다.
* 물리 메모리에 없는 가상 페이지들은 여기 저장되어 있다가 필요한 시점에 다시 메모리로 로드된다.

&ensp;동작흐름<br/>
1. 프로세스가 어떤 가상 주소에 접근함.
2. **Memory Map(페이지 테이블)**을 참조하여 해당 주소가 물리 메모리에 존재하는지 확인.
3. 존재하면 바로 접근.
4. 없으면 디스크에서 해당 페이지를 읽어와 물리 메모리에 올림 → 이를 Page Fault라 함.
5. 물리 메모리가 가득 차면 오래된 페이지를 디스크로 내보내고 새로운 페이지를 로드함 (페이지 교체 알고리즘 사용).

&ensp;예시
* 물리 메모리 크기: 4GB
* 가상 메모리 크기: 16GB
* -> 실제 4GB RAM으로 여러 개의 2~3GB급 프로그램을 동시에 실행 가능함.