---
title: "Chapter 14. File-System Implementation"
excerpt: "로컬 파일 시스템 및 디렉터리 구조 구현의 세부 사항을 설명할 수 있다."

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
use_math: true
toc_sticky: true
  
date: 2025-06-10
last_modified_at: 2025-06-10
---

1\. File-System Structure (파일 시스템 구조)<br/>
======

&ensp;<b>파일 시스템</b><br/>
* 파일들을 효율적으로 저장하고 관리하는 시스템
* 운영체제는 이 파일 시스템을 통해 디스크에 저장된 데이터에 접근한다.

&ensp;주요 구성 요소<br/>
<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-1.png" width="600"></p>

&ensp;<b>계층형 파일 시스템(Layered File System)</b><br/>
&ensp;파일 시스템은 여러 단계로 나뉘어 작동해. 각 단계는 역할이 다르다.<br/>

<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-2.png" width="600"></p>

&ensp;각 계층의 역할 자세히 설명<br/>
<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-3.png" width="600"></p>

&ensp;<b>File System Layers</b><br/>

&ensp;운영체제(OS)는 파일을 읽고 쓰기 위해 여러 단계(층, layer)로 나누어서 처리한다. <br/>

&ensp;각 계층별 설명<br/>
1. Device Drivers (장치 드라이버)
* 컴퓨터가 실제 하드디스크나 SSD 같은 장치랑 소통할 수 있게 해주는 소프트웨어

2. Basic File System (기본 파일 시스템)
* 사용자 또는 프로그램이 블록 123 읽어줘 같은 명령을 주면, 이걸 실제 드라이버 명령으로 바꿔주는 역할이야.
* 쉽게 말하면 명령어 번역기 역할!
* 버퍼(buffer): 데이터를 잠깐 저장하는 중간 공간. (예: 도서관 사서가 책 대출을 잠깐 바구니에 담아두는 느낌)
* 캐시(cache): 자주 사용하는 데이터를 미리 저장해놓는 공간. (예: 자주 보는 유튜브 영상 썸네일이 빨리 뜨는 이유!)

3. File Organization Module (파일 조직 모듈)
* 파일이 저장된 **논리적 주소 (파일의 순서)**를 실제 **물리적 주소 (디스크 블록 위치)**로 바꿔준다. 
* 디스크에서 빈 공간 관리
* 파일 저장 시, 공간 할당 (어디에 저장할지 결정)

4. 논리 파일 시스템 (Logical File System)

&ensp;논리 파일 시스템은 파일에 대한 정보를 관리하는 관리자라고 보면 된다.<br/>

&ensp;하는 일:<br/>

* 메타데이터 관리
  - 예를 들어 어떤 파일 이름이 report.txt라면, 이 이름을 실제 위치(파일 번호, 핸들, 주소 등)로 변환해준다.
  - UNIX에서는 이런 정보를 inode라는 구조체에 저장한다.
* 디렉터리 관리
  - 폴더(디렉터리)를 관리하다.
  - 예: /home/user/documents 같은 구조를 관리해주는 것이다.
* 보호 (Protection)
  - 누가 어떤 파일에 접근할 수 있는지 관리해.
  - 예: 어떤 사람은 읽기만 가능, 어떤 사람은 쓰기 가능 등.

&ensp;전체 흐름 예시<br/>
<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-4.png" width="600"></p>

&ensp;왜 계층 구조로 나눴을까?<br/>
* 좋은 점: 복잡한 기능을 계층으로 나누면 관리하기 쉽고, 이해하기 쉽다.
* 단점: 계층이 많으면 성능이 조금 느려질 수 있어. (계층마다 처리하니까 시간이 걸릴 수 있음)

&ensp;다양한 파일 시스템 종류들<br/>
<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-5.png" width="600"></p>


2\. File-System Operation
======

&ensp;<b>File-System Operation</b><br/>
* 우리가 파일을 열거나 저장하거나 지울 때, 운영체제 내부에서는 복잡한 작업들이 일어난다.
* 이런 작업은 **API(예: open(), read(), write())**를 통해 시작되는데, 실제로는 디스크에 저장된 구조(on-disk) 와 메모리에 올라온 구조(in-memory) 두 가지가 같이 작동해야 한다.

1. Boot Control Block (부트 컨트롤 블록)

&ensp;디스크(볼륨)에서 운영체제 부팅을 위한 정보 저장<br/>

* 컴퓨터가 켜졌을 때 가장 먼저 실행되는 정보.
* 운영체제를 어디서부터 읽을지를 기록해둔 영역.
* 대부분 디스크의 첫 번째 블록에 저장돼 있다.
* 만약 디스크가 OS를 포함한다면 이 블록이 꼭 필요하다.

&ensp;"이 디스크에서 OS가 설치돼 있으면, 어디서부터 읽어야 하는지 알려주는 지도!"<br/>

2. Volume Control Block (볼륨 컨트롤 블록)

&ensp;하나의 볼륨(=디스크 파티션)에 대한 전체 정보를 담고 있다.<br/>

&ensp;또는 아래 이름들로 불리기도 한다.<br/>
* 슈퍼블록(superblock) – UNIX 계열
* 마스터 파일 테이블 (master file table) – NTFS 계열

&ensp;주요 정보:<br/>
* 총 블록 수(전체 크기)
* 남은 블록 수(얼마나 여유 공간 있는지)
* 블록 크기
* 빈 블록이 가리키는 포인터 배열(어디에 파일 저장할 수 있는지)

&ensp;"디스크 용량 관리부장! 디스크 공간을 어떻게 쓰고 얼마나 남았는지를 기억해준다."<br/>

3. Directory Structure (디렉터리 구조)

&ensp;실제 파일 이름과 위치 정보들을 모아 둔 표<br/>
* 폴더처럼 보이지만, 사실 내부적으로는 파일 이름과 해당 파일의 inode 번호 등을 저장해둔 리스트 또는 트리 구조이다.
* NTFS에서는 Master File Table, UNIX에서는 디렉터리 + inode 시스템을 사용한다.

&ensp;"파일 이름과 진짜 파일 위치를 연결해주는 주소록!"<br/>

&ensp;<b>FCB (File Control Block)</b><br/>

&ensp;운영체제가 파일 하나당 하나씩 가지고 있는 정보 묶음<br/>

&ensp;파일을 만들거나 열면, OS는 그 파일에 대해 여러 가지 정보를 기억해놔야 하는데, 이걸 모아놓은 게 FCB이다.<br/>

&ensp;FCB 안에 들어 있는 정보들<br/>
<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-6.png" width="600"></p>

1. file permissions (접근 권한)
 * 누가 읽을 수 있고(Read), 쓸 수 있고(Write), 실행할 수 있는지(Execute)

2. file dates (날짜 정보)
* 파일이 언제 만들어졌는지 (created)
* 마지막으로 접근한 시각 (accessed)
* 마지막으로 수정한 시각 (written)

3. file owner, group, ACL (소유자 정보)
* 누가 만든 파일인지 (소유자, 사용자 ID)
* 어떤 그룹에 속해 있는지
* ACL: Access Control List, 사용자별로 권한을 정할 수 있는 고급 기능

4. file size (파일 크기)
* 몇 바이트짜리 파일인지
5. file data blocks or pointers (파일 내용 위치)
* 진짜 데이터를 저장한 위치를 가리키는 포인터
* 디스크에서 해당 파일 내용이 어느 블록에 저장돼 있는지 알려줌

&ensp;<b>In-Memory File System Structures</b><br/>

1. Mount table (마운트 테이블)
* 운영체제가 다양한 파일 시스템을 인식하려면 “마운트”라는 과정을 거쳐야 한다.
* 이 마운트 정보를 기억하는 테이블이 바로 Mount table이다.
  - 어떤 파일 시스템이 어디에 붙었는지(마운트 포인트)
  - 어떤 종류의 파일 시스템인지 (ex: ext4, FAT32 등)

2. System-wide open-file table (시스템 전체 파일 테이블)
* 운영체제가 모든 열린 파일을 한 곳에 기록해두는 테이블이다.
* 각 파일의 FCB(File Control Block) 정보를 복사해서 가지고 있다.

3. Per-process open-file table (프로세스별 파일 테이블)
* 각각의 프로그램(프로세스)이 어떤 파일을 열고 있는지 기록한 테이블이다.
* 이 테이블은 시스템 전체 파일 테이블의 항목을 **가리키는 포인터(주소)**들을 가지고 있다.

<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-7.png" width="600"></p>

&ensp;(a) open(file name) — 파일을 여는 과정<br/>
&ensp;1. 사용자가 open("test.txt") 같은 함수 호출<br/>
&ensp;2. 운영체제는 디스크에 있는 디렉터리 구조에서 test.txt를 찾음<br/>
&ensp;3. 해당 파일의 FCB를 찾고<br/>
&ensp;4. 그 정보를 시스템 전체 파일 테이블에 복사<br/>
&ensp;5. 그리고 그걸 가리키는 포인터를 해당 프로세스의 open-file table에 저장<br/>
&ensp;파일을 여는 순간 여러 테이블이 연결된다.<br/>

&ensp;(b) read(index) — 파일을 읽는 과정<br/>
&ensp;1. 프로그램이 read(3) 같은 함수로 데이터를 읽을 때<br/>
&ensp;2. 3은 프로세스별 open-file 테이블의 인덱스야!<br/>
&ensp;3. 이 인덱스는 시스템 전체 open-file 테이블의 항목을 가리킴<br/>
&ensp;4. 그리고 시스템은 FCB의 정보를 바탕으로 데이터 블록(실제 내용 저장소)을 읽음<br/>

3\. Directory Implementation (디렉토리 구현)
======

&ensp;Linear List 방식<br/>
* **파일 이름과 해당 데이터 블록 위치(포인터)**를 리스트로 차례대로 저장함.
* 장점: 프로그래밍이 간단함.
* 단점: 검색 속도가 느림. (리스트 처음부터 끝까지 비교해야 해서 → 선형 탐색 시간)
* 개선 방법:
  - 사전순으로 정렬된 링크드 리스트나
  - B+ 트리처럼 정렬 구조를 사용하면 조금 빨라질 수 있음.

&ensp; Hash Table 방식<br/>
* 파일 이름을 해시값으로 바꿔서 빠르게 저장하고 찾음.
* 장점: 검색 속도 매우 빠름.
* 단점:
  - 충돌(Collision): 다른 이름이 같은 해시값을 가지는 문제 발생.
  - 고정된 크기이거나, 체이닝(chained-overflow) 같은 해결 방식이 있어야 좋음.

&ensp;<b>Allocation Method (할당 방식)</b><br/>

&ensp;필요성: 하드디스크에는 파일을 저장할 공간이 블록(block) 단위로 나뉘어 있음. -> 어떤 파일이 어떤 블록에 저장될지를 정하는 것이 할당 방식!<br/>

&ensp;세 가지 방식<br/>
1. Contiguous (연속 할당)
2. Linked (연결 할당)
3. FAT (파일 할당 테이블 방식)

&ensp;<b>Contiguous Allocation Method (연속 할당 방식)</b><br/>

&ensp;특징<br/>

* 한 파일의 모든 블록이 연속적으로 저장됨.
* 시작 블록 번호와 블록 수만 알면 바로 접근 가능 -> 속도 빠름!

&ensp;장점<br/>

* 성능이 가장 좋음 (랜덤 액세스도 빠름)
* 구현도 비교적 단순

&ensp;단점<br/>

* 저장할 연속 공간을 찾기 어려움
* 파일 크기를 미리 알아야 함
* 외부 단편화(External Fragmentation) 발생
  - 조각난 빈 공간들이 많아져서 효율이 떨어짐
  - 해결책: 압축(compaction) 작업 필요 (오프라인/온라인)

&ensp;논리 주소 → 물리 주소 매핑<br/>
* 예시:
  - 블록 크기 = 512바이트
  - 논리 주소(LA)를 512로 나누면 몫 = Q, 나머지 = R
* Q = 블록 번호, R = 블록 안에서의 위치
* 실제로 접근할 블록: 시작 주소 + Q

<p align="center"><img src="/assets/img/Operating System/14. File System Implementation/14-8.png" width="600"></p>

