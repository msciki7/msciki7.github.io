---
title: "Chapter 11. Mass Storage System"
excerpt: "다양한 보조저장장치의 물리적 구조와 장치 구조가 활용에 미치는 영향을 설명한다."

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
use_math: true
toc_sticky: true
  
date: 2025-05-28
last_modified_at: 2025-05-28
---

1\. 대용량 저장장치 구조의 개관(Overview of Mass-Storage Structure)
======

1. 🌀 자기 디스크(Magnetic Disks)
* 하드디스크(HDD) 라고도 한다.
* 컴퓨터가 사진이나 게임, 동영상 같은 파일을 오래 저장해두는 곳이다.
* 이 디스크는 빙글빙글 돈다(보통 1분에 5,400 ~ 15,000번 돈다.)
* 정보를 읽거나 쓸 때는 100~250 MB/s 정도로 빠르다.

2. ⏱️ 저장장치의 속도
&ensp;Assess Time(접근 시간) = Seek Time(arm이 움직이는 시간) + Rotational Latency(디스크 돌면서 기다리는 시간) + Transfer Time(진짜 읽고 쓰는 시간)<br/>

3. 🧷 컴퓨터랑 하드디스크는 어떻게 연결돼 있을까?
&ensp;하드디스크는 그냥 혼자 작동하지 않는다. 컴퓨터와 I/O 버스를 통해 대화한다. <br/>
&ensp;I/O 버스는 다양한 종류가 있다. <br/>
* ATA / SATA: 가장 많이 쓰이는 연결 방식
* SCSI / SAS: 서버나 전문가용 컴퓨터에서 사용
* NVMe: 요즘 빠른 SSD에서 사용하는 최신 기술
&ensp;**host controller**가 컴퓨터 안에서 이 디스크와 말을 주고받는 역할을 해준다.<br/>

Hard Disk Drive(HDD)
------

<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-1.png" width="600"></p>

* Disk (디스크): 정보(파일)가 저장되는 회전 판이야. 우리가 그림이나 글을 저장하면 여기에 기록된다.
* Spindle (스핀들): 디스크를 중심에서 돌려주는 막대야. 디스크는 빠르게 회전한다.
* Saved File (저장된 파일): 우리가 저장한 글이나 사진 같은 데이터가 들어있는 부분이다.
* Read/Write Head (읽기/쓰기 머리): 정보를 읽거나 쓰는 역할을 해. 연필처럼 데이터를 적고 지우고 읽는다.
* Arm (팔): 머리를 움직이는 팔이야. 필요한 위치로 읽기/쓰기 머리를 이동시킨다.
* Actuator (액추에이터): 이 팔을 실제로 움직이는 엔진 같은 장치이다.
* Circuit Board (회로판): 하드디스크의 머리와 팔이 잘 움직이게 명령을 내리는 전자 두뇌
* Power Port (전원) & Data Cable Port (데이터): 컴퓨터랑 연결해서 전기를 공급하고 정보를 주고받게 해준다.

&ensp;Moving-head Disk Mechanism<br/>
<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-2.png" width="600"></p>

* Platter (플래터): 정보가 저장된 여러 개의 둥근 판들
* Track (트랙): 도넛처럼 둥글게 된 저장 위치. 트랙은 동그란 선처럼 정보가 줄줄이 적혀 있다.
* Sector(섹터): 트랙을 조각낸 작은 단위, 정보를 더 작게 쪼개서 저장할 수 있다.
* Cylinder (실린더): 같은 위치에 있는 여러 층의 트랙을 위아래로 모은 거야. 한 번에 여러 층에서 같은 위치를 읽을 수 있다.
* Read/Write Head (읽기/쓰기 머리): 판 위에서 정보를 읽거나 쓰는 장치.
* Arm (팔): 헤드를 원하는 트랙으로 이동시켜주는 팔.
* Spindle (스핀들): 판을 돌리는 중심 막대.
* Arm Assembly (팔 조립체): 모든 팔을 함께 움직이는 장치야.

&ensp;작동 과정<br/>
1. 디스크는 계속 회전하고 있다. 
2. 내가 저장한 파일을 읽고 싶으면 
3. 팔이 움직여서 정확한 위치에 읽기/쓰기 머리를 갖다댄다.
4. 머리가 그 위치에서 정보를 읽거나 쓴다. 

Solid-State Drive(SSD; 비휘발성 메모리 장치치)
------

&ensp;SSD는 컴퓨터에 저장공간을 제공하는 장치이다. 하지만 예전에 쓰던 하드디스크랑 다르다. 움직이는 부품이 없고 빠르게 작동한다. <br/>

&ensp;특징<br/>
1. 움직이는 부품이 없다. 
&ensp;그래서 조용하고 잘 안 망가진다. HDD처럼 돌아가는 소리도 안 난다. <br/>
2. 속도가 빠르다. 
3. 비싸다. 
4. 수명이 조금 짧을 수도 있다. 

&ensp;SSD는 저장하는 방식<br>
* 데이터를 페이지 단위로 저장한다. (4KB ~ 16 KB 크기)
* 지울 땐 블록 단위로 지워진다. (블록은 64~512개의 페이지로 이루어져 있다.)

&ensp;SSD 컨트롤러(SSD Controller)가 하는 일🧠<br/>
1. FTL(Flash Translation Layer): 운영체제가 저장하려는 주소(LBA)를 진짜 SSD위치로 바꿔준다. 
2. Wear Leveling (웨어 레벨링): 한 곳만 자주 쓰면 금방 닳으니까 골고루 나눠서 쓰게 해준다.
3. Garbage Collection (쓰레기 수거): 예전에 쓰던 낡은 데이터를 정리해서 빈 공간을 만들어준다.
4. Error Correction(ECC): 데이터가 깨지지 않게 확인하고 고쳐준다. 
5. Bad Block Management: 고장난 공간은 자동으로 피해서 사용한다. 

&ensp;FTL(Flash Translation Layer)<br/>
1. FTL이란?
&ensp;운영체제(OS)는 저장공간을 논리 주소(Logical Block Address, LBA)로 관리한다. 그런데 SSD는 실제 데이터를 저장할 때 물리적인 페이지 단위로 저장한다. 이때 논리 주소(LBA)를 실제 저장되는 물리 주소로 바꿔주는 역할을 하는 게 바로 FTL이다. 
&ensp;예시<br/>
* 어떤 데이터를 수정하면, 기존 페이지 위에 덮어쓰는 게 아니라 새로운 페이지에 데이터 쓰고 예전 페이지는 더 이상 안 씀이라고 표시한다. 
* 예전 페이지: invalid
* 새 페이지: valid

2. 페이지 수정은 어떻게 이루어질까?
&ensp;HDD와 다르게 SSD는 페이지 단위로 쓰고 블록 단위로 지운다. <br/>
* SSD는 페이지 단위로 데이터 기록 가능(4KB ~ 16KB)
* 지울 때는 페이지가 아닌 블록(64 ~ 512페이지)단위로만 가능

3. Garbage Collection(쓰레기 수집)
* 위처럼 페이지를 계속 새로 쓰다 보면 예전 페이지들이 조각난 채로 남아있는 상태가 된다. 
* 이런 쓸모없는 invalid 페이지들이 쌓이면 공간 낭비이다.
&ensp;이때 garbage collection이 나타난다.<br/>

&ensp;Garbage Collection 역할:<br/>
* 전체 블록을 보고 유효한 데이터만 복사해서 새로운 블록에 옮긴다.
* 기존 블록은 통째로 지워서 다시 쓸 수 없게 만든다.

&ensp;흐름 요약<br/>
1. 운영체제는 논리 주소(LBA)로 데이터 요청
2. FTL이 논리 주소를 물리 주소로 변환
3. 데이터 수정 시 새 페이지에 기록, 기존 페이지는 무효 처리
4. 무효 페이지가 많아지면 → Garbage Collection 작동
5. 사용 중인 데이터만 다른 블록으로 옮기고, 원래 블록은 지움

Magnetic Tape 🎞️(휘발성 메모리)
------

1. 초창기 보조 저장장치
* 컴퓨터에 하드디스크나 SSD가 생기기 전 초기 컴퓨터에서 저장용으로 사용되었다.
2. 오래 보관 가능하고 대용량 저장 가능
* 데이터를 오래 저장할 수 있고 200GB ~ 1.5TB정도 저장 가능하다. 요즘도 백업용으로 사용된다.
3. 랜덤 접근(Random Access)이 매우 느림
* 하드디스크는 원하는 위치로 바로 가서 데이터를 읽을 수 있는데 테이프는 앞에서부터 감으면서 찾아야 한다.
* 그래서 디스크보다 1000배 느리다. 

&ensp;그럼에도 불구하고 아직 쓰이는 이유?<br/>

1. 백업용으로 좋다.
* 평소에 잘 안 쓰는 데이터를 오래 저장할 때 좋음
* 예: 기업의 월별 거래 기록, 오래된 사용자 로그 등

2. 전송 속도는 느리지 않는다.
* 데이터를 테이프 헤드 아래에 위치시키면 디스크랑 비슷한 속도(140MB/s 이상)로 읽을 수 있다.

Disk Structure
------

1. 🧱 디스크는 어떻게 구성되어 있을까?
&ensp;디스크는 실제로는 둥근 판(플래터)이지만 운영체제는 이것을 1차원 배열처럼 생각한다. 즉 디스크 전체를 쭉 늘어놓은 것처럼 보고 거기서 한 칸 한 칸을 논리적 블록(logical block)이라고 부른다. <br/>
&ensp;논리적 블록(Logical Block) = 디스크에서 데이터를 읽고 쓰는 가장 작은 단위

2. 📦 논리적 블록 -> 실제 디스크 위치로 매핑
&ensp;디스크는 실제로는 둥글게 생겼고 다음과 같은 구조를 가진다. 
* 트랙(track): 디스크 표면에 원 모양으로 그려진 원
* 섹터(sector): 하나의 트랙을 조각처럼 나눈 것
* 실린더(cylinder): 여러 플래터의 같은 위치 트랙들을 수직으로 모아 놓은 것
&ensp;운영체제는 이 모든 구조를 감추고, 단순한 배열처럼 다루기 위해 논리적 블록 번호 0부터 쭉 순서대로 매핑하다.<br/>

3. 🧷 섹터 0부터 순서대로 배치
* 논리적 블록 0번은 디스크의 가장 바깥쪽 실린더의 첫 번째 트랙의 첫 번쩨 섹터에 위치함
* 그 다음 논리적 블록들은 트랙을 따라 쭉 이동
* 트랙이 끝나면 다음 트랙으로 이동
* 다음 실린더, 다음 면으로 차례대로 저장된다. 

&ensp;요약<br/>
<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-3.png" width="600"></p>


2\. 디스크 스케줄링(Disk Scheduling)
======

&ensp;디스크 스케줄링(Disk Scheduling): 디스크는 데이터를 저장하고 읽는 장치인데 여러 프로그램이 동시에 디스크를 사용하려하면 요청이 줄(queue)을 만들어 기다리게 된다. 운영체제는 이 요청들을 빠르고 효율적으로 처리하도록 순서를 잘 정해야 한다. 이게 바로 디스크 스케줄링이다.<br/>

* 운영체제의 역할:
    - 디스크 접근을 빠르게 하고 최대 대역폭을 얻도록 도와주는 게 목표이다.
* seek time 최소화: 
    - 디스크 헤드가 원하는 위치까지 움직이는 시간을 seek time이라고 하는데 이걸 최대한 줄이는 게 좋다.
* bandwidth(대역폭): 
    - 데이터를 옮기는 총량 / 걸린 시간 
    - 즉 얼마나 빨리 많은 데이터를 옮겼는지를 나타내는 지표이다.

* 디스크 I/O 요청은 다양한 곳에서 발생한다.:
    - 운영체제 자체
    - 시스템 프로세스
    - 사용자 프로그램 등
* 요청에는 다음 정보가 담겨 있어: 
    - 읽기/쓰기 여부
    - 어느 디스크 주소인지
    - 메모리 주소
    - 몇 개 섹터를 옭길 건지 등
* 요청이 많을 때는 줄을 세워 처리해야 한다.
* 이럴 때 사용하는 게 디스크 스케줄링 알고리즘이다. 단 줄이 없으면(요청 하나면)알고리즘은 의미가 없다.

* 디스크 컨트롤러도 작은 버퍼(임시 저장소)를 갖고 있어서 I/O 요청을 어느 정도 관리할 수 있다.
* 디스크 스케줄링 알고리즘이 여러 개 존재한다.:
    - 예: FCFS, SSTF, SCAN, LOOK, C-SCAN 등
* 예제: 
    - ✏️ 요청 큐: 98, 183, 37, 122, 14, 124, 65, 67
    - 현재 헤드 위치: 53
&ensp;목적은 보통 전체 이동 거리를 최소화하거나 응답 시간을 일정하게 만드는 거다.<br/>

1. FCFS(First-Come, First-Served)란?
&ensp;말 그대로 먼저 온 요청부터 처리한다.<br/>
* 디스크 헤드(데이터를 읽는 바늘)는 요청 순서대로 이동한다.

&ensp;✏️ 요청 큐 (queue):<br/>
&ensp;98, 183, 37, 122, 14, 124, 65, 67 <br/>
&ensp;디스크 헤드는 53번 위치에서 시작한다. 이제 요청 순서대로 이동할 것이다. <br/>
1. 53 → 98 → 이동 거리: 45
2. 98 → 183 → 이동 거리: 85
3. 183 → 37 → 이동 거리: 146
4. 37 → 122 → 이동 거리: 85
5. 122 → 14 → 이동 거리: 108
6. 14 → 124 → 이동 거리: 110
7. 124 → 65 → 이동 거리: 59
8. 65 → 67 → 이동 거리: 2

<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-5.png" width="600"></p>

&ensp;총 이동 거리:<br/>
&ensp;45 + 85 + 146 + 85 + 108 + 110 + 59 + 2 = 640 cylinders

&ensp;특징 및 단점 <br/>
<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-4.png" width="600"></p>

2. SSTF (Shortest Seek Time First)
&ensp;SSTF 알고리즘: 현재 헤드 위치에서 가장 가까운 요청을 먼저 처리하는 알고리즘이다. <br/>
* FCFS는 그냥 줄 선 순서대로 가니까 효율이 떨어진다.
* SSTF는 최소 이동 거리를 계산해서 가장 가까운 위치로 먼저 가는 알고리즘이다.
* SSTF는 오직 현재 큐에 있는 요청들 중에서 가장 가까운 위치를 선택한다. (지금 현재 기준에서 거리 계산)


&ensp;✏️ 요청 큐 (queue):<br/>
&ensp;98, 183, 37, 122, 14, 124, 65, 67 <br/>
&ensp;디스크 헤드는 53번 위치에서 시작한다.<br/>
1. 현재 53 → 가장 가까운 건 65 (이동 거리 12)
2. 65 → 67 (거리 2)
3. 67 → 37 (거리 30)
4. 37 → 14 (거리 23)
5. 14 → 98 (거리 84)
6. 98 → 122 (거리 24)
7. 122 → 124 (거리 2)
8. 124 → 183 (거리 59)
&ensp;총 이동 거리:<br/>
&ensp;12 + 2 + 30 + 23 + 84 + 24 + 2 + 59 = 236 cylinders<br/>

<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-6.png" width="600"></p>

&ensp;장점<br/>
* 효율: 헤드 이동 거리를 줄여서 빠르고 효율적이다.
* 성능: FCFS의 640 → SSTF는 236으로 줄어들었다.

&ensp;⚠️ SSTF의 단점: Starvation<br/>
* 어떤 요청이 자꾸 "먼 데"에 있으면 무한히 무시될 수 있다.
* 왜냐면 가까운 요청만 계속 먼저 처리되니까

3. 🚂 SCAN
&ensp;SCAN 알고리즘: 엘리베이터처럼 디스크 헤드가 왔다 갔다 하면서 요청을 처리하는 방식이다. <br/>
* 디스크는 수많은 트랙(실린더)으로 구성되어 있다.
* 디스크 헤드는 한 번에 한 위치에만 접근할 수 있다.
* 그래서 여러 요청이 있을 때 어떤 순서로 요청을 처리할지 디스크 스케줄링을 해줘야 한다. 

&ensp;🛠️ SCAN 알고리즘 동작 원리
1. 디스크 헤드(팔 같은 장치)가 한 쪽 끝 방향으로 쭉 이동하면서
2. 그 방향에 있는 모든 요청을 순서대로 처리한다.
3. 끝까지 갔다면 방향을 바꿔서 반대편으로 이동하면서 요청을 또 처리한다. 
&ensp;그래서 엘리베이터 알고리즘이라고 불린다. <br/>

&ensp;🧾 요청 목록 (Queue):<br/>
&ensp;98, 183, 37, 122, 14, 124, 65, 67 <br/>
* 헤드는 53번 위치에서 시작한다.
* SCAN은 0방향으로 먼저 간다고 가정한다. 

<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-7.png" width="600"></p>

1. 현재 53에서 출발해서 37 → 14 → (0 도착, 끝까지 감)
2. 방향 전환 → 65 → 67 → 98 → 122 → 124 → 183
&ensp;총 이동한 실린더 수: 236<br/>

&ensp;SCAN의 장점<br/>
<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-8.png" width="600"></p>

&ensp;단점<br/>
* 끝까지 간 다음에 다시 돌아오는 동안은 요청을 기다려야 하므로 평균 성능은 SSTF보다 약간 떨어질 수도 있다. 

4. C-SCAN
&ensp;C-SCAN 알고리즘: SCAN을 더 발전시킨 버전이다. 엘레베이터가 맨 아래로 내려가지 않고 다시 꼭대기로 순간이동하는 느낌이다. 디스크 헤드가 한 방향으로만 이동하면서 요청을 처리하고 끝에 도달하면 다시 처음으로 돌아가서 반복하는 방식이다. <br/>

* 한 방향(예: 오른쪽)으로만 쭉 가면서 요청 처리.
* 끝에 도달하면, 반대편 끝으로 건너뛰고, 다시 같은 방향으로 쭉 이동.

&ensp;어떻게 작동하나요?<br/>
&ensp;🧾 요청 목록 (Queue):<br/>
&ensp;98, 183, 37, 122, 14, 124, 65, 67 <br/>
* 헤드는 53번 위치에서 시작한다.

1. 디스크 헤드는 53번에서 시작한다.
2. 오른쪽(숫자 큰 쪽)으로만 이동하면서 요청(예: 65, 67, 98, 122, 124, 183)을 처리한다.
3. 끝까지 도달한 뒤에는 요청이 없어도 디스크의 가장 왼쪽(0번 위치)으로 빠르게 점프해서 돌아온다.
4. 다시 오른쪽으로 쭉 훑으면서 남은 요청(예: 14, 37)을 처리한다. 
&ensp;→ 마치 엘리베이터가 꼭대기 층까지 갔다가, 다시 1층으로 바로 내려와서 사람을 태우는 것과 비슷하다.<br/>

<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-10.png" width="600"></p>

&ensp;장점<br/>
* 공정하다: 요청 순서에 따라 무작위로 처리하는 게 아니라, 모든 요청을 한 방향으로만 정리해서 처리하니까 기다림이 골고루 분배
* 예상하기 쉽다.: 헤드가 오른쪽으로 갔으니까, 나중에 왼쪽 끝에서 다시 시작하겠구나!" 하고 예상할 수 있다.
* 기다리는 시간이 비슷해진다.: SCAN보다 더 균등한(wait time 균일) 응답 시간이 보장된다. 

&ensp;SCAN vs C-SCAN<br/>
* 📍 SCAN: 왕복형 → 가면서도, 돌아오면서도 요청 처리.
    - 비유: 엘리베이터가 위층으로 올라가며 사람들을 태우고, 내려오면서도 사람을 태운다.
    - 왔다 갔다 하면서 요청 처리 → 효율은 좋지만 가운데 있는 요청은 빨리, 끝쪽 요청은 늦게 처리될 수 있음
* 📍 C-SCAN: 순환형 → 한 방향으로만 요청 처리하고, 끝에서 돌아올 때는 건너뛰고 다시 처음부터 시작.
    - 비유: 엘리베이터가 위층으로 올라가며 사람들을 태우고, 내려올 때는 사람을 안 태우고 그냥 1층으로 돌아온다.
    - 한쪽 방향으로만 요청 처리 → 모든 요청이 비슷하게 기다림, 공정성 더 높음

<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-11.png" width="600"></p>

&ensp;✨ 공정성 & 성능 비교<br/>
<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-9.png" width="600"></p>

Selecting a Disk-Scheduling Algorithm
------

 1. SSTF는 보편적이고 자연스럽다.
 * SSTF는 Shortest Seek Time First의 약자
 * 지금 헤드 위치에서 가장 가까운 요청을 먼저 처리하는 방식이다.
 * 예를 들어, 지금 헤드가 53번에 있는데 50번과 100번 요청이 있다면 → 50번을 먼저 처리한다.
 * 그래서 자연스럽게 빠르게 처리된다고 느끼고 많이 쓰인다.
 &ensp;📌 비유: 엘리베이터가 가까운 층부터 순서대로 멈추는 느낌!<br/>

 2. SCAN과 C-SCAN은 디스크 사용량이 많을 때 좋다.
 * SCAN, C-SCAN은 디스크에 요청이 많이 몰릴 때 더 공정하고 안정적으로 처리한다. 
 * SCAN은 엘리베이터처럼 왔다 갔다 하면서, C-SCAN은 한 방향만 돌고 빠르게 처음으로 돌아와서 처리한다.
 &ensp;📌 즉, 요청이 많아도 기다리는 사람을 차별하지 않고 잘 나눠주는 알고리즘<br/>

 3. 파일 저장 방식에 따라 디스크 요청도 달라짐
 * 디스크 안에 파일을 저장하는 방법(예: 연속적으로, 조각조각 등)에 따라 디스크에서 데이터를 찾는 요청이 모양이 달라질 수 있다.
 * 파일 위치 정보(=메타데이터)가 디스크에 어떻게 저장되어 있는지도 영향을 준다.
&ensp;📌 즉, 어떤 스케줄링을 쓰면 좋을지는 파일 저장 방식에도 영향을 받는다.

&ensp;정리<br/>
<p align="center"><img src="/assets/img/Operating System/11. Mass Storage System/11-12.png" width="600"></p>