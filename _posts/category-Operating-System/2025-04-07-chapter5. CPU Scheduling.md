---
title: "Chapter 5. CPU Scheduling"
excerpt: ""

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
toc_sticky: true
  
date: 2025-04-07
last_modified_at: 2025-04-07
---


1\. 기본 개념
======

&ensp;코어가 하나인 시스템에서는 한 순간에 오직 하나의 프로세스만 실행될 수 있다. 나머지 프로세스는 CPU의 코어가 가용 상태가 되어 다시 스케줄 될 수 있을 때까지 기다려야 한다. 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다. <br/>

&ensp;1_CPU-I/O 버스트 사이클(CPU-I/O Burst Cycle)<br/>
&ensp;프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다. 프로세스 실행은 CPU 버스트(burst)로 시작된다. 뒤이어 I/O 버스트가 발행하고 그 뒤를 이어 또 다른 CPU 버스트가 발행하며 이어 또 다른 I/O 버스트 등등으로 진행된다. <br/>

&ensp;2_CPU 스케줄러(CPU Schedler)<br/>
&ensp;CPU가 유휴 상태가 될 때마다 운영체제는 준비 큐에 있는 프로세스 중 하나를 선택해 실행해야 한다. 선택절차는 CPU 스케줄러에 의해 수행된다. 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여 이들 중 하나에게 CPU를 할당한다.<br/>

<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-1.png" width="600"></p>

&ensp;3_선점 및 비선점 스케줄링(Preemptive and Nonpreemptive Scheduling)<br/>
&ensp;CPU 스케줄링 결정은 네 가지 상황에서 발생할 수 있다.<br/>
* 한 프로세스가 실행 상태에서 대기 상태로 전환될 때<br/>
* 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때<br/>
* 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때<br/>
* 프로세스가 종료할 때<br/>

<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-2.png" width="600"></p>

&ensp; 상황 1, 4에서만 스케줄링이 발생할 경우 우리는 이러한 스케줄링 방법을 비선점(nonpreemptive) 또는 협조적(cooperative)이라고 한다. 그렇지 않으면 그것은 선점(preemptive)이라고 한다. 비선점 스케줄링하에서는 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다. <br/>

&ensp;4_디스패처(Dispatcher)<br/>
&ensp;CPU 스케줄링 기능에 포함된 또 하나의 요소는 디스패처(dispatcher)이다. 디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈이며 다음 같은 작업을 포함한다.<br/>
* 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일<br/>
* 사용자 모드로 전환하는 일<br/>
* 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일<br/>

&ensp;디스패처는 모든 프로세스의 문맥 교환 시 호출되므로 가능한 한 최고로 빨리 수행되어야 한다. 디스패처가 하나 이 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소요되는 시간을 디스패치 지연(dispatch latency)이라고 한다. <br/>
<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-3.png" width="600"></p>


2\. 스케줄링 기준(Scheduling Criteria)
======

* CPU 이용률(utilization): 실제 시스템에서는 40%에서 90%까지의 범위를 가져야 한다.<br/>
* 처리량(throughput): CPU가 프로세스를 수행하느라고 바쁘다면 작업이 진행되고 있는 것이다. 작업량 측정의 한 방법은 단위 시간당 완료된 프로세스의 개수이다. 이것을 처리량(thoughput)이라고 한다. <br/>
* 총처리 시간(turnaround time): 특정한 프로세스의 입장에서 보면 중요한 기준은 그 프로세스를 실행하는 데 소요된 시간일 것이다. 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 한다. 총처리 시간은 준비 큐에서 대기한 시간, CPU에서 실행하는 시간, 그리고 I/O 시간을 합한 시간이다.<br/>
* 대기시간(waiting time): CPU 스케줄링 알고리즘은 프로세스가 실행하거나 I/O을 하는 시간의 양에 영향을 미치지는 않는다. 스케줄링 알고리즘은 단지 프로세스가 준비 큐에서 대기하는 시간의 양에만 영향을 준다. 대기 시간은 준비 큐에서 대기하면서 보낸 시간의 합이다.<br/>
* 응답 시간(response time): 대화식 시스템에서 총처리 시간은 최선의 기준이 아닐 수도 있다. 프로세스가 어떤 출력을 매우 일찍 생성하고 앞서의 결과가 사용자에게 출력되는 사이에 새로운 결과를 얻으려고 연산을 계속하는 경우가 있다. 따라서 또 다른 기준은 하나의 요구를 제출한 후 첫 번쨰 응답이 나올 때까지의 시간이다. 응답시간이라고 하는 이 기준은 응답이 시작되는 데까지 걸리는 시간이지 그 응답을 출력하는 데 걸리는 시간은 아니다.<br/>

&ensp;CPU 이용률과 처리량을 최대화하고 총처리 시간, 대기 시간, 응답 시간을 최소화하는 것이 바람직하다. 대부분의 경우 평균 측정 시간을 최적화하려고 한다. 그러나 어떤 경우에는 평균보다는 최솟값 또는 최댓값을 최적화하는 것이 바람직할 수도 있다.<br/>

3\. 스케줄링 알고리즘(Scheduling Algorithms)
======

&ensp;CPU 스케줄링은 준비 큐에 있는 어느 프로세스에 CPU코어를 할당할 것인지를 결정하는 문제를 다룬다. <br/>

&ensp;1_선입 선처리 스케줄링(First-Come, First_Served Scheduling)<br/>
&ensp;가장 간단한 CPU 스케줄링 알고리즘은 선입 선처리(FCFS)스케줄링 알고리즘이다. 이 방법에서는 CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다. 프로세스가 준비 큐에 집입하면 이 프로세스의 프로세스 제어 블록(PCB)을 큐의 끝에 연결한다. CPU가 가용 상태가 되면 준비 큐의 앞부분에 있는 프로세스에 할당된다. 이 실행 상태의 프로세스는 이어 준비 큐에서 제거된다. 부정적인 측면으로 선입 선처리 정책하에서 평균대기 시간은 종종 길 수 있다.<br/>

<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-4.JPEG" width="600"></p>
&ensp;프로세스들이 p1, p2, p3 순으로 도착하고 선입 선처리 순으로 서비스받는다면 다음의 Gantt차트(참여한 각 프로세스의 시작 시각과 종료 시각을 포함하여 특정 스케줄 기법을 도시하는 막대형 차트)에 보인 결과를 얻는다. <br/>

<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-5.JPEG" width="600"></p>

&ensp;프로세스 p1의 대기 시간은 0밀리초이며 프로세스 p2는 24밀리초이고 프로세스 p3은 27밀리초이다. 그러므로 평균대기 시간은 (0 + 24 + 27)/3 = 17밀리초이다. 그러나 프로세스들이 p2, p3, p1 순으로 도착하면 다음 Gantt차트와 같다.<br/>

<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-6.JPEG" width="600"></p>

&ensp;평균대기 시간은 이제 (6+0+3)/3 = 3밀리초이다. 그러므로 선입 선처리 정책하에서 평균대기 시간은 일반적으로 최소가 아니며 프로세스 CPU 버스트 시간이 크게 변할 경우에는 평균대기 시간도 상당히 변할 수 있다. 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양동하기를 기다리는 것을 호위 효과(convoy effect)라고 한다. 이 효과는 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저하되는 결과를 낳는다. 선입 선처리 스케줄링 알고리즘은 비선점형이다. 일단 CPU가 한 프로세스에 할당되면 그 프로세스가 종료하든지 또는 I/O 처리를 요구하든지 하여 CPU를 방출할 때까지 CPU를 점유한다.<br/>

&ensp;2_최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)<br/>
&ensp;CPU 스케줄링의 다른 접근 방법은 최단 작업 우선(shortest-job-first, SJF)알고리즘이다. 이 알고리즘은 각 프로세스에 다음 CPU 버스트 길이를 연관시키다. CPU가 이용 가능해지면 가장 작은 다음 CPU 버스트를 가진 프로세스에 할당한다. 두 프로세스가 동일한 길이의 다음 CPU버스트를 가지면 순위를 정하기 위해 선입 선처리 스케줄링을 적용한다. <br/>

<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-7.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-8.JPEG" width="600"></p>

&ensp;프로세스 p1의 대기 시간은 3밀리초, 프로세스 p2의 대기 시간은 16밀리초, 프로세스 p3는 9밀리초이고 프로세스 p4는 0초이다. 그러므로 평균대기 시간은 (3 + 16 + 9 + 0)/4 = 7밀리초이다. <br/>
&ensp;SFJ 스케줄링 알고리즘은 주어진 프로세스 집합에 대해 최소의 평균대기 시간을 가진다는 점에서 최적임을 증명할 수 있다. 짧은 프로세스를 긴 프로세스 앞으로 이동함으로써 짧은 프로세스의 대기 시간을 긴 프로세스의 대기 시간이 증가하는 것보다 더 많이 줄일 수 있다. SJF 알고리즘이 최적이긴 하지만 다음 CPU 버스트의 길이를 알 방법이 없기 때문에 CPU 스케줄링 수준에서는 구현할 수 없다. 다음 CPU 버스트의 길이를 알 수 없으나 그 값을 예측할 수는 있을 것이다. 우리는 다음 CPU 버스트가 이전의 버스트와 길이가 비슷하다고 기대한다. 그러므로 다음 CPU 버스트 길이의 근삿값을 계산해 가장 짧은 예상 CPU 버스트를 가진 프로세스를 선택한다. <br/>
&ensp;다음 CPU 버스트는 일반적으로 측정된 이전의 CPU 버스트들의 길이를 지수 평균한 것으로 예측한다. <br/>
&ensp;SJF 알고리즘은 선점형이거나 또는 비선점형일 수 있다. 앞의 프로세스가 실행되는 동안 새로운 프로세스가 준비 큐에 도착하면 선택이 발생한다. 새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU 버스트를 가질 수도 있다. 선점형 SJF 알고리즘은 현재 실행하는 프로세스를 선점할 것이고 반면에 비선점형 SJF 알고리즘은 때때로 최소 잔여 시간 우선(shortest remaining time first)스케줄링이라고 불린다. <br/>

<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-9.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/5. CPU Scheduling/5-10.JPEG" width="600"></p>

&ensp;프로세스 p1은 큐에 있는 유일한 프로세스이므로 시간 0에 시작된다. 프로세스 p2는 시간 1에 도착한다. 프로세스 p1의 남은 시간(7밀리초)이 프로세스 p2가 요구하는 시간(4밀리초)보다 크기 때문에 프로세스 p1이 선점되고 프로세스 p2가 스케줄된다. 평균대기 시간은 [(10-1) + (1-1) + (17-2) + (5-3)]/4 = 26/4 = 6.5밀리초이다.<br/>











