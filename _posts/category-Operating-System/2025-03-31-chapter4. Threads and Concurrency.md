---
title: "Chapter 4. Threads and Concurrency"
excerpt: ""

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
toc_sticky: true
  
date: 2025-03-31
last_modified_at: 2025-03-31
---

1\.Overview
=======

&ensp;1_Motivation<br/>
&ensp;현대의 컴퓨터와 모바일 기기에서 작동하는 거의 모든 소프트웨어 응용들은 다중 스레드를 이용한다. 하나의 응용 몇 개의 실행 흐름을 가진 독립적인 프로세스로 구현된다. <br/>
&middot; 이미지 모음에서 사진 축소판을 만든느 응용 프로그램은 별도의 스레드를 사용하여 개별 이미지에서 축소판을 생성할 수 있다. <br/>
&middot; 웹 브라우저는 하나의 스레드가 이미지 또는 텍스트를 표시하고 다른 스레드는 네트웨크에서 데이터를 검색하도록 할 수 있다. <br/>
&middot; 위드 프로세스에는 그래픽을 표시하는 스레드, 사용자의 키 입력에 응답하는 또 다른 스레드 및 백그라운드에서 맞춤법 및 문법 검사를 수행하는 세 번
째 스레드가 있을 수 있다. <br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-1.JPEG" width="600"></p>

&ensp;응용은 다중 코어 시스템에서 처리 능력을 향상시키도록 설계될 수 있다. 이러한 응용은 다중 계산 코어를 사용하여 다수의 CPU 집중 작업을 병렬로 처리할 수 있다. 하나의 응용 프로그램이 여러 개의 비슷한 작업을 수행할 필요가 있는 상황들이 또한 있다. 하나의 분주한 웹 서버는 여러 개의 클라이언트들이 병행하게 접근할 수 있다. 하나의 해결책은 서버가 요청이 들어오면 프로세스는 그 요청을 수행할 별도의 프로세스를 생성하는 것이다. 사실 이와 같은 방식으로 프로세스를 생성하는 것은 스레드가 대중화되기 전에는 매우 보편적이다. 하지만 새 프로세스가 해야 할 일이 기존 프로세스가 하는 일과 동일하다면 왜 이 많은 오버헤드를 감수해야 하는가? 대부분은 그렇게 하는 것보다는 프로세스 안에 여러 스레드를 만들어 나가는 것이 더 효율적이다. 웹 서버가 다중 스레드화 되면 서버는 클라이언트의 요청을 listen하는 별도의 스레드를 생성한다. 요청이 들어오면 다른 프로세스를 생성하는 것이 아니라 요청을 서비스할 새로운 스레드를 생성하고 추가적인 요청을 listen 하기 위한 작업을 재개한다. <br/>
&ensp;대부분의 운영체제 커널도 일반적으로 다중 스레드이다. 각 스레드는 장치 관리, 메모리 관리 또는 인터럽트 처리와 같은 특정 작업을 수행한다. ps -ef 명령을 사용하여 실행 중인 Linux 시스템에서 커널 스레드를 표시할 수 있다. 이 명령의 출력을 검사하면 커널 스레드 kthreadd(pid = 2)가 표시되며 다른 모든 커널 스레드의 부모 역할을 한다. 많은 응용 프로그램도 기본 정렬, 트리 및 그래프 알고리즘을 포함하여 다중 스레드를 활용할 수 있다. 또한 데이터 마이닝, 그래픽 및 인공지능에서 CPU 중심의 최신 문제를 해결해야 하는  프로그래머는 병렬로 실행되는 솔루션을 설계하여 최신 다중 코어 시승템의 성능을 활용할 수 있다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-2.JPEG" width="600"></p>

&ensp;2_장점<br/>
&ensp;1 응답성(reponsiveness) : 대화형 응용을 다중 스레드화하면 응용 프로그램의 일부분이 봉쇄되거난 응용프로그램이 긴 작업을 수행하더라도 프로그램의 수행이 계속되는 것을 허용함으로써 사용자에 대한 응답성을 증가시킨다. 이 특징은 사용자 인터페이스를 설계하는 데 있어 특히 유용하다. 대조적으로 시가닝 오래 걸리는 연산이 별도의 비동기적 스레드에서 실행된다면 응용은 여전히 사용자에게 응답할 수 있다. <br/>

&ensp;2 자원공유(resource sharing) : 프로세스는 공유 메모리와 메시지 전달 기법을 통하여만 자원을 공유할 수 있다. 이러한 기법은 프로그래머에 의해 명시적으로 처리되어야 한다. 그러나 스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다. 코드와 데이터 공유의 이점은 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다는 점이다.<br/>

&ensp;3. 경제성(economy) : 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에 스레드를 생성하고 문맥 교환하는 것이 더욱더 경제적이다. 오버헤드의 차이를 경험적으로 측정하는 것은 어려울 수 있지만 일반적으로 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 소비한다. 또한 문맥 교환은 일반적으로 프로세스 사이보다 스레드 사이에서 더 빠르다.<br/>

&ensp;규모 적응성(scalability) : 다중 스레드의 이점은 다중 처리기 구조에서 더욱 증가할 수 있다. 다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있기 때문이다. 단일 스레드 프로세스는 처리기가 아무리 많더라도 오직 한 처리기에서만 실행된다.<br/>


2\. 다중 코어 프로그래밍(Multicore Programming)
======

&ensp;각 코어는 운영체제에 별도의 CPU로 보인다. 이러한 시스템을 다중 코어라고 하며 다중 스레드 프로그래밍은 이러한 여러 컴퓨칭 코어를 보다 효율적으로 사용하고 병행성을 향상시키는 기법을 제공한다. 단일 컴퓨팅 코어가 있는 시스템에서는 단지 처리 코어가 한 번에 하나의 스레드만 실행할 수 있기 때문에 병행성은 시간이 지남에 따라 스레드 실행이 인터리브됨을 의미한다. 그러나 여러 코어가 있는 시스템에서 병행성은 시스템이 각 코어에 별도의 스레드를 할당할 수 있기 때문에 일부 스레드가 병렬로 실행될 수 있음을 의미한다. <br/>

&ensp;병행 시스템은 모든 작업이 진행되게 하여 둘 이상의 작업을 지원한다. 이에 반해 병렬 시스템은 둘 이상의 작업을 동시에 수행할 수 있다. 따라서 병렬성 없이 병행성을 가질 수 있다. 다중 처리기 및 다중 코어 아키텍처가 출현하기 전에 대부분의 컴퓨터 시스템에서는 단일 프로세스만 있었으며 CPU 스케줄러는 프로세스 간에 빠르게 전환해 각 프로세스 간에 빠르게 전환해 각 프로세스가 진행되도록 하여 병렬성의 환상을 제공하였다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-3.JPEG" width="600"></p>

&ensp;1_프로그래밍 도전과제(Programming Challenges)<br/>
&ensp;다중 코어 시스템으로 발전하는 추세는 시스템 설계자뿐 아니라 응용 프로그래머에게도 다중 코어의 활용도를 높일 수 있도록 압력을 행사하고 있다. 응용 프로그래머는 기존 프로그램을 다중 스레드를 사용하도록 수정해야 하고 새로운 다중 스레드 프로그램을 설계해야 하는 도전에 당면해 있다. <br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-4.JPEG" width="600"></p>

&ensp;Amdahl's Law<br/>
&ensp;Amdahl's Law는 순차 실행(병렬 실행이 아닌) 구성요소와 병렬 실행 구성요소로 이루어진 응용에 추가의 계산 코어를 더했을 때 얻을 수 있는 잠재적인 성능 이득을 나타내는 공식이다. N개의 처리 코어를 가진 시스템에서 실행되는 응용 중 반드시 순차적으로 실행되어야만 하는 구성요소를 S라고 하면 이 공식은 다음과 같다. 

&ensp;1. 태스크 인식(indentifying tasks) : 응용을 분석하여 독립된 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요하다. 이상적으로 태스크는 서로 독립적이고 따라서 개별 코어에서 병렬 실행될 수 있어야 한다.<br/>

&ensp;2. 균형(balance) : 병렬로 실행될 수 있는 태스크를 찾아내는 것도 중요하지만 찾아진 부분들이 전체 작업에 균등한 기여도를 가지도록 태스크로 나누는 것도 매우 중요하다.<br/>

&ensp;3. 데이터 분리(data spliting) : 응용이 독립된 태스크로 나누어지는 것처럼 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나누어져야 한다.<br/>

&ensp;4. 데이터 종속성(data dependency) : 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다. 한 태스크가 다른 태스크로부터 오는 데이터에 종속적인 경우에는 프로그래머가 데이터 종속성을 수용할 수 있도록 태스크의 수행을 잘 동기화해야 한다.<br/>

&ensp;5. 시험 및 디버깅(testing and debugging) : 프로그램이 다중 코어에서 병렬로 실행될 때 다양한 실행 경로가 존재할 수 있다. <br/>

&ensp;Amdahl's Law가 시사하는 사실 중 하나는 N이 무한대에 가까워지면 속도는 1/S에 수렴한다는 것이다. 예를 들어 응용의 40%가 순차 실행 부분이라면 코어를 아무리 추가한다고 하더라도 최대 2.0배 이상의 속도 향상은 얻을 수 없다. 이러한 사실이 바로 Amdahl's Law이면에 존재하는 근본적인 원칙이다. 응용의 순차 실행 부분은 코어를 추가하여 얻을 수 있는 성능 향상에 불균형적인 영향을 미친다.<br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-5.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-6.JPEG" width="600"></p>

&ensp;2_병렬 실행의 유형<br/>
&ensp;데이터 병렬 실행은 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는 데 초점을 맞춘다. 예를 들어 크기가 N인 배열의 내용을 더하는 경우를 생각해본다. 단일 코어 시스템에서는 하나의 스레드가 원소 [0]부터 [N-1]를 더하면 된다. 그러나 듀얼 코어 시스템에서는 코어 0에서 실행되는 스레드 A는 원소 [0]부터 [N/2-1]까지 더하고 코어 1에서 실행되는 스레드 B는 원소 [N/2]부터 [N-1]까지 더할 수 있다. 두 스레드는 각자 계산 코어에서 병렬로 실행된다. <br/>
&ensp;태스크 병렬 실행은 데이터가 아니라 태스크(스레드)를 다수의 코어에 분배한다. 각 스레드는 고유의 연산을 실행한다. 다른 스레드들이 동일한 데이터에 대한 연사을 실행할 수 있고 혹은 서로 다른 데이터에 연산을 실행할 수도 있다. 위에 상화과는 대조적으로 배열에 대해 각자 고유한 통계 연사을 수행하는 2개의 스레드가 필요할 수 있다. 이 스레드들은 개별 코어에서 병렬로 실행되지만 각각 고유한 연산을 실행한다. 기본적으로 데이터 병렬 처리에는 여러 코어에 데이터를 분배하는 것이 포함된다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-7.JPEG" width="600"></p>


3\. 다중 스레드 모델(Multithreading Models)
======

&ensp;스레드를 위한 지원은 사용자 스레드(user threads)를 위해서는 사용자 수준에서 또는 커널 스레드(kernel threads)를 위해서는 커널 수준에서 제공된다. 사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리된다. 반면에 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다. <br/>

&ensp;1_다대일 모델(Many-to-One Model)<br/>
&ensp;다대일 모델은 많은 사용자 수준 스레드를 하나의 커널 스레드로 사상한다. 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다. 따라서 효율적이지만 한 스레드가 봉쇄형 시스템 콜을 할 경우 전체 프로세스가 봉쇄된다. 또한 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-9.JPEG" width="600"></p>

&ensp;2_일대일 모델(One-to-one Model)<br/>
&ensp;일대일 모델은 각 사용자 스레드를 각각 하나의 커널 스레드로 사상한다. 이 모델은 하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 때문에 다대일 모델보다 더 많은 병렬성을 제공한다. 또한 이 모델은 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용한다. 이 모델의 단점은 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 하며 많은 수의 커널 스레드가 시스템 성능에 부담을 줄 수 있다는 것이다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-8.JPEG" width="600"></p>

&ensp;3_다대다 모델(Many-to-Many Model)<br/>
&ensp;다대다 모델은 여러 개의 사용자 수준 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플레스한다. 커널 스레드 수는 응용 프로그램이나 특정 기계에 따라 결정된다. 다대일 모델은 개발자가 원하는 만큼의 사용자 수준 스레드를 생성하도록 허용하지만 커널은 한 번에 하나의 커널 스레드만 스케줄 할 수 있기 때문에 진정한 병렬 실행을 획득할 수 없다. 일대일 모델은 더 많은 병행 실행을 제공하지만 개발자가 한 응용 내에 너무 많은 스레드를 생성하지 않도록 주의해야 한다. 다대다 모델의 변형은 여전히 많은 사용자 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스 시키지만 또한 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것만 허용한다. 이 변형은 때로 두 수준 모델(two-level model)이라고 불린다. 

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-10.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-11.JPEG" width="600"></p>


4\. 스레드 라이브러리(Threads Library)
======

&ensp;스레드 라이브러리는 프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공한다. 스레드 라이브러리를 구현하는 데에는 주된 두 가지 방법이 있다. 첫 번째 방법은 커널의 지원 없이 완전히 사용자 공간에서만 라이브러리를 제공하는 것이다. 라이브러리를 모든 코드와 자료구조는 사용자 공간에 존재한다. 라이브러리 함수를 호출하는 것은 시스템 콜이 아니라 사용자 공간의 지역 함수를 호출하게 된다는 것을 의미한다. <br/>

&ensp;두 번째 방법은 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하는 것이다. 이 경우 라이브러리를 위한 코드와 자료구조는 커널 공간에 존재한다. 라이브러리 API를 호출하는 것은 커널 시스템 콜을 부르는 결과를 낳는다.<br/>

&ensp;현재 POSIX Pthreads, Window 및 Java의 세 종류 라이브러리가 주로 사용된다. POSIX 표준 안의 스레드 확장판인 Pthreads는 사용자 또는 커널 수준 라이브러리로서 제공될 수 있다.<br/>

&ensp;비동기 스레딩과 동기 스레딩은 다수의 스레드를 생성한다. 비동기 스레딩은 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 서로 독립적으로 병행하게 실행된다. 스레가 독립적이기 때문에 스레드 사이의 데이터 공유는 거의 없다.<br/>
&ensp;동기 스레딩은 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 방식을 말한다. 여기서 부모가 생성한 스레드는 병행하게 실행되지만 부모는 자식들의 작업이 끝날 때까지 실행을 계속할 수 없다. 부모 스레드는 오직 모든 자식 스레드가 조인한 후에야 실행을 재개할 수 있다. 통상 동기 스레딩은 스레드 사이의 상당한 양의 데이터 공유를 수반한다. <br/>

&ensp;1_Pthreads<br/>
&ensp;Pthreads는 POSIX가 스레드 생성과 동기화를 위해 제정한 표준 API이다. 이것은 스레드의 동작에 관한 명세일 뿐이지 그것 자체를 구현한 것은 아니다. 이 명세를 가지고 운영체제 설계자들은 그들 나름대로 그것을 구현할 수 있다. <br/>

&ensp;Pthreads 프로그램에서 별도의 스레드는 지정된 함수에서 실행을 시작한다. 이 프로그램이 실행을 시작하면 하나의 제어 스레드가 main()함수에서 시작한다. 약간의 초기화 후에 main()은 runner() 함수에서 실행을 시작하는 두 번째 스레드를 생성한다. 두 스레드는 전역 변수 sum을 공유한다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-11.png" width="600"></p>

&ensp;모든 Pthreads 프로그램은 pthreadh 헤더 파일을 포함해야 한다. pthreadad_t tid 문장은 우리가 생성할 스레드를 위한 식별자를 선언한다. 각 스레드는 스택의 크기와 스케줄링 정보를 포함한 속성의 집합을 갖는다. pthread_attr_t attr 선언은 스레드를 위한 속성을 나타낸다. 속성을 지정하지 않으면 디폴트 속성을 사용한다. 별도의 스레드는 pthread_create()를 이용하여 생성한다. 스레드 식별자와 스레드의 속성뿐 아니라 새로운 스레드가 실행을 시작할 함수의 이름도 전달한다. 마지막으로 명령어 라인 상에 제공된 정수 매개변수인 argv[1]을 전달한다.<br/>
&ensp;이 시점에서 프로그램은 main()함수의 최초 스레드와 runner()함수에서 합을 계산하는 합 스레드의 두 개 스레드를 가지게 된다. 이 프로그램은 스레드 생성/조인 전략을 사용한다. 합산 스레드를 생성한 후에 pthread_join() 함수를 호출하여 합산 스레드가 종료하기를 부모 스레드는 기다린다. 합산 스레드는 pthread_exit() 함수를 호출하여 종료하게 된다. 합산 스레드가 복귀하면 부모 스레드는 공유 데이터 sum의 값을 출력한다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-12.png" width="600"></p>

&ensp;2_Window 스레드(Windows Threads)<br/>
&ensp;Windows 스레드 라이브러리를 이용하여 스레드를 생성하는 기술을 많은 점에서 Pthreadsr기법과 유사하다. Pthreads버전과 마찬가지로 개별 스레드가 공유하는 데이터는 전역 변수로 선언된다. 우리는 또한 별도의 스레드에서 수행될 Summation() 함수도 정의하다. 이 함수는 void형을 가리키는 포인터 변수를 인자로 전달받는다. 이 데이터 형을 Windows 에서는 LPVOID로 정의한다. 이 함수를 실행하는 스레드 이 함수를 실행하는 스레드는 0부터 Summation() 함수에 전달된 매개변수까지의 합을 전역 데이터 Sum에 저장한다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-13.png" width="600"></p>

&ensp;Window API에서 스레드 CreateThread() 함수에 의해 생성되고 Pthreads와 마찬가지로 이 함수에 스레드를 위한 속성의 집합이 전달된다. 이 속성에는 보안 정보, 스택의 크기 및 스레드가 보류 상태(suspended state)에서 시작하는지를 나타낼 수 있는 플래그 등이 포함된다. 이 프로그램에서는 이 속성들을 위한 디폴트 값을 사용한다. 합산 스레드가 생성되면 부모는 합산 스레드에 의해 지정된어야 할 Sum의 값을 출력하기 전에 합산 스레드가 종료하기를 기다려야 한다. Pthreads 프로그램이 pthread_join() 문을 이용하여 부모 스레드가 합산 스레드가 종료될 때까지 기다리게 한다. 이와 동일한 작업을 Window API에서는 WairForSingleObject()함수를 이용하여 수행하는데 이 함수는 합산 스레드가 종료할 때까지 생성 스레드가 봉쇄되도록 한다. 이 함수는 다음과 같은 4개의 매개변수를 전달받는다. <br/>
&ensp;1. 기다려야 하는 객체의 개수<br/>
&ensp;2. 객체 배열을 가리키는 포인터<br/>
&ensp;3. 모든 객체가 신호를 보내왔는지를 나타내는 플래그<br/>
&ensp;4. 대기해야 하는 타임아웃 시간<br/>

&ensp;3_Java 스레드(Java Thread)<br/>
&ensp;스레드는 Java 프로그램의 프로그램 실행의 근본적인 모델이고 Java 언어와 API는 스레드의 생성과 관리를 지원하는 풍부한 특성을 제공한다. 모든 Java 프로그램은 적어도 하나의 단일 제어 스레드를 포함하고 있다. 단지 main()함수로만 이루어진 단순한 Java 프로그램조차 JVM 내의 하나의 단일 스레드로 수행된다. Java 스레드는 JVM을 제공하는 어떠한 시스템에서도 사용할 수 있다. <br/>
&ensp;Java 프로그램에서 스레드를 명시적으로 생성하는 데에는 두 가지 기법이 있다. 한 가지 방법은 Thread 클래스에서 파생된 새 클래스를 만들고 run() 메소드를 재정의하는 것이다. 대안 기법은 Runnavle 인터페이스를 구현하는 클래스를 정의하는 것이다. 이 인터페이스는 public void run()의 서명을 가진 단일 추상 메소드를 정의한다. Runnable을 구현하는 클래스의 run() 메소드 코드는 별도의 스레드에서 실행된다.<br/>


&ensp;Java에서 스레드를 생성하려면 Thread 객체를 생성하고 Runnable을 구현하는 클래스의 인스턴스를 전달한 다음 Thread 객체의 start() 메스드를 호출해야 한다. 새 Thread 객체에 대해 start() 메소드를 호출하면 두 가지 작업이 수행된다.<br/>
&ensp;1. 메모리 할당되고 JVM 내에 새로운 스레드가 초기화된다.<br/>
&ensp;2. run() 메소드를 호출하면 스레드가 JVM에 의해 수행될 자격을 갖게 한다.<br/>

&ensp;Pthreads 및 Windows 라이브러리의 부모 스레드는 pthread_join() 및 Wait-ForSingleObject()를 사용하여 각 스레드가 완료되기를 기다렸다가 계속 진행한다. Java의 join()메소드는 유사한 기능을 제공한다. 부모가 여러 스레드가 완료되기를 기다려야 하는 경우 join()메소드는 for 루프로 묶을 수 있다. <br/>

&ensp;Thread 객체를 명시적으로 생성하는 대신 Executor 인터페이스를 중심으로 스레드 생성을 구성한다. 이 인터페이스를 구현하는 클래스는 Runnable 객체가 인자가 전달되는 execute() 메소드를 정의해야 한다. Java 개발자에게는 별도의 Thread 객체를 만들고 start() 메소드를 호출하는 대신 Executor를 사용하는 것을 의미한다. Executor는 다음과 같이 사용된다.<br/>
&ensp;Windows와 Pthreads에서 공유 데이터는 단순히 전역적으로 선언되기 때문에 동일한 프로세스에 속한 스레드 간의 데이터 공유는 쉽게 가능하다. 순수한 객체 지향 언어인 Java에는 적역 데이터에 대한 개념이 없다. Runnable을 구현하는 클래스에 매개변수를 전달할 수 있지만 Java 스레드는 결과를 반환할 수 없다. 이러한 필요를 해결하기 위해 java.util.concurrent패키지는 Callable 인터페이스를 추가로 정의하며 결과를 반환할 수 있다는 점을 제외하고 Runnable과 유사하게 작동한다. Callable 작업에서 반환된 결과를 Future 객체라고 한다.<br/>
&ensp;Summation 클래스는 메소드 call()을 지정하는 Callable 인터페이스를 구현한다. 이 call() 메소드의 코드는 별도의 스레드에서 실행된다. 이 코드를 실행하기 위해 ExecutorService 유형의 newSingleThreadExecutor 객체를 생성하고 submit() 메소드를 사용하여 Callable 태스크를 전달한다. Callable 태스크를 스레드에 제출하면 스레드가 반환하는 Future 객체의 get() 메소드를 호출하여 결과를 기다린다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-14.JPEG" width="600"></p>


5\. 암묵적 스레딩(Implicit Threading)
======

&ensp;다중 코어 처리의 지속적 성장에 따라 수백 또는 심지어 수천 개의 스레드를 가진 응용이 등장하게 되었다. 그러나 응용을 설계하는 것은 사소한 일이 아니며 프로그래머는 어려움을 극복해야 한다. 이러한 어려움을 극복하고 병행 및 병렬 응용의 설계를 도와주는 한 가지 방법은 스레딩의 생성과 관리 책임을 응용 개발자로부터 컴파일러와 실행시간 라이브러리에게 넘겨주는 것이다. 암묵적 스레딩을 이용하여 다중 코어 처리기를 활용할 수 있는 응용 프로그램을 설계하는 4가지 접근법을 탐구한다. 작업은 일반적으로 함수로 작성되며 런타임 라이브러리는 일반적으로 다대다 모델을 사용하여 별도의 스레드에 매핑된다. 이 방법의 장점은 개발자가 병렬 작업만 식별하면 되고 라이브러리는 스레드 생성 및 관리에 대한 특정 세부 사항을 결정한다는 것이다. <br/>

&ensp;1_스레드 풀(Thread Pool)<br/>
&ensp;웹 서버는 요청을 받을 때마다 그 요청을 위해 새로운 스레드를 만들어 준다. 새로운 스레드를 매요청마다 만들어주는 것은 그때마다 새로운 프로세스를 만들어주는 것보다는 확실히 더 진보된 방법임은 틀림없지만 다중 스레드 서버는 아직도 여러 문제를 가지고 있다.<br/>
&ensp;첫 번째 문제는 서비스할 때마다 스레드를 생성하는 데 소요되는 시간이다. 두 번째 이슈는 모든 요청마다 새 스레드를 만들어서 서비스해 준다면 시스템에서 동시에 실행할 수 있는 최대 스레드 수가 몇 개까지 가능할 수 있는 것인지 한계를 정해야 한다. 스레드를 무한정 만들면 언젠가는 CPU 시간, 메모리 공간 같은 시스템 자원이 고갈된다. 이러한 문제들을 해결해 줄 수 있는 방법의 하나가 스레드 풀이다. <br/>
&ensp;스레드들은 평소에는 하는 일 없이 일감을 기다리게 된다. 서버는 스레드를 생성하지 않고 요청을 받으면 대신 스레드 풀에 제출하고 추가 요청 대기를 재개한다. 풀레 사용 가능한 스레드가 있으면 깨어나고 요청이 즉시 서비스된다. 풀에 사용 가능한 스레드가 없으면 사용 가능한 스레드가 생길 때까지 작업이 대기도니다. 스레드가 서비스를 완료하면 풀로 돌아가서 더 많은 작업을 가다린다. 풀에 제출된 작벙을 비동기적으로 실행할 수 있는 경우 스레드 풀이 제대로 작동한다.<br/>

&ensp;1. 새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 종종 빠르다.<br/>
&ensp;2. 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다. 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다. 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다.<br/>
&ensp;3. 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크를 실행을 다르게 할 수 있다. <br/>

&ensp;스레드 풀이 있는 스레드의 개수는 CPU 수, 물리 메모리 용량, 동시 요청 클라이언트 최대 개수 등을 고려하여 정해질 수 있다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-15.JPEG" width="600"></p>

&ensp;PoolFunction()을 가리키는 포인터가 스레드 풀 API 중 하나의 함수에 전달되고 풀 중의 한 스레드가 이 함수를 실행한다. 그러한 스레드 풀 API 중 한 함수가 QueueUserWorkItem() 함수이며 이 함수는 다음과 같은 세 매개변수를 전달받는다.<br/>
* LPTHREAD_START_ROUTINE Function: 별도의 스레드가 실행할 함수에 대한 포인터<br/>
* PVOID param: Function에 전달될 매개변수<br/>
* ULONG Flags: 스레드 풀이 스레드를 생성하고 관리하는 방법을 가리키는 플래그<br/>

&ensp;Java 스레드 풀(Java Thread Pools)<br/>
&ensp;java.util.concurrent 패키지에는 여러 종료의 스레드 풀 구조에 대한 API가 포함되어 있다.<br/>
&ensp;1. 단일 스레드 Executor, newSingleThreadExecutor()는 크기가 1인 풀을 생성한다.<br/>
&ensp;2. 고정 스레드 Executor, newFixedThreadPool(int size)는 지정된 수의 스레드가 있는 스레드 풀을 생성한다.<br/>
&ensp;3. 캐시 스레드 Executor, newCachedThreadPool()는 많은 경우 스레드를 재사용하는 무제한 스레드 풀을 생성한다.<br/>

* FixedThreadPool : 고정된 개수의 스레드 풀을 생성한다. 모든 스레드가 바쁘면 작업이 대기열에 쌓여서 스레드가 빌 때까지 기다린다. 안정적인 작업에 적합하다.<br/>
* CachedThreadPool : 필요할 때 스레드를 생성하고 사용하지 않는 스레드를 재사용한다. 크기가 무한히 늘어날 수 있으므로 주의가 필요하다. 짧고 bursty(간헐적으로 몰리는) 작업에 적합하다.<br/>
* SingleThreadExecutor : 하나의 워커 스레드만 생성한다. 작업 FIFO(First-In-First_Out) 순서로 순차적으로 실행한다. 직렬작업처리에 적합하지만 멀티스레드 환경 내에서 사용될 수 있다.<br/>

&ensp;2_Fork Join<br/>
&ensp;이 메소드를 사용하면 메인 부모 스레드가 하나 이상의 자식 스레드를 생성(fork)한 다음 자식의 종료를 기다린 후 join하고 그 시점부터 자식의 결과를 확인하고 결합한다. 이 동기식 모델은 종종 명시적 스레드 생성이라고 특징지어지지만 암시적 스레딩에도 사용될 수 있다. 후자의 상황에서 fork 단계에서는 스레드가 직접 구축되지 않고 대신 병렬 작업이 식별된다. 라이브러리는 생성되는 스레드 수를 관리하며 스레드에 작업 배정을 책임진다. 어떤 식으로든 이 fork-join 모델은 라이브러리가 생성할 실제 스레드 수를 결정하는 동기 버전의 스레드 풀이다.

















