---
title: "Chapter 4. Threads and Concurrency"
excerpt: "프로세스의 개별 구성요소를 식별하고 운영체제에서 해당 구성요소가 어떻게 표현되고 스케줄 되는지 기술한다."

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
toc_sticky: true
  
date: 2025-03-31
last_modified_at: 2025-03-31
---

1\.Overview
=======

&ensp;1_Motivation<br/>
&ensp;현대의 컴퓨터와 모바일 기기에서 작동하는 거의 모든 소프트웨어 응용들은 다중 스레드를 이용한다. 하나의 응용 몇 개의 실행 흐름을 가진 독립적인 프로세스로 구현된다. <br/>
&middot; 이미지 모음에서 사진 축소판을 만든느 응용 프로그램은 별도의 스레드를 사용하여 개별 이미지에서 축소판을 생성할 수 있다. <br/>
&middot; 웹 브라우저는 하나의 스레드가 이미지 또는 텍스트를 표시하고 다른 스레드는 네트웨크에서 데이터를 검색하도록 할 수 있다. <br/>
&middot; 위드 프로세스에는 그래픽을 표시하는 스레드, 사용자의 키 입력에 응답하는 또 다른 스레드 및 백그라운드에서 맞춤법 및 문법 검사를 수행하는 세 번
째 스레드가 있을 수 있다. <br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-1.JPEG" width="600"></p>

&ensp;응용은 다중 코어 시스템에서 처리 능력을 향상시키도록 설계될 수 있다. 이러한 응용은 다중 계산 코어를 사용하여 다수의 CPU 집중 작업을 병렬로 처리할 수 있다. 하나의 응용 프로그램이 여러 개의 비슷한 작업을 수행할 필요가 있는 상황들이 또한 있다. 하나의 분주한 웹 서버는 여러 개의 클라이언트들이 병행하게 접근할 수 있다. 하나의 해결책은 서버가 요청이 들어오면 프로세스는 그 요청을 수행할 별도의 프로세스를 생성하는 것이다. 사실 이와 같은 방식으로 프로세스를 생성하는 것은 스레드가 대중화되기 전에는 매우 보편적이다. 하지만 새 프로세스가 해야 할 일이 기존 프로세스가 하는 일과 동일하다면 왜 이 많은 오버헤드를 감수해야 하는가? 대부분은 그렇게 하는 것보다는 프로세스 안에 여러 스레드를 만들어 나가는 것이 더 효율적이다. 웹 서버가 다중 스레드화 되면 서버는 클라이언트의 요청을 listen하는 별도의 스레드를 생성한다. 요청이 들어오면 다른 프로세스를 생성하는 것이 아니라 요청을 서비스할 새로운 스레드를 생성하고 추가적인 요청을 listen 하기 위한 작업을 재개한다. <br/>
&ensp;대부분의 운영체제 커널도 일반적으로 다중 스레드이다. 각 스레드는 장치 관리, 메모리 관리 또는 인터럽트 처리와 같은 특정 작업을 수행한다. ps -ef 명령을 사용하여 실행 중인 Linux 시스템에서 커널 스레드를 표시할 수 있다. 이 명령의 출력을 검사하면 커널 스레드 kthreadd(pid = 2)가 표시되며 다른 모든 커널 스레드의 부모 역할을 한다. 많은 응용 프로그램도 기본 정렬, 트리 및 그래프 알고리즘을 포함하여 다중 스레드를 활용할 수 있다. 또한 데이터 마이닝, 그래픽 및 인공지능에서 CPU 중심의 최신 문제를 해결해야 하는  프로그래머는 병렬로 실행되는 솔루션을 설계하여 최신 다중 코어 시승템의 성능을 활용할 수 있다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-2.JPEG" width="600"></p>

&ensp;2_장점<br/>
&ensp;1 응답성(reponsiveness) : 대화형 응용을 다중 스레드화하면 응용 프로그램의 일부분이 봉쇄되거난 응용프로그램이 긴 작업을 수행하더라도 프로그램의 수행이 계속되는 것을 허용함으로써 사용자에 대한 응답성을 증가시킨다. 이 특징은 사용자 인터페이스를 설계하는 데 있어 특히 유용하다. 대조적으로 시가닝 오래 걸리는 연산이 별도의 비동기적 스레드에서 실행된다면 응용은 여전히 사용자에게 응답할 수 있다. <br/>

&ensp;2 자원공유(resource sharing) : 프로세스는 공유 메모리와 메시지 전달 기법을 통하여만 자원을 공유할 수 있다. 이러한 기법은 프로그래머에 의해 명시적으로 처리되어야 한다. 그러나 스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다. 코드와 데이터 공유의 이점은 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다는 점이다.<br/>

&ensp;3. 경제성(economy) : 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에 스레드를 생성하고 문맥 교환하는 것이 더욱더 경제적이다. 오버헤드의 차이를 경험적으로 측정하는 것은 어려울 수 있지만 일반적으로 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 소비한다. 또한 문맥 교환은 일반적으로 프로세스 사이보다 스레드 사이에서 더 빠르다.<br/>

&ensp;규모 적응성(scalability) : 다중 스레드의 이점은 다중 처리기 구조에서 더욱 증가할 수 있다. 다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있기 때문이다. 단일 스레드 프로세스는 처리기가 아무리 많더라도 오직 한 처리기에서만 실행된다.<br/>


2\. 다중 코어 프로그래밍(Multicore Programming)
======

&ensp;각 코어는 운영체제에 별도의 CPU로 보인다. 이러한 시스템을 다중 코어라고 하며 다중 스레드 프로그래밍은 이러한 여러 컴퓨칭 코어를 보다 효율적으로 사용하고 병행성을 향상시키는 기법을 제공한다. 단일 컴퓨팅 코어가 있는 시스템에서는 단지 처리 코어가 한 번에 하나의 스레드만 실행할 수 있기 때문에 병행성은 시간이 지남에 따라 스레드 실행이 인터리브됨을 의미한다. 그러나 여러 코어가 있는 시스템에서 병행성은 시스템이 각 코어에 별도의 스레드를 할당할 수 있기 때문에 일부 스레드가 병렬로 실행될 수 있음을 의미한다. <br/>

&ensp;병행 시스템은 모든 작업이 진행되게 하여 둘 이상의 작업을 지원한다. 이에 반해 병렬 시스템은 둘 이상의 작업을 동시에 수행할 수 있다. 따라서 병렬성 없이 병행성을 가질 수 있다. 다중 처리기 및 다중 코어 아키텍처가 출현하기 전에 대부분의 컴퓨터 시스템에서는 단일 프로세스만 있었으며 CPU 스케줄러는 프로세스 간에 빠르게 전환해 각 프로세스 간에 빠르게 전환해 각 프로세스가 진행되도록 하여 병렬성의 환상을 제공하였다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-3.JPEG" width="600"></p>

&ensp;1_프로그래밍 도전과제(Programming Challenges)<br/>
&ensp;다중 코어 시스템으로 발전하는 추세는 시스템 설계자뿐 아니라 응용 프로그래머에게도 다중 코어의 활용도를 높일 수 있도록 압력을 행사하고 있다. 응용 프로그래머는 기존 프로그램을 다중 스레드를 사용하도록 수정해야 하고 새로운 다중 스레드 프로그램을 설계해야 하는 도전에 당면해 있다. <br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-4.JPEG" width="600"></p>

&ensp;Amdahl's Law<br/>
&ensp;Amdahl's Law는 순차 실행(병렬 실행이 아닌) 구성요소와 병렬 실행 구성요소로 이루어진 응용에 추가의 계산 코어를 더했을 때 얻을 수 있는 잠재적인 성능 이득을 나타내는 공식이다. N개의 처리 코어를 가진 시스템에서 실행되는 응용 중 반드시 순차적으로 실행되어야만 하는 구성요소를 S라고 하면 이 공식은 다음과 같다. 

&ensp;1. 태스크 인식(indentifying tasks) : 응용을 분석하여 독립된 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요하다. 이상적으로 태스크는 서로 독립적이고 따라서 개별 코어에서 병렬 실행될 수 있어야 한다.<br/>

&ensp;2. 균형(balance) : 병렬로 실행될 수 있는 태스크를 찾아내는 것도 중요하지만 찾아진 부분들이 전체 작업에 균등한 기여도를 가지도록 태스크로 나누는 것도 매우 중요하다.<br/>

&ensp;3. 데이터 분리(data spliting) : 응용이 독립된 태스크로 나누어지는 것처럼 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나누어져야 한다.<br/>

&ensp;4. 데이터 종속성(data dependency) : 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다. 한 태스크가 다른 태스크로부터 오는 데이터에 종속적인 경우에는 프로그래머가 데이터 종속성을 수용할 수 있도록 태스크의 수행을 잘 동기화해야 한다.<br/>

&ensp;5. 시험 및 디버깅(testing and debugging) : 프로그램이 다중 코어에서 병렬로 실행될 때 다양한 실행 경로가 존재할 수 있다. <br/>

&ensp;Amdahl's Law가 시사하는 사실 중 하나는 N이 무한대에 가까워지면 속도는 1/S에 수렴한다는 것이다. 예를 들어 응용의 40%가 순차 실행 부분이라면 코어를 아무리 추가한다고 하더라도 최대 2.0배 이상의 속도 향상은 얻을 수 없다. 이러한 사실이 바로 Amdahl's Law이면에 존재하는 근본적인 원칙이다. 응용의 순차 실행 부분은 코어를 추가하여 얻을 수 있는 성능 향상에 불균형적인 영향을 미친다.<br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-5.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-6.JPEG" width="600"></p>

&ensp;2_병렬 실행의 유형<br/>
&ensp;데이터 병렬 실행은 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는 데 초점을 맞춘다. 예를 들어 크기가 N인 배열의 내용을 더하는 경우를 생각해본다. 단일 코어 시스템에서는 하나의 스레드가 원소 [0]부터 [N-1]를 더하면 된다. 그러나 듀얼 코어 시스템에서는 코어 0에서 실행되는 스레드 A는 원소 [0]부터 [N/2-1]까지 더하고 코어 1에서 실행되는 스레드 B는 원소 [N/2]부터 [N-1]까지 더할 수 있다. 두 스레드는 각자 계산 코어에서 병렬로 실행된다. <br/>
&ensp;태스크 병렬 실행은 데이터가 아니라 태스크(스레드)를 다수의 코어에 분배한다. 각 스레드는 고유의 연산을 실행한다. 다른 스레드들이 동일한 데이터에 대한 연사을 실행할 수 있고 혹은 서로 다른 데이터에 연산을 실행할 수도 있다. 위에 상화과는 대조적으로 배열에 대해 각자 고유한 통계 연사을 수행하는 2개의 스레드가 필요할 수 있다. 이 스레드들은 개별 코어에서 병렬로 실행되지만 각각 고유한 연산을 실행한다. 기본적으로 데이터 병렬 처리에는 여러 코어에 데이터를 분배하는 것이 포함된다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-7.JPEG" width="600"></p>


3\. 다중 스레드 모델(Multithreading Models)
======

&ensp;스레드를 위한 지원은 사용자 스레드(user threads)를 위해서는 사용자 수준에서 또는 커널 스레드(kernel threads)를 위해서는 커널 수준에서 제공된다. 사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리된다. 반면에 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다. <br/>

&ensp;1_다대일 모델(Many-to-One Model)<br/>
&ensp;다대일 모델은 많은 사용자 수준 스레드를 하나의 커널 스레드로 사상한다. 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다. 따라서 효율적이지만 한 스레드가 봉쇄형 시스템 콜을 할 경우 전체 프로세스가 봉쇄된다. 또한 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-9.JPEG" width="600"></p>

&ensp;2_일대일 모델(One-to-one Model)<br/>
&ensp;일대일 모델은 각 사용자 스레드를 각각 하나의 커널 스레드로 사상한다. 이 모델은 하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 때문에 다대일 모델보다 더 많은 병렬성을 제공한다. 또한 이 모델은 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용한다. 이 모델의 단점은 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 하며 많은 수의 커널 스레드가 시스템 성능에 부담을 줄 수 있다는 것이다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-8.JPEG" width="600"></p>

&ensp;3_다대다 모델(Many-to-Many Model)<br/>
&ensp;다대다 모델은 여러 개의 사용자 수준 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플레스한다. 커널 스레드 수는 응용 프로그램이나 특정 기계에 따라 결정된다. 다대일 모델은 개발자가 원하는 만큼의 사용자 수준 스레드를 생성하도록 허용하지만 커널은 한 번에 하나의 커널 스레드만 스케줄 할 수 있기 때문에 진정한 병렬 실행을 획득할 수 없다. 일대일 모델은 더 많은 병행 실행을 제공하지만 개발자가 한 응용 내에 너무 많은 스레드를 생성하지 않도록 주의해야 한다. 다대다 모델의 변형은 여전히 많은 사용자 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스 시키지만 또한 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것만 허용한다. 이 변형은 때로 두 수준 모델(two-level model)이라고 불린다. 

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-10.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-11.JPEG" width="600"></p>