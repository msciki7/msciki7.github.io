---
title: "Chapter 4. Threads and Concurrency"
excerpt: ""

wirter: sohee kim
categories:
  - Operating System
tags:
  - operating system

toc: true
toc_sticky: true
  
date: 2025-03-31
last_modified_at: 2025-03-31
---

1\.Overview
=======

&ensp;1_Motivation<br/>
&ensp;현대의 컴퓨터와 모바일 기기에서 작동하는 거의 모든 소프트웨어 응용들은 다중 스레드를 이용한다. 하나의 응용 몇 개의 실행 흐름을 가진 독립적인 프로세스로 구현된다. <br/>
&middot; 이미지 모음에서 사진 축소판을 만든느 응용 프로그램은 별도의 스레드를 사용하여 개별 이미지에서 축소판을 생성할 수 있다. <br/>
&middot; 웹 브라우저는 하나의 스레드가 이미지 또는 텍스트를 표시하고 다른 스레드는 네트웨크에서 데이터를 검색하도록 할 수 있다. <br/>
&middot; 위드 프로세스에는 그래픽을 표시하는 스레드, 사용자의 키 입력에 응답하는 또 다른 스레드 및 백그라운드에서 맞춤법 및 문법 검사를 수행하는 세 번
째 스레드가 있을 수 있다. <br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-1.JPEG" width="600"></p>

&ensp;응용은 다중 코어 시스템에서 처리 능력을 향상시키도록 설계될 수 있다. 이러한 응용은 다중 계산 코어를 사용하여 다수의 CPU 집중 작업을 병렬로 처리할 수 있다. 하나의 응용 프로그램이 여러 개의 비슷한 작업을 수행할 필요가 있는 상황들이 또한 있다. 하나의 분주한 웹 서버는 여러 개의 클라이언트들이 병행하게 접근할 수 있다. 하나의 해결책은 서버가 요청이 들어오면 프로세스는 그 요청을 수행할 별도의 프로세스를 생성하는 것이다. 사실 이와 같은 방식으로 프로세스를 생성하는 것은 스레드가 대중화되기 전에는 매우 보편적이다. 하지만 새 프로세스가 해야 할 일이 기존 프로세스가 하는 일과 동일하다면 왜 이 많은 오버헤드를 감수해야 하는가? 대부분은 그렇게 하는 것보다는 프로세스 안에 여러 스레드를 만들어 나가는 것이 더 효율적이다. 웹 서버가 다중 스레드화 되면 서버는 클라이언트의 요청을 listen하는 별도의 스레드를 생성한다. 요청이 들어오면 다른 프로세스를 생성하는 것이 아니라 요청을 서비스할 새로운 스레드를 생성하고 추가적인 요청을 listen 하기 위한 작업을 재개한다. <br/>
&ensp;대부분의 운영체제 커널도 일반적으로 다중 스레드이다. 각 스레드는 장치 관리, 메모리 관리 또는 인터럽트 처리와 같은 특정 작업을 수행한다. ps -ef 명령을 사용하여 실행 중인 Linux 시스템에서 커널 스레드를 표시할 수 있다. 이 명령의 출력을 검사하면 커널 스레드 kthreadd(pid = 2)가 표시되며 다른 모든 커널 스레드의 부모 역할을 한다. 많은 응용 프로그램도 기본 정렬, 트리 및 그래프 알고리즘을 포함하여 다중 스레드를 활용할 수 있다. 또한 데이터 마이닝, 그래픽 및 인공지능에서 CPU 중심의 최신 문제를 해결해야 하는  프로그래머는 병렬로 실행되는 솔루션을 설계하여 최신 다중 코어 시승템의 성능을 활용할 수 있다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-2.JPEG" width="600"></p>

&ensp;2_장점<br/>
&ensp;1 응답성(reponsiveness) : 대화형 응용을 다중 스레드화하면 응용 프로그램의 일부분이 봉쇄되거난 응용프로그램이 긴 작업을 수행하더라도 프로그램의 수행이 계속되는 것을 허용함으로써 사용자에 대한 응답성을 증가시킨다. 이 특징은 사용자 인터페이스를 설계하는 데 있어 특히 유용하다. 대조적으로 시가닝 오래 걸리는 연산이 별도의 비동기적 스레드에서 실행된다면 응용은 여전히 사용자에게 응답할 수 있다. <br/>

&ensp;2 자원공유(resource sharing) : 프로세스는 공유 메모리와 메시지 전달 기법을 통하여만 자원을 공유할 수 있다. 이러한 기법은 프로그래머에 의해 명시적으로 처리되어야 한다. 그러나 스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다. 코드와 데이터 공유의 이점은 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다는 점이다.<br/>

&ensp;3. 경제성(economy) : 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에 스레드를 생성하고 문맥 교환하는 것이 더욱더 경제적이다. 오버헤드의 차이를 경험적으로 측정하는 것은 어려울 수 있지만 일반적으로 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 소비한다. 또한 문맥 교환은 일반적으로 프로세스 사이보다 스레드 사이에서 더 빠르다.<br/>

&ensp;규모 적응성(scalability) : 다중 스레드의 이점은 다중 처리기 구조에서 더욱 증가할 수 있다. 다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있기 때문이다. 단일 스레드 프로세스는 처리기가 아무리 많더라도 오직 한 처리기에서만 실행된다.<br/>


2\. 다중 코어 프로그래밍(Multicore Programming)
======

&ensp;각 코어는 운영체제에 별도의 CPU로 보인다. 이러한 시스템을 다중 코어라고 하며 다중 스레드 프로그래밍은 이러한 여러 컴퓨칭 코어를 보다 효율적으로 사용하고 병행성을 향상시키는 기법을 제공한다. 단일 컴퓨팅 코어가 있는 시스템에서는 단지 처리 코어가 한 번에 하나의 스레드만 실행할 수 있기 때문에 병행성은 시간이 지남에 따라 스레드 실행이 인터리브됨을 의미한다. 그러나 여러 코어가 있는 시스템에서 병행성은 시스템이 각 코어에 별도의 스레드를 할당할 수 있기 때문에 일부 스레드가 병렬로 실행될 수 있음을 의미한다. <br/>

&ensp;병행 시스템은 모든 작업이 진행되게 하여 둘 이상의 작업을 지원한다. 이에 반해 병렬 시스템은 둘 이상의 작업을 동시에 수행할 수 있다. 따라서 병렬성 없이 병행성을 가질 수 있다. 다중 처리기 및 다중 코어 아키텍처가 출현하기 전에 대부분의 컴퓨터 시스템에서는 단일 프로세스만 있었으며 CPU 스케줄러는 프로세스 간에 빠르게 전환해 각 프로세스 간에 빠르게 전환해 각 프로세스가 진행되도록 하여 병렬성의 환상을 제공하였다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-3.JPEG" width="600"></p>

&ensp;1_프로그래밍 도전과제(Programming Challenges)<br/>
&ensp;다중 코어 시스템으로 발전하는 추세는 시스템 설계자뿐 아니라 응용 프로그래머에게도 다중 코어의 활용도를 높일 수 있도록 압력을 행사하고 있다. 응용 프로그래머는 기존 프로그램을 다중 스레드를 사용하도록 수정해야 하고 새로운 다중 스레드 프로그램을 설계해야 하는 도전에 당면해 있다. <br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-4.JPEG" width="600"></p>

&ensp;Amdahl's Law<br/>
&ensp;Amdahl's Law는 순차 실행(병렬 실행이 아닌) 구성요소와 병렬 실행 구성요소로 이루어진 응용에 추가의 계산 코어를 더했을 때 얻을 수 있는 잠재적인 성능 이득을 나타내는 공식이다. N개의 처리 코어를 가진 시스템에서 실행되는 응용 중 반드시 순차적으로 실행되어야만 하는 구성요소를 S라고 하면 이 공식은 다음과 같다. 

&ensp;1. 태스크 인식(indentifying tasks) : 응용을 분석하여 독립된 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요하다. 이상적으로 태스크는 서로 독립적이고 따라서 개별 코어에서 병렬 실행될 수 있어야 한다.<br/>

&ensp;2. 균형(balance) : 병렬로 실행될 수 있는 태스크를 찾아내는 것도 중요하지만 찾아진 부분들이 전체 작업에 균등한 기여도를 가지도록 태스크로 나누는 것도 매우 중요하다.<br/>

&ensp;3. 데이터 분리(data spliting) : 응용이 독립된 태스크로 나누어지는 것처럼 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나누어져야 한다.<br/>

&ensp;4. 데이터 종속성(data dependency) : 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다. 한 태스크가 다른 태스크로부터 오는 데이터에 종속적인 경우에는 프로그래머가 데이터 종속성을 수용할 수 있도록 태스크의 수행을 잘 동기화해야 한다.<br/>

&ensp;5. 시험 및 디버깅(testing and debugging) : 프로그램이 다중 코어에서 병렬로 실행될 때 다양한 실행 경로가 존재할 수 있다. <br/>

&ensp;Amdahl's Law가 시사하는 사실 중 하나는 N이 무한대에 가까워지면 속도는 1/S에 수렴한다는 것이다. 예를 들어 응용의 40%가 순차 실행 부분이라면 코어를 아무리 추가한다고 하더라도 최대 2.0배 이상의 속도 향상은 얻을 수 없다. 이러한 사실이 바로 Amdahl's Law이면에 존재하는 근본적인 원칙이다. 응용의 순차 실행 부분은 코어를 추가하여 얻을 수 있는 성능 향상에 불균형적인 영향을 미친다.<br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-5.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-6.JPEG" width="600"></p>

&ensp;2_병렬 실행의 유형<br/>
&ensp;데이터 병렬 실행은 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는 데 초점을 맞춘다. 예를 들어 크기가 N인 배열의 내용을 더하는 경우를 생각해본다. 단일 코어 시스템에서는 하나의 스레드가 원소 [0]부터 [N-1]를 더하면 된다. 그러나 듀얼 코어 시스템에서는 코어 0에서 실행되는 스레드 A는 원소 [0]부터 [N/2-1]까지 더하고 코어 1에서 실행되는 스레드 B는 원소 [N/2]부터 [N-1]까지 더할 수 있다. 두 스레드는 각자 계산 코어에서 병렬로 실행된다. <br/>
&ensp;태스크 병렬 실행은 데이터가 아니라 태스크(스레드)를 다수의 코어에 분배한다. 각 스레드는 고유의 연산을 실행한다. 다른 스레드들이 동일한 데이터에 대한 연사을 실행할 수 있고 혹은 서로 다른 데이터에 연산을 실행할 수도 있다. 위에 상화과는 대조적으로 배열에 대해 각자 고유한 통계 연사을 수행하는 2개의 스레드가 필요할 수 있다. 이 스레드들은 개별 코어에서 병렬로 실행되지만 각각 고유한 연산을 실행한다. 기본적으로 데이터 병렬 처리에는 여러 코어에 데이터를 분배하는 것이 포함된다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-7.JPEG" width="600"></p>


3\. 다중 스레드 모델(Multithreading Models)
======

&ensp;스레드를 위한 지원은 사용자 스레드(user threads)를 위해서는 사용자 수준에서 또는 커널 스레드(kernel threads)를 위해서는 커널 수준에서 제공된다. 사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리된다. 반면에 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다. <br/>

&ensp;1_다대일 모델(Many-to-One Model)<br/>
&ensp;다대일 모델은 많은 사용자 수준 스레드를 하나의 커널 스레드로 사상한다. 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다. 따라서 효율적이지만 한 스레드가 봉쇄형 시스템 콜을 할 경우 전체 프로세스가 봉쇄된다. 또한 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-9.JPEG" width="600"></p>

&ensp;2_일대일 모델(One-to-one Model)<br/>
&ensp;일대일 모델은 각 사용자 스레드를 각각 하나의 커널 스레드로 사상한다. 이 모델은 하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 때문에 다대일 모델보다 더 많은 병렬성을 제공한다. 또한 이 모델은 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용한다. 이 모델의 단점은 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 하며 많은 수의 커널 스레드가 시스템 성능에 부담을 줄 수 있다는 것이다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-8.JPEG" width="600"></p>

&ensp;3_다대다 모델(Many-to-Many Model)<br/>
&ensp;다대다 모델은 여러 개의 사용자 수준 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플레스한다. 커널 스레드 수는 응용 프로그램이나 특정 기계에 따라 결정된다. 다대일 모델은 개발자가 원하는 만큼의 사용자 수준 스레드를 생성하도록 허용하지만 커널은 한 번에 하나의 커널 스레드만 스케줄 할 수 있기 때문에 진정한 병렬 실행을 획득할 수 없다. 일대일 모델은 더 많은 병행 실행을 제공하지만 개발자가 한 응용 내에 너무 많은 스레드를 생성하지 않도록 주의해야 한다. 다대다 모델의 변형은 여전히 많은 사용자 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스 시키지만 또한 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것만 허용한다. 이 변형은 때로 두 수준 모델(two-level model)이라고 불린다. 

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-10.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-11.JPEG" width="600"></p>


4\. 스레드 라이브러리(Threads Library)
======

&ensp;스레드 라이브러리는 프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공한다. 스레드 라이브러리를 구현하는 데에는 주된 두 가지 방법이 있다. 첫 번째 방법은 커널의 지원 없이 완전히 사용자 공간에서만 라이브러리를 제공하는 것이다. 라이브러리를 모든 코드와 자료구조는 사용자 공간에 존재한다. 라이브러리 함수를 호출하는 것은 시스템 콜이 아니라 사용자 공간의 지역 함수를 호출하게 된다는 것을 의미한다. <br/>

&ensp;두 번째 방법은 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하는 것이다. 이 경우 라이브러리를 위한 코드와 자료구조는 커널 공간에 존재한다. 라이브러리 API를 호출하는 것은 커널 시스템 콜을 부르는 결과를 낳는다.<br/>

&ensp;현재 POSIX Pthreads, Window 및 Java의 세 종류 라이브러리가 주로 사용된다. POSIX 표준 안의 스레드 확장판인 Pthreads는 사용자 또는 커널 수준 라이브러리로서 제공될 수 있다.<br/>

&ensp;비동기 스레딩과 동기 스레딩은 다수의 스레드를 생성한다. 비동기 스레딩은 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 서로 독립적으로 병행하게 실행된다. 스레가 독립적이기 때문에 스레드 사이의 데이터 공유는 거의 없다.<br/>
&ensp;동기 스레딩은 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 방식을 말한다. 여기서 부모가 생성한 스레드는 병행하게 실행되지만 부모는 자식들의 작업이 끝날 때까지 실행을 계속할 수 없다. 부모 스레드는 오직 모든 자식 스레드가 조인한 후에야 실행을 재개할 수 있다. 통상 동기 스레딩은 스레드 사이의 상당한 양의 데이터 공유를 수반한다. <br/>

&ensp;1_Pthreads<br/>
&ensp;Pthreads는 POSIX가 스레드 생성과 동기화를 위해 제정한 표준 API이다. 이것은 스레드의 동작에 관한 명세일 뿐이지 그것 자체를 구현한 것은 아니다. 이 명세를 가지고 운영체제 설계자들은 그들 나름대로 그것을 구현할 수 있다. <br/>

&ensp;Pthreads 프로그램에서 별도의 스레드는 지정된 함수에서 실행을 시작한다. 이 프로그램이 실행을 시작하면 하나의 제어 스레드가 main()함수에서 시작한다. 약간의 초기화 후에 main()은 runner() 함수에서 실행을 시작하는 두 번째 스레드를 생성한다. 두 스레드는 전역 변수 sum을 공유한다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-11.JPEG" width="600"></p>

&ensp;모든 Pthreads 프로그램은 pthreadh 헤더 파일을 포함해야 한다. pthreadad_t tid 문장은 우리가 생성할 스레드를 위한 식별자를 선언한다. 각 스레드는 스택의 크기와 스케줄링 정보를 포함한 속성의 집합을 갖는다. pthread_attr_t attr 선언은 스레드를 위한 속성을 나타낸다. 속성을 지정하지 않으면 디폴트 속성을 사용한다. 별도의 스레드는 pthread_create()를 이용하여 생성한다. 스레드 식별자와 스레드의 속성뿐 아니라 새로운 스레드가 실행을 시작할 함수의 이름도 전달한다. 마지막으로 명령어 라인 상에 제공된 정수 매개변수인 argv[1]을 전달한다.<br/>
&ensp;이 시점에서 프로그램은 main()함수의 최초 스레드와 runner()함수에서 합을 계산하는 합 스레드의 두 개 스레드를 가지게 된다. 이 프로그램은 스레드 생성/조인 전략을 사용한다. 합산 스레드를 생성한 후에 pthread_join() 함수를 호출하여 합산 스레드가 종료하기를 부모 스레드는 기다린다. 합산 스레드는 pthread_exit() 함수를 호출하여 종료하게 된다. 합산 스레드가 복귀하면 부모 스레드는 공유 데이터 sum의 값을 출력한다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-12.png" width="600"></p>

&ensp;2_Window 스레드(Windows Threads)<br/>
&ensp;Windows 스레드 라이브러리를 이용하여 스레드를 생성하는 기술을 많은 점에서 Pthreadsr기법과 유사하다. Pthreads버전과 마찬가지로 개별 스레드가 공유하는 데이터는 전역 변수로 선언된다. 우리는 또한 별도의 스레드에서 수행될 Summation() 함수도 정의하다. 이 함수는 void형을 가리키는 포인터 변수를 인자로 전달받는다. 이 데이터 형을 Windows 에서는 LPVOID로 정의한다. 이 함수를 실행하는 스레드 이 함수를 실행하는 스레드는 0부터 Summation() 함수에 전달된 매개변수까지의 합을 전역 데이터 Sum에 저장한다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-13.png" width="600"></p>

&ensp;Window API에서 스레드 CreateThread() 함수에 의해 생성되고 Pthreads와 마찬가지로 이 함수에 스레드를 위한 속성의 집합이 전달된다. 이 속성에는 보안 정보, 스택의 크기 및 스레드가 보류 상태(suspended state)에서 시작하는지를 나타낼 수 있는 플래그 등이 포함된다. 이 프로그램에서는 이 속성들을 위한 디폴트 값을 사용한다. 합산 스레드가 생성되면 부모는 합산 스레드에 의해 지정된어야 할 Sum의 값을 출력하기 전에 합산 스레드가 종료하기를 기다려야 한다. Pthreads 프로그램이 pthread_join() 문을 이용하여 부모 스레드가 합산 스레드가 종료될 때까지 기다리게 한다. 이와 동일한 작업을 Window API에서는 WairForSingleObject()함수를 이용하여 수행하는데 이 함수는 합산 스레드가 종료할 때까지 생성 스레드가 봉쇄되도록 한다. 이 함수는 다음과 같은 4개의 매개변수를 전달받는다. <br/>
&ensp;1. 기다려야 하는 객체의 개수<br/>
&ensp;2. 객체 배열을 가리키는 포인터<br/>
&ensp;3. 모든 객체가 신호를 보내왔는지를 나타내는 플래그<br/>
&ensp;4. 대기해야 하는 타임아웃 시간<br/>

&ensp;3_Java 스레드(Java Thread)<br/>
&ensp;스레드는 Java 프로그램의 프로그램 실행의 근본적인 모델이고 Java 언어와 API는 스레드의 생성과 관리를 지원하는 풍부한 특성을 제공한다. 모든 Java 프로그램은 적어도 하나의 단일 제어 스레드를 포함하고 있다. 단지 main()함수로만 이루어진 단순한 Java 프로그램조차 JVM 내의 하나의 단일 스레드로 수행된다. Java 스레드는 JVM을 제공하는 어떠한 시스템에서도 사용할 수 있다. <br/>
&ensp;Java 프로그램에서 스레드를 명시적으로 생성하는 데에는 두 가지 기법이 있다. 한 가지 방법은 Thread 클래스에서 파생된 새 클래스를 만들고 run() 메소드를 재정의하는 것이다. 대안 기법은 Runnavle 인터페이스를 구현하는 클래스를 정의하는 것이다. 이 인터페이스는 public void run()의 서명을 가진 단일 추상 메소드를 정의한다. Runnable을 구현하는 클래스의 run() 메소드 코드는 별도의 스레드에서 실행된다.<br/>


&ensp;Java에서 스레드를 생성하려면 Thread 객체를 생성하고 Runnable을 구현하는 클래스의 인스턴스를 전달한 다음 Thread 객체의 start() 메스드를 호출해야 한다. 새 Thread 객체에 대해 start() 메소드를 호출하면 두 가지 작업이 수행된다.<br/>
&ensp;1. 메모리 할당되고 JVM 내에 새로운 스레드가 초기화된다.<br/>
&ensp;2. run() 메소드를 호출하면 스레드가 JVM에 의해 수행될 자격을 갖게 한다.<br/>

&ensp;Pthreads 및 Windows 라이브러리의 부모 스레드는 pthread_join() 및 Wait-ForSingleObject()를 사용하여 각 스레드가 완료되기를 기다렸다가 계속 진행한다. Java의 join()메소드는 유사한 기능을 제공한다. 부모가 여러 스레드가 완료되기를 기다려야 하는 경우 join()메소드는 for 루프로 묶을 수 있다. <br/>

&ensp;Thread 객체를 명시적으로 생성하는 대신 Executor 인터페이스를 중심으로 스레드 생성을 구성한다. 이 인터페이스를 구현하는 클래스는 Runnable 객체가 인자가 전달되는 execute() 메소드를 정의해야 한다. Java 개발자에게는 별도의 Thread 객체를 만들고 start() 메소드를 호출하는 대신 Executor를 사용하는 것을 의미한다. Executor는 다음과 같이 사용된다.<br/>
&ensp;Windows와 Pthreads에서 공유 데이터는 단순히 전역적으로 선언되기 때문에 동일한 프로세스에 속한 스레드 간의 데이터 공유는 쉽게 가능하다. 순수한 객체 지향 언어인 Java에는 적역 데이터에 대한 개념이 없다. Runnable을 구현하는 클래스에 매개변수를 전달할 수 있지만 Java 스레드는 결과를 반환할 수 없다. 이러한 필요를 해결하기 위해 java.util.concurrent패키지는 Callable 인터페이스를 추가로 정의하며 결과를 반환할 수 있다는 점을 제외하고 Runnable과 유사하게 작동한다. Callable 작업에서 반환된 결과를 Future 객체라고 한다.<br/>
&ensp;Summation 클래스는 메소드 call()을 지정하는 Callable 인터페이스를 구현한다. 이 call() 메소드의 코드는 별도의 스레드에서 실행된다. 이 코드를 실행하기 위해 ExecutorService 유형의 newSingleThreadExecutor 객체를 생성하고 submit() 메소드를 사용하여 Callable 태스크를 전달한다. Callable 태스크를 스레드에 제출하면 스레드가 반환하는 Future 객체의 get() 메소드를 호출하여 결과를 기다린다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-14.JPEG" width="600"></p>


5\. 암묵적 스레딩(Implicit Threading)
======

&ensp;다중 코어 처리의 지속적 성장에 따라 수백 또는 심지어 수천 개의 스레드를 가진 응용이 등장하게 되었다. 그러나 응용을 설계하는 것은 사소한 일이 아니며 프로그래머는 어려움을 극복해야 한다. 이러한 어려움을 극복하고 병행 및 병렬 응용의 설계를 도와주는 한 가지 방법은 스레딩의 생성과 관리 책임을 응용 개발자로부터 컴파일러와 실행시간 라이브러리에게 넘겨주는 것이다. 암묵적 스레딩을 이용하여 다중 코어 처리기를 활용할 수 있는 응용 프로그램을 설계하는 4가지 접근법을 탐구한다. 작업은 일반적으로 함수로 작성되며 런타임 라이브러리는 일반적으로 다대다 모델을 사용하여 별도의 스레드에 매핑된다. 이 방법의 장점은 개발자가 병렬 작업만 식별하면 되고 라이브러리는 스레드 생성 및 관리에 대한 특정 세부 사항을 결정한다는 것이다. <br/>

&ensp;1_스레드 풀(Thread Pool)<br/>
&ensp;웹 서버는 요청을 받을 때마다 그 요청을 위해 새로운 스레드를 만들어 준다. 새로운 스레드를 매요청마다 만들어주는 것은 그때마다 새로운 프로세스를 만들어주는 것보다는 확실히 더 진보된 방법임은 틀림없지만 다중 스레드 서버는 아직도 여러 문제를 가지고 있다.<br/>
&ensp;첫 번째 문제는 서비스할 때마다 스레드를 생성하는 데 소요되는 시간이다. 두 번째 이슈는 모든 요청마다 새 스레드를 만들어서 서비스해 준다면 시스템에서 동시에 실행할 수 있는 최대 스레드 수가 몇 개까지 가능할 수 있는 것인지 한계를 정해야 한다. 스레드를 무한정 만들면 언젠가는 CPU 시간, 메모리 공간 같은 시스템 자원이 고갈된다. 이러한 문제들을 해결해 줄 수 있는 방법의 하나가 스레드 풀이다. <br/>
&ensp;스레드들은 평소에는 하는 일 없이 일감을 기다리게 된다. 서버는 스레드를 생성하지 않고 요청을 받으면 대신 스레드 풀에 제출하고 추가 요청 대기를 재개한다. 풀레 사용 가능한 스레드가 있으면 깨어나고 요청이 즉시 서비스된다. 풀에 사용 가능한 스레드가 없으면 사용 가능한 스레드가 생길 때까지 작업이 대기도니다. 스레드가 서비스를 완료하면 풀로 돌아가서 더 많은 작업을 가다린다. 풀에 제출된 작벙을 비동기적으로 실행할 수 있는 경우 스레드 풀이 제대로 작동한다.<br/>

&ensp;1. 새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 종종 빠르다.<br/>
&ensp;2. 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다. 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다. 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다.<br/>
&ensp;3. 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크를 실행을 다르게 할 수 있다. <br/>

&ensp;스레드 풀이 있는 스레드의 개수는 CPU 수, 물리 메모리 용량, 동시 요청 클라이언트 최대 개수 등을 고려하여 정해질 수 있다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-15.JPEG" width="600"></p>

&ensp;PoolFunction()을 가리키는 포인터가 스레드 풀 API 중 하나의 함수에 전달되고 풀 중의 한 스레드가 이 함수를 실행한다. 그러한 스레드 풀 API 중 한 함수가 QueueUserWorkItem() 함수이며 이 함수는 다음과 같은 세 매개변수를 전달받는다.<br/>
* LPTHREAD_START_ROUTINE Function: 별도의 스레드가 실행할 함수에 대한 포인터<br/>
* PVOID param: Function에 전달될 매개변수<br/>
* ULONG Flags: 스레드 풀이 스레드를 생성하고 관리하는 방법을 가리키는 플래그<br/>

&ensp;Java 스레드 풀(Java Thread Pools)<br/>
&ensp;java.util.concurrent 패키지에는 여러 종료의 스레드 풀 구조에 대한 API가 포함되어 있다.<br/>
&ensp;1. 단일 스레드 Executor, newSingleThreadExecutor()는 크기가 1인 풀을 생성한다.<br/>
&ensp;2. 고정 스레드 Executor, newFixedThreadPool(int size)는 지정된 수의 스레드가 있는 스레드 풀을 생성한다.<br/>
&ensp;3. 캐시 스레드 Executor, newCachedThreadPool()는 많은 경우 스레드를 재사용하는 무제한 스레드 풀을 생성한다.<br/>

* FixedThreadPool : 고정된 개수의 스레드 풀을 생성한다. 모든 스레드가 바쁘면 작업이 대기열에 쌓여서 스레드가 빌 때까지 기다린다. 안정적인 작업에 적합하다.<br/>
* CachedThreadPool : 필요할 때 스레드를 생성하고 사용하지 않는 스레드를 재사용한다. 크기가 무한히 늘어날 수 있으므로 주의가 필요하다. 짧고 bursty(간헐적으로 몰리는) 작업에 적합하다.<br/>
* SingleThreadExecutor : 하나의 워커 스레드만 생성한다. 작업 FIFO(First-In-First_Out) 순서로 순차적으로 실행한다. 직렬작업처리에 적합하지만 멀티스레드 환경 내에서 사용될 수 있다.<br/>

&ensp;2_Fork Join<br/>
&ensp;이 메소드를 사용하면 메인 부모 스레드가 하나 이상의 자식 스레드를 생성(fork)한 다음 자식의 종료를 기다린 후 join하고 그 시점부터 자식의 결과를 확인하고 결합한다. 이 동기식 모델은 종종 명시적 스레드 생성이라고 특징지어지지만 암시적 스레딩에도 사용될 수 있다. 후자의 상황에서 fork 단계에서는 스레드가 직접 구축되지 않고 대신 병렬 작업이 식별된다. 라이브러리는 생성되는 스레드 수를 관리하며 스레드에 작업 배정을 책임진다. 어떤 식으로든 이 fork-join 모델은 라이브러리가 생성할 실제 스레드 수를 결정하는 동기 버전의 스레드 풀이다.<br/>

* Java에서의 Fork Join(Fork Join in Java)<br/>
&ensp;이 라이브러리를 사용하여 분할-정복 알고리즘을 구현할 때 분할 단계 동안 별도의 작업이 fork되고 원래 문제의 작은 부분집합이 할당된다. 이러한 별도의 작업이 병행하게 실행할 수 있도록 알고리즘이 설계되어야 한다. Java fork-join 모델의 일반적인 재귀알고리즘은 다음과 같다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-16.png" width="600"></p>

* Hadoop MapReduce<br/>
&ensp;개념적으로는 Fork-Join과 유사하다. 큰 작업을 여러 개의 병렬로 처리 가능한 작업으로 나누고(fork), 결과를 모아서 최종 결과롤 합치는(join)방식과 비슷하다.구글에서는 많은 텍스트 파일이 존재한다. Word1, Word2, Word3... 텍스트 안에 단어가 몇 번 나왔는가하는 것을 계산하는 작업을 수행하게 된다. 즉 텍스트파일을 64MB 단위로 잘라내어 각 블럭에 대해서 특정 단어가 몇 번 출현했는지를 계산하는 것이다. Hadoop에서 계산시 큰 파일을 블럭단위로 나누고 모든 블럭은 같은 Map 작업을 수행하고 이후 Reduce 작업을 수행하게 된다. <br/>

&ensp;MapReduce의 세 단계<br/>
&ensp;1. Map 단계 : 입력 데이터를 처리하고 나누고 key-value 쌍으로 변환한다. 이 작업은 클러스터의 여러 노드에서 병렬로 실행된다. <br/>
&ensp;2. Shuffle and Sort 단계 : 중간 결과(key-value쌍)를 key 기준으로 그룹화한다. Reduce 작업을 위한 정렬을 준비한다.<br/>
&ensp;3. Reduce 단계 : 그룹화된 데이터를 결합하여 결과를 집계한다.<br/>

&ensp;Mapper : Haphood은 네트워크 트래픽을 방지하기 위해 메타 데이터의 일부분을 가지고 노드에서 처리한다. 동시에 실행되는 여러 맵퍼는 각각 입력 데이터의 일부를 처리하는 단계를 포함한다. 맵퍼는 Key/Value 상의 형태로 데이터를 읽는다. Mapper의 0개 또는 그 이상의 Key/Value쌍을 출력한다. 각각의 map, reduce를 어떤 PC에서 수행할지는 Job Tracker에서 결정한다. Mapper에서 중간 결과가 나오면 다시 그 중간 결과를 Shuffling하게 된다. Shulffing한 결과를 Reducer로 전달하게 된다.<br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-17.JPEG" width="600"></p>

&ensp;3_OpenMP<br/>
&ensp;OpenMP는 C, C++, Fortran으로 작성된 API와 컴파일러 디렉티브의 집합이다. OpenMP는 공유 메모리 환경에서 병렬 프로그래밍을 할 수 있도록 도와준다. OpenMP는 병렬로 실행될 수 있는 블록을 찾아 병렬 영역(parallel regions)이라고 부른다. 응용 개발자는 자신들의 코드 중 병렬 영역에 컴파일러 디렉티브를 삽입한다. 이 디렉티브는 OpenMP 실행시간 라이브러리에 해당 영역을 병렬로 실행하라고 지시한다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-18.png" width="600"></p>


&ensp;OpenMP가 #pragma omp parallel를 만나게 되면 시스템 코어 개수만큼 스레드를 생성한다. 따라서 듀얼 코어 시스템에서는 2개, 퀴드 코어 시스템에서는 4개 등 이런 식으로 스레드가 생성하게 된다. 각 스레드가 병렬 영역을 빠져나가면 스레드는 종료된다. OpenMP는 병렬 처리 반복문 등을 포함하여 코드 영역을 실행하기 위한 추가적인 디렉티브를 제공한다. OpenMP는 for반복문 안에 들어 있는 연산을 디렉티브에 따라 생성된 스레드들에게 분배한다. 병렬화를 위한 디렉티브를 제공할 뿐만 아니라 OpenMP는 개발자가 병렬화 수준을 선택할 수 있게 한다.<br/>

&ensp;5_Grand Central Dispatch<br/>
&ensp;GCD는 macOS 및 iOS 운영체제를 위해 Apple에서 개발한 기술이다. 개발자가 병렬로 실행될 코드 섹션(태스크)을 식별할 수 있도록 하는 런타임 라이브러리, API 및 언어 확장의 조합이다. OpenMP와 마찬가지로 GCD는 스레딩에 대란 대부분의 세부 사항을 관리한다.<br/>
&ensp;GCD는 실행시간 수행을 위해 태스크를 디스패치 규(Dispatch Queue)에 넣어서 스케줄 한다. 큐에서 태스크를 제거할 때 관리하는 스레드 풀에서 가용 스레드를 선택하여 태스크를 할당한다. <br/>
&ensp;GCD는 직렬(serial)과 병행(concurrent)의 두가지 유형의 디스패치 큐를 유지한다.**직렬 큐**에 넣어진 태스크는 FIFO 순서대로 제거된다. 태스크는 큐에서 제거되면 다른 태스크가 제거되기 전에 실행을 반드시 완료해야 한다. 각 프로세스에는 고유한 직렬 큐(메인 큐)<가 있으며 개발자는 특정 프로세스에 로컬인 추가 직렬 큐를 만들 수 있다. 직렬 큐를 개인 디스패치 큐라고도 하는 이유이다. 직렬 큐는 여러 작업을 순차적으로 실행하는 데 유용하다. **병렬 큐**에 넣어진 태스크도 FIFO 순서로 제거되지만 한 번에 여러 태스크가 제거되어 병렬로 실행될 수 있게 한다. 다수의 시스템 전체의 병행 큐가 존재하며 4가지 주요 서비스 품질 클래스로 나뉜다.<br/>


6\. 스레드와 관련된 문제들(Threading Issues)
=======

&ensp;1_Fork() 및 Exec() 시스템 콜(The fork() and exec() System calls)<br/>
&ensp;만일 한 프러그램의 스레드가 fork()를 호출하면 새로운 프로세스는 모든 스레드를 복제해야 하는가 아니면 한 개의 스레드만 가지는 프로세스여야 하는가? 몇몇 UNIX 기종은 이 두 가지 버전 fork()를 다 제공한다. 하나는 모든 스레드를 복사하는 것과 다른 하나는 fork()를 호출한 스레드만 복제하는 것이다. 어떤 스레드가 exec() 시스템 콜을 부르면 exec()의 매개변수로 지정된 프로그램이 모든 스레드를 포함한 전체 프로세스를 대체시킨다. 두 버전의 fork() 중 어느 쪽을 택할 것인지는 응용 프로그램에 달려있다. fork()를 부르자마자 다시  exec을 부른다면 모든 스레드를다 복제해서 만들어주는 것은 불필요하다. 왜냐하면 다시 exec에서 저장한 프로그램이 곧 모든 것을 다시 대체할 것이기 때문이다. 이 경우에는 fork() 시스템 콜을 호출한 스레드만 복사해주는 것이 적절하다. 그러나 새 프로세스가 fork() 후 exec을 하지 안흔ㄴ다면 새 프로세스는 모든 스레드들을 복제해야 한다. <br/>

&ensp;2_신호처리(Singal Handling)<br/>
&ensp;신호는 UNIX에서 프로세스에 어떤 이벤트가 일어났음을 알려주기 위해 사용된다. 신호는 알려줄 이벤트의 근원지나 이유에 따라 동기식 또는 비동기식으로 전달될 수 있다. 동기식이건 비동기식이건 모든 신호는 다음과 같은 형태로 전달된다.<br/>
&ensp;1. 신호는 특정 이벤트가 일어나야 생성된다.<br/>
&ensp;2. 생성된 신호가 프로세스에 전달된다. <br/>
&ensp;3. 신호가 전달되면 반드시 처리되어야 한다.<br/>
&ensp;모든 신호는 둘 중 하나의 처리기에 의해 처리된다.<br/>
&ensp;1. 디폴트 신호 처리기<br/>
&ensp;2. 사용자 정의 신호 처리기<br/>

&ensp;모든 신호마다 커널이 실행시키는 디폴트 신호 처리기가 있다. 이 디폴트 처리기는 신호를 처리하기 위하여 호출되는 사용자 정의 처리기에 의해 대체될 수 있다. 신호는 다른 방식으로 처리될 수 있다. 일부 신호는 무시될 수 있지만 다른 신호는 프로그램을 종료하여 처리된다. 단일 스레드 프로그램에서의 신호 처리는 간단하다. 신호는 항상 프로세스에 전달된다. 그러나 프로세스가 여러 스레드를 가지고 있는 다중 스레드 프로그램에서의 신호 처리는 더욱 복잡하다. <br/>
&ensp;1. 신호가 적용될 스레드에게 전달한다.<br/>
&ensp;2. 모든 스레드에 전달한다<br/>
&ensp;3. 몇몇 스레드들에만 선택적으로 전달한다. <br/>
&ensp;4. 특정 스레드가 모든 신호를 전달받도록 저장한다.<br/>
&ensp;신호를 전달하는 방법은 신호의 유형에 따라 다르다. 그러나 비동기식 신호의 경우는 명확하지 않다.<br/>

&ensp;Windows는 신호를 명시적으로 지원하지는 않지만 비동기식 프로시저 호출(asynchronous procedure calls, APC)이라는 것을 사용해서 이를 대리 실행(emulate)할 수 있다. APC는 사용자 스레드들이 특정 이벤트의 발생을 전달받았을 때 호출될 함수를 지정할 수 있게 한다. <br/>

&ensp;3_스레드 취소(Thread Cancellation)<br/>
&ensp;스레드 취소(thread cancellation)는 스레드가 끝나기 전에 그것을 강제 종료시키는 작업을 일컫는다. 취소되어야 할 스레드를 목적 스레드(target thread)라고 부른다. 목적 스레드의 취소는 다음과 같은 두 가지 방식으로 발생할 수 있다.<br/>
&ensp;1. 비동기식 취소(asychronous cancellation): 한 스레드가 즉시 목적 스레드를 강제 종료시킨다.<br/>
&ensp;2. 지연 취소(deferred cancellation): 목적 스레드가 주기적으로 자신이 강제 종료되어야 할지를 점검한다. 이 경우 목적 스레드가 질서정연하게 강제 종료될 수 있는 기회가 만들어진다. <br/>
&ensp;스레드 취소를 어렵게 만드는 것은 취소 스레드들에 할당된 자원 문제이다. 또한 스레드가 다른 스레드와 공유하는 자료구조를 갱신하는 도중에 취소요청이 와도 문제가 된다. 후자의 문제는 비동기식 취소의 경우 더 심각하다. 종종 운영체제는 취소된 스레드로부터 시스템 자원을 회수할 수도 있지만 모든 시스템 자원을 다 회수하지 못하는 경우도 있다.  따라서 비동기식으로 스레드를 취소하면 필요한 시스템 자원을 다 사용 가능한 상태로 만들지 못할 수도 있다.<br/>
&ensp;지연 취소의 경우에는 한 스레드가 목적 스레드를 취소해야 한다고 표시하지만 실제 취소는 목적 스레드가 취소 여부를 결정하기 위한 플래그를 검사한 이후에애 일어난다. 스레드는 자신이 취소되어도 안전하다고 판다되는 시점에서 취소 여부를 검사할 수 있다.
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-19.png" width="600"></p>

&ensp;pthread_cancel()을 호출하면 대상 스레드를 취소하라는 요청만 표시된다. 그러나 실제 취소는 요청을 처리하기 위해 대상 스레드가 설정되는 방식에 달려 있다. 대상 스레드가 최종적으로 취소되면 취소 스레드의 pthread_join() 호출이 반환된다. Pthreads는 3가지 취소 모드를 지원한다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-20.png" width="600"></p>

&ensp;기본 취소 유형은 지연 취소이다. 그러나 스레드가 취소 점에 도달한 경우에만 최소가 발생한다. POSIX 및 표준 C 라이브러리에서 대부부느이 블로킹 시스템 콜은 취소점으로 정의되며 Linux 시스템에서 man pthreads 명령을 호출할 때 나열된다. <br/>

&ensp;4_스레드-로컬 저장장치(Thread-Local Storage)<br/>\
&ensp;한 프로세스에 속한 스레들은 그 프로세스의 데이터를 모두 공유한다. 그러나 상황에 따라서는 각 스레드가 자기만 액세스할 수 있는 데이터를 가져야 할 필요도 있다. 그러한 데이터를 스레드-로컬 저장장치(thread-local storage, TLS)라고 부른다. TLS를 지역 변수와 혼동하기 쉬운데 지역변수는 하나의 함수가 호출되는 동안에만 보이지만 TLS는 전체 함수 호출에 걸쳐 보인다. 어떤 면에서 TLS는 정적 데이터와 유사하다. 차이점은 TLS데이터는 스레드마다 고유하다는 것이다. 대부분의 스레드 라이브러리 및 컴파일러는 TLS를 지원한다. Pthread에는 pthread_key_t 유형이 포함되어 있으며 각 스레드에 고유한 키를 제공한다.
<br/>

&ensp;5_스케줄러 액티베이션(Scheduler Activations)<br/>
&ensp;다중 스레드 프로그램과 관련하여 마지막으로 고려할 문제는 스레드 라이브러리와 커널의 통신 문제이다. 통신 조정은 응용 프로그램이 최고의 성능을 보이도록 보장하기 위하여 커널 스레드의 수를 동적으로 조절하는 것을 가능하게 한다. <br/>
&ensp;다대다 또는 두 수준 모델을 구현하는 많은 시스템은 사용자와 커널 스레드 사이에 중간 자료구조를 둔다. 이 자료구조는 통상 경량 프로세스 또는 LWP라고 불린다. 사용자 스레드 라이브러리에 LWP 방식은 응용이 사용자 스레드를 수행하기 위하여 스케줄 할 가상 처리기(virtual processor)처럼 보인다. 각 LWP도 같이 봉쇄된다. 이 연관에 따라 LWP에 부속된 사용자 수준 스레드도 역시 봉쇄된다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-21.png" width="600"></p>

&ensp;사용자 스레드 라이브러리와 커널 스레드 간의 통신 방법의 하나는 스케줄러 액티베이션이라고 알려진 방법이다. 커널은 응용에 가상 처리기(LWP)의 집합을 제공하고 응용은 사용자 스레드를 가용한 가상 처리기로 스케줄한다. 커널은 응용에게 특정 이벤트에 대해 알려줘야 한다. 이 프로시저를 upcall이라고 부른다. Upcall은 스레드 라이브러리의 upcall 처리기에 의해 처리되고 upcall처리기는 가상 처리기상에서 실행되어애 한다.<br/>

7\. 운영체제 사례(Operating System Examples)
======

&ensp;1_Windows 스레드(Windows Threads)
&ensp;Windows 응용들은 프로세스 형태로 실행되며 이들 각 프로세스는 한 개 또는 그 이상의 스레드를 가질 수 있다.<br/>
&ensp;스레드의 일반적인 구성요소<br/>
* 각 스레드를 유일하게 지목하는 스레드ID<br/>
* 처리기의 상태를 나타내는 레지스터 집합<br/>
* 프로그램 카운터<br/>
* 사용자 모드에서 실행될 때 필요한 사용자 스택, 커널 모드에서 실행될 때 필요한 커널 스택<br/>
* 실행 시간 라이브러리와 동적 링크 라이브러리(DLL) 등이 사용하는 개별 데이터 저장 영역<br/>
&ensp;레지스터 집합, 스택, 개별 데이터 저장 영역들은 그 스레드의 문맥으로 불린다.<br/>
&ensp;ETHREAD - 실행 스레드 블록(executive thread block), 그 스레드가 속한 프로세스를 가리키는 포인터와 그 스레드가 실행을 시작해야 할 루틴의 주소 등이다. ETHREAD는 KTHREAD에 대한 포인터도 가지고 있다. 커널 안에 존재한다.<br/>
&ensp;KTHREAD - 커널 스레드 블록(kernel thread block), 스레드의 스케줄링 및 동기화 정보를 가지고 있다. 또한 이 스레드가 커널 모드에서 실행될 때 사용되는 커널 스택과 TEB에 대한 포인터를 가지고 있다. 커널 안에 존재한다. <br/>
&ensp;TEB - 스레드 환경 블록(thread environment block), 사용자 모드에서 실행될 때 접근되는 사용자 공간 자료구조이다. 다른 필드 중에서 TEB는 스레드 식별자, 사용자 모드 스택 및 스레드 국지 저장소를 저장하기 위한 배열을 가지고 있다. <br/>
<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-22.png" width="600"></p>

&ensp;2_Linux 스레드(Linux Threads)<br/>
&ensp;Linux는 프로그램 내의 제어 흐름을 나타내기 위하여 프로세스나 스레드보다 태스크라는 용어를 사용한다. clone()이 호출될 때 부모와 자식 태스크가 자료구조를 얼마나 공유할지 결정한느 플래그의 집합이 전달된다. clone()을 사용하는 것은 부모 태스크가 자식 태스크와 거의 모든 자원을 공유하기 때문에 스레드를 생성하는 것과 같은 결과가 된다. <br/>

<p align="center"><img src="/assets/img/Operating System/4. Threads and Concurrency/4-23.png" width="600"></p>

&ensp;Linux 커널이 태스크를 표현하는 방식 때문에 다양한 공유 수준이 가능하다. 시스템의 태스크마다 고유한 커널 자료구조(struct task_struct)존재한다. 이 자료구조는 태스크의 데이터를 저장하는 것이 아니라 데이터가 저장된 다른 자료구조를 가리키는 포인터를 포함한다. 다른 자료구조에는 열린 파일의 리스트를 나타내는 자료구조, 신호 처리 정보 및 가상 메모리 등이 있다. fork()가 호출되면 부모 프로세스의 관련된 자료구조를 복사함으로써 새로운 태스크를 생성한다. 그러나 모든 데이터를 복사하는 것이 아니라 clone()에게 전달된 플래그에 따라 부모 태스크의 자료구조를 가리키게 된다.<br/>
&ensp;clone() 시스템 콜의 융통성은 컨테이너 개념으로 확장될 수 있다. 컨테이너는 운영체제가 제공하는 가상화 기법으로 하나의 Linux 커널 아래 서로 격리되어 실행되는 여러 개의 Linux 시스템(컨테이너)을 생성하는 것을 가능하게 한다. 