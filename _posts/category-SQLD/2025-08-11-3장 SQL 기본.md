---
title: "3장 SQL 기본"
excerpt: "SQL을 사용하는 기본적인 방법과 조인, 계층형 쿼리, 서브쿼리, 그룹 함수, 윈도우 함수 등을 학습한다."

wirter: sohee Kim
categories:
  - SQLD
tags:
  - SQLD

toc: true
toc_sticky: true

date: 2025-08-06
last_modified_at: 2025-08-08
---

SQL 기본
=======

관계형 데이터베이스(Relation)
------

&ensp;1. 관계형 데이터베이스(Relation Database)<br/>
&ensp;(1) 관계형 데이터베이스의 등장<br/>
* 관계형 데이터베이스는 릴레이션(Relation)과 릴레이션의 조인 연산을 통해서 합집합, 교집합,차집합 등을 만들 수 있다.
* 현재 기업에서 가장 많이 사용하는 데이터베이스로 Oracle, MS-SQL. MySQL, Sybase 등의 다양한 데이터베이스 관리 시스템이 있다.

&ensp;2. 데이터베이스와 데이터베이스 관리 시스템의 차이점<br/>
* 데이터베이스는 데이터를 어떠한 형태의 자료구조(Data Structure)로 사용하느냐에 따라서 나누어진다.
* 데이터베이스의 종류는 계층형, 네트워크형 데이터베이스, 관계형 데이터베이스 등이 있다.
* 게층형 데이터베이스는 트리(Tree) 형태의 자료구조에 데이터를 저장하고 관리하며 네트워크는 오너(Owner)와 멤버(Member) 형태로 데이터를 저장한다.
* 계층형 데이터베이스는 1대N 관계를 표현한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-1.JPEG" width="600"></p>

* 네트워크 데이터베이스는 1대N과 함께 M대N 표현도 가능하다

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-2.JPEG" width="600"></p>

* 관계형 데이터베이스는 릴레이션에 데이터를 저장하고 관리한다.
* 관계형 데이터베이스는 릴레이션을 사용해서 집합 연산과 관계 연산을 할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-3.JPEG" width="600"></p>

* 데이터베이스 관리 시스템(Database Management System)은 계층형 데이터베이스, 네트워크 데이터베이스, 관계형 데이터베이스 등을 관리하기 위한 소프트웨어를 의미하며 일명 DBMS라고 한다.
* DBMS의 종류에는 Oracle, MS-SQL. MySQL, Sybase 등이 있으며 모두 관계형 데이터베이스를 지원한다.

&ensp;(3) 관계형 데이터베이스 집합 연산과 관계 연산<br/>

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-4.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-5.JPEG" width="600"></p>

&ensp;2. 테이블(Table)의 구조<br/>
* 관계형 데이터베이스는 릴레이션에 데이터를 저장하고 릴레이션을 사용해서 집합 연산 및 관계 연산을 지원하여 다양한 형태로 데이터를 조회할 수 있다.
* 릴레이션은 최종적으로 데이터베이스 관리 시스템에서 테이블(Table)로 만들어진다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-6.JPEG" width="600"></p>

* 기본키(Primary key)는 하나의 테이블에서 유일성(Unique)과 최소성, Not Null을 만족하면서 해당 테이블을 대표하는 것이다. EMP테이블에서는 사원번호가 기본키가 된다.
* 테이블은 행과 칼럼으로 구성된다. 그중에서 행(ROW)은 하나의 테이블에 저장되는 값으로 튜플(Tuple)이라고도 한다.
* 칼럼(Column)은 어떤 데이터를 저장하기 위한 필드(Field)로 속성(Attribute)이라고 한다.
* 외래키(Foreign key)는 다른 테이블의 기본키를 참조(조인)하는 칼럼이다. 예를 들어 EMP 테이블의 부서코드는 DEPT 테이블의 기본키인 부서코드를 참조한다.
* 외래키는 관계 연산 중에서 결합 연산(Join)을 하기 위해서 사용한다.

SQL(Structured Query Language) 종류
------

&ensp;1. SQL(Structured Query Language)<br/>
* SQL은 관계형 데이터베이스에 대해서 데이터의 구조를 정의, 데이터 조작, 데이터 제어 등을 할 수 있는 절차형 언어이다.
* 관계형 데이터베이스는 데이터베이스를 연결하고 SQL문을 사용하여 데이터베이스를 누구나 쉽게 사용할 수 있도록 한다.
* SQL은 ANSI/ISO 표준을 준수하기 때문에 데이터베이스 관리 시스템이 벼경되어도 그대로 사용할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-7.JPEG" width="600"></p>

&ensp;2. SQL(Structured Query Language) 종류<br/>
* SQL은 데이터 정의, 데이터 조작, 데이터 제어 등의 기능을 지원한다.

&ensp;(1) SQL의 종류<br/>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-8.JPEG" width="600"></p>

* DDL문은 데이터베이스 테이블을 생성하거나 변경, 삭제하는 것으로 데이터를 저장할 구조를 정의하는 언어이다.
* DML은 데이터 구조가 DDL로 정의되면 해당 데이터 구조에 데이터를 입력하거나 수정, 삭제, 조회할 수 있다.
* DCL은 DDL로 정의된 구조에 어떤 사용자가 접근할 수 있는지 권한을 부여하는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-9.JPEG" width="600"></p>

* 작업의 순서를 보면 데이터베이스의 사용자에게 권한을 부여하고 권한이 부여되면 DDL로 데이터 구조를 정의한다.
* 데이터 구조가 정의되면 데이터를 입력한 후에 개발자 및 사용자가 그 데이터를 조회하는 것이다.

&ensp;(2) 트랜잭션(Transaction)<br/>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-10.JPEG" width="600"></p>

&ensp;3. SQL문의 실행 순선<br/>
* 개발자가 작성한 SQL(DDL, DML, DCL 등)은 3단계를 걸쳐서 실행된다. SQL문의 문법을 거사하고 구문 분석을 한다.
* 구분 분석 이후에 SQL을 실행한다. SQL이 실행되면 데이터를 인출하게 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-11.JPEG" width="600"></p>

DDL(Data Definition Language)
-------

&ensp;1. 테이블(Table) 생성<br/>
* 데이터베이스를 사용하기 위해서는 테이블을 먼저 생성해야 한다.
* 테입르 생성은 Create Table문을 사용하고 테이블 변경은 Alter Table문을 사용한다. 마지막으로 생성된 테이블을 삭제하고 싶을 때는 Drop Table문을 사용하면 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-12.JPEG" width="600"></p>

&ensp;(1) 기본적인 테이블 생성<br/>
* 테이블을 생성하는 방법은 여러 가지가 있다. 먼저 아주 간단한 테이블 생성 방법을 확인해보자

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-13.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-14.JPEG" width="600"></p>

&ensp;(2) 제약조건 사용<br/>
* 기본키, 외래키, 기본값, not null 등은 테이블을 생성할 때 지정할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-15.JPEG" width="600"></p>

* 위의 예를 보면 "constraint" 를 사용하여 기본키(empno)와 기본키의 이름(empppk)을 지정할 수 있다.
* 만약 위의 예에서 두 개의 기본키를 지정하고자 한다면 "constraint emppk primary key(empno, ename)"으로 지정하면 된다.
* sal 칼럼은 number(10, 2)로 지정했다. 이것은 소수점 둘째 자리까지 저장하게 된다.
* Oracle 데이터베이스에서 "sydate"는 오늘의 날짜를 조회한다. 이를 default 옵셥을 사용해서 오늘 날짜를 기본값으로 지정할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-16.JPEG" width="600"></p>

* 외래키(foreign key)를 지정하려면 먼저 마스터 테이블이 생성되어야 한다. 즉 사원과 부서 테이블에서는 부서가 마스터 테이블이 된다.
* 즉 사원 테이블이 부서 테이블의 deptno를 참조해야 하는 것이다.
* 그리고 EMP 테이블을 생성할 때 constraint를 사용하여 외래키 이름인 "deptfk"를 입력 후 외래키를 생성한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-17.JPEG" width="600"></p>

&ensp;(3) 테이블 생성 시 CASCADE 사용<br/>
* 테이블을 생성할 때 CASCADE 옵션을 사용할 수 있다. CASCADE 옵션은 참조 관계(기본키와 외래키 관계)가 있을 경우 참조되는 데이터를 자동으로 반영할 수 있는 것이다.
* 먼저 마스터 테이블을 생성한다. 즉 DEPT 테이블을 생성하고 데이터를 입력한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-18.JPEG" width="600"></p>

* 그 다음 EMP 테이블을 생성하고 데이터를 입력한다. 단 EMP 테이블을 생성할 때 "ON DELETE CASCADE" 옵션을 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-19.JPEG" width="600"></p>

* EMP 테이블을 생성하고 데이터 두 개를 입력한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-20.JPEG" width="600"></p>

* 위의 예제를 보면 DEPT 테이블에서 DEPTNO가 '1000번' 인 인사팀을 삭제한다.
* 그리고 EMP 테이블의 데이터를 조회한 결과 DEPTNO '1000'번이였던 '임베스트' 데이터도 자동으로 삭제된 것을 알 수 있다.
* 즉 ON DELETE CASCADE 옵션은 자신이 참조하고 있는 테이블(DEPT)의 데이터가 삭제되면 자동으로 자신(EMP)도 삭제되는 옵션이다.
* ON DELETE CASCADE 옵션을 사용하면 참조 무결성을 준수할 수 없다. 참조 무결성이란 마스터 테이블(DEPT)에는 해당 부서번호(DEPTNO)가 없는데 슬레이브 테이블(EMP)에는 해당 부서번호가 있는 경우를 참조 무결성 위배로 볼 수 있다.

&ensp;2. 테이블(Table) 변경<br/>
* ALTER TABLE문을 통해 테이블 변경을 할 수 있으며 테이블명 변경, 칼럼 추가, 변경, 삭제 등을 할 수 있다.

&ensp;(1) 테이블명 변경<br/>
* 테이블명 변경은 ALTER TABLE ~ RENAME TO문을 사용하면 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-21.JPEG" width="600"></p>

&ensp;(2) 칼럼 추가<br/>
* 생성된 EMP 테이블에 ALTER TABLE ~ ADD문을 사용해서 칼럼을 추가한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-22.JPEG" width="600"></p>

&ensp;(3) 칼럼 변경<br/>
* 칼럼의 변경은 ALTER TABLE ~ MODIFY문을 사용하면 된다. 칼럼 변경을 통해 데이터 타입으르 변경하거나 데이터의 길이를 변경할 수 있다.
* 칼럼을 변경할 때 제약조건을 설정할 수도 있다.
* 칼럼의 데이터 타입을 변경할 때 기존 데이터가 있는 경우 에러가 발생한다. 예를 들어 숫자 타입이고 숫자 데이터가 저장되어 있는데 문자형 데이터 타입으로 변경하면 에러가 발생하는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-23.JPEG" width="600"></p>

&ensp;(4)칼럼 삭제<br/>
* 칼럼에 대한 삭제는 ALTER TABLE ~ DROP COLUMN문으로 삭제한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-24.JPEG" width="600"></p>

&ensp;(5) 칼럼명 변경<br/>
* 칼럼명 변경은 ALTER TABLE ~ RENAME COLUMN ~ TO 문으로 변경할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-25.JPEG" width="600"></p>

&ensp;3. 테이블(Table) 삭제<br/>
* 테이블 삭제는 DROP TABLE문을 사용해서 삭제할 수 있다.
* DROP TABLE문은 테이블의 구조와 테이블를 모두 삭제한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-26.JPEG" width="600"></p>

* DROP TABLE에서 CASECADE CONSTRAINT 옵션을 사용할 수 있다. CASCADE CONSTRAINT 옵션은 해당 테이블의 데이터를 외래키로 참조한 슬레이브 테이블과 관련된 제약사항도 삭제할 때 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-27.JPEG" width="600"></p>

&ensp;4. 뷰(View)생성과 삭제<br/>
* 뷰는 테이블로부터 유도된 가상의 테이블이다.
* 실제 데이터를 가지고 있지 않고 테이블을 참조해서 원하는 칼럼만을 조회할 수 있게 한다. 
* 뷰는 데이터 딕셔너리(Data Dictionary)에 SQL문을 형태로 저장하되 실행 시에 참조된다.

* 뷰의 특징<br/>
  - 참조한 테이블이 변경되면 뷰도 변경된다.
  -  뷰의 검색은 참조한 테입르과 동일하게 할 수 있지만 뷰에 대한 입력, 수정, 삭제엔느 제약이 있다.
  - 특정 칼럼만 조회시키는 보안성을 향상시킨다.
  - 한번 생성된 뷰는 변경할 수 없고 변경을 원하면 삭제 후 재생성해야 한다.
  - ALTER문을 사용해서 뷰를 변경할 수 없다.

* 뷰를 생성할 때 CREATE VIEW문을 사용하며 이 때 참조할 테이블은 SELECT문으로 지정한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-28.JPEG" width="600"></p>

* 뷰의 조회는 SELECT문을 사용해서 일반 테이블처럼 조회한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-29.JPEG" width="600"></p>

* 뷰의 삭제는 DROP VIEW를 사용한다. 뷰를 삭제했다고 해서 참조했던 테이블이 삭제되지는 않는다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-30.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-31.JPEG" width="600"></p>

DML(Data Manipulation Language)
------

&ensp;1. INSERT문<br/>
&ensp;(1) INSERT문<br/>
* INSERT문은 테이블에 데이터를 입력하는 DML문이다.

* INSERT문

```sql
INSERT INTO data(column1, column2,...)VALUES(expression1, expression2);
```

* EMP 테이블에 데이터를 삽입하려면 테이블명, 칼럼명, 데이터 순으로 입력하면 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-32.JPEG" width="600"></p>

* 데이터를 입려할 때 문자열을 입력하는 경우에는 작음 따옴표(' ')를 사용해야 한다.
* 만약 특정 테이블의 모든 칼럼에 대한 데이터를 삽입하는 경우에는 칼럼명을 생략할 수 있다.
* 모든 칼럼에 데이터를 입력한다.

```sql
INSERT INTO EMP VALUES(1000, '임베스트');
```

* 위의 예처럼 칼럼명을 생략할 수 있다. 단 위의 예제에서 EMP 테이블의 칼럼은 숫자형 데이터 타입 한 개의 칼럼과 문자형 데이터 타입 한 개의 칼럼만 있어야 한다.
* 주의사항은 INSERT문을 실행했다고 데이터 파일에 저장되는 것은 아니다. 최종적으로 데이터를 저장하려면 TCL문인 Commit을 실행해야 한다.
* 만약 Auto Commit(Set auto commit on)으로 설정된 경우에는 Commit을 실행하지 않아도 바로 저장된다.

&ensp;(2)SELECT문으로 입력<br/>
* SELECT문을 사용하여 데이터를 조회해서 해당 테이블에 바로 삽입할 수 있다.
* 단 입력되는 테이블은 사전에 생성되어 있어야 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-33.JPEG" width="600"></p>

&ensp;(3)Nologging 사용<br/>
* 데이터베이스에 데이터를 입력하면 로그파일(Log file)에 그 정보를 기록한다.
* Check point라는 이벤트가 발생하면 로그파일의 데이터를 데이터 파일에 저장한다.
* Nologging 옵션은 로그파일의 기록을 최소화시켜서 입력 시 성능을 향상시키는 방법이다.
* Nologging 옵션은 Buffer Cache라는 메모리 영역을 생략하고 기록한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-34.JPEG" width="600"></p>

&ensp;2. UPDATE문<br/>
* 입력된 데이터이 값을 수정하려면 UPDATE문을 사용한다.
* UPDATE문을 사용하여 원하는 조건으로 데이터를 검색해서 해당 데이터를 수정할 수 있다.
* 만약 UPDATE문에 조건문을 입력하지 않으면 모든 데이터가 수정되므로 유의해야 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-35.JPEG" width="600"></p>

* UPDATE문에서 주의사항은 데이터를 수정할 때 조건절에서 검색되는 행 수 만큼 수정된다는 것이다.
* 위의 예에서 EMPNO가 100번인 직원이 두 명이라면 두 명의 ENAME은 모두 조조로 수정된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-36.JPEG" width="600"></p>

* 만약 위의 예에서 WHERE절(조건)을 입력하지 않으면 EMP 테이블의 모든 데이터가 삭제된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-37.JPEG" width="600"></p>

* TRUNCATE TABLE EMP는 EMP 테이블의 모든 데이터를 삭제하면서 테이블의 용량이 초기화된다.

&ensp;4. SELECT문<br/>
&ensp;(1) SELECT문 사용<br/>
* 테이블에 입력된 데이터를 조회하기 위해서 SELECT문을 사용한다.
* SELECT문은 특정 칼럼이나 특정 행만을 조회할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-38.JPEG" width="600"></p>

* 위의 SELECT문에서 EMP 테이블의 모든 칼럼 * 을 출력한다.
* 단 WHERE절에 있는 조건문에 있는 행만 조회한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-39.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-40.JPEG" width="600"></p>

&ensp;(2) ORDER BY를 사용한 정렬<br/>
* SELECT문을 사용할 때 ORDER BY를 같이 사용할 수 있다.
* ORDER BY는 데이터를 오름차순(Ascending) 혹은 내림차순(Descending)으로 출력한다.
* ORDER BY가 정렬을 하는 시점은 모든 실행이 끝난 후에 데이터를 출력해 주기 바로 전이다.
* ORDER BY는 정렬을 하기 때문에 데이터베이스 메모리를 많이 사용하게 된다. 즉 대용량 데이터르 정렬하게 되면 정렬로 인한 성능 저하가 발생한다.
* Oracle 데이터베이스는 정렬을 위해서 메모리 내부에 할당된 SORT_AREA_SIZE를 사용한다. 만약 SORT_AREA_SIZE가 너무 작으면 성능 저하가 발생한다.
* 정렬을 회피하기 위해서 인덱스(Index)를 생성할 때 사용자가 원하는 형태로 오름차순 혹은 내림차순으로 생성해야 한다.
* 특정한 지정이 없으면 ORDER BY는 오름차순으로 정렬한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-41.JPEG" width="600"></p>

* ENAME 부분은 ENAME ASC와 같다. 기본적으로 오름차순과 내림차순을 지정하지 않으면 오름차순으로 정렬한다.
* 내림차순으로 정렬하고 싶을 때는 DESC를 사용한다.

&ensp;(3) Index를 사용한 정렬 회피<br/>
* 정렬은 Oracle 데이터베이스에 부하를 주므로 인덱스를 사용해서 ORDER by를 회피할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-42.JPEG" width="600"></p>

* 위와 같이 데이터를 입력하고 SELECT문을 실행하면 EMPNO로 오름차순 정렬되어서 조회된다.
* 그 이유는 EMPNO가 기본키이기 때문에 자동으로 오름차순 인덱스가 생성된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-43.JPEG" width="600"></p>

* 위의 예를 보면 '/*+INDEX_DESC(A)*/'를 사용했다. EMP테이블에 생성된 인덱스를 내림차순으로 읽게 지정한 것이다.
* 따라서 SELECT문에 ORDER BY EMPNO DESC를 사용하지 않았다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-44.JPEG" width="600"></p>

* 위의 예처럼 SQL문을 사용하면 EMPNO 인덱스를 내림차순으로 읽는다.
* 인덱스를 스캔한 후에 해당 EMPNO의 값을 가지고 테이블의 데이터를 읽는다.
* 테이블에서 해당 행을 찾으면 인출하여 사용자 화면에 조회된다.

&ensp;(4) DISTINCT와 Alias<br/>
&ensp;① DISTINCT<br/>
* DISTINCT문은 칼럼명 앞에 지정하여 중복된 데이터를 한 번만 조회하게 한다.<br/>

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-45.JPEG" width="600"></p>

* 위의 예는 EMP 테이블의 DEPTNO 칼럼을 조회한 것이다. 조회 내용을 보면 DEPTNO가 중복으로 저장되어 있는 것을 확인할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-46.JPEG" width="600"></p>

* Distinct를 사용하면 DEPTNO 값이 중복되지 않는다.

&ensp;② Alias<br/>
* Alias(별칭)은테이블명이나 칼럼명이 너무 길어서 간략하게 할 때 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-47.JPEG" width="600"></p>

WHERE문 사용
-------

&ensp;(1) WHERE문이 사용하는 연산자<br/>
* WHERE문이 사용할 수 있는 연산자는 비교 연산자, 논리 연산자, SQL 연산자, 부정 SQL 연산자가 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-48.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-49.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-50.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-51.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-52.JPEG" width="600"></p>

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-53.JPEG" width="600"></p>

* 위의 예는 EMP 테이블에서 EMPNOrk 1001이 SAL이 1000보다 크거나 같은 것을 조회한다.

&ensp;(2) LIKE문 이용<br/>
* LIKE 문은 와일드카드를 사용해서 데이터를 조회할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-54.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-55.JPEG" width="600"></p>

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-56.JPEG" width="600"></p>

&ensp;(3) BETWEEN문 이용<br/>
* BETWEEN문은 지정된 범위에 있는 값을 조회한다.
* BETWEEN 1000 and 2000은 1000과 2000을 포함하고 1000과 2000사이의 값을 조회한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-57.JPEG" width="600"></p>

* 위의 예는 급여(SAL)가 1000 이상 2000이하인 직원을 조회한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-58.JPEG" width="600"></p>

* 위의 예는 급여(SAL)가 1000 미만 2000 초과인 값을 조회한다.

&ensp;(4) IN문 사용<br/>
* IN문은 OR의 의미를 가지고 있어서 하나의 조건만 만족해도 조회가 된다.
* 예를 들어 JOB이 CLERK 이거나 MANAGER인 것을 조회할 때 JOB IN('CLBRK', 'MANAGER')를 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-59.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-60.JPEG" width="600"></p>

* 괄호를 사용하여 원하는 데이터를 칼럼명에 대응되도록 입력함으로써 IN문으로 여러 개의 칼럼에 대한 조건을 지정할 수 있다.

&ensp;(5) NULL 값 조회<br/>
&ensp;① NULL의 특징<br/>
* NULL은 모르는 값을 의미한다.
* NULL은 값의 부재를 의미한다.
* NULL과 숫자 혹은 날짜를 더하면 NULL이 된다.
* NULL과 어떤 값을 비교할 때 알 수 없음이 반환된다.

&ensp;② NULL값 조회<br/>
* NULL을 조회할 경우는 IS NULL을 사용하고 NULL 값이 아닌 것을 조회할 경우는 IS NOT NULL을 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-61.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-62.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-63.JPEG" width="600"></p>

GROUP 연산
-------

&ensp;1. GROUP BY문<br/>

* GROUP BY는 테이블에서 소규모 행을 그룹화하여 합계, 평균, 최댓값, 최솟값 등을 계산할 수 있다.
* HAVING구에 조건문을 사용한다.
* Grouping된 결과에 대한 조건문을 사용한다.
* ORDER BY를 사용해서 정렬을 할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-64.JPEG" width="600"></p>

* 위의 GROUP BY 예에서 1번은 EMP 테이블을 그대로 조회한 것이다. 즉 SELECT DEPTNO, SAL FROM EMP를 실행한 것이다.
* 2번은 DEPTNO(부서번호)로 그룹을 만들고 3번은 그룹별 합계를 계산하라는 뜻이다.
* 4번은 부서별 합계를 계산하게 된다.

&ensp;2. HAVING문 사용<br/>
* GROUP BY에 조건절을 사용하려면 HAVING을 사용해야 한다. 만약 WHERE절에 조건문을 사용하게 되면 조건을 충죽하지 못하는 데이터들은 GROUP BY 대상에서 제외된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-65.JPEG" width="600"></p>

&ensp;3. 집계 함수 종류<br/>

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-66.JPEG" width="600"></p>

&ensp;4. COUNT 함수<br/>
* COUNT()함수는 행 수를 계산하는 함수이다. COUNT(*)는 NULL 값을 포함한 모든 행 수를 계산한다. 하지만 COUNT(칼럼명)는 NULL값을 제외한 행 수를 계산한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-67.JPEG" width="600"></p>

* MGR 칼럼은 한 개의 NULL을 가지고 있다. 그래서 COUNT(MGR)로 하면 NULL이 제외되고 행 수를 계산한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-68.JPEG" width="600"></p>

&ensp;5. GROUP BY 사용 예제<br/>
&ensp;(1) 부서별(DEPTNO), 관리자별(MGR) 급여평균 계산<br/>
* 부서별, 관리자별 급여평균이므로 GROUP BY에 부서와 관리자를 추가한다.
* 평균을 계산하기 위해서 SELECT믄에 AVG함수를 사용해야 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-69.JPEG" width="600"></p>

&ensp;(2) 직업별(JOB) 급여합계 중에 급여(SAL)합계가 1000이상인 직업<br/>
* 직업별 급여합계이므로 GROUP BY에 JOB을 포함시키고 급여합계가 1000이상만 조회해야 하므로 HAVING구에 조건을 넣어야 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-70.JPEG" width="600"></p>

&ensp;(3) 사원번호 1000~1003번의 부서별 급여합계<br/>
* 사원번호 1000번에서 1003번까지 조회를 해야 하므로 WHERE문에 조건을 넣어야 한다.
* 그리고 부서별 합계이므로 GROUP BY에 DEPTNO를 사용하고 SELECT문에 SUM 함수를 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-71.JPEG" width="600"></p>

SELECT문 실행 순서
-----

* SQL의 실행 순서는 결과로 조회된 데이터를 이해하는 데 아주 중요한 요소이다.
* SELECT문의 실행 순서는 FROM, WHERE, GROUP BY, SELECT, ORDER BY순으로 실행된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-72.JPEG" width="600"></p>

명시적(Explicit) 형변환과 암시적(implicit) 형변환
------

* 형변환이라는 것은 두 개의 데이터의 데이터 타입(형)이 일치하도록 변환하는 것이다.
* 예를 들어 숫자와 문자열의 비교, 문자열과 날짜형의 비교와 같이 데이터 타입이 불일치할 때 발생한다.
* 형변환은 명시적(Explicit) 형변환과 암시적(Implicit) 형변환이 있다.
* 명시적 형변환은 형변환 함수를 사용해서 데이터 타입을 일치시키는 것으로 개발자가 SQL을 사용할 때 형변환 함수를 사용해야 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-73.JPEG" width="600"></p>

* 암시적 형변환은 개발자가 형변환을 하지 않은 경우 데이터베이스 관리 시스템이 자동으로 형변환하는 것을 의미한다.

&ensp;인덱스 칼럼에 형변환을 수행하면 인덱스를 사용하지 못한다.<br/>
* 인덱스는 데이터를 빠르게 조회하기 위해서 인덱스 키를 기준으로 정렬해 놓은 데이터이다.
* 그런데 인덱스는 기본적으로 변형이라는 것이 발생하면 인덱스를 사용할 수 없다. 물론 예외적인 것도 있다.
* 따라서 인덱스가 있어도 인덱스 칼럼에 형변환이 발생하면 인덱스를 사용할 수 없다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-74.JPEG" width="600"></p>

* EMPNO 칼럼은 숫자형 타입이고 기본키이므로 자동으로 인덱스가 있다.
* 하지만 암시적 형변환으로 EMPNO가 TO_CHAR(EMPNO)로 변환되므로 인덱스를 사용할 수 없다.
* 이와 같은 문제는 명시적 형변환을 사용하면 된다. 즉 WHERE EMPNO=TO_NUMBER("100")으로 하면 EMPNO 칼럼이 변환되지 않아서 인덱스를 사용할 수 없다.

내장형 함수(BUILT-IN Function)
------

&ensp;1. 내장형 함수<br/>
* 모든 데이터베이스는 SQL에서 사용할 수 있는 내장형 함수를 가지고 있다.
* 내장형 함수는 데이터베이스 관리 시스템 벤더별로 약간의 차이가 있지만 거의 비슷한 방법으로 사용이 가능하다.
* 내장형 함수로는 앞서 배운 형변환 함수, 문자열 및 숫자형 함수, 날짜형 함수가 있다.

&ensp;2. DUAL 테이블<br/>
* DUAL 테이블은 Oracle 데이터베이스에 의해서 자동으로 생성되는 테이블이다.
* Oracle 데이터베이스 사용자가 임시로 사용할 수 있는 테이블로 내장형 함수를 실행할 때도 사용할 수 있다.
* Oracle 데이터베이스의 모든 사용자가 사용할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-75.JPEG" width="600"></p>

&ensp;3. 내장형 함수의 종류<br/>
* DUAL 테이블에 문자열 내장형 함수를 사요앟면 다음과 같다.
* ASCII함수는 문자에 대한 ASCII 코드 값을 알려준다. ASCII 코드는 대문자 A를 기준으로 A(65), B(66), C(67) 등의 값이다.
* SUBSTR 함수는 지정된 위치의 문자열을 자르는 함수고 LENGTH함수, LEN 함수는 문자열의 길이를 계산한다.
* LTRIM 함수를 사용하면 문자열의 왼쪽 공백을 제거할 수 있다.
* 또한 함수를 중첩해서 사용해도 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-76.JPEG" width="600"></p>

* Oracle 데이터베이스에서 제공하는 문자열 함수는 다음과 같다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-77.JPEG" width="600"></p>

* 날짜형 함수 중에서 오늘 날짜를 구하기 위해서는 SYSDATE를 사용하면 된다.
* 만약 해당 연도만 알고 싶다면 EXTRACT 함수를 사용한다.
* TO_CHAR 함수는 형변환 함수 중에서 가장 많이 사용하는 것으로 숫자나 날짜를 원하는 포맷의 문자열로 변환한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-78.JPEG" width="600"></p>

* Oracle 데이터베이스 날짜형 함수는 다음과 같다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-79.JPEG" width="600"></p>

* 절댓값을 계산하는 ABS 함수와 음수, 0, 양수를 구분하는 SIGN, 나머지를 계산하는 MOD 등의 함수를 사용하면 다음과 같다. 

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-80.JPEG" width="600"></p>

* Oracle 데이터베이스가 지원하는 숫자형 함수는 다음과 같다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-81.JPEG" width="600"></p>

DECODE와 CASE문
------

&ensp;1. DECODE<br/>
* DECODE문으로 IF문을 구현할 수 있다. 즉 특정 조건이 참이면 A, 거짓이면 B로 응답한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-82.JPEG" width="600"></p>

* 위의 예는 EMPNO를 1000과 비교해서 같으면 TRUE를 출력하고 다르면 FALSE를 출력한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-83.JPEG" width="600"></p>

&ensp;2. CASE문<br/>
* CASE문은 IF~THEN ~ELSE-END의 프로그래밍 언어처럼 조건문을 사용할 수 있다.
* 조건을 WHEN구에 사용한다. 해당 조건이 참이면 THEN이 실행되고 거짓이면 ELSE구가 실행된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-84.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-85.JPEG" width="600"></p>

* 위의 예는 EMPNO가 1000이면 A를 출력하고 1001이면 B를 출력한다. 만약 그렇지 않으면 C를 출력한다.


ROWNUM과 ROWID
------

&ensp;1. ROWNUM<br/>
* ROWNUM은 ORACLE데이터베이스의 SELECT문 결과에 대해서 논리적이 일련번호를 부여한다.
* ROWNUM은 조회되는 행 수를 제한할 때 많이 사용된다.
* ROWNUM은 화면에 데이터를 출력할 때 부여되는 논리적인 순번이다. 만약 ROWNUM을 사용해서 페이지 단위 출력을 하기 위해서는 인라인 뷰(Inline view)를 사용해야 한다.

&ensp;인라인뷰(Inline view)<br/>
- 인라인뷰는 SELECT문에서 FROM절에서 사용되는 서브쿼리(Sub Query)를 의미한다.

```sql
SELECT * FROM    //Main Query
(SELECT * FROM EMP)a;   //Sub Query(Inline view)
```

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-86.JPEG" width="600"></p>

* 위의 예에서 ROWNUM < 2 까지는 사용 가능하다. 한 행을 가지고 올 수 있기 때문이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-87.JPEG" width="600"></p>

* 위와 같이 5건의 행을 조회하기 위해서는 인라인 뷰를 사용하고 ROWNUM에 별칭을 사용해야한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-88.JPEG" width="600"></p>

* 위의 웹 페이지를 보면 한 페이지당 18개의 행을 조회한다. 그래서 첫 번째 페이지는 1~18개를 조회하고 두 번째 페이지는 19~36개의 행을 조회하는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-89.JPEG" width="600"></p>

* 위의 예처럼 ROWNUM과 BETWEEN구를 사용해서 웹 페이지 조회를 구현할 수 있다.
*
&ensp;2. ROWID<br/>

* ROWID는 ORAClE 데이터베이스 내에서 데이터를 구분할 수 있는 유일한 값이다.
* ROWID는 "SELECT ROWID, EMPNO FROM EMP" 와 같은 SELECT문으로 확인할 수 있다. 
* ROWID를 통해서 데이터가 어떤 데이터 파일, 어느 블록에 저장되어 있는 지 알 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-90.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-91.JPEG" width="600"></p>

WITH구문
-------

* WITH구문은 서브쿼리(Subquery)를 사용해서 임시 테이블이나 뷰처럼 사용할 수 있는 구문이다.
* 서브쿼리 블록에 별칭을 지정할 수 있다.
* 옵티마이저는 SQL을 인라인 뷰나 임시 테이블로 판단한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-92.JPEG" width="600"></p>

DCL(Data Control Language)
------

&ensp;1. GRANT<br/>
* GRANT문은 데이터베이스 사용자에게 권한을 부여한다.
* 데이터베이스 사용을 위해서는 권한이 필요하며 연결, 입력, 수정, 삭제, 조회를 할 수 있다.

&ensp;GRANT문<br/>

```sql
GRANT privileges ON object TO user;
```

* privileges는 권한을 의미하며 objectsms 테이블명이다.
* user는 Oracle 데이터베이스 사용자를 지정하면 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-93.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-94.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-95.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-96.JPEG" width="600"></p>

&ensp;2. REVOKE<br/>
* REVOKE문은 데이터베이스 사용자에게 부여된 권한을 회수한다.

&ensp;REVOKE문<br/>

```sql
REVOKE privileges ON object FROM user;
```

TCL(Transaction Control Language)
------

&ensp;1. COMMIT<br/>
* COMMIT은 INSERT, UPDATE, DELECT문으로 변경한 데이터를 데이터베이스에 반영한다.
* 변경 이전 데이터는 잃어버린다. 즉 A값을 B로 변경하고 COMMIT을 하면 A값은 읽어버리고 B값을 반영한다.
* 다른 모든 데이터베이스 사용자는 변경된 데이터를 볼 수 있다.
* COMMIT이 완료되면 데이터베이스 변경으로 인한 LOCK이 해제(UNLOCK)된다.
* COMMIT을 실행하면 하나의 트랜잭션 과정을 종료한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-97.JPEG" width="600"></p>

* Oracle 데이터베이스는 암시적 트랜잭션 관리를 한다. 즉 Oracle 데이터베이스로 트랜잭션을 시작하고 트랜잭션의 종료는 Oracle 데이터베이스 사용자가 COMMIT 혹은 ROLL-BACK으로 처리해야 한다. 

&ensp;2. ROLLBACK<br/>
* ROLLBACK을 실행하면 데이터에 대한 변경 사용을 모두 취소하고 트랜잭션을 종료한다.
* INSERT, UPDATE, DELECT문의 작업을 모두 취소한다. 단 이전에 COMMIT한 곳까지만 복구한다.
* ROLLBACK을 실행하면 LOCK이 해제되고 다른 사용자도 데이터베이스 행을 조작할 수 있다. 

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-98.JPEG" width="600"></p>

&ensp;3. SAVEPOINT(저장점)<br/>
* SAVEPOINT는 트랜잭션을 작게 분할하여 관리하는 것으로 SAVEPOINT를 사용하면 지정된 위치 이후의 트랜잭션만 ROLLBACK 할수 있다.
* SAVEPOINT의 지정은 SAVEPOINT <SAVEPOINT명>을 실행한다.
* 지정된 SAVEPOINT까지만 데이터 변경을 취소하고 싶은 경우는 ROLLBACK TO <SAVEPOINT명>을 실행한다.
* ROLLBACK을 실행하면 SAVEPOINT와 관계없이 데이터의 모든 변경사항을 저장하지 않는다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-99.JPEG" width="600"></p>

SQL활용
======

조인(JOIN)
------

&ensp;1. EQU(등가) JOIN(교집합)<br/>
&ensp;(1) EQU(등가) JOIN<br/>
* 조인은 여러 개의 릴레이션을 사용해서 새로운 릴레이션을 만드는 과정이다.
* 조인의 가장 기본은 교집합을 만드는 것이다.
* 두 개의 테이블 간에 일치하는 것을 조인한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-100.JPEG" width="600"></p>

* EQUI 조인은 EMP 테이블과 DEPT 테이블에서 DEPTNO 칼럼을 사용하여 같은 것을 조인한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-101.JPEG" width="600"></p>

* 위의 예를 보면 EMP 테이블의 DEPTNO와 DEPT 테이블의 DEPTNO가 같은 것을 사용하여 조인한다, 

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-102.JPEG" width="600"></p>

* EQUI JOIN은 "="을 사용해서 두 개의 테이블을 연결한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-103.JPEG" width="600"></p>

&ensp;(2) INNER JOIN<br/>
* EQUI JOIN과 마찬가지로 ISO 표준 SQL로 INNER JOIN 이 있다. INNER JOIN은 ON문을 사용해서 테이블을 연결한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-104.JPEG" width="600"></p>

* 위의 예를 보면 INNER JOIN구에 두 개의 테이블명을 서술하고 ON문 조인 조건을 서술한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-105.JPEG" width="600"></p>

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-106.JPEG" width="600"></p>

* EQUI JOIN을 한 후에 실행 계획을 확인해서 내부적으로 두 개의 테이블을 어떻게 연결했는지 확인할 수 있다.
* 위의 예를 보면 DEPT 테이블과 EMP 테이블 전체를 읽은 다음에 (TABLE ACCESS FULL) 해시 함수를 사용해서 두 개의 테이블을 연결한 것이다. 
* 해시 함수는 테이블을 해시 메모리에 적재한 후에 해시 함수로써 연결하는 방법이다.
* 해시 조인은 EQUI JOIN만 사용 가능한 방법이다.

&ensp;(3) INTERSECT 연산<br/>
* INTERSECT 연산은 두 개의 테이블에서 교집합을 조회한다.
* 즉 두 개 테이블에서 공통된 값을 조회한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-107.JPEG" width="600"></p>

&ensp;2. Non-EQUI(비등가) JOIN<br/>
* Non-EQUI는 두 개의 테이블 간에 조인하는 경우 "="을 사용하지 않고 ">", "<", ">=", "<=" 등을 사용한다.
* 즉 Non-EQUI JOIN은 정확하게 일치하지 않는 것을 조인하는 것이다.

&ensp;3. OUTER JOIN<br/>
* OUTER JOIN은 두 개의 테이블 간에 교집합(EQUI JOIN)을 조회하고 한쪽 테이블에만 있는 데이터도 포함시켜서 조회한다.
* 예를 들어 DEPT 테이블과 EMP 테이블을 OUTER JOIN 하면 DEPTNO가 같은 것을 조회하고 DEPT 테이블에만 있는 DEPTNO도 포함시킨다. 
* 이때 왼쪽 테이블에만 있는 행도 포함하면 LEFT OUTER JOIN이라고 하고 오른쪽 테이블의 행만 포함시키면 RIGHT OUTER JOIN이라고 한다.
* FULL OUTER JOIN은 LEFT OUTER JOIN과 RIGHT OUTER JOIN 모두를 하는 것이다.
* Oracle 데이터베이스에서는 OUTER JOIN을 할 때 "(+)" 기호를 사용해서 할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-108.JPEG" width="600"></p>

* 위의 예를 보면 FROM 절에 DEPT와 EMP 테이블이 있다. 

&ensp;(1) LEFT OUTER JOIN과 RIGHT OUTER JOIN<br/>
* LEFT OUTER JOIN은 두 개의 테이블에서 같은 것을 조회하고 왼쪽 테이블에만 있는 것을 포함해서 조회한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-109.JPEG" width="600"></p>

* 위의 예처럼 왼쪽 부서코드에 40번까지 조회된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-110.JPEG" width="600"></p>

* RIGHT OUTER JOIN은 두 개의 테이블에서 같은 것을 조회하고 오른쪽 테이블에만 있는 것을 포함해서 조회된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-111.JPEG" width="600"></p>

* 위의 예처럼 오른쪽 사원번호 1002, 1003까지 포함되어서 조회된다.
* 즉 관리자 테이블의 NULL인 행도 조회된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-112.JPEG" width="600"></p>

&ensp;4. CROSS JOIN<br/>
* CROSS JOIN은 조인 조건구 없이 2개의 테이블을 하나로 조인한다.
* 조인구가 없기 때문에 카테시안 곱이 발생한다.
* 예를 들어 행이 14개 있는 테이블과 행이 4개 있는 테이블을 조인하면 56개의 행이 조회된다.
* CROSS JOIN은 FROM절에 "CROSS JOIN"구를 사용하면 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-113.JPEG" width="600"></p>

&ensp;5. UNION을 사용한 합집합 구현<br/>
* UNION 연산은 두 개의 테이블을 하나로 만드는 연산이다. 
* 즉 2개의 테이블을 하나로 합치는 것이다. 주의사항은 두 개의 테이블의 칼럼 수, 칼럼의 데이터 형식 모두가 일치해야 한다. 만약 두 개의 테이블에 UNION 연산이 사용될 때 칼럼 수 혹은 데이터 형식이 다르면 오류가 발생한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-114.JPEG" width="600"></p>

* UNION 연산은 두 개의 테이블을 하나로 합치면서 중복된 데이터를 제거한다.
* 그래서 UNION은 정렬(Sort)과정을 발생시킨다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-115.JPEG" width="600"></p>

&ensp;(2) UNION ALL<br/>
* UNION ALL은 두 개의 테이블을 하나로 합치는 것이다. UNION처럼 중복을 제거하거나 정렬을 유발하지 않는다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-116.JPEG" width="600"></p>

&ensp;6. 차집합을 만드는 MINUS<br/>
* MINUS 연산은 두 개의 테이블에서 차집합을 조회한다. 즉 먼저 쓴 SELECT문에는 있고 뒤에 쓴느 SELECT문에는 없는 집합을 조회하는 것이다.
* MS-SQL에서는 MINUS와 동일한 연산이 EXCEPT이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-117.JPEG" width="600"></p>

* 위의 예처럼 DEPT와 EMP를 MINUS 연산을 하면 DEPT에만 있는 행을 조회하는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-118.JPEG" width="600"></p>

* 앞의 MINUS 연산 결과를 보면 DEPT 테이블에만 존재하는 DEPTNO 40번이 조회된 것을 확인할 수 있다.

계층형 조회(CONNECT BY)
------

* 계층형 조회는 Oracle 데이터베이스에서 지원하는 것으로 계층형으로 데이터를 조회할 수 있다. 
* 예를 들어 부장에서 차장, 차장에서 과장, 과장에서 대리, 대리에서 사원 순으로 트리 형태의 구조를 위에서 아래로 탐색하면서 조회하는 것이다. 물론 역방향 조회도 가능하다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-119.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-120.JPEG" width="600"></p>

* CONNECT BY는 트리(Tree)형태의 구조로 질의를 수행하는 것으로 START WITH구는 시작 조건을 의미하고 CONNECT BY PRIOR는 조인 조건이다. Root 노드로부터 하위 노드의 질의를 실행한다.
* 계층적 조회에서 MAX(LEVEL)을 사용하여 최대 계층 수를 구할 수 있다. 즉 계층형 구조에서 마지막 Leaf Node의 계층값을 구한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-121.JPEG" width="600"></p>

* 위의 SQL에서 MAX(LEVEL)이 4이므로 트리의 최대 깊이는 4이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-122.JPEG" width="600"></p>

* 위의 예에서 EMPNO와 MGR 칼럼 모두 사원번호가 입력되어 있다.
* 하지만 MGR은 관리자 사원번호를 가지고 있다. 즉 MGR 1000번은 1001과 1002의 사원을 관리한다.
* 계층형 조회 결과를 명확히 보기 위해서 LPAD함수를 사용할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-123.JPEG" width="600"></p>

* 위의 예를 보면 4*LEVEL-1이 있다. LEVEL 값이 Root이면 1이 된다. 따라서 4*(1-1)=0이 된다.
* 즉 Root일 때는 LPAD('',0)이므로 아무런 의미가 없다.
* 하지만 LEVEL 값이 2가 되면 4*(2-1)=4가 된다. LPAD('',4)이므로 왼쪽 공백 4칸을 화면에 찍는다.
* 결과적으로 LPAD는 트리 형태로 보기 위해서 사용한 것이다. 왜냐하면 LEVEL 값은 Root에 1을 되돌리고 그 다음 자식은 2, 그리고 그다음 자식 3이 되기 때문이다.

&ensp;PRIOR 키워드: 바로 직전에 출력된 행을 의미한다.<br/>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-124.JPEG" width="600"></p>

&ensp;Connect by구는 순방향 조회와 역방향 조회가 있다. 순방향 조회는 부모 엔터티로부터 자식 엔터티을 찾아가는 검색을 의미하고 역방향 조회는 자식 엔터티로부터 부모 엔터티를 찾아가는 검색이다.<br/>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-125.JPEG" width="600"></p>

&ensp;먼저 역방향 전개를 하기 위해서 순방향 전개를 실행하여 Leaf 노드의 사원번호를 확인한다.<br/>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-126.JPEG" width="600"></p>

&ensp;위의 예는 관리자(MGR)로부터 사원을 조회하는 순방향 전개이다.<br/>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-127.JPEG" width="600"></p>

서브쿼리(Subquery)
------

&ensp;1. Main query와 Subquery<br/>
* Subquery는 SELECT문 내에 다시 SELECT문을 사용하는 SQL문이다.
* Subquery의 형태는 FROM구에 SELECT문을 사용하는 인라인 뷰(Inline View)와 SELECT문에 Subquery를 사용하는 스칼라 서브쿼리(Scala Subquery) 등이 있다.
* WHERE구에 SELECT문을 사용하면 서브쿼리(Subquery)라고 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-128.JPEG" width="600"></p>

* 위의 예에 WHERE구에 있는 SELECT문은 서브쿼리(Subquery)이고 괄호 내에 SELECT문을 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-129.JPEG" width="600"></p>

* FROM구에 SELECT문을 사용하여 가상의 테이블을 만드는 효과를 얻을 수 있다.
* 이렇게 FROM구에 SELECT문을 사용한 것이 인라인 뷰(Inline View)이다.

&ensp;2. 단일 행 서브쿼리와 다중 행 서브쿼리<br/>
* 서브쿼리(Subquery)는 변환하는 행 수가 개인 것과 여러 개인 것에 따라서 단일 행 서브쿼리와 멀티 행 서브쿼리로 분류된다. 
* 단일 행 서브쿼리는 단 하나의 행만 반환하는 서브쿼리로 비교 연산자(=, <, <=, >=, <>)를 사용한다.
* 다중 행 서브쿼리는 여러 개의 행을 반환하는 것으로 IN, ANY, ALL, EXISTS를 사용해야 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-130.JPEG" width="600"></p>

&ensp;3. 다중 행(Muti row) Subquery<br/>
* 다중 행 서브쿼리(Multi row Subquery)는 서브쿼리 결과가 여러 개의 행을 반환하는 것으로 다중 행 연산자를 사용해야 한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-131.JPEG" width="600"></p>

&ensp;(1) IN<br/>
* IN은 반환되는 여러 개의 행 중에서 하나만 참이 되어도 참이 되는 연산이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-132.JPEG" width="600"></p>

* 위의 예에서는 EMP 테이블에서 SAL이 2000원 초과인 사원번호를 반환하고 반환된 사원번호와 메인쿼리에 있는 사원번호와 비교해서 같은 것을 조회하는 것이다.

&ensp;(2) ALL<br/>
* 메인쿼리와 서브쿼리의 결과가 모두 동일하면 참이 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-133.JPEG" width="600"></p>

* 위의 예는 DEPTNO가 20, 30보다 작거나 같으면 조회되는 것이다.

&ensp;(3) EXISTS<br/>
* EXISTS는 Subquery로 어떤 데이터 존재 여부를 확인하는 것이다. 
* 즉 EXISTS의 결과는 참과 거짓이 반환된다.
* 다음의 예는 직원 중에서 급여가 2000이상이 있으면 참이 반환되고 없으먼 거짓이 반환한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-134.JPEG" width="600"></p>

&ensp;4. 스칼라(Scala) Subquery<br/>
* 스칼라 Subquery는 반드시 한 행과 한 칼럼만 반환하는 서브쿼리이다.
* 만약 여러 행이 반환되는 오류가 발생한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-135.JPEG" width="600"></p>

* 앞의 예처럼 직원 급여를 조회할 때 평균 급여를 같이 계산하여 조회한다.
* 스칼라 Subquery를 사용해서 직원의 평균 급여를 계산한 것이다.

&ensp;5. 연관(Correlated) Subquery<br/>
* 연관 Subquery는 Subquery 내에서 Main Query 내의 칼럼을 사용하는 것을 의미한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-136.JPEG" width="600"></p>

&ensp;4. 그룹 함수(Group Function)<br/>
&ensp;1. ROLLUP<br/>
* ROLLUP은 GROUP BY의 칼럼에 대해서 Subtotal을 만들어 준다.
* ROLLUP을 함께 할 때 GROUP BY구에 칼럼이 두 개 이상 오면 순서에 따라서 결과가 달라진다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-137.JPEG" width="600"></p>

* 위의 예는 DEPTNO에 대해서 GROUP BY로 급여합계를 계산하고 부서별 전체합계를 추가해서 계산했다. 즉 ROLLUP은 DEPTNO에 대해서 기존 GROUP BY와는 다르게 부서별 전체합계를 계산하게 된다.
* DECODE문은 전체합계를 조회할 때 '전체합계'라는 문자를 출력하기 위해서 사용된다. DE-CODE문을 사용해서 DEPTNO가 NULL과 같으면 전체합계라는 문자를 출력하고 그렇지 않으면 부서번호(DEPTNO)를 출력한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-138.JPEG" width="600"></p>

* 부서별, 직업별 ROLLUP을 실행하면 부서별 합계, 직업별 합계, 전체합계가 모두 조회된다.
* ROLLUP으로 실행되는 칼럼별로 Subtotal을 만들어 준다.

&ensp;2. GROUPING 함수<br/>
* GROUPING 함수는 ROLLUP, CUBE, GROUPING SETS에서 생성되는 합계값을 구분하기 위해서 만들어진 함수이다.
* 예를 들어 소계, 합계 등이 계산되면 GROUPING 함수는 1을 반환하고 그렇지 않으면 0을 반환해서 합계값을 식별할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-139.JPEG" width="600"></p>

* 위의 SQL문을 보면 소계와 합계가 계산된 데이터는 GROUPING 함수에서 1이 출력된 것을 알 수 있다.
* GROUPING의 반환값을 DECODE 혹은 CASE문으로 식별해서 SELECT문으로 소계, 합계를 구분하는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-140.JPEG" width="600"></p>

* 위의 예를 보면 DECODE 함수를 사용해서 GROUPING 함수 결과가 1이면 전체합계 혹은 부서합계를 출력하고 그렇지 않으면 NULL을 반환한다.
* GROUPING함수의 기능을 사용하면 사용자가 필요로 하는 데이터를 SELECT문으로 작성하여 제공할 수 있다.

&ensp;3. GROUPING SETS 함수<br/>
* GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있다. 
* GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계없이 개별적으로 모두 처리한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-141.JPEG" width="600"></p>

* 위의 예를 보면 GROUPING SETS 함수로 DEPTNO와 JOB을 실행했다.
* 그 결과 DEPTNO 합계와 JOB 합계가 개별적으로 조회되었다. 즉 서로 관계가 없다는 것이다.

&ensp;CUBE 함수<br/>
* CUBE는 CUBE 함수에 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산한다.
* 다차원 집계를 제공하여 다양하게 데이터를 분석할 수 있게 한다.
* 예를 들어 부서와 작업을 CUBE로 사용하면 부서별 합계, 직업별 합계, 부서별 직업별 합계, 전체합계가 조회된다.
* 즉 조합할 수 있는 경우의 수가 모두 조합되는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-142.JPEG" width="600"></p>

* 위의 예에서는 CUBE로 부서코드와 작업을 실행했다. 그 결과 전체합계, 직업별 합계, 부서별 합계, 직업별 합계가 조회됐다.

윈도우 함수(Window Function)
-------

&ensp;1. 윈도우 함수<br/>
* 윈도우 함수는 행과 행 간의 관계를 정의하기 위해서 제공되는 함수이다.
* 윈도우 함수를 사용해서 순위, 합계, 평균, 행 위치 등을 조작할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-143.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-144.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-145.JPEG" width="600"></p>

* WINDOWING은 아래와 같이 사용한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-146.JPEG" width="600"></p>

* UNBOUNDED PRECEDING은 처음 행을 의미하며 UNDOUNDED FOLLOWING은 마지막 행을 의미한다. 그러므로 TOTSAL에 처음부터 마지막까지의 합계(SUM(SAL))를 계산한 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-147.JPEG" width="600"></p>

* 위의 SQL문은 처음부터 CURRENT ROW까지의 합계를 계산한다. 결과적으로 누적합계가 된다.  
* 즉 첫 번째 행의 SAL은 800이고 두 번째 행의 SAL은 950이다. 그러므로 두 번째 행의 TOTSAL은 800+950=1750이 된다. 세 번째 행은 다시 1100+1750=2850이 된다.
* CURRENT ROW는 데이터가 인출된 현재 행을 의미한다. 

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-148.JPEG" width="600"></p>

* 위의 SQL문은 현재 행(CURRENT ROW)부터 마지막 행(UNBOUNDED FOLLOWING)까지의 합계를 계산한다.
* 첫 번째 행의 SAL이 800이므로 800부터 끝까지의 합계를 TOTSAL에 계산한다. 결과적으로 전체합계가 된다.
* 그다음은 950부터 마지막까지이므로 800이 제외된 합계가 된다. 따라서 28225가 된다.

&ensp;2. 순위 함수(RANK FUNCTION)<br/>
* 윈도우 함수는 특정 항목과 파티션에 대해서 순위를 계산할 수 있는 함수를 제공한다.
* 순위 함수는 RANK, DENSE_RANK, ROW_NUMBER 함수가 있다. 

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-149.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-150.JPEG" width="600"></p>

* RANK 함수는 순위를 계산하며 동일한 순위에는 같은 순위가 부여된다.
* RANK() OVER (ORDER BY SAL DESC)는 SAL로 등수를 계산하고 내림차순으로 조회하게 된다.
* RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC)는 JOB으로 파티션을 만들고 JOB별 순위를 조회하게 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-151.JPEG" width="600"></p>

* DENSE_RANK는 동일한 순위를 하나의 건수로 인식해서 조회한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-152.JPEG" width="600"></p>

* ROW_NUMBER 함수는 동일한 순위에 대해서 고유의 순위를 부여한다.

&ensp;집계함수(AGGREGATE Function)<br/>
* 윈도우 함수를 제공한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-153.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-154.JPEG" width="600"></p>

&ensp;4. 행 순서 관련 함수<br/>
* 행의 순서 관련 함수는 상위 행의 값을 하위에 출력하거나 하위 행의 값을 상위 행에 출력할 수 있다.
* 특정 위치의 행을 출력할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-155.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-156.JPEG" width="600"></p>

* FIRST_VALUE 함수는 파티션에서 조회된 행 중에서 첫 번째 행의 값을 가지고 온다. 
* 위의 예에서 TEST7과 TEST14가 조회되었다. 그중에서 TEST7이 첫 번째 행이므로 첫 번째 행의 TEST7을 가지고 온다.
*  단 SAL 내림차순으로 조회했기 때문에 의미상으로는 부서 내에서 가장 급여가 많은 사원이 된다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-157.JPEG" width="600"></p>

* LAST_VALUE 함수는 파티션에서 마지막 행을 가지고 온다 그래서 FIRST_VALUE와 다르게 TEST14가 출력된다.
* BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING의 의미는 현재 행에서 마지막 행까지의 파티션을 의미한다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-158.JPEG" width="600"></p>

* LAG 함수는 이전 값을 가지고 오는 것이다. 예를 들어 PRE_SAL의 5000값은 SAL의 이전 데이터이다. 

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-159.JPEG" width="600"></p>

* LEAD함수는 지정된 행의 값을 가지고 오는 것이다. 위의 예는 SAL에서 2번째 행의 값을 가지고 온다.
* LEAD의 기본값은 1이며 첫 번째 행의 값을 가지고 오는 것이다.

&ensp;5. 비율 관련 함수<br/>
* 비율 관련 함수는 누적 백분율, 순서별 백분율, 파티션을 N분으로 분할한 결과 등을 조회할 수 있다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-160.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-161.JPEG" width="600"></p>

* PERCENT_RANK함수는 파티션에서 등수의 퍼센트를 구하는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-162.JPEG" width="600"></p>

* NTILE(4)는 4등분으로 분할하라는 의미로 위의 예에서는 급여가 높은 순으로 1~4으로 분할한다.

&ensp;6. 테이블 파티션(Table Partition)<br/>
* 파티션은 대용량의 테이블을 여러 개의 데이터 파일에 분리해서 저장한다.
* 테이블의 데이터가 물리적으로 데이터 파일에 저장되면 입력, 수정, 삭제, 조회 성능이 향상된다.
* 파티션은 각각의 파티션 별로 독립적으로 관리할 수 있다. 즉 파티션 별로 백업하고 복구가 가능하면 파티션 전용 인덱스 생성도 가능하다.
* 파티션은 Oracle 데이터베이스의 논리적 관리 단위인 테이블 스페이스 간에 이동이 가능하다.
* 데이터를 조회할 때 데이터의 범위를 줄여서 성능을 향상시킨다.

&ensp;2. Range Partition<br/>
* Range Partition은 테이블의 칼럼 중에서 값의 범위를 기준으로 여러 개의 파티션으로 데이터를 나누어 저장하는 것이다. 

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-163.JPEG" width="600"></p>

* 위의 예에서 SAL값 2000~4000은 Datefile1.dbf파일에 저장하고 SAL값 5000~7000의 값은 Datefile2.dbf에 저장한다.

&ensp;3. List Parttion<br/>
* List Partition은 특정 값을 기준으로 분할하는 방법이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-164.JPEG" width="600"></p>

* 위의 예에서 DEPTNO가 10번인 것은 Datafile1.dbf에 저장하고 20번인 것은 Datafile2.dbf에 저장한다.

&ensp;4. Hash Partition<br/>
* Hash Partition은 데이터베이스 관리 시스템이 내부적으로 해시 함수를 사용해서 데이터를 분할한다.
* 결과적으로 데이터베이스 관리 시스템이 알아서 분할하고 관리하는 것이다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-165.JPEG" width="600"></p>

* Hash Partiition 이외에도 Composite Partition이 있는데 Composite Partition은 여러 개의 파티션 기법을 조합해서 사용하는 것이다. 

&ensp;5. 파티션 인덱스<br/>
* 파티션 인덱스는 4가지 유형의 인덱스를 제공한다. 즉 파티션 키를 사용해서 인덱스를 만드는 Prefixed Index와 해당 파티션만 사용하는 Local Index 등으로 나누어진다. 
* Oracle 데이터베이스는 Global Non-Prefixed를 지원하지 않는다.

<p align="center"><img src="/assets/img/SQLD/3. SQL 기본 및 활용/3-166.JPEG" width="600"></p>