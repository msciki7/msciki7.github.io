---
title: "2장 데이터 모델링의 이해"
excerpt: "데이터 모델링의 기본적인 용어에 대한 구분을 배운다."

wirter: sohee Kim
categories:
  - SQLD
tags:
  - SQLD

toc: true
toc_sticky: true

date: 2025-08-06
last_modified_at: 2025-08-08
---

데이터 모델링의 이해
======

데이터 모델링
------

* 데이터 모델링은 현실 세계를 데이터베이스로 표현하기 위해서 추상화한다.
* 데이터 모델링을 하기 위해서는 고객과의 의사소통을 통해 고객으 업무 프로세스를 이해해야 한다.
* 고객의 업무 프로세스를 이해한 후 데이터 모델링 표기법을 사용해서 모델링을 한다.
* 데이터 모델링은 고객의 업무 프로세스를 추상화하고 소프트웨어를 분석, 설계하면서 점점 더 상세해진다.
* 데이터 모델링은 고객의 비지니스 프로세스를 이해하고 비지니스 프로세스의 규칙을 정의한다. 정의된 비지니스 규칙을 데이터 모델로 표현한다.

데이터 모델링의 특징
------

* 데이터 모델링은 추상화해야 한다. -> 추상화는 공통적인 특징을 찾고 간략하게 표현한다.
* 데이터 모델링은 단순화해야 한다. -> 복잡한 문제를 피하고 누구나 이해할 수 있게 표현한다.
* 데이터 모델링은 명확해야 한다. -> 의미적 해석이 모호하지 않고 명확하게 해석되어야 한다.

&ensp;데이터 모델링의 주요 특징<br/>
|특징|설명|
|------|---|
|추상화(Abstraction)|현실 세계를 간략하게 표현한다.|
|단순화(Simplification)|누구나 쉽게 이해할 수 있도록 표현한다.|
|명확성(Clarity)|명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 한다.|

데이터 모델링 단계
------

&ensp;1. 개념적 모델링(Conceptual Data Modeling)<br/>
* 고객의 비지니스 프로세스를 분석하고 업무 전체에 대해서 데이터 모델링을 수행한다.
* 복잡하게 표현하지 않고 중요한 부분을 위주로 모델링하는 단계이다.
* 업무적 관점에서 모델링하며 기술적인 용어는 가급적 사용하지 않는다.
* 엔터티(Entity)와 속성(Attribute)을 도출하고 개념적 ERD(Entity Relationship Diagram)를 작성한다.

&ensp;2. 논리적 모델링(Logical Data Modeling)<br/>
* 개념적 모델링을 논리적 모델링으로 변환하는 작업이다.
* 식별자를 도출하고 필요한 모든 릴레이션을 정의한다. 
* 정규화를 수행해서 데이터 모델을 독립성을 확보한다. 

&ensp;3. 물리적 모델링(Physical Modeling)<br/>
* 데이터베이스를 실제 구축한다. 즉 테이블, 인덱스, 함수 등을 생성한다.
* 성능, 보안, 가용성을 고려해서 구축한다.

&ensp;데이터 모델링 단계<br/>

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-1.JPEG" width="600"></p>

&ensp;데이터 모델링 관점<br/>

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-2.JPEG" width="600"></p>

&ensp;4. 데이터 모델링을 위한 ERD(Entity Relationship Diagram)<br/>
* 엔터티와 엔터티 간의 관계를 정의하는 모델링 방법이다.

&ensp;(1) ERD 작성 절차<br/>

&ensp;① 엔터티를 도출하고 그린다.<br/>
* 업무에서 관리해야 하는 집합을 도출한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-3.JPEG" width="600"></p>

&ensp;② 엔터티를 배치한다.<br/>
* 엔터티를 도출한 후 엔터티를 배치한다.
* 중요한 엔터티를 왼쪽 상단에 배치한다.

&ensp;③ 엔터티 간의 관계를 설정한다.<br/>

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-4.JPEG" width="600"></p>

&ensp;④ 관계명을 서술한다.<br/>

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-5.JPEG" width="600"></p>

&ensp;⑤ 관계 참여도를 표현한다.<br/>
* 관계 참여도는 한 개의 엔터티와 다른 엔터티 간의 참여하는 관계 수를 의미한다.
* 즉 고객이 여러 개의 계좌를 개설할 수 있다. 와 같은 의미를 표현하는 것이다.

&ensp;⑥ 관계의 필수 여부를 표현한다.<br/>
* 필수는 반드시 존재해야 한느 것이다.
* 예를 들어 모든 고객은 반드시 하나의 계좌를 개설해야 한다와 같은 의미를 표현한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-6.JPEG" width="600"></p>

&ensp;(2) ERD 작성 시 고려사항<br/>
* 중요한 엔터티를 가급적 왼쪽 상단에 배치한다.
* ERD는 이해가 쉬워야 하고 너무 복잡하지 않아야 한다.

데이터 모델링 고려사항
------

&ensp;1. 데이터 모델의 독립성<br/>
* 독립성이 확보도니 모델은 고객이 업무 변화에 능동적으로 대응할 수 있다.
* 독립성을 확보하기 위해서는 중복된 데이터를 제거해야 한다.
* 데이터 중복을 제거하는 방법이 바로 정규화이다.

&ensp;2. 고객 요구사항의 표현<br/>
* 데이터 모델링으로 고객과 데이터 모델러 간에 의사소통을 할 수 있어야 하므로 고객의 요구사항을 간결하고 명확하게 표현해야 한다.

&ensp;3. 데이터 품질 확보<br/>
* 데이터베이스 구축 시에 데이터 표준을 정의하고 표준 준수율을 관리해야 한다.
* 데이터 표준을 확보해야 데이터 품질을 향상시킬 수 있다.

3층 스키마(3-Level Schema)
------

&ensp;1. 3층 스키마<br/>
* 사용자, 설계자, 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들 간의 관계를 정의한 ANSI 표준이다.
* 3층 스키마는 데이터베이스의 독립성을 확보하기 위한 방법이다.
* 데이터의 독립성을 확보하면 데이터 복잡도 감소, 데이터 중복 제거, 사용자 요구사항 변경에 따른 대응력 향상, 관리 및 유지보수 비용 절감 등의 장점을 갖는다.
* 3단계 계층으로 분리해서 독립성을 확보하는 방법으로 각 계층을 뷰(View)라고도 한다.

* 3층 스키마의 독립성
<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-7.JPEG" width="600"></p>

&ensp;2. 3층 스키마 구조<br/>
<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-8.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-9.JPEG" width="600"></p> 

엔터티(Entity)
-------

&ensp;1. 엔터티(Entity)<br/>
* 엔터티는 업무에서 관리해야 하는 데이터 집합을 의미하여 저장되고 관리되어야 하는 데이터이다.
* 엔터티는 개념, 사건, 장소 등의 명사이다.

&ensp;2. 엔터티(Entity) 도출<br/>
* 엔터티는 고객의 비지니스 프로세스에서 관리되어야 하는 정보를 추출해야 한다.
* 다음의 예를 통해 업무에서 관리해야 하는 엔터티를 도출해보자

&ensp;3. 엔터티(Entity) 특징<br/>
<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-10.JPEG" width="600"></p> 

&ensp;릴레이션과 테이블,인스턴스(instance)<br/>
* 릴레이션과 테이블은 같은 의미라고 해석하면 된다. 릴레이션에 기본키 및 제약조건을 설정하면 테이블이 된다.
* 단 Relationship은 릴레이션 간의 관계를 의미한다.
* 인스턴스는 릴레이션이 가질 수 있는 값을 의미한다. 간단하게 생각하면 행의 수를 의미한다.

&ensp;4. 엔터티(Entity) 종류<br/>
* 엔터티의 종류는 유형과 무형에 따른 종류, 엔터티가 발생하는 시점에 따른 종류로 나누어진다.
* 엔터티를 유형과 무형으로 분류하는 기준은 물리적 형태의 존재 여부이다.

* 유형과 무형에 따른 엔터티 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-11.JPEG" width="600"></p> 

* 발생 시점에 따른 엔터티 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-12.JPEG" width="600"></p> 

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-13.JPEG" width="600"></p> 

속성(Attribute)
------

* 속성이라는 것은 업무에서 필요한 정보인 엔터티가 가지는 항목이다.
* 속성은 더 이상 분리되지 않는 단위로 업무에 필요한 데이터를 저장할 수 있다.
* 인스턴스의 구성요소이고 의미적으로 더 이상 분해되지 않는다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-14.JPEG" width="600"></p> 

&ensp;<b>속성의 특징과 종류</b></br>

* 속성은 업무에서 관리하는 정보이다.
* 속성은 하나의 값만 가진다.
* 주식별자에게 함수적으로 종속된다. 즉 기본키가 변경되면 속성의 값도 변경되는 것이다.

* 분해 여부에 따른 속성의 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-15.JPEG" width="600"></p> 

* 특성에 따른 속성의 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-16.JPEG" width="600"></p> 

&ensp;도메인: 도메인은 속성이 가질 수 있는 값의 범위이다.(예: 성별이라는 속성의 도메인은 남자와 여자이다.)<br/>

관계(Relationship)
-------

&ensp;관계<br/>
* 관계는 엔터티 간의 관련성을 의미하며 존재 관계와 행위 관계로 분류된다.
* 존재 관계는 두 개의 엔터티가 존재 여부의 관계가 있는 것이고 행위 관계는 두 개의 엔터디가 어떤 행위에 의한 관련성이 있는 것이다.

&ensp;<b>관계의 종류</b></br>

&ensp;1. 존재 관계<br/>
* 존재 관계는 엔터디 간의 상태를 의미한다. 예를 들어 고객이 은행에 회원가입을 하면 관리점이 할당되고 그 할당된 관리점에서 고객을 관리한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-17.JPEG" width="600"></p> 

&ensp;2. 행위 관계<br/>
* 행위 관계는 엔터디 간에 어떤 행위가 있는 것으로 계좌를 사용해서 주문을 발주하는 관계가 만들어진다.
* 예를 들어 증권회사는 계좌를 개설하고 주문을 발주하는 것이다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-18.JPEG" width="600"></p> 

&ensp;<b>관계 차수(Relation Cardinality)</b></br>

&ensp;1. 관계 차수(Relation Cardinality)<br/>
* 관계 차수는 두 개의 엔터티 간에 관계에 참여하는 수를 의미한다.
* 예를 들어 한 명의 고객은 여러 개의 계좌를 개설할 수 있다. 이러한 경우는 1대N 관계가 된다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-19.JPEG" width="600"></p> 

&ensp;2. 관계 차수의 종류<br/>
&ensp;① 1대1 관계<br/>
* 1대1 관계는 완전 1대1 관계와 선택 적 1대1 관계가 있다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-20.JPEG" width="600"></p> 

* 1대1 관계

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-21.JPEG" width="600"></p> 

&ensp;② 1대N 관계<br/>
* 1대N 관계는 엔터티에 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계이다.
* 예를 들어 고객은 여러 개의 계좌를 가질 수 있다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-22.JPEG" width="600"></p> 

&ensp;③ M대N 관계<br/>
* M과N 관계는 두 개 엔터티가 서로 여러 개의 관계를 가지고 있는 것이다. 
* 예를 들어 한 명의 학생이 여러 개의 과목을 수강할 수 있따. 반대로 한 개의 과목은 여러 명의 학생이 수강한다. 그래서 M대N 관계가 발생한다.
* 관계형 데이터베이스에서 M과N 관계의 조인(Join)은 카테시안 곱(각 릴레이션에 존재하는 모든 데이터를 조합하여 연산하는 것)이 발생한다. 그래서 M과N 관계를 1대N, N대1로 해소해야 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-23.JPEG" width="600"></p> 

* 위에 예는 수강이라는 엔터티를 추가적으로 도출하여 1대N, N대1로 해소해야 한다.

&ensp;④ 필수적 관계와 선택적 관계<br/>
* 필수적 관계는 반드시 하나는 존재해야 하는 관계이고 선택적 관계는 없을 수도 있는 관계이다.
* 필수적 관계는 "|" 로 표현되고 선택적 관계는 "O" 으로 표현된다.

* 필수적 관계, 선택적 관계<br/>

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-24.JPEG" width="600"></p> 
<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-25.JPEG" width="600"></p> 

&ensp;<b>식별 관계와 비식별 관계</b></br>

&ensp;1. 식별 관계(Identification Realtionship)<br/>
* 고객과 계좌 엔터티에서 고객은 독립적으로 존재할 수 있는 강한 개체(Strong Entity)이다.
* 강한 개체는 어떤 다른 엔터티에게 의존하지 않고 독립적으로 존재한다.
* 강한 개체는 다른 엔터티와 관계를 가질 때 다른 엔터티에게 기본키를 공유한다.
* 강한 개체는 식별 관계로 표현된다.
* 즉 식별 관계란 고객 엔터티의 기본키인 회원ID를 계좌 엔터티의 기본키의 하나로 공유하는 것이다.
* 강한 개체의 기본키 값이 변경되면 식별 관계(기본키를 공유받는)에 있는 엔터티의 값도 변경된다.
* 여기서 계좌 엔터티는 약한 개체가 된다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-26.JPEG" width="600"></p> 

&ensp;2. 식별 관계(Non-Identification Relationship)<br/>
* 비식별 관계는 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 컬럼으로 관계를 가지는 것이다.
* 예를 들어 관리점 엔터티의 기본키는 지점 코드이고 고객 엔터티와 비식별 관계를 가지고 있다. 즉 지점 코드는 고객 엔터티의 기본키가 아닌 일반 컬럼으로 참조된다. 비식별 관계는 점선으로 표현된다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-27.JPEG" width="600"></p> 

* 위의 예에서 계좌 엔터티는 고객 엔터티의 회원ID 칼럼은 기본키로 공유하고 있다. 이러한 관계를 식별 관계라고 하고 실선으로 표현한다.

엔터티 식별자(Entity Identifier)
------

&ensp;식별자라는 것은 엔터티를 대표할 수 있는 유일성을 만족하는 속성이다. 일반적으로 회원ID, 계좌번호, 주민등록번호, 외국인등록번호, 여권번호 등이 있다.<br/>

&ensp;<b>주식별자(기본키, Primary key)</b><br/>

* 최소성: 주식별자는 최소성을 만족하는 키이다.
* 대표성: 주식별자는 엔터티를 대표할 수 있어야 한다.
* 유일성: 주식별자는 엔터티의 인스턴스를 유일하게 식별한다.
* 불변성: 주식별자는 자주 변경되지 않아야 한다.

* 키의 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-28.JPEG" width="600"></p> 

&ensp;<b>식별자의 종류</b><br/>

* 식별자는 대표성, 생성 여부, 속성의 수, 대체 여부로 분류된다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-29.JPEG" width="600"></p> 

&ensp;1. 식별자의 대표성<br/>
* 주식별자는 엔터티를 대표할 수 있는 식별자이다. 예를 들어 회원ID는 고객 엔터티에 주식별자가 된다.

* 대표성 여부에 따른 식별자의 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-30.JPEG" width="600"></p> 

&ensp;2. 생성 여부<br/>
* 생성 여부에 따른 식별자의 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-31.JPEG" width="600"></p> 

&ensp;3. 속성의 수<br/>
* 속성의 수에 따른 식별자의 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-32.JPEG" width="600"></p> 

&ensp;4. 대체 여부<br/>
* 대체 여부에 따른 식별자의 종류

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-33.JPEG" width="600"></p> 

&ensp;인조 식별자: 인조 식별자는 후보 식별자 중에서 주식별자로 선정할 것이 없거나 주식별자가 너무 많은 칼럼으로 되어 있는 경우에 사용한다. 즉 순서번호(Sequence Number)를 사용해서 식별자를 만드는 것이다.<br/>

데이터 모델과 성능
======

정규화
------

* 정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정이다.
* 정규화는 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법이다.
* 정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높인다. 
* 정규화를 수행하면 비지니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할 수 있다.
* 정규화는 제 1정규화부터 제 5정규화까지 있지만 실질적으로는 제 3정규화까지만 수행한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-34.JPEG" width="600"></p> 

* 위의 테이블은 정규화를 수행하지 않은 것으로 부서 테이블과 직원 테이블을 하나로 합쳐 둔 것이다. 만약 위의 테이블에서 새로운 직원이 추가되는 경우 부서 정보가 없으면 부서코드를 임의의 값으로 넣어야 한다. 즉 불필요한 정보가 같이 추가되는 것이다. 또한 새로운 충무부가 추가되어야 할 경우 사우너 정보가 없기 때문에 임의의 값으로 사원번호를 입력하거나 추가할 수 없게 된다. 이러한 문제를 이상현상이라고 한다.
* 위와 같은 문제를 해결하기 위해서는 테이블을 분해해야 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-35.JPEG" width="600"></p> 

* 정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 직원 테이블과 부서 테이블 간에 부서코드로 조인(Join)을 수행하여 하나의 합집합으로 만들 수도 있다.
* 정규화를 수행하면 불필요한 데이터를 입력하지 않아도 되기 때문에 중복 데이터가 제거된다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-36.JPEG" width="600"></p> 

함수적 종속성(Functional Dependency)
------

&ensp;1. 제1 정규화<br/>
* 정규화는 함수적 종속성을 근거로 한다. 함수적 종속성이란 X -> Y이면 Y는 X에 함수적으로 종속된다고 말한다.
* 함수적 종속성은 X가 변화하면 Y도 변화하는지 확인한다. 예를 들어 회원 ID가 변화하면 이름도 변경될 것이다. 이런 경우는 회원 ID가 기본키가 되고 회원 ID가 이름을 함수적으로 종속한다고 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-37.JPEG" width="600"></p> 

* 위의 예를 보면 계좌 테이블 X가 Y의 칼럼들을 함수적으로 종속하고 있다.
* 위의 예에서 X는 계좌번호 하나만으로는 유일성을 만족하지 못한다고 가정한 것이다. 그래서 계좌번호와 회원 ID를 기본키로 잡은 것이다.
* 이처럼 기본키를 잡는 것이 제 1정규화이다.

&ensp;2. 제 2정규화<br/>
* 부분 함수 종속성이란 기본키가 2개 이상의 칼럼으로 이루어진 경우에만 발생한다.
* 기본키가 하나의 칼럼으로 이루어지면 제 2정규화는 생략한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-38.JPEG" width="600"></p> 

* 위의 예를 보면 기본키에 있는 회원 ID가 변경되면 이름이 변경된다. 회원 ID가 이름을 함수적으로 종속하고 있는 것이다.
* 바로 이러한 경우를 부분 함수 종속성이라 한다. 부분 함수 종속성이 발생하면 분해를 하야 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-39.JPEG" width="600"></p> 

* 부분 함수 종속성을 제거하면 위와 같다. 회원이라는 새로운 테이블이 도출되고 회원 ID가 기본키가 된다.

&ensp;3. 제 3정규화<br/>
* 제 3정규화는 이행 함수 종속성을 제거한다. 이행 함수 종속성이란 기본키를 제외하고 칼럼 간에 족속성이 발생하는 것이다.
* 제 3정규화는 제 1정규화와 제 2정규화를 수행한 다음에 해야 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-40.JPEG" width="600"></p> 

* 위처럼 관리점이 관리점 코드에 종속되는 것을 이행 함수 종속성이라 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-41.JPEG" width="600"></p> 

* 제 3정규화를 수행하면 위처럼 관리점 테이블이 도출되고 관리점 코드가 기본키가 된다.

&ensp;4. BCNF(Boyce-Codd Normal Form)<br/>
* BCNF는 복수의 후보키가 있고 후보키들이 복합 속성이여야 하며 서로 중첩이어야 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-42.JPEG" width="600"></p>

* 위의 예처럼 기본키(학번, 과목 번호)가 교수를 함수적으로 종속하고 있다.
* 이때 교수가 후보키(최소성과 유일성을 만족)이고 교수가 과목 번호를 함수적으로 종속하는 경우 분해가 일어난다.
* 이러한 작업을 BCNF라고 한다.

정규화 예제
------

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-43.JPEG" width="600"></p>

&ensp;1. 제 1정규화<br/>
* 속성을 보고 한 개의 속성으로 유일성을 만족할 수 있는지 확인한다.
* 제품번호는 1001, 1007 등이 두 번 이상 나오므로 중복되고 주민번호 또한 AB345가 두 번 나와서 중복된다.
* 결과적으로 한 개의 속성으로는 유일성을 만족할 수 없다. 그러므로 2개의 조합으로 유일성을 만족할 수 있는지 확인해 보아야 한다.
* 제품번호 + 주문번호가 식별자가 되면 엔터티의 유일성을 만족하게 된다.
* 제 1정규화는 이러한 식별자를 찾는 과정이며 여기까지 수행하면 된다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-44.JPEG" width="600"></p>

&ensp;2. 제 2정규화<br/>
* 제 2정규화는 기본키가 두 개 이상인 경우 대상이 된다.
* 기본키가 제품번호 + 주문번호이므로 제 2정규화 대상이다.
* 제 2정규화는 모든 속성(제품명, 재고 수량, 수출 여부 등)이 식별자에 종속해야 하며 그렇지 않은 경우에는 분해한다.
* 확인 방법은 제 1정규화와 마찬가지로 중복을 확인하는 것이다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-45.JPEG" width="600"></p>

* 위의 경우를 보면 1001, 모니터가 중복되는 것을 확인할 수 있다. 이러한 경우에 엔터티를 분해하는 것이 제 2정규화이다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-46.JPEG" width="600"></p>

* 위의 경우도 AB345 주문번호에 중복이 발생한다. 이러한 경우는 분해를 해야 한다. 결과적으로 최종 엔터티는 다음과 같다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-47.JPEG" width="600"></p>

* 위와 같이 3개의 엔터티가 도출한다.

정규화와 성능
------

&ensp;1. 정규화의 문제점<br/>
* 정규화는 데이터 조회(SELECT)시에 조인(JOIN)을 유발하기 때문에 CPU와 메모리를 많이 사용한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-48.JPEG" width="600"></p>

* 위와 같이 두 개의 테이블로 이루어진 경우 "사원 번호, 부서코드, 부서명, 이름, 전화번호, 주소"를 조회하려면 조인을 해야 한다.

&ensp;‣ 조인의 사용<br/>

```sql
SELECT 사원번호, 부서코드, 부서명 이름, 전화번호, 주소
  FROM 직원, 부서
WHERE 직원.부서코드=부서.부서코드;
```

&ensp;ANSI Join<br/>
&ensp;위의 조인 사용에서의 SELECT문은 ANSI Join으로 작성하면 다음과 같다.<br/>

```sql
SELECT 사원번호, 부서코드, 부서명 이름, 전화번호, 주소
  FROM 직원 INNER JOIN 부서
WHERE 직원.부서코드=부서.부서코드;
```

* 위의 테이블은 직원과 부서 테이블에서 부서코드가 같은 것을 찾는 것이다. 이것을 프로그램화한다면 중첩된 루프(Nested Loop)를 사용해야 한다.

&ensp;‣ 중첩된 루프(Nested Loop)<br/>

```sql
for(i=0;i<N;i=i+1)
  for(j=0;j<M;j=j+1)
    if(직원_부서코드[i] == 부서_부서코드[j]){  }
```

* 위의 예에서 N은 직원 테이블의 건수이고 M은 부서 테이블의 건수이다.
* 결과적으로 이중으로 for문을 사용해서 비교하는 기능을 만들어야 조인을 할 수 있다.
* 이러한 구조는 데이터 양이 증가하면 비교해야 하는 건수도 증가한다.
* 물론 실제로 위와 같은 비효율이 발생하지는 않는다. 이러한 문제를 해결하기 위해서는 인덱스와 옵티마이저(Optimizer)가 있는 것이다.
* 결론적으로 조인이 부하를 유발하는 것은 분명하다.
* 정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인을 통한 성능 저하는 해결될 것이다.
* 이런 성능 저하를 해결하기 위해 반정규화가 있는 것이다.

&ensp;2. 정규화를 사용한 성능 튜닝<br/>
* 조인으로 인하여 성능이 저하되는 문제를 반정규화로 해결할 수 있다.
* 반정규화는 데이터를 종복시키기 때문에 또 다른 문제점을 발생시킨다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-49.JPEG" width="600"></p>

* 위의 예처럼 계좌마스터의 칼럼이 계속적으로 증가하면 조인이 최소화되기 때문에 조회를 빠르게 할 수 있을 것이다.
* 하지만 너무 많은 칼럼이 추가되면 한 개 행의 크기가 데이터베이스 관리 시스템의 입출력 단위인 블록의 크기(Block Size)를 넘어서게 된다.
* 그렇게 되면 한 개의 행을 읽기 위해서 여러 개의 블록을 읽어야 한다. 한 행을 읽기 위해서 여러 개의 블록을 읽게 되면 디스크 입출력이 증가하기 때문에 성능이 떨어지게 된다. 반정규화는 이러한 문제점을 유발할 수 있다.
* 위와 같은 문제가 발생하면 테이블을 분해하는 방법밖에 없다. 따라서 정규화는 입출력 데이터의 양을 줄여서 성능을 향상시킬 수 있는 것이다.

반정규화(De-Normalization)
------

* 데이터베이스의 성능 향상을 위하여 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
* 반정규화는 조회(SELECT) 속도를 향상하지만 데이터 모델의 유연성은 낮아진다.

&ensp;1. 반정규화를 수행하는 경우<br/>
* 정규화에 충실하면 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우
* 다량의 범위를 자주 처리해야 하는 경우
* 특정 범위의 데이터만 자주 처리하는 경우
* 요약/집계 정보가 자주 요구되는 경우

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-50.JPEG" width="600"></p>

&ensp;클러스터링(Clustering)<br/>
* 클러스터링 인덱스라는 것은 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 방법이다.
* 따라서 조회 시에 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.

&ensp;2. 반정규화 기법<br/>
&ensp;(1) 계산된 칼럼 추가<br/>
* 배치 프로그램에서 총판매액, 평균잔고, 계좌평가 등을 미리 계산하고 그 결과를 특정 칼럼에 추가한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-51.JPEG" width="600"></p>

&ensp;(2) 테이블 수직 분할<br/>
* 하나의 테이블을 두 개 이상의 테이블로 분할한다. 즉 칼럼을 분할하여 새로운 테이블을 만드는 것이다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-52.JPEG" width="600"></p>

&ensp;(3) 테이블 수평 분할<br/>
* 하나의 테이블에 있는 값을 기존으로 테이블을 분할하는 방법이다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-53.JPEG" width="600"></p>

&ensp;파티션(Partition) 기법<br/>
* 데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러 개의 데이터 파일에 분산되어서 저장된다.
* Range Partition: 데이터 값의 범위를 기준으로 파티션을 수행한다.
* List Partition: 특정한 값을 지정하여 파티션을 수행한다.
* Hash Partition: 해시 함수를 적용하여 파티션을 수행한다.
* Composite Partition: 범위와 해시를 복합적으로 사용하여 파티션을 수행한다.

&ensp;(4) 테이블 병합<br/>
* 1대1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
* 1대N 관계의 테이블을 병확하여 성능을 향상시킨다. 하지만 많은 양의 데이터 종복이 발생한다.
* 슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능을 향상시킨다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-54.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-55.JPEG" width="600"></p>

분산 데이터베이스
------

&ensp;1. 데이터베이스의 구조<br/>
* 데이터베이스 시스템 구축 시에 한 대의 물리적 시스템에 데이터베이스 관리 시스템을 설치하고 여러 명의 사용자가 데이터베이스 관리 시스템에 접속하여 데이터베이스를 사용하는 구조를 중앙 집중형 데이터베이스라고 한다.
* 또는 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여 주고 분산된 작업 처리를 수행하는 데이터베이스를 분산 데이터베이스라고 한다.

&ensp;2. 분산 데이터베이스의 투명성<br/>
* 분산 데이터베이스를 사용하는 고객은 시스템이 네트워크로 분산되어 있는지의 여부를 인식하지 못하면서 자신만의 데이터베이스를 사용하는 것처럼 사용할 수 있다. 이철머 데이터베이스는 투명성을 제공해야 한다.
* 투명성은 분산 데이터베이스에서 중요한 요소이며 투명성의 종류에는 분할, 위치, 지역사상, 중복, 장애 및 병행 투명성이 있다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-56.JPEG" width="600"></p>

&ensp;3. 분산 데이터베이스 설계 방식<br/>
* 분산 데이터베이스의 구축 방법에는 상향식 설계 방식과 하향식 설계 방식 2가지가 있다.

&ensp;(1) 상향식 설계 방식<br/>
&ensp;지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스를 구축한다.<br/>
&ensp;(2) 하향식 설계 방식<br/>
&ensp;전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스를 구축한다.<br/>

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-57.JPEG" width="600"></p>

* 분산 데이터베이스를 하향식 접근 방식으로 구축한다는 것은 기업 전체의 전사 데이터 모델을 수렴하여 전역 스키마를 생성하고 그 다음 각 지역별로 지역 스키마를 생성하여 분산 데이터베이스를 구축하는 것이다. 상향식 접근 방식은 지역별로 데이터베이스를 구축한 후에 전역 스키마로 통합하는 것이다.
* 분산 데이터베이스를 구축하거나 운영할 때 동일한 데이터베이스 관리 시스템으로 분산 데이터베이스를 구축하는 것은 크게 어렵지 않다. 하지만 기업에 여러 종류의 데이터베이스 관리 시스템이 있으면 이기종 데이터베이스 관리 시스템으로 연동해야 한다. 이기종 데이터베이스 시스템으로 연동하기 위해서는 데이터베이스 미들웨어(ODBC, JDBC)를 사용해야 한다.

<p align="center"><img src="/assets/img/SQLD/2. 데이터 모델링의 이해/2-58.JPEG" width="600"></p>