---
title: "설계 과제 #2"
date: 2025-11-20
---

설계과제 #2 - 3 질문 예측



1. 지난 시간에 작성한 순서도를 기반으로 r_init(), r_scanf(), r_printf(), r_cleanup을 완성하시오.
1. Recover Mode 구현 (핵심 기능)
1. 비정상 종료 실험 및 동작 확인  (임의의 프로그램에서도 가능해야 함)
Child process에서 작업을 수행하고 Parent process는 비정상 종료를 감지하여 재실행하는 supervisor 구조를 작성하시오. (fork(), wait(), signal 사용)



예상 문제

1. 지난 시간에 작성한 순서도를 기반으로 r_init(), r_scanf(), r_printf(), r_cleanup()을 완성하시오.
- Shared Memory를 이용할 것
- mmap + MAP_SHARED 조합을 사용할 것
- union을 이용하여 입력 타입(int, float, char)을 통합 관리할 것
- data1에는 입력 버퍼, data2에는 진행 상태(nscan, nprint 등)를 기록할 것


1. r_scanf()는 복구 가능한 입력 함수로 작성한다.
정상 모드:

- scanf()로 입력을 받고
- union 배열(data1)에 저장하고
- index를 증가시키고
- msync로 상태를 동기화한다
복구 모드(mode=1):

- 이미 읽은 부분은 skip
- 아직 읽지 않은 입력을 data1에서 읽어 arg에 전달
- nscan 도달 시 mode=0으로 전환


1. r_printf()는 복구 가능한 출력 함수로 작성한다.
정상 모드:

- vprintf()로 바로 출력
- data2[0]에 출력 위치(cnt) 기록
- msync로 동기화
복구 모드:

- cnt <= nprint인 경우 출력하지 않음
- cnt > nprint인 경우만 vprintf()로 출력


1. Supervisor Process를 구현하시오.
- parent는 감시자(supervisor) 역할
- child는 실제 입력/출력 처리
- child가 비정상 종료(신호 등)되면 parent는 mode=1로 설정하고 다시 실행
- child가 정상 종료되면 shared memory 제거 후 종료
사용해야 하는 함수 예시:

fork(), wait(), WIFSIGNALED(), WEXITSTATUS(), sigaction(), WTERMSIG()



myio3.c 



test.c - 실제 입출력을 수행하는 자식 프로세스



supervisor.c — 안 죽는 프로그램 완성본



