---
title: "chapter 5. 상속"
excerpt: ""

wirter: sohee Kim
categories:
  - 문제해결 및 실습-Java
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-09-22
last_modified_at: 2025-09-22
---

상속(inheritance)
=====

&ensp;<b>객체 지향의 상속</b><br/>
* 부모 클래스에 만들어진 필드, 메소드를 자식클래스가 물려받음
* 부모의 생물학적 특성을 물려받는 유전과 유사
* 상속을 통해 간결한 자식 클래스 작성
    - 동일한 특성을 재정의할 필요가 없어 자식 클래스가 간결해짐

&ensp;상속의 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-1.png" width="600"></p>

&ensp;<b>객체 지향에서 상속의 장점</b><br/>
* 클래스의 간결화
    - 멤버의 중복 작성 불필요
* 클래스 관리 용이
    - 클래스들의 계층적 분류
* 소프트웨어의 생산성 향상
    - 클래스 재사용과 확장 요이
    - 새로운 클래스의 작성 속도 빠름

&ensp;<b>클래스 상속과 객체</b><br/>
&ensp;자바의 상속 선언<br/>
```java
public class Person {
...
}
public class Student extends Person { // Person을 상속받는 클래스 Student 선언
...
}
public class StudentWorker extends Student { // Student를 상속받는 StudentWorker 선언
...
}
```

* 부모 클래스 -> 슈퍼 클래스(super class)로 부름
* 자식 클래스 -> 서브 클래스(sub class)로 부름
* extends 키워드 사용
    - 슈퍼 클래스를 확장한다는 개념

`예제5-1`
&ensp;(x, y)의 한 점을 표현하는 Point 클래스와 이를 상속받아 색을 가진 점을 표현하는 ColorPoint 클래스를 만들고 활용해보자<br/>

```java
class Point {
    private int x, y; // 한 점을 구성하는 x, y 좌표
    public void set(int x, int y) {
        this.x = x; this.y = y;
    }
    public void showPoint() { // 점의 좌표 출력
        System.out.println("(" + x + "," + y + ")");
    }
}
```

```java
// Point를 상속받은 ColorPoint 선언
class ColorPoint extends Point { 
    private String color; // 점의 색
    public void setColor(String color) {
        this.color = color;
    }
    public void showColorPoint() { // 컬러 점의 좌표 출력
        System.out.print(color);
        showPoint(); // Point 클래스의 showPoint() 호출 
    }
}
```

```java
// Point를 상속받은 ColorPoint 선언
class ColorPoint extends Point { 
    private String color; // 점의 색
    public void setColor(String color) {
        this.color = color;
    }
    public void showColorPoint() { // 컬러 점의 좌표 출력
        System.out.print(color);
        showPoint(); // Point 클래스의 showPoint() 호출 
    }
}

```

&ensp;객체 생성<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-3.png" width="600"></p>

&ensp;서브클래스에서 슈퍼 클래스의 멤버 접근<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-4.png" width="600"></p>

&ensp;<b>상속의 특징</b><br/>
* 클래스의 다중 상속 지원하지 않음
* 상속 횟수 무제한
* 상속의 최상위 조상 클래스는 java.lang.Object 클래스
    - 모든 클래스는 자동으로 java.lang.Object를 상속받음
    - 자바 컴파일러에 의해 자동으로 이루어짐

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-5.png" width="600"></p>

&ensp;<b>상속과 접근 지정자</b><br/>
* 자바의 접근 지정자 4 가지
    - public, protected, 디폴트, private
        + 상속 관계에서 주의할 접근 지정자는 private와 protected
* 슈퍼 클래스의 private 멤버
    - 슈퍼 클래스의 private 멤버는 다른 모든 클래스에 접근 불허
    - 클래스내의 멤버들에게만 접근 허용
* 슈퍼 클래스의 디폴트 멤버
    - 슈퍼 클래스의 디폴트 멤버는 패키지내 모든 클래스에 접근 허용
* 슈퍼 클래스의 public 멤버
    - 슈퍼 클래스의 public 멤버는 다른 모든 클래스에 접근 허용
* 슈퍼 클래스의 protected 멤버
    - 같은 패키지 내의 모든 클래스 접근 허용
    - 다른 패키지에 있어도 서브 클래스는 슈퍼 클래스의 protected 멤버 접근 가능

&ensp;슈퍼 클래스의 멤버에 대한 서브 클래스의 접근<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-6.png" width="600"></p>

`예제 5-2`
&ensp;클래스 Person을 아래와 같은 멤버 필드를 갖도록 선언하고 클래스 Student는 클래스 Person을 상속받아 각 멤버 필드에 값을 저장하시오. 이 예제에서 Person 클래스의 private 필드인 weight는 Student 클래스에서는 접근이 불가능하여 슈퍼 클래스인 Person의 getXXX, setXXX 메소드를 통해서만 조작이 가능하다.<br/>
* private int weight;
* int age;
* protected int height;
* public String name;

```java
class Person {
    private int weight;
    int age;
    protected int height;
    public String name;

    public void setWeight(int weight) {
        this.weight = weight;
    }
    public int getWeight() {
        return weight;
    }
}
```

```java
class Student extends Person {
    public void set() {
        age = 30; // 슈퍼 클래스의 디폴트 멤버 접근 가능
        name = "홍길동"; // 슈퍼 클래스의 public 멤버 접근 가능
        height = 175; // 슈퍼 클래스의 protected 멤버 접근 가능
        // weight = 99; // 오류. 슈퍼 클래스의 private 접근 불가
        setWeight(99); // private 멤버 weight은 setWeight()으로 간접 접근
    }
}
```

```java
public class InheritanceEx {
    public static void main(String[] args) {
        Student s = new Student();
        s.set();
    }
}
```

&ensp;<b>서브 클래스/슈퍼 클래스의 생성자 호출 및 실행</b><br/>
&ensp;new에 의해 서브 클래스의 객체가 생성될 때<br/>
* 슈퍼클래스 생성자와 서브 클래스 생성자 모두 실행됨
* 호출 순서
    - 서브 클래스의 생성자가 먼저 호출, 서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
* 실행 순서
    - 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

&ensp;슈퍼클래스와 서브 클래스의 생성자간의 호출 및 실행 관계<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-7.png" width="600"></p>

&ensp;<b>서브 클래스에서 슈퍼 클래스의 생성자 선택</b><br/>
* 상속 관계에서의 생성자
    - 슈퍼 클래스와 서브 클래스 각각 각각 여러 생성자 작성 가능
* 서브 클래스 생성자 작성 원칙
    - 서버 클래스 생성자에서 슈퍼 클래스 생성자 하나 선택
* 서브 클래스에서 슈퍼 클래스의 생성자를 선택하지 않는 경우
    - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택
* 서브 클래스에서 슈퍼 클래스의 생성자를 선택하는 방법
    - super() 이용
