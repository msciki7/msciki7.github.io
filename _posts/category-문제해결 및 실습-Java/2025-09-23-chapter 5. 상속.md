---
title: "chapter 5. 상속"
excerpt: ""

wirter: sohee Kim
categories:
  - 문제해결 및 실습-Java
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-09-22
last_modified_at: 2025-09-22
---

상속(inheritance)
=====

&ensp;<b>객체 지향의 상속</b><br/>
* 부모 클래스에 만들어진 필드, 메소드를 자식클래스가 물려받음
* 부모의 생물학적 특성을 물려받는 유전과 유사
* 상속을 통해 간결한 자식 클래스 작성
    - 동일한 특성을 재정의할 필요가 없어 자식 클래스가 간결해짐

&ensp;상속의 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-1.png" width="600"></p>

&ensp;<b>객체 지향에서 상속의 장점</b><br/>
* 클래스의 간결화
    - 멤버의 중복 작성 불필요
* 클래스 관리 용이
    - 클래스들의 계층적 분류
* 소프트웨어의 생산성 향상
    - 클래스 재사용과 확장 요이
    - 새로운 클래스의 작성 속도 빠름

&ensp;<b>클래스 상속과 객체</b><br/>
&ensp;자바의 상속 선언<br/>
```java
public class Person {
...
}
public class Student extends Person { // Person을 상속받는 클래스 Student 선언
...
}
public class StudentWorker extends Student { // Student를 상속받는 StudentWorker 선언
...
}
```

* 부모 클래스 -> 슈퍼 클래스(super class)로 부름
* 자식 클래스 -> 서브 클래스(sub class)로 부름
* extends 키워드 사용
    - 슈퍼 클래스를 확장한다는 개념

`예제5-1`
&ensp;(x, y)의 한 점을 표현하는 Point 클래스와 이를 상속받아 색을 가진 점을 표현하는 ColorPoint 클래스를 만들고 활용해보자<br/>

```java
class Point {
    private int x, y; // 한 점을 구성하는 x, y 좌표
    public void set(int x, int y) {
        this.x = x; this.y = y;
    }
    public void showPoint() { // 점의 좌표 출력
        System.out.println("(" + x + "," + y + ")");
    }
}
```

```java
// Point를 상속받은 ColorPoint 선언
class ColorPoint extends Point { 
    private String color; // 점의 색
    public void setColor(String color) {
        this.color = color;
    }
    public void showColorPoint() { // 컬러 점의 좌표 출력
        System.out.print(color);
        showPoint(); // Point 클래스의 showPoint() 호출 
    }
}
```

```java
// Point를 상속받은 ColorPoint 선언
class ColorPoint extends Point { 
    private String color; // 점의 색
    public void setColor(String color) {
        this.color = color;
    }
    public void showColorPoint() { // 컬러 점의 좌표 출력
        System.out.print(color);
        showPoint(); // Point 클래스의 showPoint() 호출 
    }
}

```

&ensp;객체 생성<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-3.png" width="600"></p>

&ensp;서브클래스에서 슈퍼 클래스의 멤버 접근<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-4.png" width="600"></p>

&ensp;<b>상속의 특징</b><br/>
* 클래스의 다중 상속 지원하지 않음
* 상속 횟수 무제한
* 상속의 최상위 조상 클래스는 java.lang.Object 클래스
    - 모든 클래스는 자동으로 java.lang.Object를 상속받음
    - 자바 컴파일러에 의해 자동으로 이루어짐

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-5.png" width="600"></p>

&ensp;<b>상속과 접근 지정자</b><br/>
* 자바의 접근 지정자 4 가지
    - public, protected, 디폴트, private
        + 상속 관계에서 주의할 접근 지정자는 private와 protected
* 슈퍼 클래스의 private 멤버
    - 슈퍼 클래스의 private 멤버는 다른 모든 클래스에 접근 불허
    - 클래스내의 멤버들에게만 접근 허용
* 슈퍼 클래스의 디폴트 멤버
    - 슈퍼 클래스의 디폴트 멤버는 패키지내 모든 클래스에 접근 허용
* 슈퍼 클래스의 public 멤버
    - 슈퍼 클래스의 public 멤버는 다른 모든 클래스에 접근 허용
* 슈퍼 클래스의 protected 멤버
    - 같은 패키지 내의 모든 클래스 접근 허용
    - 다른 패키지에 있어도 서브 클래스는 슈퍼 클래스의 protected 멤버 접근 가능

&ensp;슈퍼 클래스의 멤버에 대한 서브 클래스의 접근<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-6.png" width="600"></p>

`예제 5-2`
&ensp;클래스 Person을 아래와 같은 멤버 필드를 갖도록 선언하고 클래스 Student는 클래스 Person을 상속받아 각 멤버 필드에 값을 저장하시오. 이 예제에서 Person 클래스의 private 필드인 weight는 Student 클래스에서는 접근이 불가능하여 슈퍼 클래스인 Person의 getXXX, setXXX 메소드를 통해서만 조작이 가능하다.<br/>
* private int weight;
* int age;
* protected int height;
* public String name;

```java
class Person {
    private int weight;
    int age;
    protected int height;
    public String name;

    public void setWeight(int weight) {
        this.weight = weight;
    }
    public int getWeight() {
        return weight;
    }
}
```

```java
class Student extends Person {
    public void set() {
        age = 30; // 슈퍼 클래스의 디폴트 멤버 접근 가능
        name = "홍길동"; // 슈퍼 클래스의 public 멤버 접근 가능
        height = 175; // 슈퍼 클래스의 protected 멤버 접근 가능
        // weight = 99; // 오류. 슈퍼 클래스의 private 접근 불가
        setWeight(99); // private 멤버 weight은 setWeight()으로 간접 접근
    }
}
```

```java
public class InheritanceEx {
    public static void main(String[] args) {
        Student s = new Student();
        s.set();
    }
}
```

&ensp;<b>서브 클래스/슈퍼 클래스의 생성자 호출 및 실행</b><br/>
&ensp;new에 의해 서브 클래스의 객체가 생성될 때<br/>
* 슈퍼클래스 생성자와 서브 클래스 생성자 모두 실행됨
* 호출 순서
    - 서브 클래스의 생성자가 먼저 호출, 서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
* 실행 순서
    - 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

&ensp;슈퍼클래스와 서브 클래스의 생성자간의 호출 및 실행 관계<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-7.png" width="600"></p>

&ensp;<b>서브 클래스에서 슈퍼 클래스의 생성자 선택</b><br/>
* 상속 관계에서의 생성자
    - 슈퍼 클래스와 서브 클래스 각각 각각 여러 생성자 작성 가능
* 서브 클래스 생성자 작성 원칙
    - 서버 클래스 생성자에서 슈퍼 클래스 생성자 하나 선택
* 서브 클래스에서 슈퍼 클래스의 생성자를 선택하지 않는 경우
    - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택
* 서브 클래스에서 슈퍼 클래스의 생성자를 선택하는 방법
    - super() 이용

&ensp;슈퍼 클래스의 기본 생성자가 자동 선택<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-8.png" width="600"></p>

&ensp;슈퍼 클래스에 기본 생성자가 없어 오류 난 경우<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-9.png" width="600"></p>

&ensp;서브 클래스에 매개변수를 가진 생성자<br/>
&ensp;서브 클래스의 생성자가 슈퍼 클래스의 생성자를 선택하지 않은 경우<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-10.png" width="600"></p>

&ensp;super()를 이용하여 명시적으로 슈퍼 클래스 생성자 선택<br/>
* super()
    - 서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출
        + super(parameter);
        + 인자를 이용하여 슈퍼 클래스의 적당한 생성자 호출
        + 반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야 함
    
&ensp;super()를 이용한 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-11.png" width="600"></p>

`예제 5-3`
&ensp;super()를 이용하여 ColorPoint 클래스의 생성자에서 슈퍼 클래스 Point의 생성자를 호출하는 예를 보인다.<br/>
```java
class Point {
    private int x, y; // 한 점을 구성하는 x, y 좌표
    public Point() {
        this.x = this.y = 0;
    }
    public Point(int x, int y) {
        this.x = x; this.y = y;
    }
    public void showPoint() { // 점의 좌표 출력
        System.out.println("(" + x + "," + y + ")");
    }
}

class ColorPoint extends Point { 
    private String color; // 점의 색
    public ColorPoint(int x, int y, String color) {
        super(x, y); // Point의 생성자 Point(x, y) 호출
        this.color = color;
    }
    public void showColorPoint() { // 컬러 점의 좌표 출력
        System.out.print(color);
        showPoint(); // Point 클래스의 showPoint() 호출
    }
}
```

```java
public class SuperEx {
    public static void main(String[] args) {
        ColorPoint cp = new ColorPoint(5, 6, "blue");
        cp.showColorPoint();
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-12.png" width="600"></p>

업캐스팅(upcasting)
=====

&ensp;서브 클래스의 객체<br/>
* 슈퍼 클래스의 멤버를 모두 가지고 있음
* 슈퍼 클래스의 객체로 취급할 수 있음

&ensp;업캐스팅이란?<br/>
* 서브 클래스 객체를 슈퍼 클래스 타입으로 타입 변환

```java
class Person { … }
class Student extends Person { … }

Student s = new Student();
Person p = s; // 업캐스팅, 자동타입변환
```

&ensp;업캐스팅된 레퍼런스<br/>
* 객체 내에 슈퍼 클래스의 멤버만 접근 가능

&ensp;업캐스팅 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-13.png" width="600"></p>

다운캐스팅(downcasting)
====

* 슈퍼 클래스 객체를 서브 클래스 타입으로 변환
* 개발자의 명시적 타입 변환 필요

```java
class Person { … }
class Student extends Person { … }
...
Person p = new Student("이재문"); // 업캐스팅
…
Student s = (Student)p; // 다운캐스팅, (Student)의 타입 변환 표시 필요
```

&ensp;다운캐스팅 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-14.png" width="600"></p>

instanceof 연산자와 객체의 타입 판단
====

&ensp;업캐스팅된 레퍼런스로 객체의 타입 판단 어려움<br/>
* 슈퍼 클래스는 여러 서브 클래스에 상속되기 때문

&ensp;instanceof 연산자<br/>
* 레퍼런스가 가리키는 객체의 타입 식별을 위해 사용
* 사용법

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-15.png" width="600"></p>

&ensp;업캐스팅 레퍼런스가 가리키는 객체는?<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-16.png" width="600"></p>

&ensp;Person타입의 레퍼런스 person이 어떤 타입의 객체를 가리키는지 알 수 없음<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-17.png" width="600"></p>

&ensp;instanceof 사용 예<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-18.png" width="600"></p>

`예제 5-4`
&ensp;instanceof 연산자를 이용하여 상속 관계에 따라 레퍼런스가 가리키는 객체의 타입을 알아본다. 실행 결과는 무엇인가?<br/>

```java
class Person { }
class Student extends Person { }
class Researcher extends Person { }
class Professor extends Researcher { }

public class InstanceOfEx {
    static void print(Person p) {
        if(p instanceof Person)
            System.out.print("Person ");
        if(p instanceof Student)
            System.out.print("Student ");
        if(p instanceof Researcher)
            System.out.print("Researcher ");
        if(p instanceof Professor)
            System.out.print("Professor ");
        System.out.println();
    }
    public static void main(String[] args) {
        System.out.print("new Student() ->\t"); print(new Student());
        System.out.print("new Researcher() ->\t"); print(new Researcher());
        System.out.print("new Professor() ->\t"); print(new Professor());
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-19.png" width="600"></p>

메소드 오버라이딩
=====

&ensp;슈퍼 클래스의 메소드를 서브 클래스에서 재정의<br/>
* 슈퍼 클래스 메소드의 이름, 매개변수 타입 및 개수, 리턴 타입 등 모든 것 동일하게 작성

&ensp;메소드 무시하기, 덮어쓰기로 번역되기도 
&ensp;동적 바인딩 발생<br/>
* 서브 클래스에 오버라이딩된 메소드가 무조건 실행되는 동적 바인딩

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-20.png" width="600"></p>

&ensp;메소드 오버라이딩 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-21.png" width="600"></p>

&ensp;오버라이딩에 의해 서브 클래스의 메소드 호출<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-22.png" width="600"></p>

&ensp;오버라이딩 목적, 다형성 실현<br/>
* 오버라이딩
    - 슈퍼 클래스에 선언된 메소드들, 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 기능
    - 상속을 통해 하나의 인터페이스(같은 이름)에 서로 다른 내용 구현이라는 객체 지향의 다형성 실현
        + Line 클래스에서 draw()는 선을 그리고
        + Circle 클래스에서 draw()는 원을 그리고
        + Rect 클래스에서 draw()는 사각형 그린다.
* 오버라이딩은 실행 시간 다형성 실현
    - 동적 바인딩을 통해 실행 중에 다형성 실현
        + 오버로딩은 컴파일 타입 다형성 실현

`예제 5-5`
&ensp;메소드 오버라이딩으로 다형성 실현<br/>
```java
public class MethodOverridingEx {
    static void paint(Shape p) {
        p.draw(); // p가 가리키는 객체 내에 오버라이딩된 draw() 호출. 
                      // 동적 바인딩
    }

    public static void main(String[] args) {
        Line line = new Line();
        paint(line); 
        paint(new Shape()); 
        paint(new Line()); 
        paint(new Rect()); 
        paint(new Circle()); 
    }
}
```

```java
class Shape { // 슈퍼 클래스
    public Shape next; 
    public Shape() { next = null; }

    public void draw() {
        System.out.println("Shape");
    }
}

class Line extends Shape {
    public void draw() { // 메소드 오버라이딩
        System.out.println("Line");
    }
}

class Rect extends Shape {
    public void draw() { // 메소드 오버라이딩
        System.out.println("Rect");
    }
}

class Circle extends Shape {
    public void draw() { // 메소드 오버라이딩
        System.out.println("Circle");
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-23.png" width="600"></p>

&ensp;실행 과정<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-24.png" width="600"></p>

&ensp;오버라이딩 활용<br/>
```java
// 예제 5-5의 Shape, Line, Rect, Circle 클래스 활용
public class UsingOverride {
    public static void main(String [] args) {
        Shape start, last, obj;
        // 링크드 리스트로 도형 생성하여 연결
        start = new Line(); // Line 객체 연결
        last = start;
        obj = new Rect();
        last.next = obj; // Rect 객체 연결
        last = obj;
        obj = new Line(); // Line 객체 연결
        last.next = obj;
        last = obj;
        obj = new Circle(); // Circle 객체 연결
        last.next = obj;
        // 모든 도형 출력
        Shape p = start;
        while(p != null) {
            p.draw();
            p = p.next;
        }
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-25.png" width="600"></p>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-26.png" width="600"></p>

동적 바인딩
=====

* 실행할 메소드를 실행 시 (run time)에 결정
* 오버라이딩 메소드가 항상 호출

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-27.png" width="600"></p>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-28.png" width="600"></p>

&ensp;오버라이딩과 super 키워드<br/>
* super는 슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
* 서브 클래스에서만 사용
* 슈퍼 클래스의 메소드 호출
* 컴파일러는 super의 접근을 정적 바인딩으로 처리

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-29.png" width="600"></p>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-30.png" width="600"></p>

`예제 5-6`
&ensp;게임에서 무기를 표현하는 Weapon 클래스를 만들고 살상능력을 리턴하는 fire() 메소드를 작성하면 다음과 같다. fire()은 1을 리턴한다.<br/>
```java
class Weapon {
    protected int fire() {
        return 1; // 무기는 기본적으로 한 명만 살상
    }
}
```

&ensp;대포를 구현하기 위해 Weapon을 상속받는 Cannon 클래스를 작성하라. Cannon은 살상능력이 10이다. fire() 메소드를 이에 맞게 오버라이딩하라. main()을 작성하여 오버라이딩을 테스트하라.<br/>
```java
class Cannon extends Weapon {
    @Override
    protected int fire() { // 오버라이딩
        return 10; // 대포는 한 번에 10명을 살상
    }
}
```

```java
public class Overriding {
    public static void main(String[] args) {
        Weapon weapon;
        weapon = new Weapon();
        System.out.println("기본 무기의 살상 능력은 " + 
                                        weapon.fire());
        weapon = new Cannon();
        System.out.println("대포의 살상 능력은 " + 
                                        weapon.fire());
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-31.png" width="600"></p>

&ensp;오버라이딩 vs. 오버로딩<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-32.png" width="600"></p>

추상 메소드와 추상 클래스
=====

&ensp;추상 메소드(abstract method)<br/>
* 선언되어 있으나 구현되어 있지 않은 메소드, abstract로 선언

```java
public abstract String getName();
public abstract void setName(String s);
```

* 추상 메소드는 서브 클래스에서 오버라이딩하여 구현해야 함

&ensp;추상 클래스의 2종류<br/>
1. 추상 메소드를 하나라도 가진 클래스
    - 클래스 앞에 반드시 abstract라고 선언해야 함
2. 추상 메소드가 하나도 없지만 abstract로 선언된 클래스

&ensp;2 가지 종류의 추상 클래스 사례<br/>
```java
// 1. 추상 메소드를 포함하는 추상 클래스

abstract class Shape { // 추상 클래스 선언
    public Shape() { }
    public void paint() { draw(); }
    abstract public void draw(); // 추상 메소드
}
```

```java
// 2. 추상 메소드 없는 추상 클래스

abstract class MyComponent { // 추상 클래스 선언
    String name;
    public void load(String name) {
        this.name = name;
    }
}
```

&ensp;추상 클래스는 객체를 생성할 수 없다.<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-33.png" width="600"></p>

&ensp;<b>추상 클래스의 상속</b><br/>
&ensp;추상 클래스의 상속 2 가지 경우<br/>
&ensp;1. 추상 클래스의 단순 상속<br/>
* 추상 클래스를 상속받아, 추상 메소드를 구현하지 않으면 추상 클래스 됨 
* 서브 클래스도 abstract로 선언해야 함

```java
abstract class Shape { // 추상 클래스
    public Shape() { }
    public void paint() { draw(); }
    abstract public void draw(); // 추상 메소드
}
abstract class Line extends Shape { // 추상 클래스. draw()를 상속받기 때문
    public String toString() { return "Line"; }
}
```

&ensp;2. 추상 클래스 구현 상속<br/>
* 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)
* 서브 클래스는 추상 클래스 아님

&ensp;추상 클래스의 구현 및 활용 예<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-34.png" width="600"></p>

&ensp;<b>추상 클래스의 용도</b><br/>
* 설계와 구현 분리
    - 슈퍼 클래스에서는 개념 정의
        + 서브 클래스마다 다른 구현이 필요한 메소드는 추상 메소드로 선언
    - 각 서브 클래스에서 구체적 행위 구현
        + 서브 클래스마다 목적에 맞게 추상 메소드 다르게 구현
* 계층적 상속 관계를 갖는 클래스 구조를 만들 때

`예제 5-7`
&ensp;다음 추상 클래스 Calculator를 상속받은 GoodCalc 클래스를 구현하라<br/>
```java
abstract class Calculator {
    public abstract int add(int a, int b);
    public abstract int subtract(int a, int b);
    public abstract double average(int[] a);
}
```

```java
public class GoodCalc extends Calculator {
    @Override
    public int add(int a, int b) { // 추상 메소드 구현
        return a + b;
    }
    @Override
    public int subtract(int a, int b) { // 추상 메소드 구현
        return a - b;
    }
    @Override
    public double average(int[] a) { // 추상 메소드 구현
        double sum = 0;
        for (int i = 0; i <a.length; i++)
            sum += a[i];
        return sum/a.length;
    }

    public static void main(String [] args) {
        GoodCalc c = new GoodCalc();
        System.out.println(c.add(2,3));
        System.out.println(c.subtract(2,3));
        System.out.println(c.average(new int [] { 2,3,4 }));
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-35.png" width="600"></p>

인터페이스
====

&ensp;자바의 인터페이스<br/>
* 자바의 인터페이스
    - 클래스가 구현해야 할 메소드들이 선언되는 추상형
    - 인터페이스 선언
        + interface 키워드로 선언
        + Ex) public interface SerialDriver {…}
* 자바 인터페이스에 대한 변화
    - Java 7까지 
        + 인터페이스는 상수와 추상 메소드로만 구현  
    - Java 8부터 
        + 상수와 추상메소드 포함
        + default 메소드 포함 (Java 8)
        + private 메소드 포함 (Java 9)
        + static 메소드 포함 (Java 9)
* 여전히 인터페이스에는 필드(멤버 변수)선언 불가

&ensp;자바 인터페이스 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-36.png" width="600"></p>

&ensp;<b>인터페이스의 구성 요소들의 특징</b><br/>
&ensp;인터페이스의 구성 요소들<br/>
* 상수
    - public만 허용, public static final 생략
* 추상 메소드
    - public abstract 생략 가능
* default 메소드
    - 인터페이스에 코드가 작성된 메소드
    - 인터페이스를 구현하는 클래스에 자동 상속
    - public 접근 지정만 허용, 생략 가능
* private 메소드
    - 인터페이스 내에 메소드 코드가 작성되어야 함
    - 인터페이스 내에 있는 다른 메소드에 의해서만 호출 가능
* static 메소드
    - public, private 모두 지정 가능, 생략하면 public

&ensp;자바 인터페이스의 전체적인 특징<br/>
* 인터페이스의 객체 생성 불가

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-37.png" width="600"></p>

* 인터페이스 타이브이 레퍼런스 변수 선언 가능

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-38.png" width="600"></p>

* 인터페이스 구현
    - 인터페이스를 상속받는 클래스는 인터페이스의 모든 추상 메소드 반드시 구현
* 다른 인터페이스 상속 가능
* 인터페이스의 다중 상속 가능

&ensp;<b>인터페이스 구현</b><br/>
&ensp;인터페이스의 추상 메소드를 모두 구현한 클래스 작성
* implements 키워드 사용
* 여러 개의 인터페이스 동시 구현 가능

&ensp;인터페이스 구현 사례<br/>
* PhoneInterface 인터페이스를 구현한 SamsungPhone 클래스

```java
class SamsungPhone implements PhoneInterface { // 인터페이스 구현
    // PhoneInterface의 모든 메소드 구현
    public void sendCall() { System.out.println("띠리리리링"); }
    public void receiveCall() { System.out.println("전화가 왔습니다."); }

    // 메소드 추가 작성
    public void flash() { System.out.println("전화기에 불이 켜졌습니다."); }
}
```

* SamsungPhone 클래스는 PhoneInterface의 default 메소드 상속

`예제 5-8`
&ensp;PhoneInterface 인터페이스를 구현하고 flash() 메소드를 추가한 SamsungPhone 클래스를 작성하라.<br/>

```java
interface PhoneInterface { // 인터페이스 선언
    final int TIMEOUT = 10000; // 상수 필드 선언
    void sendCall(); // 추상 메소드
    void receiveCall(); // 추상 메소드
    default void printLogo() { // default 메소드
        System.out.println("** Phone **");
    }
}
class SamsungPhone implements PhoneInterface { // 인터페이스 구현
    // PhoneInterface의 모든 추상 메소드 구현
    @Override
    public void sendCall() {
        System.out.println("띠리리리링");
    }
    @Override
    public void receiveCall() {
        System.out.println("전화가 왔습니다.");
    }

    // 메소드 추가 작성
    public void flash() { System.out.println("전화기에 불이 켜졌습니다."); }
}
public class InterfaceEx {
    public static void main(String[] args) {
        SamsungPhone phone = new SamsungPhone();
        phone.printLogo();
        phone.sendCall();
        phone.receiveCall();
        phone.flash();
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-39.png" width="600"></p>

&ensp;<b>인터페이스 상속</b><br/>
&ensp;인터페이스가 다른 인터페이스 상속<br/>
* extends 키워드 이용

```java
interface MobilePhoneInterface extends PhoneInterface {
    void sendSMS(); 		// 새로운 추상 메소드 추가
    void receiveSMS(); 	// 새로운 추상 메소드 추가
}
```

* 다중 인터페이스 상속

```java
interface MP3Interface {
    void play(); // 추상 메소드
    void stop(); // 추상 메소드
}

interface MusicPhoneInterface extends MobilePhoneInterface, MP3Interface {
    void playMP3RingTone(); // 새로운 추상 메소드 추가
}
```

&ensp;인터페이스의 목적<br/>
&ensp;인터페이스는 스펙을 주어 클래스들이 그 기능을 서로 다르게 구현할 수 있도록 하는 클래스의 규격 선언이며, 클래스의 다형성을 실현하는 도구이다.<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-40.png" width="600"></p>

&ensp;다중 인터페이스 구현<br/>
&ensp;클래스는 하나 이상의 인터페이스를 구현할 수 있음<br/>
```java
interface AIInterface {
    void recognizeSpeech(); // 음성 인식
    void synthesizeSpeech(); // 음성 합성
}

class AIPhone implements MobilePhoneInterface, AIInterface { // 인터페이스 구현
    // MobilePhoneInterface의 모든 메소드를 구현한다.
    public void sendCall() { ... }
    public void receiveCall() { ... }
    public void sendSMS() { ... }
    public void receiveSMS() { ... }

    // AIInterface의 모든 메소드를 구현한다.
    public void recognizeSpeech() { ... } // 음성 인식
    public void synthesizeSpeech() { ... } // 음성 합성

    // 추가적으로 다른 메소드를 작성할 수 있다.
    public int touch() { ... }
}
```

`예제 5-9`
&ensp;인터페이스를 구현하고 동시에 클래스를 상속받는 사례<br/>
```java
interface PhoneInterface { // 인터페이스 선언
    final int TIMEOUT = 10000; // 상수 필드 선언
    void sendCall(); // 추상 메소드
    void receiveCall(); // 추상 메소드
    default void printLogo() { // default 메소드
        System.out.println("** Phone **");
    }
}
interface MobilePhoneInterface extends PhoneInterface {
    void sendSMS();
    void receiveSMS();
}
interface MP3Interface { // 인터페이스 선언
    public void play();
    public void stop();
}
class PDA { // 클래스 작성
    public int calculate(int x, int y) {
        return x + y;
    }
}
// SmartPhone 클래스는 PDA를 상속받고,
// MobilePhoneInterface와 MP3Interface 인터페이스에 선언된 추상 메소드를 모두 구현한다.
class SmartPhone extends PDA implements MobilePhoneInterface, MP3Interface {
    // MobilePhoneInterface의 추상 메소드 구현
    @Override
    public void sendCall() {
        System.out.println("따르릉따르릉~~");
    }
    @Override
    public void receiveCall() {
        System.out.println("전화 왔어요.");
    }
```

```java
@Override
    public void sendSMS() {
        System.out.println("문자갑니다.");
    }
    @Override
    public void receiveSMS() {
        System.out.println("문자왔어요.");
    }
    // MP3Interface의 추상 메소드 구현
    @Override
    public void play() {
        System.out.println("음악 연주합니다.");
    }
    @Override
    public void stop() {
        System.out.println("음악 중단합니다.");
    }
    // 추가로 작성한 메소드
    public void schedule() {
        System.out.println("일정 관리합니다.");
    }
}
public class InterfaceEx {
    public static void main(String [] args) {
    SmartPhone phone = new SmartPhone();
    phone.printLogo();
    phone.sendCall();
    phone.play();
    System.out.println("3과 5를 더하면 " +
         phone.calculate(3,5));
    phone.schedule();
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-41.png" width="600"></p>

&ensp;추상 클래스와 인터페이스 비교<br/>
&ensp;유사점<br/>
* 객체를 생성할 수 없고 상속을 위한 슈퍼 클래스로만 사용
* 클래스의 다형성을 실현하기 위한 목적

&ensp;차이점<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter5. 상속/5-42.png" width="600"></p>