---
title: "chapter 4. 클래스와 객체"
excerpt: ""

wirter: sohee Kim
categories:
  - 문제해결 및 실습-Java
tags:
  - Java

toc: true
toc_sticky: true

date: 2025-09-17
last_modified_at: 2025-09-17
---

객체 지향 특성
=====

&ensp;캡슐화<br/>
&ensp;객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것<br/>
* 객체의 본질적인 특징
    - 외부의 접근으로부터 객체 보호

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-1.png" width="600"></p>

&ensp;클래스(class): 객체 모양을 선언한 틀(캡슐화)<br/>
* 메소드(멤버 함수)와 필드(멤버 변수)는 모두 클래스 내에 구현

&ensp;객체<br/>
* 클래스의 모양대로 생성된 실체(instance)
* 객체 내 데이터에 대한 보호, 외부 접근 제한
    - 객체 외부에서는 비공개 멤버(필드, 메소드)에 직접 접근할 수 없음
    - 객체 외부에서는 공개된 메소드를 통해 비공개 멤버 접근

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-2.png" width="600"></p>

&ensp;상속<br/>
&ensp;자식 클래스가 부모 클래스의 속성 물려받고, 기능 확장<br/>
* 부모 클래스 : 수퍼 클래스
* 하위 클래스 : 서브 클래스. 수퍼 클래스를 재사용하고  새로운 특성 추가 

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-3.png" width="600"></p>

&ensp;다형성<br/>
&ensp;같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현<br/>
&ensp;다형성 사례<br/>
* 메소드 오버로딩 : 같은 이름이지만 다르게 작동하는 여러 메소드
* 메소드 오버라이딩 : 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-4.png" width="600"></p>

&ensp;객체 지향 언어의 목적<br/>
1. 소프트웨어의 생산성 향상
* 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
    - 소프트웨어를 빠른 속도로 생산할 필요성 증대
* 객체 지향 언어
    - 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
    - 소프트웨어 재사용과 부분 수정 빠름
    - 소프트웨어를 다시 만드는 부담 대폭 줄임
    - 소프트웨어 생산성 향상

2. 실세계에 대한 쉬운 모델링
* 컴퓨터 초기 시대의 프로그래밍
    - 수학 계산/통계 처리를 하는 등 처리 과정, 계산 절차 중요
* 현대의 프로그래밍
    - 컴퓨터가 산업 전반에 활용
    - 실세계에서 발생하는 일을 프로그래밍
    - 실세계에서는 절차나 과정보다 물체(객체)들의 상호 작용으로 묘사하는 것이 용이
* 객체 지향 언어
    - 실세계의 일을 보다 쉽게 프로그래밍하기 위한 객체 중심적 언어

&ensp;절차 지향 프로그래밍과 객체 지향 프로그래밍<br/>
* 절차 지향 프로그래밍
    - 작업 순서 표현
    - 작업 함수를 작성한 함수들의 집합
* 객체 지향 프로그래밍
    - 객체들간의 상호 작용으로 표현
    - 클래스 혹은 객체들의 집합으로 프로그램 작성

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-5.png" width="600"></p>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-6.png" width="600"></p>

&ensp;클래스와 객체<br/>
* 클래스
    - 객체를 만들어내기 위한 설계도 혹은 틀
    - 객체의 속성(state)과 행동(behavior) 포함
* 객체
    - 클래스의 모양 그대로 찍어낸 실체
        + 프로그램 실행 중에 생성되는 실체
        + 메모리 공간을 갖는 구체적인 실체
        + 인스턴스(instance)라고도 부름

&ensp;클래스와 객체와의 관계<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-7.png" width="600"></p>

&ensp;사람을 사례로 든 클래스와 객체 사례<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-8.png" width="600"></p>

* 객체들은 클래스에 선언된 동일한 속성을 가지지만 객체마다 서로 다른 고유한 값으로 구분됨

클래스 구성
====

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-9.png" width="600"></p>

* 클래스 선언, class Circle 
    - class 키워드로 선언
    - 클래스는 {로 시작하여 }로 닫으며 이곳에 모든 필드와 메소드 구현
    - class Circle은 Circle 이름의 클래스 선언
    - 클래스 접근 권한, public
    - 다른 클래스들에서 Circle 클래스를 사용하거나 접근할 수 있음을 선언
* 필드와 메소드
    - 필드 (field) : 객체 내에 값을 저장하는 멤버 변수
    - 메소드 (method) : 함수이며 객체의 행동(행위)를 구현
* 필드의 접근 지정자, public
    - 필드나 메소드 앞에 붙어 다른 클래스의 접근 허용을 표시
    - public 접근 지정자 : 다른 모든 클래스의 접근 허용
* 생성자
    - 클래스의 이름과 동일한 특별한 메소드
    - 객체가 생성될 때 자동으로 한 번 호출되는 메소드
    - 개발자는 객체를 초기화하는데 필요한 코드 작성

&ensp;객체 생성 및 접근<br/>
* 객체 생성
    - 반드시 new 키워드를 이용하여 생성
        + new는 객체의 생성자 호출
* 객체 생성 과정
    - 객체에 대한 레퍼런스 변수 선언
    - 객체 생성
        + 클래스 타입 크기의 메모리 할당
        + 객체 내 생성자 코드 실행
* 객체의 멤버 접근
    - 객체 레퍼런스.멤버

&ensp;객체 생성과 접근<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-10.png" width="600"></p>

`예제 4-1`
&ensp;반지름과 이름을 가진 Circle 클래스를 작성하고, Circle 클래스의 객체를 생성하라. 그리고 객체가 생성된 모습을 그려보라.<br/>

```java
public class Circle {
    int radius; 					// 원의 반지름 필드
    String name; 				// 원의 이름 필드

    public Circle() { }			// 원의 생성자

    public double getArea() { 	// 원의 면적 계산 메소드
        return 3.14*radius*radius;
    }

    public static void main(String[] args) {
        Circle pizza; 
        pizza = new Circle(); 					// Circle 객체 생성
        pizza.radius = 10; 						// 피자의 반지름을 10으로 설정
        pizza.name = "자바피자"; 			// 피자의 이름 설정
        double area = pizza.getArea(); 		// 피자의 면적 알아내기
        System.out.println(pizza.name + "의 면적은 " + area);

        Circle donut = new Circle(); 		// Circle 객체 생성
        donut.radius = 2; 						// 도넛의 반지름을 2로 설정
        donut.name = "자바도넛"; 			// 도넛의 이름 설정
        area = donut.getArea(); 				// 도넛의 면적 알아내기
        System.out.println(donut.name + "의 면적은 " + area);
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-11.png" width="600"></p>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-12.png" width="600"></p>

`예제 4-2`
&ensp;너비와 높이를 입력 받아 사각형의 합을 출력하는 프로그램을 작성하라. 너비(width)와 높이(height) 필드, 그리고 면적 값을 제공하는 getArea() 메소드를 가진 Rectangle 클래스를 만들어 활용하라.<br/>

```java
import java.util.Scanner;

public class Rectangle {
    int width;
    int height;

    public int getArea() {
        return width*height;
    }

    public static void main(String[] args) {
        Rectangle rect = new Rectangle(); // 객체 생성
        Scanner scanner = new Scanner(System.in);
        System.out.print(">> ");

        rect.width = scanner.nextInt();
        rect.height = scanner.nextInt();

        System.out.println("사각형의 면적은 " + rect.getArea());

        scanner.close();
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-13.png" width="600"></p>

`예제 4-2`
&ensp;너비와 높이를 입력 받아 사각형의 합을 출력하는 프로그램을 작성하라. 너비(width)와 높이(height) 필드, 그리고 면적 값을 제공하는 getArea() 메소드를 가진 Rectangle 클래스를 만들어 활용하라. <br/>

```java
import java.util.Scanner;

public class Rectangle {
    int width;
    int height;

    public int getArea() {
        return width*height;
    }

    public static void main(String[] args) {
        Rectangle rect = new Rectangle(); // 객체 생성
        Scanner scanner = new Scanner(System.in);
        System.out.print(">> ");

        rect.width = scanner.nextInt();
        rect.height = scanner.nextInt();

        System.out.println("사각형의 면적은 " + rect.getArea());

        scanner.close();
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-14.png" width="600"></p>

생성자
=====

&ensp;객체가 생성될 때 초기화를 위해 실행되는 메소드<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-15.png" width="600"></p>

`예제 4-3`
&ensp;다음 코드는 2개의 생성자를 가진 Circle 클래스이다. 실행 결과는 무엇인가?<br/>

```java
public class Circle {
    int radius;
    String name;

    public Circle() { // 매개 변수 없는 생성자
        radius = 1; name = ""; // radius의 초기값은 1
    }
    public Circle(int r, String n) { // 매개 변수를 가진 생성자
        radius = r; name = n;
    }
    public double getArea() {
        return 3.14*radius*radius;
    }

    public static void main(String[] args) {
        Circle pizza = new Circle(10, "자바피자"); // Circle 객체 생성, 반지름 10

        double area = pizza.getArea();
        System.out.println(pizza.name + "의 면적은 " + area);

        Circle donut = new Circle(); // Circle 객체 생성, 반지름 1
        donut.name = "도넛피자";
        area = donut.getArea();
        System.out.println(donut.name + "의 면적은 " + area);
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-16.png" width="600"></p>

&ensp;생성자의 특징<br/>
* 생성자는 메소드
* 생성자 이름은 클래스 이름과 반드시 동일
* 생성자 여러 개작성 가능 (오버로딩) 
* 생성자는 new를 통해 객체를 생성할 때, 객체당 한 번 호출
* 생성자는 리턴 타입을 지정할 수 없음
* 생성자의 목적은 객체 초기화
* 생성자는 객체가 생성될 때 반드시 호출됨.
    - 그러므로 하나 이상 선언되어야 함
        + 개발자가 생성자를 작성하지 않았으면 컴파일러가 자동으로 기본 생성자 삽입
    
`예제 4-4`
&ensp;제목과 저자를 나타내는 title과 author 필드를 가진 Book 클래스를 작성하고, 생성자를 작성하여 필드를 초기화하라.<br/>

```java
public class Book {
    String title;
    String author;
    
    public Book(String t) { // 생성자
        title = t; author = "작자미상";
    }
    
    public Book(String t, String a) { // 생성자
        title = t; author = a;
    }
    
    public static void main(String [] args) {
        Book littlePrince = new Book("어린왕자", "생텍쥐페리"); 
        Book loveStory = new Book("춘향전"); 
        System.out.println(littlePrince.title + " " + littlePrince.author);
        System.out.println(loveStory.title + " " + loveStory.author);
    }
}
```
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-17.png" width="600"></p>

기본 생성자
----

&ensp;매개 변수 없고 아무 작업 없이 단순 리턴하는 생성자<br/>
&ensp;디폴트 생성자라고도 부름<br/>
&ensp;클래스에 생성자가 하나도 선언되지 않은 경우 컴파일러에 의해 자동으로 삽입<br/>

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-18.png" width="600"></p>

&ensp;기본 생성자가 자동 생성되지 않는 경우<br/>
* 개발자가 클래스에 생성자가 하나라도 작성한 경우
    - 기본 생성자 자동 삽입되지 않음

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-19.png" width="600"></p>

this 레퍼런스
=====

&ensp;객체 자신에 대한 레퍼런스
* 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
* this.멤버 형태로 멤버 사용

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-20.png" width="600"></p>

&ensp;this가 필요한 경우<br/>

* this의 필요성
    - 객체의 멤버 변수와 메소드 변수의 이름이 같은 경우
    - 다른 메소드 호출 시 객체 자신의 레퍼런스를 전달할 때
    - 메소드가 객체 자신의 레퍼런스를 반환할 때
    
&ensp;객체 속에서의 this<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-21.png" width="600"></p>

&ensp;this()로 다른 생성자 호출<br/>
* this()
- 클래스 내의 다른 생성자 호출
- 생성자 내에서만 사용 가능
- 반드시 생성자 코드의 제일 처음에 수행

&ensp;this() 사용 실패 예<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-22.png" width="600"></p>

`예제 4-5`
&ensp;예제 4-4에서 작성한 Book 클래스의 생성자를 this()를 이용하여 수정하라.<br/>
```java
public class Book {
    String title;
    String author;
    void show() { System.out.println(title + " " + author); }

    public Book() {
        this("", "");
        System.out.println("생성자 호출됨");
    }

    public Book(String title) {
        this(title, "작자미상");
    }

    public Book(String title, String author) {
        this.title = title; this.author = author;
    }
    public static void main(String [] args) {
        Book littlePrince = new Book("어린왕자", "생텍쥐페리");
        Book loveStory = new Book("춘향전");
        Book emptyBook = new Book();		
        loveStory.show();
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-23.png" width="600"></p>

&ensp;객체의 치환<br/>
* 객체의 치환은 객체가 복사되는 것이 아니며 레퍼런스가 복사된다.

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-24.png" width="600"></p>

&ensp;객체 배열<br/>
* 객체 배열 생성 및 사용

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-25.png" width="600"></p>

&ensp;객체 배열 선언과 생성 과정<br/>
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-26.png" width="600"></p>

`예제 4-6`
&ensp;반지름이 0~4인 Circle 객체 5개를 가지는 배열을 생성하고, 배열에 있는 모든 Circle 객체의 면적을 출력하라.<br/>
```java
class Circle {
    int radius;
    public Circle(int radius) {
        this.radius = radius;
    }
    public double getArea() {
        return 3.14*radius*radius;
    }
}
 
public class CircleArray {
    public static void main(String[] args) {
        Circle [] c; 
        c = new Circle[5]; 		

        for(int i=0; i<c.length; i++)
            c[i] = new Circle(i); 
 
        for(int i=0; i<c.length; i++) 
            System.out.print((int)(c[i].getArea()) + " ");
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-27.png" width="600"></p>

`예제 4-7`
&ensp;예제 4-4의 Book 클래스를 활용하여 2개짜리 Book 객체 배열을 만들고, 사용자로부터 책의 제목과 저자를 입력 받아 배열을 완성하라.<br/>
```java
import java.util.Scanner;
class Book {
    String title, author;
    public Book(String title, String author) { 
        this.title = title;
        this.author = author;
    }
}

public class BookArray {
    public static void main(String[] args) {
        Book [] book = new Book[2]; // Book 배열 선언

        Scanner scanner = new Scanner(System.in);
        for(int i=0; i<book.length; i++) {
            System.out.print("제목>>");
            String title = scanner.nextLine();
            System.out.print("저자>>");
            String author = scanner.nextLine();
            book[i] = new Book(title, author); // 배열 원소 객체 생성
        }

        for(int i=0; i<book.length; i++)
            System.out.print("(" + book[i].title + ", " + book[i].author + ")");

        scanner.close();
    }
}
```

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-28.png" width="600"></p>

메소드 형식
=====

* 매소드
    - 클래스의 멤버 함수, C/C++의 함수와 동일 
    - 자바의 모든 메소드는 반드시 클래스 안에 있어야 함(캡슐화 원칙)
* 메소드 구성 형식
    - 접근 지정자
        + public. private, protected, 디폴트(접근 지정자 생략된 경우)
    - 리턴 타입
        + 메소드가 반환하는 값의 데이터 타입
    
<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-29.png" width="600"></p>

인자 전달
----

* 자바의 인자 전달 방식
    - 경우 1. 기본 타입의 값 전달
        + 값이 복사되어 전달
        + 메소드의 매개변수가 변경되어도 호출한 실인자 값은 변경되지 않음
    - 경우 2. 객체 혹은 배열 전달
        + 객체나 배열의 레퍼런스만 전달(객체 혹은 배열이 통째로 복사되어 전달되는 것이 아님)
        + 메소드의 매개변수와 호출한 실인자 객체나 배열 공유
    
&ensp;인자 전달 – 기본 타입의 값이 전달되는 경우<br/>
* 매개변수가 byte, int, double 등 기본 타입의 값일 때
    - 호출자가 건네는 값이 매개변수에 복사되어 전달. 실인자 값은 변경되지 않음

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-30.png" width="600"></p>

&ensp;인자 전달 – 객체가 전달되는 경우<br/>
* 객체의 레퍼런스만 전달
    - 매개 변수가 실인자 객체 공유

<p align="center"><img src="/assets/img/문제해결 및 실습-Java/chapter4. 클래스와 객체/4-31.png" width="600"></p>