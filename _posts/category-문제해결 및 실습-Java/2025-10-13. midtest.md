---
title: "midtest"
excerpt: ""

writer: sohee Kim
categories:
  - 문제해결 및 실습-Java
tags:
  - Java

toc: true
use_math: true 
toc_sticky: true

date: 2025-10-13
last_modified_at: 2025-10-13
---

2024년도 문제
=====

`문제 1`
&ensp;PrintShop" 클래스는 특수문자(pChar)를 이용하여 지정된 줄 수(maxNum)만큼 반복(maxIter) 출력하는 프로그램이다. 각 줄 앞에는 공백(emptySpace)이 삽입되며 print()는 정방향, printReverse()는 역방향으로 출력한다.<br/>
&ensp;즉 삼각형 출력 패턴 문제<br/>

&ensp;요구 멤버 분석<br/>
| 멤버 변수 이름     | 의미             | 기본값 |
| ------------ | -------------- | --- |
| `emptySpace` | 줄 앞에 삽입할 공백 개수 | 0   |
| `pChar`      | 출력 문자          | `#` |
| `maxNum`     | 한 줄당 최대 출력 개수  | 3   |
| `maxIter`    | 전체 반복 횟수       | 2   |


&ensp;구현해야 할 기능 요약<br/>
| 메서드                           | 설명                                   |
| ----------------------------- | ------------------------------------ |
| `printBasic(int maxN)`        | 1 ~ maxN까지 증가하며 문자 출력                |
| `printBasicReverse(int maxN)` | maxN ~ 1까지 감소하며 문자 출력                |
| `print()`                     | `printBasic()`을 `maxIter`번 반복        |
| `printReverse()`              | `printBasicReverse()`를 `maxIter`번 반복 |


&ensp;정답 코드 예시<br/>
```java
package Num1;

import Util.ReadText;

class PrintShop {
    // 🔹 4개의 private 멤버
    private int emptySpace;   // 앞쪽 공백
    private String pChar;     // 출력 문자
    private int maxNum;       // 한 줄 최대 문자 수
    private int maxIter;      // 반복 횟수

    // 🔹 기본 생성자
    PrintShop() {
        emptySpace = 0;
        pChar = "#";
        maxNum = 3;
        maxIter = 2;
    }

    // 🔹 (1) 공백 개수만 지정
    PrintShop(int maxE) {
        emptySpace = maxE;
        pChar = "#";
        maxNum = 3;
        maxIter = 2;
    }

    // 🔹 (2) 공백 개수 + 문자 지정
    PrintShop(int maxE, String anotherChar) {
        emptySpace = maxE;
        pChar = anotherChar;
        maxNum = 3;
        maxIter = 2;
    }

    // 🔹 (3) 공백 + 문자 + 최대 출력 수 지정
    PrintShop(int maxE, String anotherChar, int mN) {
        emptySpace = maxE;
        pChar = anotherChar;
        maxNum = mN;
        maxIter = 2;
    }

    // 🔹 (4) 공백 + 문자 + 최대 출력 수 + 반복 횟수 지정
    PrintShop(int maxE, String anotherChar, int mN, int mI) {
        emptySpace = maxE;
        pChar = anotherChar;
        maxNum = mN;
        maxIter = mI;
    }

    // 🔹 1 → maxN까지 출력
    void printBasic(int maxN) {
        for (int i = 1; i <= maxN; i++) {
            for (int s = 0; s < emptySpace; s++)
                System.out.print(" "); // 앞쪽 공백
            for (int j = 0; j < i; j++)
                System.out.print(pChar);
            System.out.println();
        }
    }

    // 🔹 maxN → 1까지 출력
    void printBasicReverse(int maxN) {
        for (int i = maxN; i >= 1; i--) {
            for (int s = 0; s < emptySpace; s++)
                System.out.print(" ");
            for (int j = 0; j < i; j++)
                System.out.print(pChar);
            System.out.println();
        }
    }

    // 🔹 정방향 출력
    void print() {
        for (int i = 0; i < maxIter; i++) {
            printBasic(maxNum);
        }
        System.out.println("--------------------");
    }

    // 🔹 역방향 출력
    void printReverse() {
        for (int i = 0; i < maxIter; i++) {
            printBasicReverse(maxNum);
        }
        System.out.println("--------------------");
    }
}

public class JC01 {
    public static void main(String[] args) {
        ReadText rT = new ReadText("num1-1");
        String line = "";
        String tokens[];

        PrintShop p1;

        System.out.println("홍길동 23000000"); // <- 이름 / 학번

        while ((line = rT.readLine()) != null) {
            tokens = line.split(" ");
            switch (tokens.length) {
                case 1:
                    p1 = new PrintShop(Integer.parseInt(tokens[0]));
                    break;
                case 2:
                    p1 = new PrintShop(Integer.parseInt(tokens[0]), tokens[1]);
                    break;
                case 3:
                    p1 = new PrintShop(Integer.parseInt(tokens[0]), tokens[1], Integer.parseInt(tokens[2]));
                    break;
                case 4:
                    p1 = new PrintShop(Integer.parseInt(tokens[0]), tokens[1], Integer.parseInt(tokens[2]), Integer.parseInt(tokens[3]));
                    break;
                default:
                    p1 = new PrintShop();
                    break;
            }
            p1.print();
            p1.printReverse();
        }
    }
}
```

`문제 2`
&ensp;num1-2.txt 파일에는 여러 개의 정수가 주어집니다. 각 정수는 금액(원 단위)을 의미합니다. 이를 읽어와서, MoneyExchange 클래스를 이용해 다음을 수행하세요:<br/>
1. setAmount() : 금액을 설정한다.
2. getAmount() : 금액을 반환한다.
3. show() : 해당 금액을 10000원, 5000원, 1000원, 500원, 100원, 50원, 10원, 5원, 1원 단위로 나누어 출력한다.


&ensp;포인트<br/>
| 항목       | 내용                                               |
| -------- | ------------------------------------------------ |
| 핵심 개념    | 클래스, 생성자 오버로딩, private 멤버, getter/setter         |
| 연습 주제    | 금액을 화폐 단위별로 나누는 알고리즘                             |
| 파일 입력    | `ReadText("num1-2")` → `num1-2.txt` 파일에서 한 줄씩 읽음 |
| 수정 금지 영역 | `main()` 안의 while문 이후는 변경 금지                     |
| 작성 영역    | `MoneyExchange` 클래스 내부 4개 메서드                    |


```java
package Num2;

import Util.*;

class MoneyExchange {
	// 🔹 1. private 멤버 변수
	private int amount; // 현재 금액
	private int[] currency = {50000, 10000, 5000, 1000, 500, 100, 50, 10, 1};

	// 🔹 2. 기본 생성자
	MoneyExchange() {
		amount = 0;
	}

	// 🔹 3. 매개변수 있는 생성자
	MoneyExchange(int a) {
		amount = a;
	}

	// 🔹 4. 현재 금액 반환
	int getAmount() {
		return amount;
	}

	// 🔹 5. 현재 금액 설정
	void setAmount(int newA) {
		amount = newA;
	}

	// 🔹 6. 금액을 화폐 단위별로 출력
	void show() {
		int money = amount;

		for (int unit : currency) {
			int count = money / unit;
			System.out.println(unit + "원: " + count + "개");
			money %= unit;
		}
		System.out.println("--------------------");
	}
}

public class JC02 {
	public static void main(String[] args) {
		ReadText rT = new ReadText("num1-2");
		String line = "";
		String tokens[];

		MoneyExchange[] nx = new MoneyExchange[10];
		int i = 0;

		System.out.println("홍길동 23000000"); // ← 여기에 이름/학번 작성

		while ((line = rT.readLine()) != null) {
			tokens = line.split(" ");
			nx[i] = new MoneyExchange();
			nx[i].setAmount(Integer.parseInt(tokens[0]));
			System.out.println("#" + (i + 1) + " amount= " + nx[i].getAmount());
			nx[i].show();
			i++;
		}
	}
}
```

`문제 3`
&ensp;추상 클래스 Automobile을 설계하고 이를 상속받는 Sedan, SUV 클래스를 구현하라. 자동차의 주행거리, 연비, 연료량 변화를 계산하고 출력하는 프로그램이다.<br/>

&ensp;요구사항 정리<br/>
| 항목       | 설명                  |
| -------- | ------------------- |
| maker    | 제조사 이름              |
| model    | 모델 이름               |
| serialNo | 일련번호 (옵션, 자동 생성 가능) |
| tankSize | 연료탱크 용량 (리터)        |
| fuel     | 현재 남은 연료량 (리터)      |
| kilo     | 누적 주행 거리 (km)       |

&ensp;이 클래스는 직접 객체 생성 불가(abstract) → Sedan, SUV 가 상속해서 구현해야 함<br/>

&ensp;Sedan<br/>
| 항목         | 설명            |
| ---------- | ------------- |
| kmPerLiter | 1리터당 주행 가능 거리 |

&ensp;연비 기반으로 연료를 계산해 fuel 감소, kilo 증가<br/>
&ensp;50km씩 5번 반복 주행(running(50) → 5회)<br/>

&ensp;프로그램 동작 흐름<br/>
&ensp;Sedan 예시 입력<br/>
```markdown
S Hyundai Sonata 50 15
```

&ensp;→ 탱크용량 50L, 연비 15km/L<br/>
&ensp;→ 50km씩 5회 주행<br/>

&ensp;SUV 예시 입력<br/>
```nginx
V Kia Sorento 70 10 7
```

&ensp;→ 탱크용량 70L, 연비 10km/L, 좌석 7<br/>
&ensp;→ 50km씩 5회 주행, 연료소비량 20% 추가<br/>


```java
package Num3;
import Util.*;

abstract class Automobile {
    // 🔹 6개의 private 멤버
    private String maker;
    private String model;
    private double tankSize;
    private double fuel;
    private double kilo;
    private static int serialCounter = 1000; // 일련번호 자동 증가용
    private int serialNo;

    // 🔹 생성자
    Automobile(String maker, String model, double tank) {
        this.maker = maker;
        this.model = model;
        this.tankSize = tank;
        this.fuel = tank; // 처음엔 탱크가 가득 차 있음
        this.kilo = 0;
        this.serialNo = serialCounter++;
    }

    // 🔹 모델/제조사/탱크 정보 출력
    void showModelMakerTank() {
        System.out.println("Maker: " + maker + ", Model: " + model + ", Tank: " + tankSize + "L");
    }

    // 🔹 연료 상태 출력
    void showFuel() {
        System.out.printf("Remaining Fuel: %.2fL\n", fuel);
    }

    // 🔹 추상 메서드 (하위 클래스에서 구현)
    public abstract boolean running(double kM);

    // 🔹 Getter / Setter
    String getMaker() { return maker; }
    String getModel() { return model; }
    double getFuel() { return fuel; }
    void setFuel(double F) { fuel = F; }
    double getKilo() { return kilo; }
    void setKilo(double k) { kilo = k; }
}

// ===============================
// 🚗 Sedan 클래스
// ===============================
class Sedan extends Automobile {
    private double kmPerLiter; // 연비

    public Sedan(String maker, String model, double tank, double kP) {
        super(maker, model, tank);
        this.kmPerLiter = kP;
    }

    @Override
    public boolean running(double kM) {
        double usedFuel = kM / kmPerLiter;
        if (getFuel() >= usedFuel) {
            setFuel(getFuel() - usedFuel);
            setKilo(getKilo() + kM);
            return true;
        } else {
            System.out.println("⚠️ Not enough fuel to drive " + kM + "km");
            return false;
        }
    }

    void showAll() {
        showModelMakerTank();
        System.out.println("Type: Sedan, km/L = " + kmPerLiter);
    }
}

// ===============================
// 🚙 SUV 클래스
// ===============================
class SUV extends Automobile {
    private double kmPerLiter;
    private int numSeats;

    public SUV(String maker, String model, double tank, double kP, int nS) {
        super(maker, model, tank);
        this.kmPerLiter = kP;
        this.numSeats = nS;
    }

    @Override
    public boolean running(double kM) {
        double usedFuel = kM / kmPerLiter;
        if (numSeats > 5) usedFuel *= 1.2; // 20% 추가 연료소비

        if (getFuel() >= usedFuel) {
            setFuel(getFuel() - usedFuel);
            setKilo(getKilo() + kM);
            return true;
        } else {
            System.out.println("⚠️ Not enough fuel to drive " + kM + "km");
            return false;
        }
    }

    void showAll() {
        showModelMakerTank();
        System.out.println("Type: SUV, km/L = " + kmPerLiter + ", Seats = " + numSeats);
    }
}

public class JC03 {
    public static void main(String[] args) {
        ReadText rT = new ReadText("num1-3");
        String line = "";
        String tokens[];
        int i;

        System.out.println("홍길동 23000000");

        while ((line = rT.readLine()) != null) {
            tokens = line.split(" ");

            switch (tokens[0]) {
                case "S":
                    Sedan s1 = new Sedan(tokens[1], tokens[2],
                            Double.parseDouble(tokens[3]),
                            Double.parseDouble(tokens[4]));
                    s1.showAll();
                    for (i = 0; i < 5; i++) {
                        s1.running(50);
                        s1.showFuel();
                    }
                    break;
                case "V":
                    SUV s2 = new SUV(tokens[1], tokens[2],
                            Double.parseDouble(tokens[3]),
                            Double.parseDouble(tokens[4]),
                            Integer.parseInt(tokens[5]));
                    s2.showAll();
                    for (i = 0; i < 5; i++) {
                        s2.running(50);
                        s2.showFuel();
                    }
                    break;
                default:
                    break;
            }
        }
    }
}
```

&ensp;핵심 개념 요약<br/>
| 개념                | 설명                         |
| ----------------- | -------------------------- |
| `abstract class`  | 추상 클래스, 직접 객체 생성 불가        |
| `abstract method` | 하위 클래스에서 반드시 구현해야 함        |
| `super()`         | 상위 클래스 생성자 호출              |
| `@Override`       | 부모의 추상 메서드 재정의             |
| `연비 계산`           | `사용연료 = 주행거리 / kmPerLiter` |
| `SUV 추가조건`        | 좌석 5초과 시 `연료 * 1.2`        |


`문제 4`
&ensp;num1-41.txt 에는 상품 이름, 가격, 재고 수량이 저장되어 있다. num1-42.txt 에는 고객이 주문한 상품명과 주문 수량이 저장되어 있다. 프로그램은 파일을 읽어서 MartDB에 상품 정보를 저장하고 고객 주문을 처리하며 총 결제 금액을 출력해야 한다.<br/>

&ensp;클래스별 역할 요약<br/>
| 클래스      | 역할                     |
| -------- | ---------------------- |
| `Item`   | 상품 1개를 표현 (이름, 가격, 재고) |
| `MartDB` | 모든 상품을 HashMap으로 저장/관리 |
| `JC04`   | 실행부 (파일에서 주문 읽고 처리)    |


```java
package num4;

import Util.ReadText;

import java.util.HashMap;

class Item{

    private String name;
    private double price;
    private int num;

    public Item (String na, double p, int nn) {
        //your code
        this.name = na;
        this.price = p;
        this.num = nn;
    }

    public String getName() {   //get: 데이터를 가져오는 역할
        //your code
        return name;
    }
    public double getPrice() {
        //your code
        return price;
    }
    public int getNum() {
        //your code
        return num;
    }
    public void setNum(int nn) {   //데에터를 설정하는 역할
        //your code
        num = nn;
    }
}

class MartDB {
    // 1 private member with HashMap
    // mart item database in HashMap
    private HashMap<String, Item> martDB;   //키: 상품명(String), 값: Item 객체

    public MartDB () {
        //your code
        martDB = new HashMap<>();  // 1) 해시맵 생성

        ReadText rT = new ReadText("num1-41");  // 2) 주어진 유틸 클래스로 텍스트 파일을 한 줄씩 읽을 준비
        String line = "";
        String tokens[];
        Item iT;

        while ((line = rT.readLine()) != null) {   // 3) EOF까지 한 줄씩 읽기
            // your code
            tokens = line.split(" ");  // 3-1) 공백 분리 ["apple", "1200.0", "10"]
            String name = tokens[0];        // 3-2) 상품명
            double price = Double.parseDouble(tokens[1]);   // 3-4) 재고
            int num = Integer.parseInt(tokens[2]);      // 3-5) Item 객체 생성
            Item item = new Item(name, price, num);   // 3-6) 해시맵에 저장
            martDB.put(name, item);
        }

    }

    double getPrice(String name) {
        //your code
        if(martDB.containsKey(name)) {    // 상품명이 존재하면 가격
            return martDB.get(name).getPrice();
        }else{   // 없으면 0
            return 0;
        }
    }

    int getNumber(String name) {
        //your code
        if(martDB.containsKey(name)){   // 상품명이 존재하면 현재 재고 수량
            return martDB.get(name).getNum();
        }else{   // 없으면 0
            return 0;
        }
    }

    boolean sellItem(String name, int order) {
        //your code
        // if order is smaller or equal to the current stock, then reduce the current stock and return true
        // if order is larger than the current stock, return false.
        if(!martDB.containsKey(name)) return false;   // 0) 없는 상품이면 실패

        Item item = martDB.get(name);   // 1) 해당 삼품 객체
        int currentStock = item.getNum();  // 2) 현재 재고 조회
        if(order <= currentStock){   // 3) 주문 ≤ 재고 → 판매 가능
            item.setNum(currentStock - order);  // 3-1) 재고 감소(객체 내부 상태 변경)
            return true;               // 3-2) 성공
        }else{
            return false;              // 4) 재고 부족 → 실패
        }
    }
}


public class JC04 {

    public static void main(String[] args) {
        ReadText rT = new ReadText("num1-42");  // 주문 데이터
        String line = "";
        String tokens[];
        String name;
        int orders;
        double price, total;
        MartDB myM = new MartDB();


        // your name and student number
        System.out.println("23013240 Kim sohee");

        // do not change any source code from here!!
        total = 0;
        while ((line = rT.readLine()) != null) {
            tokens = line.split(" ");
            name = tokens[0];
            orders = Integer.parseInt(tokens[1]);

            price = myM.getPrice(name);

            if (myM.sellItem (name, orders)) {
                total = total + (price * orders);
                System.out.println("ordered item= "+name+" / each price= "+price+
                        " / ordered num= "+orders+" / remain= "+myM.getNumber(name));
            } else {
                System.out.println(name+" is out of stock!");
            }

        }

        System.out.println("[Total] "+total);
    }
}
```

25도 문제
====

`문제 1`
&ensp;이 문제는 PrintShop 클래스의 출력 패턴 제어 문제. 즉, 방향(forward / reverse)과 출력문자(pChar), 줄 길이(maxNum)를 읽어서 반복 출력<br/>


&ensp;파일 입력(num1.txt)<br/>
```markdown
forward # 3
reverse @ 5
forward $ 4
```

&ensp;실행 순서<br/>
```markdown
p1 = new PrintShop();
p1.myPrint();

→ 기본 생성자: direction = true (forward), pChar = "*", maxNum = 3
→ forward 방향으로 2번 반복 출력

그 다음 while문에서
forward # 3 → PrintShop("forward", "#", 3)
reverse @ 5 → PrintShop("reverse", "@", 5)
forward $ 4 → PrintShop("forward", "$", 4)
```

```java
package Num1;

import Util.*;

class PrintShop {
	private boolean direction = true;
	private String pChar;  // special character for output
	private int maxNum = 3;   // maximum lengh of a line
	final private int maxIter = 2;  // maximum iteration
	
	PrintShop() {
		pChar = "*";
	}
	
	PrintShop (String direct, String pC, int mN) {
		String forward = "forward";
		String reverse = "reverse";
		
		// your code
		if(direct.equals(forward)) {
			this.direction = true;
		};
		if(direct.equals(reverse)) {
			this.direction = false;
		}
		pChar = pC;
		maxNum = mN;
	}
	

	void printForward() {
		int i, j, k;

		// your code
		for(i = 1; i <= maxNum; i++) {
			for(j = 0; j < maxNum-i; j++){
				System.out.print(" ");
			}
			for(k = 0; k < i; k++){
				System.out.print(pChar);
			}
			System.out.println();
		}

	}
	
	void printReverse() {
		int j, k;
		
		// your code
		for(j = maxNum; j >= 1; j--) {
			for(k = 0; k < j; k++){
				System.out.print(pChar);
			}
			System.out.println();
		}
	}
	
	void myPrint() {
		boolean printDirection = direction;
		int i;
		
		// your code
		for(i = 0; i < maxIter; i++) {
			if(printDirection){
				printForward();
			}else{
				printReverse();
			}

			printDirection = !printDirection;  //방향 전환
		}
		
		System.out.println("--------------------");
	}
}

public class JC1 {
	public static void main(String[] args) {
		ReadText rT = new ReadText("num1");
		String line="";
		String tokens[];
		
		PrintShop p1;
		int i;
		
		//print your student number and English name !
		System.out.println("Student number and English name are here!\n");
		
		// DO NOT CHANGE THE CODES BELOW!
		// 아래의 코드는 절대로 수정하지 마세요!!!
		p1= new PrintShop();
		p1.myPrint();
		
		while ((line = rT.readLine()) != null) {
			tokens = line.split(" ");
			p1 = new PrintShop(tokens[0],tokens[1],Integer.parseInt(tokens[2]));
			p1.myPrint();
		}

		
	}

}
```

&ensp;출력 예시 (pChar = "#", maxNum = 4)<br/>

&ensp;printForward();<br/>
```shell
   #
  ##
 ###
####
```

&ensp;printReverse();<br/>
```shell
####
 ###
  ##
   #
```

&ensp;교수님 의도 정리<br/>
| 함수               | 선언 변수                      | 의미                | 비고                 |
| ---------------- | -------------------------- | ----------------- | ------------------ |
| `printForward()` | `int i, j, k;`             | i=줄 번호, j/k=출력 제어 | 3중 for문 가능         |
| `printReverse()` | `int j, k;`                | j=줄 번호, k=출력 제어   | 2중 for문            |
| 공통               | `System.out.print(pChar);` | 줄바꿈 없이 이어서 출력     | `println`은 한 줄 끝에만 |

`문제 2`
&ensp;2차원 배열 안에 Point 객체들을 저장하고 특정 두 점 사이의 유클리드 거리(Euclidean distance) 를 계산하는 문제<br/>
&ensp;프로그램 전체 흐름 요약<br/>
1. num2.txt에서 읽기
2. PointArray(row, column) 생성 → 내부에서 Point 객체들 초기화
3. showAll() → 모든 점 좌표 출력
4. getPoint(r, c)로 좌표 가져오기
5. getDistance()로 거리 계산 후 출력

&ensp;클래스별 역할 정리<br/>
| 클래스          | 역할                   |
| ------------ | -------------------- |
| `Point`      | x, y 좌표 한 점 표현       |
| `PointArray` | Point 객체 2차원 배열 관리   |
| `JC2`        | main — 입력 처리 및 전체 실행 |


```java
package Num2;

import Util.ReadText;

class Point {
	private double x, y;

	public Point(double x, double y) {
		// your code
		this.x = x;
		this.y = y;
	}
	public double getX() {
		// your code
		return x;
	}
	public double getY() {
		// your code
		return y;
	}
	protected void move(double x, double y) {
		// your code
		this.x = x;
		this.y = y;
	}
	void printPoint() {
		System.out.printf("(%4.2f , %4.2f)",x,y);
	}
	double getDistance (Point p2) {
		// distance between this point and p2 -> use Eclidean distance
		// distance = sqrt ( (x - p2.x)^2 + (y - p2.y)^2 )

		// your code
		double dx = this.x -p2.x;
		double dy = this.y - p2.y;
		return Math.sqrt(dx * dx + dy * dy);
	}
}

class PointArray {
	int row, column;
	Point mA[][];

	PointArray () {
		// your code
		//기본 5x5 배열 생성
		row = 5;
		column = 5;
		mA = new Point[row][column];

		for(int i = 0; i < row; i++){
			for(int j = 0; j < column; j++){
				mA[i][j] = new Point(Math.random()*10, Math.random()*10);  //0.0 이상 10.0 미만의 실수 좌표 (11을 곱하면 10.0까지)
			}
		}
	}

	PointArray (int r, int c) {
		// your code
		row = r;
		column = c;
		mA = new Point[row][column];
		for(int i = 0; i < row; i++){
			for(int j = 0; j < column; j++){
				mA[i][j] = new Point(Math.random()*10, Math.random()*10);
			}
		}
	}

	void reset() {
		// reset all Point to (random, random)

		// your code
		for(int i = 0 ; i < row; i++){
			for(int j = 0; j < column; j++){
				mA[i][j].move(Math.random()*10, Math.random()*10);
			}
		}
	}

	void showAll() {
		int i, j;

		// your code
		for(i = 0; i< row; i++){
			for(j = 0; j< column; j++){
				mA[i][j].printPoint();
				System.out.print(" ");
			}
			System.out.println();
		}
	}

	Point getPoint(int r, int c) {
		// your code
		return mA[r][c];
	}
}

public class JC2 {

	public static void main(String[] args) {
		ReadText rT = new ReadText("num2");
		String line = "";
		String tokens[];
		int i,j, row, column;
		double x,y;
		int x1, y1, x2, y2;
		double dist;
		PointArray m1, m2;


		// your name and student number
		System.out.println("your name and st number here");

		// do not change any source code from here!!
		line = rT.readLine();
		tokens = line.split(" ");
		row = Integer.parseInt(tokens[0]);
		column = Integer.parseInt(tokens[1]);

		m1 = new PointArray(row, column);
		m1.showAll();

		line = rT.readLine();
		tokens = line.split(" ");
		x1 = Integer.parseInt(tokens[0]);
		y1 = Integer.parseInt(tokens[1]);

		line = rT.readLine();
		tokens = line.split(" ");
		x2 = Integer.parseInt(tokens[0]);
		y2 = Integer.parseInt(tokens[1]);

		dist = m1.getPoint(x1,y1).getDistance(m1.getPoint(x2,y2));
		System.out.print("Distance between ");
		m1.getPoint(x1, y1).printPoint();
		System.out.print(" and ");
		m1.getPoint(x2,  y2).printPoint();
		System.out.println(" = "+dist);


	}
}
```

&ensp;주요 개념 정리<br/>
| 메서드              | 역할                 | 공식 / 포인트                |
| ---------------- | ------------------ | ----------------------- |
| `getDistance()`  | 두 점 사이 거리 계산       | √((x1-x2)² + (y1-y2)²)  |
| `move(x, y)`     | 점 이동               | this.x = x; this.y = y; |
| `showAll()`      | 2D 배열의 모든 좌표 출력    | 이중 for문                 |
| `getPoint(r, c)` | 특정 위치의 Point 반환    | `return mA[r][c];`      |
| `reset()`        | 배열의 모든 점을 랜덤으로 재설정 | `Math.random() * 10`    |


&ensp;암기 포인트 요약<br/>
| 구분    | 핵심 코드                                                      | 설명                   |
| ----- | ---------------------------------------------------------- | -------------------- |
| 거리 계산 | `Math.sqrt((x - p2.x)*(x - p2.x) + (y - p2.y)*(y - p2.y))` | 유클리드 거리              |
| 초기화   | `new Point(Math.random()*10, Math.random()*10)`            | 랜덤 좌표 생성             |
| 이동    | `move(double x, double y)`                                 | 좌표 재설정               |
| 배열 접근 | `mA[r][c]`                                                 | 이중 for문              |
| 출력    | `printPoint()`                                             | `(%4.2f , %4.2f)` 형식 |

`문제 3`
&ensp;추상 클래스 Automobile을 기반으로 Sedan과 Sports를 상속하여, 각각 연비(km/l)에 따라 주행과 연료 소모를 시뮬레이션하라.<br/>

&ensp;파일 구조<br/>
```scss
Automobile (추상 클래스)
│
├── Sedan (extends Automobile)
│
└── Sports (extends Sedan)
```

```java
package Num3;

import Util.ReadText;

abstract class Automobile {
    private String makerName; // maker name
    private String modelName; // model name
    private int serialNum; // serial number
    private double tankSize; // size of tank in liter
    private double remainingFuel; // remaining fuel in liter
    private double odometer; // accumulated running distance in kilo meter

    Automobile (String maker, String model, double tank) {
        // your code
        makerName = maker;
        modelName = model;
        tankSize = tank;
        remainingFuel = tank;
        odometer = 0;
    }

    void showModelMakerTank() {
        System.out.print(makerName+" "+modelName+" "+serialNum+" ["+tankSize+" liter]");
        //showFuel();

    }

    void showFuel() {
        System.out.println("fuel left= "+remainingFuel+" l / "+odometer+" kilo");
    }

    public abstract boolean running (double kM);

    String getMaker() {
        // your code
        return makerName;

    }
    String getModel() {
        // your code
        return modelName;
    }
    double getFuel() {
        // your code
        return remainingFuel;
    }
    void setFuel(double F) {
        // your code
        remainingFuel = F;
    }
    double getKilo() {
        // your code
        return odometer;
    }
    void setKilo(double k) {
        // your code
        odometer = k;
    }

}

class Sedan extends Automobile {
    private double kiloPerL;

    public Sedan (String m, String mM, double t, double kP) {
        // your code
        super(m, mM, t);
        this.kiloPerL = kP;
    }

    public boolean running(double kM) {
        // your code
        double fuelNeeded = kM / kiloPerL;  //주행에 필요한 연료
        double cF = getFuel();  //현재 연료량
        double cK = getKilo();  //현재 주행거리

        if(cF <  fuelNeeded) {
            System.out.println("Not enough fuel to drive" + kM + "km");
            return false;
        }else{  
            setFuel(fuelNeeded);
            setKilo(cK + kM);
            return true;
        }
    }

    void showAll() {
        // your code
        System.out.print("Sedan");
        showModelMakerTank();
        System.out.println(" "  + kiloPerL + "km/l");
    }

}

class Sports extends Sedan {
    private double kiloPerL;
    private int numCylinder;

    public Sports (String m, String mM, double tT, double kP, int cyl) {
        // your code
		super(m, mM, tT, kP);
        this.kiloPerL = kP;
        this.numCylinder = cyl;
    }

    public boolean running(double kM) {
        double cF = getFuel();  //현재 연료량
        double cK = getKilo();   //현재 주행거리
        double liter;  //주행에 필요한 연료량

        // your code
        //연비 보정(실린더 수가 많으면 연비 감소)
		double adjustedKPL = kiloPerL - (numCylinder * 0.1);
        if (adjustedKPL <= 0){
            adjustedKPL = 1;   //0이하 방지
        }

        liter = kM/adjustedKPL;
        if(cF <  liter){
            System.out.println("Not enough fuel to drive" + kM + "km");
            return false;
        }else{
            setFuel(cF - liter);
            setKilo(cK + kM);
            return true;
        }
    }

    void showAll() {
        System.out.print("[Sports] ");
        showModelMakerTank();
        System.out.print(" Cylinder= "+numCylinder);
        System.out.println();
    }
}

public class JC3 {

    public static void main(String[] args) {
        ReadText rT = new ReadText("num3");
        String line="";
        String tokens[];
        int i;

        // your name and student number
        System.out.println("your name and st number here");

        // do not change any source code from here!!
        while ((line = rT.readLine()) != null) {
            tokens = line.split(" ");

            switch (tokens[0]) {
                case "S" :
                    Sedan s1 = new Sedan(tokens[1],tokens[2], Double.parseDouble(tokens[3]),
                            Double.parseDouble(tokens[4]));
                    s1.showAll();
                    for (i=0; i < 5; i ++) {
                        s1.running(50);
                        s1.showFuel();
                    }
                    break;
                case "P" :
                    Sports s2 = new Sports(tokens[1], tokens[2], Double.parseDouble(tokens[3]),
                            Double.parseDouble(tokens[4]), Integer.parseInt(tokens[5]) );
                    s2.showAll();
                    for (i=0; i < 5; i ++) {
                        s2.running(50);
                        s2.showFuel();
                    }
                    break;
                default :
                    break;
            }

        }

    }

}
```

&ensp;두 클래스 차이 요약표<br/>
| 항목       | Sedan                         | Sports                         |
| -------- | ----------------------------- | ------------------------------ |
| 상속       | `extends Automobile`          | `extends Sedan`                |
| 연비 변수    | `kiloPerL`                    | `kiloPerL` (별도 선언, 재정의 가능)     |
| 연비 보정    | 없음                            | `kiloPerL - numCylinder * 0.1` |
| 필요한 연료   | `fuelNeeded = kM / kiloPerL`  | `liter = kM / adjustedKPL`     |
| 실린더 수    | 사용 안 함                        | 연비 계산에 반영                      |
| 연료 부족 처리 | `if (cF < fuelNeeded)`        | `if (cF < liter)`              |
| 공통점      | 연료 차감, 거리 증가, boolean 반환      | 완전히 동일                         |
| 반환값      | `true` (성공) / `false` (연료 부족) | 동일                             |

&ensp;문제 3번 구조 흐름도<br/>
```markdown
┌───────────────────────────┐
│        Automobile         │   ← abstract class (추상 클래스)
├───────────────────────────┤
│ - makerName:String        │
│ - modelName:String        │
│ - serialNum:int           │
│ - tankSize:double         │
│ - remainingFuel:double    │
│ - odometer:double         │
├───────────────────────────┤
│ + Automobile(String,String,double) │
│ + showModelMakerTank()   │
│ + showFuel()             │
│ + getMaker(), getModel() │
│ + getFuel(), setFuel()   │
│ + getKilo(), setKilo()   │
│ + abstract running(double)│ ← 반드시 자식 클래스가 구현
└───────────────────────────┘
                ▲
                │
     ┌──────────┴──────────┐
     │                     │
┌──────────────┐     ┌────────────────┐
│    Sedan     │     │     Sports     │
├──────────────┤     ├────────────────┤
│ - kiloPerL   │     │ - kiloPerL     │
│              │     │ - numCylinder  │
├──────────────┤     ├────────────────┤
│ + Sedan(m, mM, t, kP)   │  + Sports(m, mM, t, kP, cyl)
│ + running(double)       │  + running(double) (오버라이드)
│ + showAll()             │  + showAll()
└──────────────┘     └────────────────┘
```

