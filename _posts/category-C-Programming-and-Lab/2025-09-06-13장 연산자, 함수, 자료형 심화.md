---
title: "13장 연산자/함수/자료형 심화"
excerpt: ""

wirter: sohee Kim
categories:
  - C Programming and Lab
tags:
  - C

toc: true
toc_sticky: true

date: 2025-09-06
last_modified_at: 2025-09-06
---

비트연산자
=====

&ensp;2진수와16진수<br/>
* 컴퓨터의 기본 정보단위는 bit와 byte로 표현
* 2진수, 16진수표기가편리한경우가있음
    - 1 bit -> 2진수 한 자리
    - 1 byte -> 16진수 두 자리
* 2진수

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-1.png" width="600"></p>

* 16진수

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-2.png" width="600"></p>

&ensp;2진수와16진수의관계<br/>
* 2진수 4자리 = 16진수 1자리

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-3.png" width="600"></p>

&ensp;비트 연산<br/>
* 비트 단위로 처리되는 연산
* 비트 1은 참, 비트 0은 거짓을 의미
* 예: 두 이진수의 비트 단위 논리곱(bitwise AND)
    - 해당 자리의 비트가 모두 1인 경우에만 참

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-4.png" width="600"></p>

* 비트 연산의 종류
    - 비트 단위 논리 연산
    - 비트 단위 이동 연산

&ensp;비트 단위 논리 연산<br/>
* 예: 비트 AND 연산자: x & y
    - 두 정수 x와 y의 비트단위 논리곱
* 비트 연산을 할 때는 16진수로 표현하는 것이 이해하기 쉬움

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-5.png" width="600"></p>

&ensp;C언어비트연산자(논리연산)<br/>
<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-6.png" width="600"></p>

&ensp;비트 단위 이동 연산<br/>
* 예: 왼쪽 이동 연산자: x << k
    - x를 비트 단위로 왼쪽으로 k만큼 이동
    - 오른쪽 빈 자리는 k개의 0으로 채움

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-7.png" width="600"></p>

&ensp;C언어 비트 연산자(이동 연산)<br/>
<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-8.png" width="600"></p>

&ensp;비트 연산의 피연산자<br/>
* 피연산자는 정수형(char, int, long 등)에 대해서만 연산 가능
* 특별한 이유가 없으면 unsigned 정수 사용
    - 이동 연산에서 빈 자리는 0으로 채우는 것이 기본이지만 signed 정수는 1로 채워지는 경우도 있음(표준은 아님)

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-9.png" width="600"></p>

&ensp;어떤 정수N을 이진수로 표기했을때, 오른쪽에서 10번째 자리의 비트값을 출력(비트연산의 응용)<br/>

* 가장 오른쪽 비트를 0번째 비트라고 가정

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-10.png" width="600"></p>

재귀함수
=====

&ensp;함수 호출과 반환<br/>
* 다음 프로그램의 함수 호출과 반환 과정은?

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-11.png" width="600"></p>
<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-12.png" width="600"></p>

&ensp;다음 프로그램은 정상적인 프로그램일까?<br/> 
&ensp;dec(?)함수에서 자기를 다시호출한다??<br/>
&ensp;그럼 현재수행중이던 dec(?) 함수는 어떻게되는거지?<br/>
&ensp;놀랍게도 정상적으로 컴파일되고 실행도 된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-13.png" width="600"></p>

&ensp;함수 호출 과정 들여다보기<br/>
* 아래 두 그림 중 어느 것이 print() 함수의 호출 과정을 더 정확하게 표현한 것일까?

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-14.png" width="600"></p>

&ensp;재귀 함수 호출 과정<br/>
* 이전 프로그램의 함수 호출 과정을 그림으로 표현하면?

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-15.png" width="600"></p>

* 동작 과정을 파악을 위해 함수의 시작과 끝에 출력문 삽입

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-16.png" width="600"></p>

&ensp;함수 정의와 호출의 의미<br/>
* 함수 정의는 틀에 해당하고 호출이 되어야 실체를 가짐

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-17.png" width="600"></p>

&ensp;재귀함수<br/>
* 함수 내부에서 자기와 동일한 (이름의) 함수를 호출하는 함수
* 유사 개념: 점화식
    - $A_n = A_{n-1} + 2$ (등차 수열의 점화식)
    - A: 함수 이름에 해당
    - 첨자 n: 함수 인자에 해당

&ensp;주의사항: 재귀 호출의 종료 조건이 없으면 제대로 동작하지 않음<br/>
* 점화식에서 초기항이 없으면 정의되지 않는 것처럼 $A_n = A_{n-1} + 2, A_1 = 1$

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-18.png" width="600"></p>

&ensp;재귀함수를 사용하여 1부터 n까지의 합 계산<br/>
* sum(n) = 1+2+3+ … + (n-1) + n을 점화식으로 표현하면?
    - sum(n) = sum(n-1) + n (n > 1 인 경우)
    - sum(1) = 1; (n==1 인 경우)

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-19.png" width="600"></p>

&ensp;재귀함수를 이용하여 n!을 계산하는 프로그램을 작성하라.<br/>

* n! = n * (n-1) * (n-2) * … * 2 * 1
* 점화식으로 표현하면  
    - n! = n*(n-1)! (n > 1 인 경우)
    - 1! = 1; (n==1 인경우)

라이브러리 활용
=====

&ensp;난수(random number) 생성<br/>
* 난수: 정의된 범위 내에서 임의로 추출되는 수
* C언어에서는 난수를 생성하는 함수 제공
* 관련 함수: rand(), srand(), time()

* rand( ) 함수: <stdlib.h>에 선언되어 있음
    -  0~RAND_MAX 사이의 임의의 수 리턴
    -  RAND_MAX는 stdlib.h에 정의된 상수(32767)

```c
#include <stdio.h>
#include <stdlib.h>// rand 함수 사용을 위해

int main() {
    int i;
    for( i=0 ; i < 5 ; ++i) // 5개의 난수 생성
        printf(" %d", rand() );
    return 0;
}
```

* srand( ) 함수: <stdlib.h>에 선언되어 있음
    - rand() 함수의 시드(seed) 변경

```c
#include <stdio.h>
#include <stdlib.h>// rand 함수 사용을 위해

int main() {
    int i;
    srand( 10 ); // 시드를 10으로 지정
    for( i=0 ; i < 5 ; ++i) // 5개의 난수 생성
        printf(" %d", rand() );
    return 0;
}
```

* time( ) 함수: <time.h>에 선언되어 있음
    - 현재 시스템의 시간에 의해 결정되는 정수 리턴
    - 실행할 때마다 시드를 바꾸기 위해서 사용

```c
#include <stdio.h>
#include <stdlib.h>// rand 함수 사용을 위해
#include <time.h> // time 함수 사용을 위해

int main() {
    int i;
    srand( time(NULL) );   // 시드를 현재시간으로 지정
    for( i=0 ; i < 5 ; ++i) // 5개의 난수 생성
        printf(" %d", rand() );
    return 0;
}
```

&ensp;실행할 때마다 결과가 달라짐<br/>

&ensp;\[min, max\) 사이의난수하나생성하기<br/>
* % 연산자를 사용하는 방식보다 아래 방식 권장

<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-20.png" width="600"></p>
<p align="center"><img src="/assets/img/C Progrmming and Lab/13장 연산자,함수,자료형 심화/13-21.png" width="600"></p>

* rand(): 0~RAND_MAX 사이의 임의의 정수 생성
* /((double)RAND_MAX + 1): 생성된 정수를 \[0, 1\) 사이의 소수로 변환
* (max-min) : \[0,1\) 사이의 소수를 \[0,max-min\) 사이의 값으로 변환
* +min: 수를 min만큼 이동시켜 \[min, max\)사이의 수로 변환 

&ensp;실행 시간 측정<br/>
* C언어에서는 제공되는 시간 관련 함수를 사용하여 프로그램이 실행되는데 필요한 시간을 측정할 수 있음
* 관련 함수: clock()
* clock( ) 함수사용: <time.h>에 선언되어 있음
    - 호출 당시의 시스템 시각을 CLOCKS_PER_SEC(time.h에 정의된 상수) 단위로 반환
    - 초 단위의 시간을 얻기 위해서는 clock() 함수에 의해 측정된 시각을 CLOCKS_PER_SEC로 나누어야 함

&ensp;실행 시간 측정 코드<br/>
```c
#include <stdio.h>
#include <time.h>  // clock() 함수 사용을 위해

int main( void ) {
    clock_t start, finish; 
    double duration; 

    start = clock();   //시작 시각
    ....               //수행시간을 측정하고 하는 코드
    finish = clock();  //종료 시각

    duration = (double)(finish-start) / CLOCKS_PER_SEC;

    printf("실행 시간: %lf 초\n", duration);
    return;
}
```