---
title: "12장 동적 할당"
excerpt: ""

wirter: sohee Kim
categories:
  - C Programming and Lab
tags:
  - C

toc: true
toc_sticky: true

date: 2025-07-17
last_modified_at: 2025-07-17
---

동적 할당 개요
======

&ensp;프로그램에서 값을 저장하기 위해 필요한 기억 장소를 확보하는 것을 메모리 할당이라고 한다. 할당 방식에 따라 정적(static) 메모리 할당 과 동적(dynamic) 메모리 할당 두 가지로 구분된다.<br/>

&ensp;프로그램에 필요한 기억 장소를 확보하기 위해 지금까지 사용한 방식은 변수를 선언하는 것이었다.  변수를 선언하면 자료형에 따라 메모리 크기가 정해지고 선언된 변수에 할당되는 메모리 크기는 프로그램이 실행할 때마다 일정하다. 이 경우 메모리의 크기는 프로그램이 시작하기 전에 결정되며 프로그램의 실행 도중에 크기가 변경될 수 없다. <br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-1.JPEG" width="600"></p>

&ensp;정적 할당에서는 프로그램 작성 단계에서 필요한 메모리 크기가 얼마인지 미리 알아야 하고 크기를 정확히 알 수 없는 경우에는 충분히 큰 크기를 가정해서 선언해야 한다. 정적 할당은 아주 간단하게 메모리를 할당할 수 있지만 경우에 따라 비효율적일 수 있다. 예를 들어 100개의 성적을 저장할 수 있는 공간을 할당하고 있다. 하지만 처리해야하는 성적의 개수가 200개라면 전부 처리할 수 없을 것이다. 반대로 항상 30개 정도의 성적만 입력된다면 70개를 저장할 수 있는 공간은 낭비될 것이다.<br/>

&ensp;이러한 문제를 해결하기 위해 C 언어에서는 프로그램 작성 단계가 아니라 프로그램 실행 단계에서 결정되는 크기에 따라 메모리를 할당하는 방식인 동적 할당을 제공한다. 동적 할당을 활용하면 상황에 따라 필요한 만큼의 메모리를 할당받을 수 있어 유연한 프로그램을 작성하는 것이 가능하다.<br/>

동적 메모리 사용 절차
======

&ensp;메모리를 사용하기 위해서는 메모리를 할당하고 해제하는 과정이 필요하다. 정적 할당에서는 프로그램 실행 시에 미리 정해 놓은 크기만큼 메모리를 할당하고 더 이상 필요 없는 메모리는 해제하는데 이 과정이 프로그램과 함수의 실행 및 종료에 따라 자동으로 수행되어 프로그래머가 메모리 할당 및 해제를 특별히 신셩 쓰지 않아도 된다. 하지만 동적 할당에서는 메모리를 할당하고 해제하는 과정을 프로그래머가 직접 조작해야 한다.<br/>

&ensp;동적 메모리를 사용하는 절차는 세 단계로 구성된다. 우선 malloc() 함수를 이요하여 메모리를 할당 받고 포인터 변수를 이용하여 할당받는 메모리에 접근한다. free() 함수는 동적 할당 받은 메모리를 해제(반납)한다. 동적 할당을 사용하기 위해서는 위 두 함수가 선언되어 있는 stdlib.h 헤더 파일을 포함해야 한다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-2.JPEG" width="600"></p>

```cpp
#include <stdlib.h>   //동적 메모리 관련 함수 사용을 위한 헤더

int main(){  //동적 메모리 접근을 위한 포인터 변수
  int *p = NULL;  //동적 메모리 접근을 위한 포인터 변수
  p = (int *)malloc(5*sizeof(int)); //동적 메모리 할당

  p[0] = 1;  //동적 메모리 사용: 배열 형태
  *(p+2) = 3;   //동적 메모리 사용: 포인터 형태

  free(p);   //동적 메모리 해제
  return 0;
}
```

동적 메모리 할당 
------

&ensp;malloc() 함수는 메모리 할당(memory allocatoin)을 하는 함수이다. 인자로 할당할 메모리의 크기가 바이트 단위로 주어지는데 보통 sizeof() 연산자가 사용된다. malloc() 는 할당된 메모리의 시작 주소를 반환하는데 할당된 메모리가 어떤 자료형으로 사용될지 모르므로 void * (void 포인터) 형으로 반환된다. void 포인터는 특정 자료형을 나타내지 않는 주소를 의미하는 것이다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-3.JPEG" width="600"></p>

동적 메모리 사용
------

&ensp;동적 메모리는 몇 개가 필요할지 프로그램 작성 단계에서는 알 수 없기 때문에 변수 이름을 붙이는 것이 불가능하다. 그래서 포인터 변수를 이용하여 간접적으로 참조하게 된다. malloc() 함수가 할당된 메모리의 시작 주소를 반환하므로 이를 포인터 변수에 대입하고 이후에 이 포인터 변수를 이용하여 동적으로 할당받은 메모리에 접근한다.<br/>
&ensp;malloc() 함수는 할당된 메모리를 어떤 자료형으로 사용할지 모르기 때문에 void * 형을 반환하므로 이를 사용하고자 하는 자료형의 포인터로 명시적으로 형변환을 해주어야 한다.<br/>
&ensp;우선 할당된 공간을 사용하고자 하는 자료형으로 포인터 변수를 선언한다. 다음 malloc() 함수를 호출하여 메모리를 할당 받고 이를 사용하고자 하는 자료형으로 변환을 하여 앞서 선언한 포인터 변수에 대입한다. 물론 변수 선언과 동시에 malloc() 함수를 호출하여 주소를 대입할 수도 있다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-4.JPEG" width="600"></p>

* 동적 할당된 메모리 사용 예시

```cpp
int *p = (int *)malloc(10*sizeof(int));  //변수 선언과 동시에 동적 할당된 주소 대입

p[0] = 1;  //*p = 1; 과 동일
*(p + 2) =3  //p[2] = 3; 과 동일
```

동적 메모리 해제
------

&ensp;정적 할당된 변수는 자동으로 메모리가 해제되지만 동적 할당된 메모리는 자동으로 해제되지 않기 때문에 더 이상 할당받은 메모리를 사용할 필요가 없는 경우 프로그래머가 명시적으로 해제를 시켜줘야 한다.<br/>
&ensp;동적 메모리 해제는 아래와 같이 free() 함수를 이용한다. free() 함수는 인자로 받은 메모리의 시작 주소로 할당받은 공간을 해제한다. 이 때 할당 받은 메모리가 해제되는 것이지 포인터 변수가 해제되는 것이 아니다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-5.JPEG" width="600"></p>

&ensp;메모리 해제를 제대로 해주지 않으면 메모리 누수(memory leak)가 발생한다. memory leak는 프로그램이 실제로 사용하지 않는 메모리를 계속 점유하고 있는 현상의 의미하는데 간단한 프로그램에서는 크게 문제가 되지 않지만 서버 프로그램과 같이 오랫동안 실행되는 프로그램에서는 메모리 누수가 발생하면 실제로 사용하지 않은 메모리가 많지만 할당 가능한 메모리는 부족하게 되어 문제가 발생할 수 있다.<br/>

동적 메모리를 안전하게 사용하기 위한 주의사항
------

&ensp;1. 동적 메모리를 할당 받기 전과 해제한 후 포인터 변수에 NULL을 대입하여 메모리 접근 오류를 방지<br/>
  - 특히 free() 함수 호출 이후에 포인터 변수는 여전히 메모리가 해제된 영역을 가리키고 있는데 이를 댕글링 포인터(dangling pointer)라 부른다. 댕글링 포인터는 메모리 접근 오류를 발생시키므로 포인터 변수에 NULL을 대입해서 방지해야 한다.

```cpp
int *p = NULL;  //포인터 변수 선언 시 NULL로 초기화
p = (int *)malloc(10*sizeof(int));

free(p);   //함수 호출 후 포인터 변수 p 는 댕글링 포인터
p = NULL;  //메모리 해제 후 NULL 대입(댕글링 포인터 방지)
```
&ensp;2. malloc() 함수를 호출한 후에는 그 반환 값을 검사하여 메모리 할당의 성공 여부를 확인<br/>
  - 규모가 큰 프로그램을 작성하다보면 시스템의 메모리가 부족하여 동적 할당을 실행하는 경우가 있다. 이 경우 malloc() 함수는 NULL을 반환하므로 아래와 같이 malloc() 의 반환 값이 NULL인 경우 적절한 조치를 취해야 한다.

```cpp
int *p = NULL;
p = (int *)malloc(10*sizeof(int));

if(p == NULL){    //메모리 할당 실패하면 오류 상황 알리고 함수 종류
  printf("NOt enough memory!");   
  return -1;
}
```

&ensp;3. 해제하려는 메모리 주소가 NULL인지 점검<br/>

```cpp
int *p = NULL;
p = (int *)malloc(10 * sizeof(int));

if(p != NULL)   //p가 NULL이 아닌 경우에만 free() 함수 호출
  free(p);   
```

&ensp;4. 포인터 변수와 동적 메모리의 관계를 정확히 이해<br/>
  - 포인터 변수는 동적 할당한 공간과는 별개의 메모리 공간을 가진다.

동적 메모리 사용 예제
=======

&ensp;메모리를 동적 할당 받아 사용하는 기본 프로그램<br/>
&ensp;malloc() 함수를 이용해 메모리를 동적 할당받아 포인터 변수에 연결하여 사용하고 사용이 끝나면 free() 함수를 이용해 메모리를 해제한다.<br/>

```java
#include <stdio.h>
#include <stdlih.h>   //동적 할당 함수가 선언된 헤더 파일

int main(){
  int *p = NULL;   //포인터 변수 선언
  p = (int *)malloc(sizeof(int));  //동적 할당
  if(p == NULL){    //동적 할당 오류 검사
    printf("Not enough memory!");
    return -1;
  }

  *p = 15;   //동적 할당 메모리에 값 저장
  printf("동적 메모리 할당 (정수형): %d", *p);
  free(p);
  
  return 0;
}
```

&ensp;2. 일차원 배열을 동적 할당 받아 사용하는 프로그램<br/>
&ensp;여러 개의 정수를 저장하는 메모리를 동적 할당 받아 사용하는 예제이다. 동적 메모리를 사용하기 위해 선언한 포인터 변수를 일반 배열명처럼 사용한다.<br/>
1. 프로그램 실행 중에 사용자로부터 과목 수 n을 직접 입력 받음
2. n개의 정수형 값을 저장할 수 있는 메모리를 동적으로 할당 받아 할당 받은 메모리의 시작 주소를 score에 저장
3. 할당 받은 메모리를 score[0] ~ score[n-1]까지 일반 배열 원소처럼 참조하여 사용
4. 할당 받은 메모리 해제

```java
#include <stdio.h>
#include <stdlih.h>

int main(){
  int n, i, sum = 0;
  int *score = NULL;

  scanf("%d", &n);   //1. 과목 수 입력 받긷

  score = (int *)malloc(n*sizeof(int));   //2. 배열 동적 할당
  if(score == NULL){                      //동적 할당 오류 검사
    printf("Not enough momory!");
    return -1;
  }

  for(i = 0; i < n; i++){
    scanf("%d", &score[i]);    //3. 과목별 점수 입력받기
    sum += score[i];           //누적 합 계산
  }

  printf("%.1f", (double)sum/n)  //평균 계산

  free(score);   //4. 동적 할당 메모리 해제
  return 0;
}
```

&ensp;3. 동적 메모리 할당을 사용한 문자열 처리 프로그램<br/>
&ensp;길이가 다른 여러 개의 문자열을 효율적으로 저장하기 위해서 다음과 같은 방식으로 동적 메모리 할당을 이용한다.<br/>
1. 문자열을 입력 받기 위한 충분한 크기의 문자 배열을 선언(정적 할당)
2. 1의 문자 배열에 문자열을 입력 받음
3. 2에서 입력된 문자열의 길이를 계산하여 그 크기에 맞게 메모리를 동적으로 할당 받음(널 문자 포함)
4. 할당 받은 메모리 공간에 1의 문자 배열의 문자열을 복사함

&ensp;다음은 사용자로부터 책의 개수 n을 입력받아 n개의 책 제목을 저장하는 프로그램으로 위에서 설명한 절차대로 책 제목을 동적 할당 받은 배열에 저장한다.<br/>

```c
typedef struct book_title{
  char *title;
} BINFO;

int main(){
  BINFO * bp = NULL;
  int n, i, len;
  char temp[100];   //1. 문자열을 입력 받기 위한 문자 배열을 선언

  scanf("%d", &n);   //책 개수 입력
  getchar();         //개행 문자 버리기

  bp = (BINFO *)malloc(n*sizeof(BINFO));   //책 배열 동적 할당
  if(bp == NULL){   }  //동적 할당 오류 검사(생략)

  for(i = 0; i < n; i++){
    gets(temp);   //2. 문자 배열 temp에 문자열을 입력 받음

    //3. temp에 입력된 문자열 길이를 계산하고
    //그 크기만큼 메모리를 동적으로 할당 받음(널 문자 포함)
    len = strlen(temp);
    bp[i].title = (char *)malloc((len+1)*sizeof(char));

    if(bp[i].title == NULL){   }  //동적 할당 오류 검사(생략)
    strcpy(bp[i].title, temp);    //4. 할당 받은 메모리에 제목 복사
  }

  for(i = 0; i < n; i++){
    printf("%s\n", bp[i].title);   //책 제목 출력
  }

  for(i = 0; i < n; i++)
    free(bp[i].title);    //문자 배열에 대한 메모리 해제

  free(bp);    //책 배열에 대한 메모리 해제
  return 0;
}
``` 

&ensp;4. 동적 메모리 할당을 사용하여 2차원 배열 할당하는 프로그램<br/>
&ensp;2차원 배열을 동적 할당하기 위해서는 포인터 배열을 사용해 다음과 같은 형태로 할당을 해야 한다.<br/>

```java
int main(){
  int i;
  char **pch;
  pch = (char **)malloc(3*sizeof(char *));  //포인터 배열 할당

  for(i = 0; i < 3; i++)
    pch[i] = (char *)malloc(4 * sizeof(char));   //1차원 배열 할당

  strcpy(pch[0], "aaa");
  strcpy(pch[1], "bbb"); 
  pch[2][0] = '\0';  //2차원 배열처럼 사용

  for(i = 0; i < 3; i++)
    puts(pch[i]);

  for(i = 0; i < 3; i++)
    free(pch[i]);    //1차원 배열에 대한 메모리 해제
  
  free(pch);     //포인터 배열에 대한 메모리 해제
}
```

<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-6.JPEG" width="600"></p>

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include <stdlib.h>
#include <math.h>


int main() {
	
	int n;
	scanf("%d", &n);
	getchar();


// 동적할당: N개의 문자열 포인터
	char** p;  // p는 문자 포인트들(char *)의 배열을 가리키는 이중 포인터
	p = (char**)malloc(n * sizeof(char*)); 

	for (int i = 0; i < n; i++) {
		p[i] = (char*)malloc(101 * sizeof(char));  // p[i]는 문자열(문자 배열)을 가리키는 포인터, malloc으로 새로 확보된 공간(101바이트 크기의 배열)을 가리키는 포인터(sizeof(p[i])은 p[i] 변수 자체의 타입 크기. 즉 p[i]의 타입이 char *이므로 8바이트를 반환)
	}

	int idx = 0;
	int len = 0;
	int min = 101;
	for (int i = 0; i < n; i++) {
		fgets(p[i], 101, stdin);
		if (p[i][strlen(p[i])-1] == '\n') {
			p[i][strlen(p[i])-1] = '\0';
		}

		len = strlen(p[i]);
    // 가장 짧은 문자열 찾기
		if (min > len) {
			min = len;
			idx = i;
		}
	}

	printf("%s", p[idx]);

// 메모리 해제
	for (int i = 0; i < n; i++) {
		free(p[i]);
	}
	free(p);

	return 0;
}
```

| 표현                           | 의미              | 실제 값(64비트 기준) |
| ---------------------------- | --------------- | ------------- |
| `sizeof(p)`                  | char** 포인터의 크기  | 8             |
| `sizeof(p[i])`               | char* 포인터의 크기   | 8             |
| `sizeof(*p[i])`              | char 타입의 크기     | 1             |
| `malloc(101 * sizeof(char))` | 101바이트 메모리 동적할당 | 101           |
| `fgets(p[i], 101, stdin)`    | 안전하게 100글자 읽기   | ✅ 정답          |

&ensp;2차원 정수 배열도 동일한 방법을 동적 할당받아 사용할 수 있다.<br/>

* 2차원 int 배열 동적 할당

```java
int **pa;
pa = (int **)malloc(row * sizeof(int *));    //정수 포인터 배열 할당
for(i = 0; i < row; i++)
  pa[i] = (int *)malloc(col * sizeof(int));   //1차원 정수 배열 할당

pa[1][3] = 10;    //원소 접근

for(i = 0; i < row; i++)
  free(pa[i]);     //1차원 정수 배열 해제
free(pa);    //정수 포인터 배열 해제
```

기타 동적 메모리 할당 함수
======

&ensp;malloc() 함수 이외에도 동적 메모리 할당하는 함수로 calloc() 함수의 realloc() 함수가 있다.<br/>

calloc() 함수
------

&ensp;calloc() 함수는 malloc() 함수와 비슷하게 메모리를 할당해주는 함수인데 인자가 조금 다르고 할당 받은 메모리 공간을 0으로 초기화 해주는 차이가 있다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-7.JPEG" width="600"></p>

realloc() 함수
------

&ensp;realloc() 함수는 할당 받은 메모리 공간의 크기를 변경하고자 할 때 사용한다.<br/>
<p align="center"><img src="/assets/img/C Progrmming and Lab/12장 동적 할당/12-8.JPEG" width="600"></p>

&ensp;realloc() 함수는 메모리 공간을 줄일 때는 기존의 공간을 그대로 쓰지만 메모리 크기를 늘릴 경우 기존의 위치에서 공간을 늘릴 수 없으면 기존 위치의 공간을 해제하고 새로운 위치에 공간을 할당한다. 이 경우 시작 주소가 바뀌게 되므로 주의해야 한다.<br/>