---
title: "11장 구조체"
excerpt: ""

wirter: sohee Kim
categories:
  - C Programming and Lab
tags:
  - C

toc: true
toc_sticky: true

date: 2025-07-02
last_modified_at: 2025-07-02
---

구조체 개요
======

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-1.JPEG" width="600"></p>

&ensp;구조체(structure)란 의미상 연관관계가 있는 항목을 그룹으로 묶어 표현한 자료형이다. 구조체 자료형으로 선언된 변수는 구조체 변수라고 하는데 의미상 혼동이 없으면 변수라는 용어는 생략하기도 한다. 구조체를 구성하는 변수들을 멤버(member) 변수(또는 간단히 멤버)라고 부른다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-2.JPEG" width="600"></p>

&ensp;배열이 여러 개의 같은 자료형을 하나로 묶는 것이라면 구조체는 서로 다른 자료형을 하나로 묶는 것이다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-3.JPEG" width="600"></p>

구조체의 정의, 선언, 사용
======

&ensp;int와 같이 모양이 미리 정해져 있는 기본 자료형과 달리 구조체는 모양이 정해져 있지 않기 때문에 변수 선언 전에 자료형(변수의 모양)을 정의해 주는 일이 추가로 필요하다.<br/>

* 구조체 정의: 구조체 자료형(변수의 모양, 틀)을 명시하는 것
* 구조체 선언: 구조체 변수를 사용하겠다고 선언하는 것
<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-4.JPEG" width="600"></p>

구조체(자료형) 정의
------

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-5.JPEG" width="600"></p>

* 구조체 저료형 이름: struct는 구조체를 정의하기 위해 사용하는 키워드이다. 이 후에 구조체 자료형의 이름을 명시한다. 명시된 이름은 변수 이름이 아니라 자료형 이름이다. 
* 멤버 변수: 자료형 이름 명시 이 후에 중괄호 안에 멤버 변수들을 명시한다. 멤버 변수 명시 방법은 변수 선언과 동일하고 기본 자료형, 배열, 포인터, 심지어 구조체까지 어떤 자료형의 변수도 구조체 멤버로 사용할 수 있다. 구조체 정의 안에 명시된 멤버 변수는 구조체의 모양을 분명하게 해주는 역할 뿐 실제 변수가 선언된 것이 아니다. 

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-6.JPEG" width="600"></p>

구조체 (변수) 선언과 초기화
-------

&ensp;구조체 정의는 구조체 안에 어떠한 변수들이 사용되는지를 명시한 것 뿐으로 정의를 한다고 해서 멤버 변수에 데이터를 저장하기 위한 공간이 할당되는 것은 아니다. 메모리 공간을 할당하기 위해서는 변수 선언을 해야 한다. 구조체 변수 선언의 형식은 일반적으로 변수 선언과 동일하다. <br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-7.JPEG" width="600"></p>

&ensp;각 멤버 변수는 해당 자료형의 크기만큼의 공간을 할당받고 구조체 변수 자체는 메모리 공간을 따로 가지지 않고 멤버들의 메모리로 구성된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-8.JPEG" width="600"></p>

&ensp;구조체 변수의 초기화도 다른 초기화와 유사하게 중괄호 안에 멤버 변수 순서대로 초기화 값ㅇ르 나열해주면 된다. 각 멤버의 초기화는 해당 멤버의 초기화 형식을 사용하면 된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-9.JPEG" width="600"></p>

구조채 맴버 변수 사용
------

&ensp;구조체 변수는 구조체의 멤버 변수 전체를 나타내고 구조체의 각 멤버에 접근하기 위해서는 구조체 멤버 연산자(.)를 사용한다. 각 멤버 변수는 해당 변수의 자료형에 의해 사용 방법이 결정된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-10.JPEG" width="600"></p>

* 구조체 기본 예제

```cpp
#include <stdio.h>

struct student{
  int id;   //구조체 student 정의
  char name[8];  //구조체는 일반적으로 함수 밖에서 정의함
  double grade;
}

int main(){
  struct student str1 = {10, "Tom", 3.2};  //변수 선언 및 초기화

  st1.id += 20;   //구조체 멤버 참조
  strcpy(st1.name, "alice");  //주의: st1.name = "alice" (X)
  st1.name[0] = "A";  //문자 배열 원소에 문자 대입

  printf("id: %d\n", st1.id);  //정수 출력
  printf("name: %s\n", st1.name);  //문자열 출력
  printf("grade: %.2f\n", st1.grade);   //부동소수 출력
  return 0;
}
```

* struct student{...}; : 구조체 student를 정의하는 부분이다. 구조체는 일반적으로 함수 밖에서 정의된다.
* struct student st1 = ...; : 구조체 변수를 선언하고 초기화 하는 문장이다. 중괄호를 사용하여 멤버 변수의 초기 값을 묶어 준다.
* st1.id += 20; : 구조체 멤버를 참조하기 위해서는 멤버 연산자(.)를 사용한다. 멤버가 int형이므로 일반적으로 int형 변수와 동일하게 사용하면 된다.
* strcpy(st1.name, "alice"); : 문자열을 구조체의 문자 배열 멤버에 복사하는 문장이다.
* st1.name[0] = 'A'; : 멤버 배열의 원소에 값을 대입하는 문장이다.
* printf(...); : 변수 값 출력하는 문장으로 멤버 변수의 자료형에 따라 적절한 서식 인자를 사용하면 된다.

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-11.JPEG" width="600"></p>

구조체 정의와 선언의 다양한 형태
-------

&ensp;구조체를 정의하고 선언하는 방식은 다양하다.<br/>
&ensp;1. 일반적인 형태는 자료형 정의와 변수 선언을 따로 하는 것이다. 여러 함수에서 구조체를 사용하기 위해 자료형은 보통 함수 밖에서 정의한다.<br/> 

```cpp
struct student{   //구조체 자료형 정의(함수 밖에서)
  int id; 
  char name[8];
  double grade;
};

void func(){
  struct student st1;   //지역 변수 st1 선언
}
```

&ensp;2. 자료형 정의와 변수 선언을 동시에 하나의 문장에서 작성할 수도 있다. 변수 st는 함수 밖에서 선언하였으므로 전역 변수가 된다.<br/>

```cpp
struct student{  //구조체 자료형 정의
  int id;
  char name[8];
  double grade;
} st;  //전역 변수 st 선언

void func(){
  struct student st1;   //지역 변수 st1 선언
  ....
}
```

&ensp;정의, 선언 동시에 초기화를 할 수도 있다.<br/>

```cpp
struct student{  //구조체 자료형 정의
  int id;
  char name[8];
  double grade;
} st = {10, "Tom", 3, 2};  //전역 변수 st 선언 및 초기화
```

&ensp;3. 구조체 자료형의 이름은 생략가능하다. 다만 자료형의 이름이 없으므로 다른 곳에서 이 구조체를 사용할 수 없다.<br/>

```cpp
struct{  //구조체 자료형 정의
  int id;
  char name[8];
  double grade;
} st;  //전역 변수 st 선언

void func(){
  struct student st1;  //컴파일 오류(student 정의 되어 있지 않음)
  struct str2  //컴파일 오류(어떤 구조체인지 알 수 없음)
}
```

&ensp;4. 구조체는 함수 밖 또는 함수 안 어디서나 정의할 수 있다. 다만 함수 안에서 정의하면 정의한 함수 안에서만 사용 가능하다. 함수 안에서 선언된 변수가 그 함수 안에서만 사용할 수 있는 것과 마찬가지이다.<br/>

```cpp
void func1(){
  struct student{  //구조체 자료형 정의(함수 안)
    int id;
    char name[8];
    double grade;
  };
  struct student st1;  //구조체 변수 선언
  ....
}
void func2(){
  struct student st2; //컴파일 오류(student func1에서만 사용 가능)
}
```

구조체에 사용 가능한 연산자
------

&ensp;구조체 사용자가 만든 자료형이기 때문에 기본 자료형인 int, char, double 등에 비해 사용 가능한 연산자가 제한적이다. 예를 들어 산술 연산, 비교 연산 등은 지원되지 않는데 두 구조체의 덧셈, 두 구조체의 비교가 의미적으로 불명확하기 때문이다. 구조체 변수에 사용 가능한 연산자는 대입 연산자(=), 주소 연산자(&), 간접참조 연산자(*), sizeof 연산자 정도이다. <br/>

&ensp;구조체 변수의 대입 연산은 모든 멤버 변수에 대한 대입 연산을 의미한다. 아래 코드에서 st2에 st1을 대입하면 st2의 멤버가 st1의 멤버와 동일한 값을 가지게 된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-12.JPEG" width="600"></p>

&ensp;구조체 대입은 멤버 변수끼리의 단순 대입이라는 점에 유의하자. 문자 배열에 문자열이 저장되어 있는 경우 문자열 복사를 위해 strcpy가 호출되는 것이 아니고 단순히 배열 원소끼리 대입이 수행된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-13.JPEG" width="600"></p>

구조체에 할당되는 메모리 크기
------

&ensp;구조체는 멤버 변수로 구성되므로 구조체의 크기는 멤버 변수에 할당되는 메모리 크기의 합이 될 것이라고 예상할 수 있지만 반드시 그렇지는 않다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-14.JPEG" width="600"></p>

&ensp;int, char [8], double 의 크기는 우리가 예상하는 대로 4, 8, 8 바이트이다. 그러나 이 자료형의 멤버들로 구성된 struct 구조체의 크기는 20바이트가 아니고 24바이트이다. <br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-15.JPEG" width="600"></p>

&ensp;구조체의 변수를 특정수의 배수의 크기로 할당하고 자투리 공간은 사용하지 않는다.(메모리 효율성) 메모리 관리 방식은 시스템마다 다를 수 있어 위 내용이 모든 시스템에 동일하게 적용되지는 않는다. 따라서 구조체의 크기가 필요한 경우 멤버 변수 크기의 합으로 계산하지 말고 sizeof 연산자를 이용해야 한다.<br/>

구조체 멤버 참조
------

&ensp;구조체 변수를 통하여 멤버들을 참조하려면 특별 연산자가 필요하다. 구조체의 멤버는 멤버 연산자(.)를 이용하여 액세스할 수 있다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-16.JPEG" width="600"></p>

구조체를 멤버로 가지는 구조체
------

&ensp;어떤 자료형도 구조체의 변수가 될 수 있다. 다른 구조체도 다른 구조체의 멤버가 될 수 있다. 포인터도 구조체의 멤버가 될 수 있다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-17.JPEG" width="600"></p>

구조체 변수의 대입과 비교
------

&ensp;구조체를 다른 구조체에 대입하는 것ㅇ은 가능하다. 즉 하나의 구조체 변수에 들어 있는 자료들을 다른 구조체 변수로 복사할 수 있다. <br/>

```cpp
struct point{
  int x;
  int y;
};

struct point p1 = {10, 20};
struct point p2 = {30, 40};
```

&ensp;p2=p1; 과 같이 하나의 구조체를 다른 구조체로 대입하는 연산이 가능하다. p2 = p1; 문장을 실행하면 p1과 p2의 좌표값이 (10, 20)으로 같아진다. <br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-18.JPEG" width="600"></p>

&ensp;그러나 구조체 변수와 구조체 변수를 서로 비교하는 것은 허용되지 않는다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-19.JPEG" width="600"></p>

구조체 배열
======

&ensp;구조체의 배열이란 구조체가 여러 개 모인 구조이다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-20.JPEG" width="600"></p>

배열이 구조체의 멤버로 사용
------

&ensp;멤버인 배열을 사용하기 위해 구조체 변수 이름까지 명시해야 한다는 것을 제외하면 특별한 점은 없다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-21.JPEG" width="600"></p>

구조체 배열의 선언
------

&ensp;구조체의 배열은 int나 char배열을 선언하는 것과 비슷하다. 다만 앞에 struct가 붙는 것이 다를 뿐이다.<br/>

```cpp
strct student{
  int number;
  char name[20];
  double grade;
};

struct student list[100]; //구조체의 배열로서 구조체 100개를 저장할 수 있다.
```

&ensp;배열에서 인덱스가 2인 요소에 있는 구조체에 값을 저장하여 보자. 배열의 인덱스는 0부터 시작한다.<br/>

```cpp
list[2].number = 24;
strcpy(list[2].name, "홍길동");  //문자열은 항상 strcpy()를 이용하여 대입
list[2].grade =4.3;
```

구조체 배열의 초기화
------

&ensp;구조체의 배열도 초기화가 가능하다. 다만 배열 초기화 안에 초기화가 들어가야 하므로 중괄호 안에 또 중괄호가 필요하게 된다.<br/>

```cpp
struct student list[3] = {
  {1, "Park", 3.42},
  {2, "Kim", 4.31},
  {3, "Lee", 2.98}
};
```

구조체가 배열의 원소로 사용(구조체 배열)
------

&ensp;정수 변수를 묶어 배열을 만들듯이 구조체 변수를 묶어 배열을 만들 수 있다.<br/>
&ensp;구조체가 원소로 사용된 배열을 구조체 배열이라고 하는데 선언, 참조, 초기화 등 구조체 배열에 대한 문법은 일반 배열과 동일하다. 구조체 배열을 선언하기 위해서는 구조체 자료형과 첨자 연산자 [] 안에 원소 개수를 명시하고 구조체 배열 원소에 접근하기 위해서는 첨자 연산자를 사용한다. 원소 하나가 구조체 변수 하나에 해당되므로 해당 원소 멤버에 접근하려면 멤버 연산자 . 을 사용하면 된다.<br/>

* 구조체 배열 사용 예제

```cpp
struct student ast[3];   //크기 3인 student 구조체 배열 선언

ast[0].id - 10;  //0번 원소의 값 변경
strcpy(ast[0].name, "Tom");
ast[0].grade = 3.2;

ast[1] = ast[0];  //1번 원소의 값 변경(구조체 대입)
ast[1].name[0] = 'M';

printf("ast[0] : %d %s, %.2f\n", ast[0].id, ast[0].name, ast[0].grade);
printf("ast[1] : %d %s, %.2f\n", ast[1].id, ast[1].name, ast[1].grade);
```

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-22.JPEG" width="600"></p>

&ensp;구조체 배열을 선언과 동시에 초기화할 때에도 동일하게 중괄호 안에 초기화할 수조체의 값을 나열한다. 다만 구조체 변수 하나의 멤버 값을 나열하기 위해서도 중괄호를 사용하므로 중괗로가 이중으로 사용된다. 아래에서 바깥쪽의 중괄호는 배열 초기화에 사용된 중괄호이고 두 개의 안쪽 중괄호 쌍은 구조체 초기화에 사용된 중괄호이다. 초기화에서 생략된 부분은 모두 0으로 초기화된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-23.JPEG" width="600"></p>

구조체와 포인터
======

&ensp;구조체와 포인터가 결합되는 형태는 대략 3가지 이다.<br/>

1. 포인터가 구조체의 멤버로 사용
2. 구조체를 가리키는 포인터(구조체 포인터)
3. 구조체 포인터가 배열의 원소로 사용(구조체 포인터 배열)

포인터가 구조체 멤버로 사용
-------

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-24.JPEG" width="600"></p>

* st.pname[0] -> (st.pname)[0] : 연산자 . 과 [ ]는 우선순위가 동일하다. 따라서 구조체 st 내의 배열 pname의 0번 원소를 의미한다.
* *st.pname -> *(st.pname) : 연산자 . 의 우선순위가 * 보다 높다. 따라서 구조체 st 내의 포인터 pname이 가리키는 변수를 의미한다. (st.(*pname)으로 잘못 사용하지 않도록 하자. pname 만으로는 어느 구조체 변수의 멤버인지 알 수가 없다.)

&ensp;구조체는 멤버로 포인터를 가질 수 있다. int형이나 double형에 대한 포인터도 가능하고 다른 구조체에 대한 포인터도 가능하다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-25.JPEG" width="600"></p>
<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-26.JPEG" width="600"></p>

구조체를 가리키는 포인터(구조체 포인터)
------

&ensp;구조체를 가리키는 포인터를 '구조체 포인터' 라고 한다. 즉 구조체 포인터에는 구조체 변수의 시작 주소가 저장된다. 구조체 포인터의 사용법은 일반적인 포인터의 사용법과 동일하다. 다만 구조체 포인터에서만 사용하는 전용 연산자가 새로이 등장한다.<br/>

&ensp;일반 포인터와 마찬가지로 구조체 포인터 변수를 선언하기 위해서는 참조 연산자(*)를 변수 앞에 붙이면 되고 참조 연산자를 이용하여 포인터가 가리키는 구조체 변수에 접근할 수 있다. 구조체 변수의 시작 주소를 알기 위해서 주소 연산자(&)를 붙이면 된다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-27.JPEG" width="600"></p>

```cpp
struct student s = {24, "Kim", 4.3};
struct student *p;  //구조체 student를 가리키는 포인터 선언

p = &s;  //구조체의 주소를 포인터에 대입

printf("학번 = %d 이름 = %s 학점 = %f \n", (*p).number, (*p).name, (*p).grade);  //포인터를 통하여 구조체의 정보에 접근한다. (*p)가 구조체가 된다.
```

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-28.JPEG" width="600"></p>

&ensp;간접 참조를 이용하여 구조체 변수의 멤버에 접근하려면 어떻게 해야 할까? 우선 포인터가 가리키는 구조체에 접근하기 위해 참조 연산자(*)를 사용하고 구조체의 멤버에 접근하기 위해 멤버 연산자(.)를 사용하면 된다. 이 때 멤버 연산자의 우선순위가 참조 연산자보다 높기 때문에 참조 연산자를 먼저 적용시켜주기 위해 괄호가 필요하다.<br/>

```cpp
struct student st1, *pst = &st1;

(*pst).id = 20; //pst가 가리키는 구조체의 멤버 id에 20대입(괄호 필수)
 
printf("id: %d\n", (*pst).id + 15);
```

&ensp;그런데 포인터 구조체를 통한 간접 참조는 매우 빈번히 발생하기 때문에 괄호를 사용하는 것은 불편하다. 그래서 이것을 위한 특수 연산자 -> 가 있다. 연산자 -> 는 간접 참조 연산자(*) 와 멤버 연산자(.)를 합쳐놓은 연산자로 아래와 같이 사용한다.<br/>

&ensp;(*pst).id = 20   =    pst->id = 20;<br/>

&ensp;다음은 혼동하기 쉬운 구조체 변수와 구조체 포인터 조합을 비교 정리한 것이다. 

&ensp;1. (*p)number : 포인터 p가 가리키는 구조체의 멤버 number를 의미한다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-29.JPEG" width="600"></p>

&ensp;2. p->number : 포인터 p가 가리키는 구조체의 멤버 number를 의미하며 (*p).number와 완전히 동일하다.<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-30.JPEG" width="600"></p>

&ensp;3. *p.number : 연산자 우선순위에 의하여 *(p.number)와 같다. 구조체 p의 멤버 number가 가리키는 것이란 의미이다. 이때 number는 반드시 포인터여야 한다. number가 포인터가 아니면 오류이다.<br/>

&ensp;4. *p->number : 연산자 우선순위에 의하여 *(p->number)와 같다. p가 가리키는 구조체의 멤버 number가 가리키는 내용을 의미한다. 만약 number가 포인터가 아니면 오류이다.<br/>

* 구조체 포인터를 이용한 간접 참조 예제

```cpp
struct student st1 = {10, "Tom", 3.2};  //변수 선언 및 초기화
struct student *pst = &st1;  //포인터 선언 및 연결

pst -> id += 20;  //pst가 가리키는 구조체의 멤버 id에 접근
strcpy(pst->name, "alice");  //멤버 name에 접근
pst->name[0] = 'A';

printf("id: %d\n", pst->id); //pst가 가리키는 구조체의 멤버 값 출력
printf("name: %s\n", pst->name);
printf("grade: %.2f\n", pst->grade);
```

구조체 포인터가 배열의 원소로 사용(구조체 포인터 배열)
------

* 구조체 포인터 배열 예제

```cpp
int i;
struct student st1 = {10, "Tom", 3.2}, st2;
struct student *past[3] = {&st1, &st2}; //구조체 포인터 배열 선언 및 초기화

past[2] = past[1];  //주소 값 대입: past[2]도 st2를 가리킴
*past[2] = *past[0]; //past[2]가 가리키는 구조체에 past[0]이 가리키는 구조체 대입

past[1]->id = 20;  //포이터를 이용한 멤버 간접 접근
past[2]->name[0] = 'M';

for(i = 0; i < 3; i++)
  printf("past[%d]: %d, %s, %.2f\n", i, past[i]->id, past[i]->name, past[i]->grade);  //past[i]가ㅏ 가리키는 구조체 정보 출력
```

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-31.JPEG" width="600"></p>

* struct student *past[3] = {&st1, &st2}; : 구조체 포인터 배열을 선언하고 초기화하는 문장으로 2번 원소의 초기 값이 명시되지 않았으므로 2번 원소 NULL로 초기화된다.
* past[2] = past[1]; : 배열 원소의 대입이다. 1번 원소에 st2의 주소 값이 지정되어 있으므로 2번 원소에도 st2의 주소 값이 대입되고 결과적으로 2번 원소로 st2를 가리킨다. 
* *past[2] = *past[0]; : 간접 참조를 이용해 past[2]가 가리키는 구조체 변수에 past[0]이 가리키는 구조체 변수를 대입하는 문장이다. 결과적으로 st2에 st1의 값이 대입된다.
* past[1]->id = 20; : past[1]이 가리키는 구조체, 즉 st2의 멤버 id에 20을 대입하는 문장이다.
* past[2]->name[0] = 'M'; : past[2]가 가리키는 구조체, 즉 st2의 멤버인 배열 name의 0번 원소에 문자 'M'을 대입한다. 

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-32.JPEG" width="600"></p>

구조체와 함수
======

&ensp;구조체가 인수나 반환값으로 사용될 때는 값에 의한 호출 원칙이 적용된다. 즉 구조체 변수의 모든 내용이 복사되어 함수로 전달되고 반환된다. 따라서 함수에는 구조체의 복사본이 인수로 전달되므로 함수 안에서 인수의 값이 변경되더라도 원본 구조체에 영향을 주지 않는다.<br/>

구조체 인자와 반환
-------

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-33.JPEG" width="600"></p>

&ensp;이 함수의 인수는 2개이며 모두 구조체이다. 두 개의 구조체 s1, s2를 받아서 멤버인 number가 같은지를 검사한다. 만약 number가 같으면 1을 반환하고 다르면 0를 반환한다.<br/>

&ensp;구조체의 경우도 다른 자료형들과 마찬가지로 복사본이 함수로 전달된다. 따라서 구조체의 크기가 크다면 적지않은 시간과 메모리 공간을 차지할 수 있다. 따라서 이런 경우에는 구조체를 직접 보내는 것이 아니라 구조체의 포인터를 인수로 보내는 것이 좋다. 포인터는 항상 일정한 크기이다. <br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/11장 구조체/11-34.JPEG" width="600"></p>

&ensp;포인터를 잘못 사용하게 되면 원본 데이터를 훼손할 수도 있다. 앞에서의 구조체를 직접 보내는 방식에서는 복사본이기 때문에 아무리 변경하여도 원본에 영향을 주지 않는다. <br/>
&ensp;이런 점을 방지하기 위해 원본을 포인터를 통하여 읽기만 하고 쓸 필요는 없는 경우 매개변수를 정의할 때 다음과 같이 const 키워드를 써주면 된다. const 키워드가 *p1앞에 있으면 이 포인터가 가리키는 구조체의 값을 변경하려고 하면 컴파일 과정에서 오류 메시지가 출력된다.<br/>

```cpp
int equal(struct student const *p1, struct student const *p2){  //이 포인터를 통하여 구조체를 변경하는 것은 금지된다.
  if(p1->number == p2->number)
    return 1;
  else
    return 0;
}
```