---
title: "9장 포인터"
excerpt: ""

wirter: sohee Kim
categories:
  - C Programming and Lab
tags:
  - C

toc: true
toc_sticky: true

date: 2025-05-30
last_modified_at: 2025-06-05
---

1\. 개요
=======

&ensp;메모리<br/>
* 프로그램이 실행되기 위해 필요한 정보(값)을 저장하는 공간
* 1 bytes(8bits) 단위로 물리 주소가 부여되어 있음
* 개념적으로 메모리는 일렬로 연속되어 있는 크기가 1 bytes인 방들의 모임이라고 볼 수 있다.
* 일반적으로 주소의 길이는 4 bytes이고 주소 16진수로 표현 
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-1.JPEG" width="600"></p>

&ensp;변수와 메모리의 관계<br/>
* 변수는 선언될 때 메모리에 그 변수를 위한 공간이 할당된다. (주의: 변수에 할당되는 메모리 주소는 시스템마다 다르다.)
* 주소 연산자(&): 변수에 할당된 메모리 공간의 시작 주소를 구해 준다.
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-2.JPEG" width="600"></p>

&ensp;C프로그램에서 변수의 의미(2 가지)<br/>
1. 그 변수에 할당된 공간을 의미(주소를 뜻하는 것은 아님)
&ensp;선언 or 대입문의 왼쪽 변수(I-value)로 사용될 때<br/>
2. 그 변수에 저장된 값을 의미
&ensp;그 변수에 저장된 값을 의미<br/>
&ensp;대입문의 오른쪽 변수(r-value), 조건식, 함수의 인수로 사용될 때<br/>
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-3.JPEG" width="600"></p>

&ensp;메모리에 변수가 할당되면 연속으로 할당된다는 보방은 없다.<br/>
&ensp;메모리에 배열이 할당되면 배열은 항상 연속된 공간에 할당된다. <br/>

&ensp;포인터(자료형)<br/>
* 주소를 나타내는 특수 자료형
* 주소는 기본적으로 양의 정수로 표현된다.
* 하지만 int(정수형 자료형)와 구별되어 처리된다(다른 자료형)
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-4.JPEG" width="600"></p>

* 선언: 변수 명 앞에 *(참조 연산자)사용
* 연결: &(주소 연산자)를 이용해 포인터 변수를 다른 변숭에 연결
* 참조: *(참조 연산자)를 이용해 포인터에 연결된 변수에 접군
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-5.JPEG" width="600"></p>

&ensp;정리<br/>
* 메모리는 프로그램이 실행되기 위해 필요한 정보(값)을 저장하는 공간으로 1 byte(8 bit) 단위로 물리 주소가 부여 되어 있다.
* 변수는 선언 시에 그 변수를 위해 메모리 공간이 할당되고 할당된 위치는 변경되지 않는다.
* 포인터는 메모리 주소를 나타내는 개념으로 저장 공간을 가리키는 것이라는 의미이다.
* 변수의 주소는 주소 연산자(&)를 사용하여 얻을 수 있다. 

2\. 포인터 선언과 사용
======

&ensp;<b>포인터(변수) 선언</b><br/>
* 구문: 변수 명 앞에 *(참조 연산자)만 덧붙이면 된다.
&ensp;기존의 자료형 표시 + 표인터라는 표시<br/>

&ensp;예 <br/>
* char *pch;
* int *pnum;

&ensp;pch와 pnum은 똑같이 주소를 저장하지만 대상의 자료형이 다르기 때문에 다른 자료형으로 취급<br/>
&ensp;pch는 문자형 포인터(변수)이고 pnum은 정수형 포인터(변수)

&ensp;초기화<br/>
* 일반 변수 초기화 형태와 동일
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-6.JPEG" width="600"></p>

&ensp;포인터 변수 선언은 다양한 형태<br/>
* 동일 기본 자료형(int)에서 파생된 자료형의 변수는 모아서 선언 가능
* int *pnum1, num1 = 10, * pnum2, num2, arr[10];
* 그러나 가독성 때문에 추천 안 한다.

&ensp;포인터 대입(연결)<br/>
* 포인터(변수)에 주소를 대입하여 특정 변수와 연결시키는 것을 **가리킨다**라고 표현하고 그림에서는 화살표 -> 로 표시
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-7.JPEG" width="600"></p>

&ensp;포인터 참조<br/>
* 포인터(변수)가 가리키는 변수에 접근하는 것
* 참조 연산자 * (간접 연산자, 포인터 연산자라고도 부름)를 사용
* *pch: 포인터 pch가 가리키는 변수, 그 주소에 저장된 값
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-8.JPEG" width="600"></p>

&ensp;참조 연산자를 이용한 대입 예시<br/>
* *pch = 'B' 의 의미: pch가 가리키는 공간에 'B' 대입
* *pch = 'B'는 ch = 'B'와 동일한 시능 수행
&ensp;전자는 간접 접근, 후자는 직접 접근<br/>
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-9.JPEG" width="600"></p>

&ensp;참조 연산자 추가 예시<br/>
* *pnum은 정수를 나타내므로 정수를 사용하는 어떤 형태든 가능
* 단 참조연산자와 다른 연산자와의 우선 순위에 주의해서 사용
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-10.JPEG" width="600"></p>

&ensp;정리<br/>
* 포인터 변수는 참조 연산자(*)를 사용하여 선언한다.
* 포인터 변수는 다른 변수에 연결을 시킨 후 사용해야 한다.
* 포인터 변수는 가리키는 변수에 접근하기 위해서는 참조 연산자(*)를 사용해야 한다. 


&ensp;포인터와 관련한 두 연산자 정리<br/>
* 주소 연산자(&): 해당 변수의 주소 값
* 변수 이름: 변수 영역 또는 변수에 저장된 값
* 참조 연산자(*): 포인터가 가리키는 변수

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-11.JPEG" width="600"></p>

* 주의: pnum과 &num의 값은 동일하지만 지칭하는 부분은 전혀 다름

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-12.JPEG" width="600"></p>

&ensp;<b>포인터 주의사항</b><br/>
* 초기화
  - 선언 후  연결 없이 바로 사용하면?

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-13.JPEG" width="600"></p>

* &(주소 연산자)는 포인터를 포함한 모든 변수에 사용가능
* *(참조 연산자)는 포인터 변수에서만 가능 (*num(num이 가리키는 변수)은 정의 되지 않음)

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-15.JPEG" width="600"></p>

* 대입
  - 포인터의 자료형과 연결된 변수의 자료형은 일치해야 한다.
  - 서로 다른 자료형의 포인터 간 대입
    + 문법적으로 허용이 되기도 하지만 프로그램 오류의 원인이 됨

  <p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-16.JPEG" width="600"></p>

&ensp;널(NULL) 포인터<br/>
* 주소 값 0을 나타내는 특별한 기호
* 아무것도 가리키지 않음을 의미
* NULL의 값은 0이므로 조건문에서 사용하며 거짓에 해당
* 예기치 못한 오류 방지를 위해 포인터 변수를 NULL로 초기화

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-14.JPEG" width="600"></p>

&ensp;포인터의 크기<br/>
* 포인터의 종류(자료형)에 관계 없이 주소를 저장하기 위해 필요한 공간은 동일(단 포인터의 크기는 시스템에 따라 다를 수 있음)
* sizeof 연산자를 이용하여 확인해보면

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-17.JPEG" width="600"></p>

3\. 배열과 포인터
======

&ensp;<b>배열의 이름</b><br/>
* 배열의 이름은 배열의 0번 원소의 시작 주소를 의미한다.
* 비교: &ar는 전체 배열의 시작 주소(값은 같지만 다른 자료형)

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-18.JPEG" width="600"></p>

* 일반 변수와 배열 비교

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-19.JPEG" width="600"></p>

&ensp;주소를 이용한 배열 참조<br/>
* 배열 이름은 주소를 의미하므로 참조 연산자와 함께 사용 가능
  - ar: 0번 원소의 주소
  - *ar: 0번 원소의 주소에 저장된 값, 즉 0번 원소의 값을 의미

  <p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-20.JPEG" width="600"></p>

&ensp;배열 주소에 대한 증감 연산<br/>
* 배열 원소 하나의 크기 만큼 증가 or 감소
* ar+i: 배열 ar의 i번째 원소의 주소
* *(ar+i): 배열 ar의 i번째 원소의 값, 즉 ar[i]

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-21.JPEG" width="600"></p>

&ensp;정리<br/>
* 포인터 변수는 다른 변수에 연결한 후에 사용해야 함
* NULL은 주소 값 0을 나타내는 특별 기호로 아무것도 가리키지 않는다는 것을 의미함
* 포인터의 자료형과 연결된 변수의 자료형은 일치해야 함
* 배열 이름은 0번 원소의 주소를 의미하고 배열 이름의 값은 변경 불가능 함

&ensp;배열을 포인터 변수에 연결하여 사용하기<br/>
* 배열 이름은 주소를 의미하므로 포인터 변수에 대입 가능
* 포인터 변수에 대한 증감 연산
  - 포인터 변수가 나타내는 자료형의 크기 단위로 증가 or 감소

  <p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-22.JPEG" width="600"></p>

* 포인터 변수도 배열의 첨자 형태로 값을 참조할 수 있다.
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-23.png" width="600"></p>

&ensp;<strong>배열과 포인터의 관계 정리</strong><br/>
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-24.png" width="600"></p>

```cpp
int ar[5], *p = ar;
```

* 주소에 1을 더하면 원소의 크기만큼 주소가 증가한다. 
  - ar + 3, p + 3: ar과 p 모두 주소
* 주소가 주어 졌을 때 해당 주소에 저장된 원소(변수) 값은 다음 두 가지 형태로 참조할 수 있다
  - ar[3]과 p[3]: 배열 첨자 연산자 [] 사용
  - *(ar + 3)과 *(p + 3): 포인터의 참조 연산자 *사용

&ensp;배열 이름이든 포인터 변수이든 주소를 의미하고 따라서 참조 방식도 동일하다. <br/>

&ensp;<b>배열과 포인터 주의사항</b><br/>
1. 포인터를 배열의 중간 원소에 연결시키는 것도 가능

  <p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-25.png" width="600"></p>

* 포인터는 단지 자신이 가리키는 주소를 기준으로 배열처럼 쓰는 것일 뿐

2. 포인터의 참조 연산자 사용시 괄호에 유의

&ensp;*(ar + 2) -> ar[2] -> 5<br/>
&ensp;*ar + 2 -> *(ar) + 2 -> ar[0] + 2 -> 4 (연산자 우선순위 때문)<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-26.png" width="600"></p>

3. 포인터 변수의 증감량은 가리키는 배열의 원소 크기가 아니라 **포인터 자신의 자료형에 의해** 결정

&ensp;예: char * 형 포인터에 int배열을 연결하면<br/>

<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-27.png" width="600"></p>

&ensp;<b>배열 이름과 포인터 변수의 차이점</b><br/>
* int num;
  - 변수 num에 저장된 값(정수)은 변경 가능
  - 변수 num에 할당된 주소는 변경 불가
* int *p;
  - 변수 p에 저장된 값(주소)은 변경 가능
  - 변수 p애 할당된 주소는 변경 불가
* int ar[5];
  - 배열 ar에 저장된 값은 변경 가능
  - 배열 ar에 할당된 주소는 변경 불가
    + 배열 이름은 포인터 상수로 변경하지 못한다.
    + 대입문의 왼쪽에서 사용될 때 (I-value) 차이 발생

    <p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-28.png" width="600"></p>

&ensp;정리<br/>
* 배열을 포인터 형태로 사용할 수 있고 반대로 포인터를 배열 형태로 사용할 수 있다.
* 포인터 변수의 증감량은 가리키는 배열의 원소 크기가 아니라 포인터 자신의 자료형에 의해 결정된다.
* 변수에 할당된 주소는 변경이 불가능하나 변수에 저장된 주소 값은 변경 가능하다.

실습 문제
======

문제 1
------

`문제`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-29.png" width="600"></p>

`코드`
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


int main(void) {



	int x, y, z;
	int *px = &x;
	int *py = &y;
	int *pz = &z;


	scanf("%d %d %d", px, py, pz);

	int *tmp = px;
	px = pz;
	pz = py;
	py = tmp;
	

	printf("%d %d %d", *px, *py, *pz);

	return 0;

}

```

`결과`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-30.png" width="600"></p>


문제 2
------

`문제`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-31.png" width="600"></p>

`코드`
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


int main(void) {

	char ch[20];
	int i = 0;
	char *p = ch;

	while (1) {
		scanf("%c", p + i);
		
		if (*(p + i) == '#') {
			break;
		}

		i++;
		
	}


	for (int j = i-1; j >= 0; j--) {
		printf("%c", *(p + j));
	}

	return 0;

}

```

`결과`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-32.png" width="600"></p>


문제 3
------

`문제`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-33.png" width="600"></p>

`코드`
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


int main(void) {

	int arr[50] = { 0 }, N;

	int* p;
	scanf("%d", &N);

	for (p = arr; p < arr + N; p++) {
		scanf("%d", p);
	}

	int cnt = 0;
	for (p = arr; p < arr + N; p++) {

		if (*p > 0 || *p <0) {
			cnt++;
		}

		if (*p == 0) {
			break;
		}
	}
	printf("%d", cnt);



	return 0;

}

```

`결과`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-34.png" width="600"></p>


문제 4
------

`문제`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-35.png" width="600"></p>
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-36.png" width="600"></p>


`코드`
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


int main(void) {

	int x[3];

	int *p;

	for (p = x; p < x + 3; p++) {
		scanf("%d", p);
	}

	int max = -1;
	int min = 100000000;
	for (p = x; p < x + 3; p++) {
		if (max < *p) {
			max = *p;
		}
		if (min > *p) {
			min = *p;
		}
	}

	int mid;
	for (p = x; p < x + 3; p++) {
		if (*p != max && *p != min) {
			mid = *p;
		}
	}
	printf("%d", mid);

	return 0;

}

```

`결과`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-37.png" width="600"></p>


문제 5
------

`문제`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-38.png" width="600"></p>


`코드`
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


int main(void) {

	int arr[5];
	int *p;

	for (p = arr; p < arr + 5; p++) {
		scanf("%d", p);
	}

	int *tmp;
	
	for (p = arr; p < arr + 5; p++) {
		int rank = 1;
		for (tmp = arr; tmp < arr + 5; tmp++) {
			if (*p < *tmp) {
				rank++;
			}
		}
		printf("%d=r%d ", *p, rank);
	}

	return 0;

}

```

`결과`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-39.png" width="600"></p>


문제 6
------

`문제`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-40.png" width="600"></p>


`코드`
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


int main(void) {

	char ch[10];
	char *p;

	for (p = ch; p < ch + 10; p++) {
		scanf("%c", p);
	}

	char* tmp;
	char result;
	int max = -1;

	for (p = ch; p < ch + 10; p++) {
		int cnt = 0;
		for (tmp = ch; tmp < ch + 10; tmp++) {
			if (*p == *tmp) {
				cnt++;
			}
		}
		if (max < cnt) {
			max = cnt;
			result = *p;
		}

	}

	printf("%c %d", result, max);

	return 0;

}

```

`결과`
<p align="center"><img src="/assets/img/C Progrmming and Lab/9장 포인트/9-41.png" width="600"></p>
