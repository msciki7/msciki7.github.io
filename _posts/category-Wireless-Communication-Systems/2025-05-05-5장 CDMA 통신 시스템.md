---
title: "5장 CDMA 통신 시스템"
excerpt: ""

wirter: sohee Kim
categories:
  - Wireless Communication Systems
tags:
  - Wireless Communication System

toc: true
use_math: true 
toc_sticky: true

date: 2025-05-05
last_modified_at: 2025-05-05
---

CDMA PN code
======

&ensp;IS-95 CDMA PN code<br/>
&ensp;CDMA는 여러 사용자가 동일한 주파수를 공유하면서 통신할 수 있도록 하기 위해 각 사용자에게 고유한 코드(PN 코드)를 부여해서 신호를 확산한다. 이 과정에서 사용자 구분, 기지국 구분, 암호화를 위한 여러 코드들이 함께 사용된다. <br/>

&ensp;BS Transmitter(기자국 송신기) <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-1.png" width="600"></p>

1. Long PN Code(보안용)
* 보통 암호화 또는 개인 정보 보호용으로 사용
* 사용자마다 다르게 설정된다.
* 데이터 암호화라고 표시된 부분에서 사용된다.

2. Walsh Code(직교 코드)
* 여러 사용자들 동시에 구분하는 데 사용
* IS-95에서는 각 사용자는 서로 다른 직교 Walsh 코드를 배정받는다.
* 채널 구분(사용자 간 구분) 역할 수행

3. Short PN Code 1, 2
* 기지국 구분 용도
* 모든 기지국이 공유하는 PN 코드지만 서로 다른 시작점으로 사용된다.
* 출력 신호를 두 갈래로 나누어 하나는 일반 캐리어, 다른 하나는 90도 위상차를 주어 I/Q 신호로 전송

&ensp;MS Transmitter(모바일 기기 송신기) <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-2.png" width="600"></p>

* M-ary Walsh modulation : 다중 비트 데이터를 효율적으로 표현
* Long PN Code : 모바일 사용자 식별 및 보안 역할
* Short PN Code 1, 2 : 1/2 칩 지연를 적용해 두 경로를 위상 차 있게 만들고 이후 결합하여 복소수 성분으로 만드는 구조이다.  

&ensp;OVSF code <br/>

&ensp; CDMA 시스템에서 직교성을 유지하면서도 유동적인 확산 계수(SF: Spreading Factor)를 갖는 확산 코드<br/>
&ensp;사용자마다 데이터 속도가 다르므로 코드 길이(SF)를 다르게 해줄 필요가 있는데, 그 와중에도 서로 간섭하지 않도록 만들어주는 것이 OVSF 코드<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-3.png" width="600"></p>

&ensp;서로 다른 코드끼리는 곱해서 평균이 0이 되어야 한다. = 간섭하지 않음

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-4.png" width="600"></p>

&ensp;부모-자식 간 직교성 불가<br/>
&ensp;예: (1, 1, 1, 1)과 (1, 1, -1, -1)은 서로 직교하지 않는다. 같은 경로에 있기 때문에.<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-5.png" width="600"></p>

1. $w_{6}(t)$ - 코드 시퀀스: (1, -1, 1, -1, 1, -1, 1, 1)
* 시간 $T_{c}$ 단위로 정의된 코드 시퀀스
* 각각의 비트는 +1 또는 -1로 표현되며 $T_{c}$ 만큼 지속된다
* Walsh 코드 /OVSF 코드의 한 예이다.

2. $w_{7}(t)$ - 코드 시퀀스: (1, -1, -1, 1, -1, -1, 1, 1)
* 다른 Walsh 코드이다.
* $T_{c}$ 단위의 신호 블록들로 구성된다.

3. $w_{6}(t)w_{7}(t)$
* 두 시퀀스를 원소별로 곱한 결고를 보여준다.

Rake receiver
======

&ensp;여러 개의 다중경로(multipath) 신호를 각각 추적해서 각각의 지연(τ)을 보상하고 이를 결합(combining)하여 수신성능을 향상시키는 구조이다. <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-6.png" width="600"></p>

1. Multipath 환경
* 송신된 신호는 건물 등 환경으로 인해 여러 경로를 통해 수신기에 도달
* 각 경로는 다른 감쇠 계수(α₁, α₂, α₃)와 지연(τ₁, τ₂, τ₃)을 가진다.
* 이 경로들 중 중요한 것들을 추적하여 각각 복조함

2. RAKE 구조
* LPF : 각 경로 신호를 저역통과시킴
* 지연 보상 : 각 경로의 지연에 맞춰 신호를 보정
* BPSK Finger : 각 지연 성분에 대해 복조를 수행하는 finger
* Searcher : 유효한 다중경로를 탐색해서 적절한 finger에 할당함

3. Combiner(결합기)
* 각 BPSK Finger 출력에 대해 채널 계수 $|α_{i}|$에 비례하는 가중치를 부여해 결합
* 출력 신호는 여러 경로의 constructive gain을 활용한 합성 결과
* 결과적으로 SNR(Singnal-to-Noise Ratio)을 향상시킴

PN Code Acquisition
======

&ensp;목적<br/>
&ensp;수신기는 받은 PN코드의 시작점을 모르므로 자신이 만든 PN코드를 여러 타이밍으로 이동시키며 비교해봐서 **타이밍 offset τ**을 알아낸다.<br/>

&ensp;실제 계산 방법<br/>
&ensp;수신 코드 c(t)와 로컬 코드 c(t)를 비트마다 곱하고 모두 더한다.<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-7.png" width="600"></p>

&ensp;코드에 0를 추가한 이유는 상관기(correlator)에서 연산할 때 필요한 비트 수를 정확히 맞추기 위한 패딩이다. <br/>

&ensp;z(t) 값이 가장 높게 나올 때 = 코드가 정렬됨 -> 이 시점을 찾는 것이 acquisition의 핵심<br/>

&ensp;Serial PN code acquisition<br/>

&ensp;$η_{s}$ 는 serial search acquisition에서 수신 신호와 로컬 PN 코드 사이의 상관값 $z_{i}$ 를 평가할 때 사용하는 탐색 임계값이다. <br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-8.png" width="600"></p>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-9.png" width="600"></p>

&ensp;단계별 상세 설명<br/>

1. Uncertainty Region
* 수신기의 PN 코드 생성기는 송신기의 코드와 위상이 맞지 않음
* 전체 주기 내 어디서 시작했는지 모르므로 모든 가능한 시작점을 탐색해야 함
* 예: PN 코드 길이가 15라면, 최대 15개의 시작 지점을 검사해야 함

2. Search Mode (탐색 단계)
* r(t) : 수신 신호
* $c(t - \tau _{r})$ : 로컬 PN 코드, 현재 테스트 중인 offset
* I-Q Matched Filter (MF):
* 실제 신호 r(t) 와 PN 코드 $c(t - \tau _{r})$ 의 상관값 $z_{i}$ 계산
* 결과 : $z_{i} = \int r(t)c(t-\tau _{r})dt$
* 판단 : 이 $z_{i}$ 값이 임계값 $\eta _{s}$ 를 넘으면 -> 후보 offset $\tau \hat{} = \tau _{r}$ 
* 넘지 않으면 -> 다음 offset $\tau _{r} + 1$ 로 이동하여 반복

3. Verification Mode (검증 단계)
* 후보 $\tau \hat{}$ 가 진짜인지 확인하기 위해 여러 번 상관값을 측정
* B out of A 방식 : 
* 예: 10번 테스트 중 8번 이상이 threshold $η_{v}$ 를 넘기면 -> 확인 완료
* 목적: **우연히 발생한 높은 상관값(노이즈)**인지 필터링

4. Tracking Mode (추적 단계)
* 이후에는 아주 미세한 시간차이 $(\delta \tau )$ 까지 조정
* Fine synchronization 수행
* 이 단계부터는 코드 동기화가 거의 맞춰진 상태

&ensp;Non-coherent I-Q matched filter<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-10.png" width="600"></p>

&ensp;수신한 신호 r(t)에서 정확한 PN 코드 offset( $\tau$ )을 찾기 위해 위상 정보 없이도 사용할 수 있는 비동기 방식의 상관값 $z_{i}$ 를 계산<br/>

1. r(t) : 수신 신호
&ensp;$r(t) = \sqrt{E_{b}}b(t-\tau )c(t - \tau )\varphi  (t + \theta ) + n(t)$

2. 반송파 동기화 없이 분리하기 위해 I/Q 분해
* 상단 : 
&ensp;$\varphi _{1}(t) = cos(2\Pi f_{c}t) $
&ensp;->In-phase(직류) 성분 추출
* 하단 : 
&ensp;$\varphi _{2}(t) = sin(2\Pi f_{c}t)$
&ensp;-> Quadrature(직각 위상) 성분 추출

3. Low Pass Filter (LPF)
* 반송파 성분 제거, baseband로 변환
* 이 후 신호는 $r(t)cos(2\Pi f_{c}t)$ 와 $r(t)sin(2\Pi f_{c}t)$ 로 분리된 baseband 신호

4. PN 코드 정렬 여부 확인용 상관기
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-11.png" width="600"></p>

5. $z_{i} = z_{c}^{2} + z_{s}^{2}$
* 위상 정보 $\theta $ 없이도 절대적인 correlation 정도를 측정 가능

&ensp;최종 결정 변수 : $\theta z_{i} = z_{c}^{2} + z_{s}^{2} = E_{b}R^{2}(\tau -\tau _{r})$ <br/>
&ensp;->위상 $\theta $ 에 무관하게 최대값이 정확한 offset에서 발생<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-12.png" width="600"></p>

&ensp;흐름 설명<br/>
&ensp;serach mode<br/>
* Local PN 코드 $c(t- \tau _{r})$ 를 다양한 지연으로 적용
* 수신 신호와 상관하여 상관값 $z_{i}$ 계산
* $z_{i} > \eta _{s}$ 인 지점을 탐색 후보( $\tau _{r}$ )로 간주

&ensp;verification mode<br/>
* 탐색된 후보가 우연히 나온 잡음인지 확인
* 여러 상관값이 threshold $\eta _{s}$ 를 넘는지 판단 -> B out of A 조건 만족 시 확인

&ensp;acquisition point<br/>
* 수신기의 PN 코드와 정확히 일치하는 시작점은 $\tau = \tau _{r}$
* 이 시점에서 $z_{i}$ 최대 -> 동기화 성공

&ensp;Parallel PN code Acquisition 구조<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-13.png" width="600"></p>

* serial 방식과 달리 여러 개의 offset을 동시에 계산 -> 탐색 시간 단축
* 고속 프로세서나 하드웨어로 병렬 처리 가능

&ensp;흐름 구성도<br/>

1. Uncertainty Region
* 전체 가능한 offset에 대해 모두 병렬 검사

2. Matched Filter Bank
* I-Q 분해된 matched filter들 (I-Q MF1, MF2)이 각각 여러 delay에 대해 동시에 상관 연산

3. Choose Max
* 모든 delay 중 상관값 $z_{i}$ 가 가장 큰 것을 선택 -> $\tau = \tau _{r}$

4. Coincidence Detection
* Verification 단계로 넘어가서 B out of A 조건 검사

&ensp;Matched Filter Output<br/>
1. 첫 번째 결과 (Serial or Parallel 1차 필터)
&ensp;$z_{i} = z_{c}^{2} + z_{s}^{2} = E_{b}[R_{c}(\tau - \tau _{r})]^{2}$ <br/>
* 상관값은 오차가 작을수록 커짐
* 최대 : $\tau = \tau _{r}$

2. 두 번째 결과 (Parallel 방식에서 2개의 filter 사용 시)
* 두 번째 matched filter는 $\frac{N_{c}}{2}$ 만큼 다른 offset으로 비교: <br/>
&ensp;$z_i^{(2)} = E_b × [ R_c(τ - τ_r - N_c / 2) ]^2$ <br/>
* 병렬 구조에서는 이 둘 중 큰 상관값을 선택하여 offset 결정


Multiuser Detection(MUD)
======

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-14.png" width="600"></p>

&ensp;CDMA 시스템에서는 여러 사용자의 신호가 동일하 주파수와 시간을 사용하지만 서로 다른 코드를 사용하여 구분된다. 하지만 다른 사용자의 간섭(Multiple Access Interference, MAI)가 존재하므로 성능 저하를 유발한다.<br/>

&ensp;목표<br/>
&ensp;원하는 사용자 신호를 정확히 추출하고 다른 사용자 간섭(Interference Cancellation, IC) 제거한다. <br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-15.png" width="600"></p>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-16.png" width="600"></p>

&ensp;수신기 구조<br/>
* LPF로 밴드 제한
* 각 사용자별 BPSK finger로 코드 $c_{m}(t)$ 에 상관 -> $ b\hat{}_{m}(t)$ 추정
* Re-generator에서 $b\hat{}_{m}(t)c_{m}(t)$ 로 신호 재구성
* Interference Cancellation Block에서 간섭 신호를 제거

&ensp;Re-generator의 핵심 역할<br/>
* 간섭 신호 재생 : 다른 사용자에게 간섭이 되었던 신호 복원
* 간섭 제거에 사용 : PIC/SIC 블록에서 빼주는 연산에 사용
* 정확도 의존 : $b\hat{}_{m}(t)$ 가 정확할수록 간섭 제거도 성공적

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-17.png" width="600"></p>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-21.png" width="600"></p>

&ensp;수신 신호 <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-18.png" width="600"></p>

&ensp;상관기 통과 후 평균 <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-19.png" width="600"></p>

&ensp;사용자 k의 간섭 제거<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-20.png" width="600"></p>

&ensp;M 단계 PIC 수신기<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-22.png" width="600"></p>

&ensp;Neaer-Far Problem(근거리-원거리 문제)<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-23.png" width="600"></p>

&ensp;문제 상황: 모든 사용자가 동일한 전략으로 전송하지만 기지국에서의 수신 전략은 사용자 거리에 따라 다르다.<br/>
* 가까운 사용자는 신호가 강하게 수신됨
* 먼 사용자는 신호가 약하게 수신됨
&ensp;결과: 강한 사용자 신호가 약한 사용자 신호를 마스킹(덮어버림)해서 약한 사용자의 오류율 증가<br/>

&ensp;Power control<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-24.png" width="600"></p>

&ensp;해결 방안: 사용자의 거리 및 채널 상태에 따라 전송 전력을 조절<br/>
* 가까운 사용자는 전송 전력을 줄이고 먼 사용자는 전송 전력을 키움
&ensp;결과: 모든 사용자의 수신 전력이 균형, 즉 기지국에서 동일하게 수신되도록 조정 -> 공정한 다중접속 환경 조성<br/>

&ensp;Serial Interference Cancellation(SIC)
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-25.png" width="600"></p>

* 기본 아이디어:
1. 가장 강한 사용자부터 검출
2. 해당 사용자의 신호를 재생(re-generator)
3. 수신 신호에서 해당 신호를 제거
4. 다음으로 강한 사용자를 검출 -> 반복

* 구성 요소
1. 수신 신호 입력
* 안테나로부터 r(t) 수신
* 신호에는 모든 사용자의 합성된 전송 신호가 포함되어 있음
&ensp;$ r(t) = \sum_{m=1}^{N_{u}}\sqrt{E_{m}}b_{m}(t-\tau -{m})c_{m}(t-\tau _{m})\varphi (2\Pi f_{c}t + \theta _{m})$ <br/>

2. Delay
* 모든 경로 지연 시간을 맞춰주는 블록
* 이유: 사용자의 신호가 서로 다른 타이밍으로 수신되므로 각 사용자의 타이밍에 맞게 보정

3. correlator(사용자 1~ N)
* 각 사용자의 PN 코드 $c_{m}(t)$ 와 상관기를 통해 사용자별 상관 출력 계산
&ensp;$z_{t} = \int r(t)c_{m}(t-\tau _{m})dt$ <br/>
* 이 출력값을 보고 가장 강한 사용자를 선택할 수 있음

4. select max(가장 강한 사용자 선택)
* 상관값이 가장 큰 사용자 m 선택
* 이유: 가장 강한 사용자를 먼저 제거하면 다른 사용자에 대한 간섭 효과가 줄어듦(Near-Far 문제 해결에 효과적)

5. Re-generator
* 선택된 사용자의 신호를 복원:
* 비트 추정 $b\hat{}_{m}(t)$
* PN 코드 $c_{m}(t-\tau _{m})$
* 재생된 신호 :
&ensp;$s\hat{}_{m}(t) = \sqrt{E_{m}}b\hat{}_{m}(t-\tau _{m})c_{m}(t-\tau _{m})$ <br/>

6. Interference Cancellation
* 원래 수신 신호에서 복원한 사용자 m의 신호를 제거:
&ensp;$r'(t) = r(t) - \hat{s}_m(t)$ <br/>

* 이 과정을 통해 남은 사용자들의 간섭 환경이 개선됨

7. 다음 사용자에 대해 반복 수행
* 사용자 2, 사용자 3,.. 순서로 위의 과정을 반복 수행
* 각각의 코릴레이터, 리제너레이터, 간섭 제거 블록을 통해 점점 더 간섭 없는 신호로 정제됨

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-27.png" width="600"></p>

* iteration 1: User 1이 가장 강함 -> 검출 후 제거
* iteration 2: User 2 검출 -> 제거
* iteration 3: User 3 검출
* BER(bit error rate) 순서 : 
* 강한 신호부터 제거하므로 User 1 < User 2 < User 3 순으로 정확도가 낮아짐


&ensp;요약<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-26.png" width="600"></p>

&ensp;Serial Interference Cancellation 수신기<br/>
* 목적: 여러 사용자의 신호가 동시에 수신될 때 가장 강한 사용자부터 하나씩 신호를 복원 -> 재생 -> 제거하여 다른 사용자의 신호를 추출
* 전제 : 사용자 전력이 서로 다르고 P1 > P2 > ... > $P_{Nu}$

1. 수신 신호(기저대역 평균)
&ensp;$\bar{r}(t) = \sum_{m=1}^{N_u} \sqrt{\frac{E_m}{T_b}}\, b_m(t - \tau_m)\, c_m(t - \tau_m)$

2. 간섭 제거 1 단계
&ensp;가장 강한 사용자 m =1 신호를 복원 후 제거:
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-28.png" width="600"></p>

3. 사용자 1의 신호 재생
&ensp;$r_{1}(k) = \sqrt{\frac{E_{1}}{T_{b}}}b\hat{}_{1}(t-\tau _{1})c_{1}(t-\tau _{1})$ 

4. 간섭 제거 2 단계(사용자 2)
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-29.png" width="600"></p>

* 이전 단계에서 복원이 완벽하지 않으면 오차 성분이 누적됨

&ensp;kth Iteration(일반화)<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-30.png" width="600"></p>

5. 결정변수
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-31.png" width="600"></p>

&ensp;SIC 수신기 간섭 제거 흐름도<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-32.png" width="600"></p>

Transmit Diversity
======

* Multiple antenna diversity
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-33.png" width="600"></p>

&ensp;📌 핵심 내용 요약<br/>
* Multiple-antenna techniques는 송신기(Tx)와 수신기(Rx) 양쪽에 여러 개의 안테나를 사용하여 성능을 향상시키는 방식이다.
* 각각의 전송 방식은 특정 성능 목표에 따라 구분된다. 
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-34.png" width="600"></p>

&ensp;⚖️ 핵심 개념: Trade-off 관계<br/>
* 예) Multiplexing gain을 높이면 전송률은 올라가지만 오류율이 증가.
* 반대로 Diversity gain은 오류율을 줄이지만 데이터 전송 속도에 영향을 줄 수 있다.

&ensp;STTD (Space-Time Transmit Diversity)<br/>
&ensp;📌 STTD란?<br/>
* STTD는 WCDMA에서 사용되는 송신 다이버시티 기법.
* 2개의 송신 안테나를 이용해 동일한 정보를 시간과 공간을 나누어 전송함.
* 수신기는 다중 경로에서 정보를 조합하여 더 높은 신뢰도로 데이터를 복원함.

&ensp;📂 주요 구성 요소 및 흐름<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-35.png" width="600"></p>

1. 입력 데이터
  - QAM mapper를 통해 복소수 신호 $x_{1}(t)$ , $x_{2}(t)$ 로 변환된다. 
2. STTD Encoding:
  - 두 심볼을 시간과 안테나에 분산시켜 전송.
  - 타임 슬롯 기준:
    + $t_{1}$ : 안테나 1에서 $x_{1}$, 안테나 2에서 $x_{2}$ 전송
    + $t_{2}$ : 안테나 1에서 $x_{1}^{*}$, 안테나 2에서 $x_{2}^{*}$ 전송
    * 수학적 구조:
    &ensp;$\begin{bmatrix} x_{1} & x_{2} \\-x_{2}^{*} & x^{*} \\ \end{bmatrix}$
3. Complex Spreading:
  - 확산코드 $c_{1}(t)$ , $c_{2}(t)$ 를 복소 형태로 사용
  - $c_{1}(t) + jc_{2}(t)$ 와 같은 형식으로 각각의 송신 신호에 곱해져 다이버시티를 극대화
4. 수신 측 (Rx):
  - 두 안테나의 채널 응답 $h_{1}(t)$ , $h_{2}(t)$ 을 이용해 채널 등화를 수행하고
  - STTD 구조에 따라 합산 복원을 수행하여 심볼 복원.

1. Transmit Diversity: 송신 신호와 수신 신호<br/>
* 송신 신호 구조
  - 두 개의 송신 안테나에서 전송되는 STTD 부호화 신호:
    + 안테나 1
    <p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-36.png" width="600"></p>

    + 안테나 2
    <p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-37.png" width="600"></p>

&ensp;-> 두 안테나는 서로 다른 시간에 conjugate, 음수 부호 등을 달리하여 보냄<br/>
* 수신 신호 구조
  - 수신기에서는 두 안테나의 채널 $h_{1}(t), h_{2}(t)$ 를 통해 도달한 $s_{1}, s_{2}$ 를 수신하고,
    + 예를 들어 첫 번째 기호 구간에서는: 
    &ensp;$r_{1}(t) = α_{1}s_{1}(t) + α_{2}s_{2}(t)$C <br/>
    &ensp;를 통해 합성 수신 신호가 생성됨<br/>

2. Transmit Diversity: Decision Variable 구성
* 수신기에서는 각 기호 구간의 결정을 위해 다음과 같은 연산 수행:
  + 첫 번째 심볼에 대한 decision variable:
  &ensp;$y_1 = \int_{t_k}^{t_k + T_s} r_1(t)\, w(t)\, dt = E_s \left[ \alpha_1 x_i1 - \alpha_2 x_i2^* \right]$ <br/>

  + 두 번째 심볼에 대한 decision variable: 
  &ensp; $y_2 = \int_{t_k}^{t_k + T_s} r_2(t)\, w(t)\, dt = E_s \left[ \alpha_2 x_i2 - \alpha_1 x_i1^* \right]$ <br/>

  + 이 두 결과를 결합해서 원하는 기호 복원:
  &ensp;$z_1 = \alpha_1^* y_1 + \alpha_2 y_2 \Rightarrow E_s \left( |\alpha_1|^2 + |\alpha_2|^2 \right) x_i1$ <br/>
&ensp;-> 채널 이득 × 원래 보낸 심볼 복원이 가능

3. Transmit Diversity: 심볼 복원 결과
* 앞으로 나온 $Z_{1}$ 와 유사하게 $z_{2}$ 는 다음과 같이 구성됨:
&ensp;$z_2 = \alpha_2^* y_2 + \alpha_1 y_1 \Rightarrow E_s \left( |\alpha_1|^2 + |\alpha_2|^2 \right) x_2$ <br/>
* 즉 두 개의 송신 경로의 channel gain을 조합한 신호 강도로 원래의 심볼이 복원됨:
  - 더 많은 diversity 경로를 확보할 수 있다.
  - ->fading에 강함 + 에러 확률이 낮아짐

&ensp;왜 diversity가 성능을 향상시키는가?<br/>
&ensp;📌 요점 요약<br/>
1. **다이버시티(Diversity)**란?
* 동일한 정보 신호를 **서로 독립적인 여러 경로(채널)**를 통해 전송하는 기술
* 대표작 예: STTD 등
2. 핵심 장점:
* 모든 채널이 동시에 페이딩(fading)되는 확률이 매우 낮음
* 따라서 최소 하나의 채널은 양호한 품질을 유지하고 있을 가능성이 높음
* 결과적으로 전체 수신 신호의 신뢰도와 성능이 향상됨

&ensp;그래프 해석: $h_{1}(t)$ , $h_{2}(t)$ 두 채널 이득 변화 <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-38.png" width="600"></p>

* x축 시간(time[sec])
  - 예: 0.03초 ~ 0.1초 구간
* y축: 채널 이득(Chaneel amplitude[dB])
  - 수신된 신호의 강도
  - 낮을수록 신호 감쇄(fading)가 심함 -> 특히 Deep fading 이 성능 저하의 핵심 원인
* 파란 선 $h_{1}(t)$ , $h_{2}(t)$ : 
  - 서로 독립적인 두 채널의 페이딩 특성
  - 두 선이 동시에 -10 dB 이하로 떨어지는 경우는 매우 드뭄
  - 보통 한 채널이 deep fading에 빠질 때 다른 채널은 양호한 상태

&ensp;Deep Fading에 대한 해석<br/>
* Deep fading: 수신 신호 강도가 매우 약해져 **비트 오류율(BER)**이 크게 증가하는 현상
* 위 그래프에서는:
  - 예: $h_{1}(t)$ , $h_{2}(t)$ 가 모두 -10dB 아래로 떨어진 경우는 아주 짧음
  - 동시에 페이딩 확률이 낮다 -> 수신 신호의 **합산 이득(combined gain)** 을 통해 복원이 가능

&ensp;✅ 결론: 다이버시티의 효과<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-39.png" width="600"></p>

&ensp;Space-Time Block Code (STBC)<br/>
* STBC는 공간(안테나) + 시간 축을 활용한 코딩 방식으로, 송신 diversity를 제공하여 수신 성능을 높이는 기술
* 가장 대표적인 STBC는 Alamouti 코드이다.

1. 송신부 구조 
* 입력
  - x(t): QAM 또는 PSK로 변조된 신호
  - S/P 변환을 통해 두 심볼로 나눔 -> $x_{1}, x_{2}$
* STBC 인코딩
&ensp;STBC 인코딩은 아래와 같이 2개 심볼을 시간과 안테나 축으로 재배열한다:
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-40.png" width="600"></p>

&ensp;즉, 한 시간에 하나의 안테나에서만 송신하는 방식이다.<br/>

2. 📡 채널과 수신부

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-42.png" width="600"></p>

&ensp;채널 계수<br/>
* $α_{1}$ : 안테나 1에서 수신기까지의 채널
* $α_{2}$ : 안테나 2에서 수신기까지의 채널

&ensp;수신신호<br/>
&ensp;두 시간 구간에서의 수신 신호는 다음과 같다<br/> 
&ensp;수신 1: <br/>
&ensp;$y_{1} = α_{1}x_{1} + α_{2}x_{2} + n_{1}$ <br/>
&ensp;수신 2: <br/>
&ensp;$y_{2} = -α_{1}x_{2}^{*} + α_{2}x_{1}^{*} + n_{2}$ <br/>

3. 수신기에서의 복원 (Decoding)
&ensp;이제 $y_{1}, y_{2}$를 바탕으로 $x_{1}, x_{2}$ 를 복원한다. <br/>
&ensp;복원 수식 정리: <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-41.png" width="600"></p>

&ensp;-> STBC 구조 덕분에 두 심볼을 독립적으로 복원할 수 있고, 채널 간섭이 상쇄된다.

&ensp;🎯 성능 향상 포인트<br/>
* Diversity Gain: 두 개의 독립적인 경로로 인해 페이딩의 영향을 극복 가능
* Channel estimation만 정확하다면 간단한 선형 연산으로 복원이 가능
* 수신기 복잡도는 낮고, 성능은 향상됨

Spatial Multiplexing
======

&ensp;Transmitter<br/>
&ensp;🧩 시스템 구조<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-44.png" width="600"></p>

* 송신 신호 흐름
1. 원본 비트열 b(t) -> QAM mapper: 심볼 x(t) 생성
2. MIMO encoder에서 송신 엔테나 수만큼 분할:
  - $x_{1}(t), x_{2}(t)$ : 서로 다른 두 심볼
3. Complex spreading:
  - 확산 코드 $c_{1}(t), c_{2}(t)$ 와 정규화된 직교 가산 $jc_{2}(t)$ 이용
  - 송신신호: 
  $ s_{1}(t) = \sqrt{\frac{E_{s}}{T_{s}}}x_{1}(t)w(t)$ , 
  $ s_{2}(t) = \sqrt{\frac{E_{s}}{T_{s}}}x_{2}(t)w(t)$
4. 각 안테나는 s1(t), s2(t)를 다른 채널 $h_{ij}(t)$ 을 통해 전송

&ensp;receiver<br/>
&ensp;🧩 수신기 구조<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-43.png" width="600"></p>

1. 수신 안테나 출력:
&ensp;$r_{1}(t), r_{2}(t) = h_{11}s_{1}(t) + h_{12}(t)s_{2}(t) , h_{21}s_{1}(t) + h_{22}s_{2}(t)$ <br/>
2. 복소 확산 코드 제거 (despreading):
  - $c_{1}(t) - jc_{2}(t)$ 를 곱하고 적분 -> $y_{11}, y_{12}$
3. MIMO Detection:
  - 공간적으로 겹친 신호를 분리 (ex. Zero-Forcing, MMSE detection 등)
  - 출력: $z_{1}, z_{2}$ -> 복조기(QAM demapper)

&ensp;🧮 수신 신호 수식<br/>
&ensp;$r_m(t) = \alpha_{m1} s_1(t) + \alpha_{m2} s_2(t) = T_s E_s \left[ \alpha_{m1} x_1(t) + \alpha_{m2} x_2(t) \right] w(t) + n_m(t)$

&ensp;🎯 핵심 요점<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-45.png" width="600"></p>

&ensp;Correlation Output (수신 신호 처리)<br/>

&ensp;💡 목적<br/>
&ensp;수신 신호에서 기저대역 심볼 $x_{1}, x_{2}$ 를 복원하기 위해 복소 확산 코드 제거 후 적분하는 과정이다.<br/>

1. 첫 번째 안테나 출력
&ensp;$y_1 = \int_{(i)T_s}^{(i+1)T_s} r_1(t)\, w^*(t)\, dt$  <br/>
* 여기서 $r_{1}(t)$ 는 첫 번째 수신 안테나의 신호이며 w(t)는 전송 신호에 공통으로 곱해졌던 확산 파형
* 복조 시 conjugate $w^*(t)$를 곱해 적분

&ensp;전개하면<br/>

<p align="center">$y_{i1} = \sqrt{E_s}\alpha _{11}x_{i1} + \sqrt{E_s}\alpha _{21}x_{i2} + n_1$ </p>

2. 두 번째 수신 안테나
&ensp;동일하게 적용하면:<br/>

<p align="center">$y_{i2} = \sqrt{E_s}\alpha _{12}x_{i1} + \sqrt{E_s}\alpha _{22}x_{i2} + n_2$  </p>

&ensp;행렬 표현<br/>
&ensp;위 두 수식을 벡터와 행렬로 표현하면: <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-46.png" width="600"></p>

&ensp;Combined Decision Variable (MIMO Detection)<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-47.png" width="600"></p>

Multicode
======

&ensp;1️⃣ 우리 상황 상상해볼까?<br/>
* 당신은 무전기 1대로 친구한테 말을 하고 있다.
* 그런데 한 번에 한 마디씩만 말하면 시간이 오래 걸리겠죠?
* 그래서 3개의 무전기를 사용해서 친구한테 동시에 3마디를 보내는 거다!
&ensp;바로 이게 멀티코드 방식이다. <br/>

&ensp;2️⃣ 어떻게 작동할까?<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-48.png" width="600"></p>

* 입력 데이터 b(t)
  - 먼저, 보낼 메시지를 3조각으로 나눈다. 
    + 예: b1(t), b2(t), b3(t) ← 각각은 전송할 작은 메시지 조각
* S/P 블록
  - 이건 나누기 블록이다.
  - b(t)를 3개의 작은 b1, b2, b3로 나눈다.
* 각 조각을 각각 다른 "비밀 코드"로 섞는다.
  - 각각은 w1(t), w2(t), w3(t)라는 다른 코드랑 곱해진다. 
*  그리고 다 더한다!
  - 마지막에 b1*w1 + b2*w2 + b3*w3 이런 식으로 합쳐진다.
  - 즉, 하나의 신호로 보이지만, 안에 세 가지 메시지가 섞여있는 거다.
* 곱하고 보내기
  - 이 메시지는 w(t)와 다시 곱해지고, cos(2πf₀t) 신호랑 곱해서 전파를 타고 날아간다.

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-49.png" width="600"></p>

1. b1(t), b2(t), b3(t) - 우리가 보낼 세 조각 메시지
2. w₁(t), w₂(t), w₃(t) - 각각의 메시지에 곱할 비밀코드
  - 이건 1과 -1로 구성된 특별한 패턴이다.
  - 예: w₁(t) = [1, -1, -1, 1, 1]
3. 각각의 b₁(t), b₂(t), b₃(t)를 코드랑 곱한다.(2, 3, 4 번 그림이 그 과정)
4. 5번 그림은 그 세 신호를 모두 더한 것
  - 어떤 부분은 겹쳐서 커지고, 어떤 건 없어지기도 한다. 
5. 6번은 그 합쳐진 신호가 전파로 바뀐 모습이다.
  - 복잡한 모양이지만 나중에 코드 w₁, w₂, w₃를 이용하면 다시 풀 수 있다.

&ensp;Reveiver<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-50.png" width="600"></p>

&ensp;수신된 신호는 여러 메시지($w_1, w_2, w_3$ 로 인코딩된 편지)가 섞인 상태다.<br/>
&ensp;수신기는 다음 과정을 거친다: <br/>
1. LPF를 통해 고주파를 없애고 기본 신호만 남겨
2. $w_1(t)$ 로 곱해서 내가 찾는 메시지에 해당하는 부분만 꺼내
3. 그 다음 시간에 따라 평균을 계산(적분)해서 $z_1$ 을 만들어
4. z₁ > η이면 이 편지는 "1"이야, z₁ < η이면 이 편지는 "0"이야
&ensp;이걸 w₂(t), w₃(t)에 대해서도 똑같이 한다.

&ensp;Multicode in WCDMA uplink<br/>
&ensp;🔍 전체 개요<br/>
* 우리가 보내려는 데이터: DPDCH(Dedicated Physical Data CHannel)
* 추가 정보나 제어신호: DPCCH (Dedicated Physical Control CHannel)
* 멀티코드를 사용해서 데이터 속도를 높이고,
* 채널화 코드 (w₀(t)~w₅(t)) 와 스크램블 코드 (c₁(t)+jc₂(t)) 로 다중 사용자를 구별함

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-51.png" width="600"></p>

&ensp;📦 구조 해설<br/>
1. DPDCH → S/P
* 전송할 데이터 비트를 여러 개의 DPDCH로 나눔 -> 병렬 처리: 데이터 전송 속도 향상

2. 각각의 DPDCHᵢ × wᵢ(t)
* 각각의 데이터 채널은 서로 다른 채널화 코드 wᵢ(t)와 곱해짐
  - 이걸 통해 각 채널의 데이터 신호가 고유해짐
  - 서로 간섭 없이 구분 가능
&ensp;예: w₀(t), w₁(t), ..., w₅(t)는 직교해서 서로 간섭이 없음<br/>

3. 채널들을 두 그룹으로 나눔: I채널 / Q채널
* I (In-phase), Q (Quadrature) → 복소수 표현을 위한 두 축
* 6개의 DPDCH 중 일부는 I 브랜치, 나머지는 Q 브랜치로 감
* 각 브랜치에서 합(sum) 계산해서 하나의 신호로 만듦

4. Scrambling: c₁(t) + j·c₂(t)
* Scrambling code를 통해 사용자마다 **신호의 '서명'**을 부여
* 복소수 코드 c₁(t) + j·c₂(t) 와 곱해서 전송 전 마지막 사용자 식별을 보장

5. 두 브랜치 결합 및 Upconversion
* I-브랜치 × 캐리어 cos파 (𝜙₁)
* Q-브랜치 × 캐리어 sin파 (𝜙₂)
* 두 신호를 더해 s(t)라는 최종 무선 신호를 생성

&ensp;receiver<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-52.png" width="600"></p>

1. 신호 분리 준비(LPF: Low Pass Filter)
* 받은 소리를 저주파만 남도록 필터링함 (쓸데없는 고주파 잡음 제거)
* 위쪽은 I 채널 (실수 성분),
* 아래쪽은 Q 채널 (허수 성분)

2. 코드로 다시 분리하기
* 예: w₁(t), w₂(t) ... w₆(t)
* 각 코드로 곱해서 각각의 신호를 뽑아냄!

3. 적분 (신호 평균 내기)
&ensp;각 코드별로 곱한 결과를 일정 시간 동안 평균을 냄 -> 이걸 수식으로는 **∫ (적분)**이라고 함<br/>
&ensp;그럼 1이라고 말했는지 0이라고 말했는지 알 수 있다.<br/>

4. 판단하기 (비트 복원)
* 각 평균값이 기준값 η보다 크면 -> 1,
* 작으면 -> 0으로 판단해서 다시 원래 데이터로 복원함!

5. 마지막 단계
* 분리한 6개의 결과를 다시 차례대로 합쳐서 원래의 데이터 비트열 bᵢ를 만든다.(이걸 P/S 변환기가 한다. 병렬-> 직렬)

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-53.png" width="600"></p>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-54.png" width="600"></p>

Maximum Data Rate
======

&ensp;동기CDMA 전송속도<br/>
* 2G: 문자나 간단한 데이터를 느리게 보낼 수 있었음
* 3G: 사진, 동영상까지 빠르게 전송 가능

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-55.png" width="600"></p>

&ensp;2G<br/>
* IS-95 (2G 초기)
  - 속도: 9.6~14.4kbps
  - 아주 느림. 문자 보내기 딱 좋은 정도
  - BPSK (1비트를 한 번에 전송)
* IS-95B
  - 속도: 115.2kbps (x8 향상)
  - 한 번에 여러 채널을 사용해서 속도 ↑
  - 여전히 BPSK이지만 여러 개 묶어서 송신
* CDMA2000-1x (Release 0)
  - 속도: 153.6kbps
  - 채널 품질을 개선해서 속도 ↑
* CDMA2000-1x (Release A)
  - 속도: 307.2kbps (x2 향상)
  - 변조 방식이 QPSK로 바뀜 → 한 번에 2비트 전송 가능해서 속도 ↑

&ensp;3G<br/>
* EV-DO Rel. 0
  - 속도: 2.4576Mbps
  - 변조 방식: 16QAM (한 번에 4비트 전송!)
  - Coding: 2/3 → 2개의 데이터에 1개의 에러보정코드 추가
* EV-DO Rev. A
  - 속도: 3.072Mbps
  - Coding이 5/6 → 에러보정이 줄어들고 실제 데이터 양 ↑
* EV-DO Rev. B
  - 속도: 최대 14.7Mbps
  - 64QAM 사용 → 한 번에 6비트 전송!
  - 멀티캐리어 사용: 주파수를 3개나 동시에 사용 (병렬 처리 느낌!)

&ensp;✨ QAM, BPSK, QPSK<br/>
* BPSK: 1비트 전송 (ex. 0이면 왼쪽, 1이면 오른쪽)
* QPSK: 2비트 전송 (00, 01, 10, 11 네 가지 각도로 표현)
* 16QAM: 4비트 전송 (더 많은 점으로 세밀하게 표현)
* 64QAM: 6비트 전송 (복잡하지만 훨씬 많은 정보 전송 가능)

&ensp;목표: 7.2kbps 데이터를 19.2kbps로 바꾸기까지의 과정!<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-56.png" width="600"></p>

1. 원래 데이터
* 입력: 1 0 1처럼 생긴 비트열
* 전송 속도: 7.2 kbps
* 이게 우리가 처음 전송하고 싶은 진짜 데이터

2. Channel Encoder (rate 1/2)
* 1개의 비트를 -> 2개의 비트로 바뀜
* 이유: 에러가 나도 복구할 수 있게 하기 위해
* 결과: 7.2kbps -> 14.4kbps
* 예시: 1 -> 10, 0 -> 01 같은 방식으로 두 배로 만듦

3. Symbol Repetition (2회 반복)
* 비트 하나하나를 2번씩 반복
* 예시: 1 0 1 -> 1 1 0 0 1 1
* 결과: 14.4kbps → 28.8kbps
* 이유: 노이즈 때문에 깨질까봐 한 번 더 보냄

4. Puncture (삭제)
* 반복해서 길어진 데이터를 조금 잘라냄
* 예시: 6개 중 2개 제거 -> 4개만 유지
* 결과: 28.8kbps → 19.2kbps
* 똑같은 걸 2번 보냈지만 일부만 남기니까 데이터가 적당히 안전하면서도 빠르게 전송됨

5. 결과
* 최종적으로 원래 7.2kbps -> 19.2kbps로 향상
* 효율은 좋아졌고 에러 복원도 가능한 상태

&ensp;요약<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-57.png" width="600"></p>

&ensp;왜 이렇게 복잡하게 할까?<br/>
* 무선 환경은 잡음, 끊김, 간섭이 많다.
* **신호를 반복하거나 추가 정보**를 더해서 안전하게 전달하려는 거다. 

&ensp;Cannel coding<br/>
* Convolutional Encoder란?
&ensp;데이터를 더 안전하게 전송하기 위해 입력 데이터를 규칙적으로 섞고 늘리는 장치이다.<br/>
&ensp;하나의 입력 비트가 들어오면 두 개의 출력 비트가 나간다. <br/>
&ensp;그래서 **1/2 rate** 라고 부른다. (입력 1개 -> 출력 2개)<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-58.png" width="600"></p>

1. 왼쪽 블록 다이어그램
* 입력 비트: aᵢ(한 비트씩 들어옴)
* 메모리 셀: s₁(t)와 s₀(t) -> 최근 입력 비트를 기억해놓은 장치(총 2개의 기억장치)
* 모듈로 2 덧셈기(⊕): 
  - 비트 계산: 1 + 1 = 0, 0 + 1 = 1 같은 XOR 연산
  - bᵢ, cᵢ 두 개의 출력 비트를 만듦

2. 오른쪽 테이블(시물레이션 표)
* Clock Pulse: 시간 흐름(1, 2초처럼 단계)
* Input  aᵢ: 그 순간에 들어온 데이터
* State s₁, s₀: 이전에 기억하던 두 개의 값
* Output bᵢ, cᵢ: ⊕ 계산 결과로 출력된 두 개의 비트

&ensp;예시로 흐름을 따라가 보자! <br/>
&ensp;처음 상태: s₁ = 1, s₀ = 1<br/>
1. 입력 aᵢ = 0
  - s₁ = aᵢ = 0, s₀ = 이전s₁ = 1
  - 출력 bᵢ = aᵢ ⊕ s₀ = 0⊕1 = 1
  - 출력 cᵢ = aᵢ ⊕ s₁ ⊕ s₀ = 0⊕1⊕1 = 0
2. 다음 입력 aᵢ = 0
  - s₁ = 0, s₀ = 0
  - bᵢ = 0⊕0 = 0, cᵢ = 0⊕0⊕0 = 0
3. 다음 입력 aᵢ = 1
  -  s₁ = 1, s₀ = 0
  - bᵢ = 1⊕0 = 1, cᵢ = 1⊕1⊕0 = 0

&ensp;이 방식을 사용하는 이유<br/>
* 통신 중에 오류가 생기더라도 복원할 수 있게 하기 위해서
* 데이터를 늘려서 보냈기 때문에 수신기가 더 똑똑하게 복구할 수 있다.
* 이런 걸 **에러 정정 코드(Error Correctin Code, ECC)**라고 부르기도 한다. 

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-59.png" width="600"></p>

&ensp;전송 과정 설명<br/>

1. 데이터 입력
* RS1 또는 RS2에서 데이터를 받는다. 
* 예: RS2에서는 14.4 kbps, 7.2 kbps, 3.6 kbps, 1.8 kbps 이건 통화 품질에 따라 다르다.

2.  채널 부호화 (Channel encoder rate 1/2)
* 한 비트를 두 개로 늘려서 전송 오류에 강하게 만듦.
*  왜 두 배로 늘리냐면?: 잘못 전달되었을 때 복원하기 쉽게 하기 위해서이다. (convolution encoder라고 생각하면 됨)

3. 심볼 반복 (Symbol repetition)
* RS1에서는 반복 안 하고, RS2는 두 번씩 심볼을 반복해서 보냄.(예: 14.4 kbps × 2 = 28.8 kbps)

4. 펑처링 (Puncture 2 of every 6)
* 너무 많이 늘어나면 안 되니까, 일부 심볼은 버림(제거) -> 6개 중 2개 삭제 -> 데이터 압축 효과 ->  28.8 kbps × (4/6) = 19.2 kbps

5. 확산 (Spreading)
* DMA는 모든 사용자들이 같은 주파수를 사용하므로, 서로 섞이지 않게 각자만의 코드를 곱해서 보냄 (→ Walsh 코드)
* Walsh 코드
  - 각 사용자는 서로 직교하는(=서로 겹치지 않는) 코드 사용
  - 칩 속도: 1.2288 Mcps
  - 데이터 속도: 19.2 kbps
  - 확산비(Spreading Factor, SF): SF = 1.2288M / 19.2K = 64 -> 데이터 1비트마다 64개의 칩 전송

6. Scrambling (Short PN 코드)
* Walsh 코드로 확산한 후 **PN 코드(무작위 코드)**도 곱함
* 사용자들이 송신 타이밍이 다르더라도 구분되게 함
* 코드 종류
  - Short PN Code 1: I 채널(실제 데이터)
  - Short PN code 2: Q 채널(위상 90도 차이)

&ensp;무선 채널구조<br/>
* ownlink CDMA Channel (1.25 MHz) -> 여러 채널이 있음(W = 0부터 W = 63까지) -> 각 채널도 Walsh 코드로 구분됨

