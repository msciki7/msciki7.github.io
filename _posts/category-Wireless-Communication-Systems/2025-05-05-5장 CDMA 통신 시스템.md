---
title: "5장 CDMA 통신 시스템"
excerpt: ""

wirter: sohee Kim
categories:
  - Wireless Communication Systems
tags:
  - Wireless Communication System

toc: true
use_math: true 
toc_sticky: true

date: 2025-05-05
last_modified_at: 2025-05-05
---

CDMA PN code
======

&ensp;IS-95 CDMA PN code<br/>
&ensp;CDMA는 여러 사용자가 동일한 주파수를 공유하면서 통신할 수 있도록 하기 위해 각 사용자에게 고유한 코드(PN 코드)를 부여해서 신호를 확산한다. 이 과정에서 사용자 구분, 기지국 구분, 암호화를 위한 여러 코드들이 함께 사용된다. <br/>

&ensp;BS Transmitter(기자국 송신기) <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-1.png" width="600"></p>

1. Long PN Code(보안용)
* 보통 암호화 또는 개인 정보 보호용으로 사용
* 사용자마다 다르게 설정된다.
* 데이터 암호화라고 표시된 부분에서 사용된다.

2. Walsh Code(직교 코드)
* 여러 사용자들 동시에 구분하는 데 사용
* IS-95에서는 각 사용자는 서로 다른 직교 Walsh 코드를 배정받는다.
* 채널 구분(사용자 간 구분) 역할 수행

3. Short PN Code 1, 2
* 기지국 구분 용도
* 모든 기지국이 공유하는 PN 코드지만 서로 다른 시작점으로 사용된다.
* 출력 신호를 두 갈래로 나누어 하나는 일반 캐리어, 다른 하나는 90도 위상차를 주어 I/Q 신호로 전송

&ensp;MS Transmitter(모바일 기기 송신기) <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-2.png" width="600"></p>

* M-ary Walsh modulation : 다중 비트 데이터를 효율적으로 표현
* Long PN Code : 모바일 사용자 식별 및 보안 역할
* Short PN Code 1, 2 : 1/2 칩 지연를 적용해 두 경로를 위상 차 있게 만들고 이후 결합하여 복소수 성분으로 만드는 구조이다.  

&ensp;OVSF code <br/>

&ensp; CDMA 시스템에서 직교성을 유지하면서도 유동적인 확산 계수(SF: Spreading Factor)를 갖는 확산 코드<br/>
&ensp;사용자마다 데이터 속도가 다르므로 코드 길이(SF)를 다르게 해줄 필요가 있는데, 그 와중에도 서로 간섭하지 않도록 만들어주는 것이 OVSF 코드<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-3.png" width="600"></p>

&ensp;서로 다른 코드끼리는 곱해서 평균이 0이 되어야 한다. = 간섭하지 않음

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-4.png" width="600"></p>

&ensp;부모-자식 간 직교성 불가<br/>
&ensp;예: (1, 1, 1, 1)과 (1, 1, -1, -1)은 서로 직교하지 않는다. 같은 경로에 있기 때문에.<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-5.png" width="600"></p>

1. $w_{6}(t)$ - 코드 시퀀스: (1, -1, 1, -1, 1, -1, 1, 1)
* 시간 $T_{c}$ 단위로 정의된 코드 시퀀스
* 각각의 비트는 +1 또는 -1로 표현되며 $T_{c}$ 만큼 지속된다
* Walsh 코드 /OVSF 코드의 한 예이다.

2. $w_{7}(t)$ - 코드 시퀀스: (1, -1, -1, 1, -1, -1, 1, 1)
* 다른 Walsh 코드이다.
* $T_{c}$ 단위의 신호 블록들로 구성된다.

3. $w_{6}(t)w_{7}(t)$
* 두 시퀀스를 원소별로 곱한 결고를 보여준다.

Rake receiver
======

&ensp;여러 개의 다중경로(multipath) 신호를 각각 추적해서 각각의 지연(τ)을 보상하고 이를 결합(combining)하여 수신성능을 향상시키는 구조이다. <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-6.png" width="600"></p>

1. Multipath 환경
* 송신된 신호는 건물 등 환경으로 인해 여러 경로를 통해 수신기에 도달
* 각 경로는 다른 감쇠 계수(α₁, α₂, α₃)와 지연(τ₁, τ₂, τ₃)을 가진다.
* 이 경로들 중 중요한 것들을 추적하여 각각 복조함

2. RAKE 구조
* LPF : 각 경로 신호를 저역통과시킴
* 지연 보상 : 각 경로의 지연에 맞춰 신호를 보정
* BPSK Finger : 각 지연 성분에 대해 복조를 수행하는 finger
* Searcher : 유효한 다중경로를 탐색해서 적절한 finger에 할당함

3. Combiner(결합기)
* 각 BPSK Finger 출력에 대해 채널 계수 $|α_{i}|$ 에 비례하는 가중치를 부여해 결합
* 출력 신호는 여러 경로의 constructive gain을 활용한 합성 결과
* 결과적으로 SNR(Singnal-to-Noise Ratio)을 향상시킴

PN Code Acquisition
======

&ensp;목적<br/>
&ensp;수신기는 받은 PN코드의 시작점을 모르므로 자신이 만든 PN코드를 여러 타이밍으로 이동시키며 비교해봐서 **타이밍 offset τ**을 알아낸다.<br/>

&ensp;실제 계산 방법<br/>
&ensp;수신 코드 c(t)와 로컬 코드 c(t)를 비트마다 곱하고 모두 더한다.<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-7.png" width="600"></p>

&ensp;코드에 0를 추가한 이유는 상관기(correlator)에서 연산할 때 필요한 비트 수를 정확히 맞추기 위한 패딩이다. <br/>

&ensp;z(t) 값이 가장 높게 나올 때 = 코드가 정렬됨 -> 이 시점을 찾는 것이 acquisition의 핵심<br/>

&ensp;Serial PN code acquisition<br/>

&ensp;$η_{s}$ 는 serial search acquisition에서 수신 신호와 로컬 PN 코드 사이의 상관값 $z_{i}$ 를 평가할 때 사용하는 탐색 임계값이다. <br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-8.png" width="600"></p>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-9.png" width="600"></p>

&ensp;단계별 상세 설명<br/>

1. Uncertainty Region
* 수신기의 PN 코드 생성기는 송신기의 코드와 위상이 맞지 않음
* 전체 주기 내 어디서 시작했는지 모르므로 모든 가능한 시작점을 탐색해야 함
* 예: PN 코드 길이가 15라면, 최대 15개의 시작 지점을 검사해야 함

2. Search Mode (탐색 단계)
* r(t) : 수신 신호
* $c(t - \tau _{r})$ : 로컬 PN 코드, 현재 테스트 중인 offset
* I-Q Matched Filter (MF):
* 실제 신호 r(t) 와 PN 코드 $c(t - \tau _{r})$  의 상관값  $z_{i}$ 계산
* 결과 : $z_{i} = \int r(t)c(t-\tau _{r})dt$
* 판단 : 이 $z_{i}$ 값이 임계값 $\eta _{s}$ 를 넘으면 -> 후보 offset $\tau \hat{} = \tau _{r}$ 
* 넘지 않으면 -> 다음 offset $\tau _{r} + 1$ 로 이동하여 반복

3. Verification Mode (검증 단계)
* 후보 $\tau \hat{}$ 가 진짜인지 확인하기 위해 여러 번 상관값을 측정
* B out of A 방식 : 
* 예: 10번 테스트 중 8번 이상이 threshold $η_{v}$ 를 넘기면 -> 확인 완료
* 목적: **우연히 발생한 높은 상관값(노이즈)**인지 필터링

4. Tracking Mode (추적 단계)
* 이후에는 아주 미세한 시간차이 $(\delta \tau )$ 까지 조정
* Fine synchronization 수행
* 이 단계부터는 코드 동기화가 거의 맞춰진 상태

&ensp;Non-coherent I-Q matched filter<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-10.png" width="600"></p>

&ensp;수신한 신호 r(t)에서 정확한 PN 코드 offset( $\tau$ )을 찾기 위해 위상 정보 없이도 사용할 수 있는 비동기 방식의 상관값 $z_{i}$ 를 계산<br/>

1. r(t) : 수신 신호
&ensp;$r(t) = \sqrt{E_{b}}b(t-\tau )c(t - \tau )\varphi  (t + \theta ) + n(t)$

2. 반송파 동기화 없이 분리하기 위해 I/Q 분해
* 상단 : 
<p align="center">$\varphi _{1}(t) = cos(2\Pi f_{c}t) $</p>

&ensp;->In-phase(직류) 성분 추출
* 하단 : 
<p align="center">$\varphi _{2}(t) = sin(2\Pi f_{c}t)$</p>
&ensp;-> Quadrature(직각 위상) 성분 추출

3. Low Pass Filter (LPF)
* 반송파 성분 제거, baseband로 변환
* 이 후 신호는 $r(t)cos(2\Pi f_{c}t)$ 와 $r(t)sin(2\Pi f_{c}t)$ 로 분리된 baseband 신호

4. PN 코드 정렬 여부 확인용 상관기
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-11.png" width="600"></p>

5. $z_{i} = z_{c}^{2} + z_{s}^{2}$
* 위상 정보 $\theta $ 없이도 절대적인 correlation 정도를 측정 가능

&ensp;최종 결정 변수 : $\theta z_{i} = z_{c}^{2} + z_{s}^{2} = E_{b}R^{2}(\tau -\tau _{r})$ <br/>
&ensp;->위상 $\theta $ 에 무관하게 최대값이 정확한 offset에서 발생<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-12.png" width="600"></p>

&ensp;흐름 설명<br/>
&ensp;serach mode<br/>
* Local PN 코드 $c(t- \tau _{r})$ 를 다양한 지연으로 적용
* 수신 신호와 상관하여 상관값 $z_{i}$ 계산
* $z_{i} > \eta _{s}$ 인 지점을 탐색 후보( $\tau _{r}$ )로 간주

&ensp;verification mode<br/>
* 탐색된 후보가 우연히 나온 잡음인지 확인
* 여러 상관값이 threshold $\eta _{s}$ 를 넘는지 판단 -> B out of A 조건 만족 시 확인

&ensp;acquisition point<br/>
* 수신기의 PN 코드와 정확히 일치하는 시작점은 $\tau = \tau _{r}$
* 이 시점에서 $z_{i}$ 최대 -> 동기화 성공

&ensp;Parallel PN code Acquisition 구조<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-13.png" width="600"></p>

* serial 방식과 달리 여러 개의 offset을 동시에 계산 -> 탐색 시간 단축
* 고속 프로세서나 하드웨어로 병렬 처리 가능

&ensp;흐름 구성도<br/>

1. Uncertainty Region
* 전체 가능한 offset에 대해 모두 병렬 검사

2. Matched Filter Bank
* I-Q 분해된 matched filter들 (I-Q MF1, MF2)이 각각 여러 delay에 대해 동시에 상관 연산

3. Choose Max
* 모든 delay 중 상관값 $z_{i}$ 가 가장 큰 것을 선택 -> $\tau = \tau _{r}$

4. Coincidence Detection
* Verification 단계로 넘어가서 B out of A 조건 검사

&ensp;Matched Filter Output<br/>
1. 첫 번째 결과 (Serial or Parallel 1차 필터)
&ensp;$z_{i} = z_{c}^{2} + z_{s}^{2} = E_{b}[R_{c}(\tau - \tau _{r})]^{2}$ <br/>
* 상관값은 오차가 작을수록 커짐
* 최대 : $\tau = \tau _{r}$

2. 두 번째 결과 (Parallel 방식에서 2개의 filter 사용 시)
* 두 번째 matched filter는 $\frac{N_{c}}{2}$ 만큼 다른 offset으로 비교: <br/>
&ensp;$z_i^{(2)} = E_b × [ R_c(τ - τ_r - N_c / 2) ]^2$ <br/>
* 병렬 구조에서는 이 둘 중 큰 상관값을 선택하여 offset 결정


Multiuser Detection(MUD)
======

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-14.png" width="600"></p>

&ensp;CDMA 시스템에서는 여러 사용자의 신호가 동일하 주파수와 시간을 사용하지만 서로 다른 코드를 사용하여 구분된다. 하지만 다른 사용자의 간섭(Multiple Access Interference, MAI)가 존재하므로 성능 저하를 유발한다.<br/>

&ensp;목표<br/>
&ensp;원하는 사용자 신호를 정확히 추출하고 다른 사용자 간섭(Interference Cancellation, IC) 제거한다. <br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-15.png" width="600"></p>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-16.png" width="600"></p>

&ensp;수신기 구조<br/>
* LPF로 밴드 제한
* 각 사용자별 BPSK finger로 코드 $c_{m}(t)$ 에 상관 -> $ b\hat{}_{m}(t)$ 추정
* Re-generator에서  $b\hat{}_{m}(t)c_{m}(t)$  로 신호 재구성
* Interference Cancellation Block에서 간섭신호를 제거

&ensp;Re-generator의 핵심 역할<br/>
* 간섭 신호 재생 : 다른 사용자에게 간섭이 되었던 신호 복원
* 간섭 제거에 사용 : PIC/SIC 블록에서 빼주는 연산에 사용
* 정확도 의존 : $b\hat{}_{m}(t)$ 가 정확할수록 간섭 제거도 성공적

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-17.png" width="600"></p>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-21.png" width="600"></p>

&ensp;수신 신호 <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-18.png" width="600"></p>

&ensp;상관기 통과 후 평균 <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-19.png" width="600"></p>

&ensp;사용자 k의 간섭 제거<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-20.png" width="600"></p>

&ensp;M 단계 PIC 수신기<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-22.png" width="600"></p>

&ensp;Neaer-Far Problem(근거리-원거리 문제)<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-23.png" width="600"></p>

&ensp;문제 상황: 모든 사용자가 동일한 전략으로 전송하지만 기지국에서의 수신 전략은 사용자 거리에 따라 다르다.<br/>
* 가까운 사용자는 신호가 강하게 수신됨
* 먼 사용자는 신호가 약하게 수신됨
&ensp;결과: 강한 사용자 신호가 약한 사용자 신호를 마스킹(덮어버림)해서 약한 사용자의 오류율 증가<br/>

&ensp;Power control<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-24.png" width="600"></p>

&ensp;해결 방안: 사용자의 거리 및 채널 상태에 따라 전송 전력을 조절<br/>
* 가까운 사용자는 전송 전력을 줄이고 먼 사용자는 전송 전력을 키움
&ensp;결과: 모든 사용자의 수신 전력이 균형, 즉 기지국에서 동일하게 수신되도록 조정 -> 공정한 다중접속 환경 조성<br/>

&ensp;Serial Interference Cancellation(SIC)
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-25.png" width="600"></p>

* 기본 아이디어:
1. 가장 강한 사용자부터 검출
2. 해당 사용자의 신호를 재생(re-generator)
3. 수신 신호에서 해당 신호를 제거
4. 다음으로 강한 사용자를 검출 -> 반복

* 구성 요소
1. 수신 신호 입력
* 안테나로부터 r(t) 수신
* 신호에는 모든 사용자의 합성된 전송 신호가 포함되어 있음

<p align="center">$ r(t) = \sum_{m=1}^{N_{u}}\sqrt{E_{m}}b_{m}(t-\tau -{m})c_{m}(t-\tau _{m})\varphi (2\Pi f_{c}t + \theta _{m})$</p>

2. Delay
* 모든 경로 지연 시간을 맞춰주는 블록
* 이유: 사용자의 신호가 서로 다른 타이밍으로 수신되므로 각 사용자의 타이밍에 맞게 보정

3. correlator(사용자 1~ N)
* 각 사용자의 PN 코드 $c_{m}(t)$ 와 상관기를 통해 사용자별 상관 출력 계산
&ensp;$z_{t} = \int r(t)c_{m}(t-\tau _{m})dt$ <br/>
* 이 출력값을 보고 가장 강한 사용자를 선택할 수 있음

4. select max(가장 강한 사용자 선택)
* 상관값이 가장 큰 사용자 m 선택
* 이유: 가장 강한 사용자를 먼저 제거하면 다른 사용자에 대한 간섭 효과가 줄어듦(Near-Far 문제 해결에 효과적)

5. Re-generator
* 선택된 사용자의 신호를 복원:
* 비트 추정 $b\hat{}_{m}(t)$
* PN 코드 $c_{m}(t-\tau _{m})$
* 재생된 신호 :
<p align="center">$s\hat{}_{m}(t) = \sqrt{E_{m}}b\hat{}_{m}(t-\tau _{m})c_{m}(t-\tau _{m})$</p>

6. Interference Cancellation
* 원래 수신 신호에서 복원한 사용자 m의 신호를 제거:
&ensp;$r'(t) = r(t) - \hat{s}_m(t)$ <br/>

* 이 과정을 통해 남은 사용자들의 간섭 환경이 개선됨

7. 다음 사용자에 대해 반복 수행
* 사용자 2, 사용자 3,.. 순서로 위의 과정을 반복 수행
* 각각의 코릴레이터, 리제너레이터, 간섭 제거 블록을 통해 점점 더 간섭 없는 신호로 정제됨

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-27.png" width="600"></p>

* iteration 1: User 1이 가장 강함 -> 검출 후 제거
* iteration 2: User 2 검출 -> 제거
* iteration 3: User 3 검출
* BER(bit error rate) 순서 : 
* 강한 신호부터 제거하므로 User 1 < User 2 < User 3 순으로 정확도가 낮아짐


&ensp;요약<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-26.png" width="600"></p>

&ensp;Serial Interference Cancellation 수신기<br/>
* 목적: 여러 사용자의 신호가 동시에 수신될 때 가장 강한 사용자부터 하나씩 신호를 복원 -> 재생 -> 제거하여 다른 사용자의 신호를 추출
* 전제 : 사용자 전력이 서로 다르고 P1 > P2 > ... > $P_{Nu}$

1. 수신 신호(기저대역 평균)
&ensp;$\bar{r}(t) = \sum_{m=1}^{N_u} \sqrt{\frac{E_m}{T_b}}\, b_m(t - \tau_m)\, c_m(t - \tau_m)$

2. 간섭 제거 1 단계
&ensp;가장 강한 사용자 m =1 신호를 복원 후 제거:
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-28.png" width="600"></p>

3. 사용자 1의 신호 재생
<p align="center">$r_{1}(k) = \sqrt{\frac{E_{1}}{T_{b}}}b\hat{}_{1}(t-\tau _{1})c_{1}(t-\tau _{1})</p>

4. 간섭 제거 2 단계(사용자 2)
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-29.png" width="600"></p>

* 이전 단계에서 복원이 완벽하지 않으면 오차 성분이 누적됨

&ensp;kth Iteration(일반화)<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-30.png" width="600"></p>

5. 결정변수
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-31.png" width="600"></p>

&ensp;SIC 수신기 간섭 제거 흐름도<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-32.png" width="600"></p>

Transmit Diversity
======

* Multiple antenna diversity
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-33.png" width="600"></p>

&ensp;📌 핵심 내용 요약<br/>
* Multiple-antenna techniques는 송신기(Tx)와 수신기(Rx) 양쪽에 여러 개의 안테나를 사용하여 성능을 향상시키는 방식이다.
* 각각의 전송 방식은 특정 성능 목표에 따라 구분된다. 
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-34.png" width="600"></p>

&ensp;⚖️ 핵심 개념: Trade-off 관계<br/>
* 예) Multiplexing gain을 높이면 전송률은 올라가지만 오류율이 증가.
* 반대로 Diversity gain은 오류율을 줄이지만 데이터 전송 속도에 영향을 줄 수 있다.

&ensp;STTD (Space-Time Transmit Diversity)<br/>
&ensp;📌 STTD란?<br/>
* STTD는 WCDMA에서 사용되는 송신 다이버시티 기법.
* 2개의 송신 안테나를 이용해 동일한 정보를 시간과 공간을 나누어 전송함.
* 수신기는 다중 경로에서 정보를 조합하여 더 높은 신뢰도로 데이터를 복원함.

&ensp;📂 주요 구성 요소 및 흐름<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-35.png" width="600"></p>

1. 입력 데이터
  - QAM mapper를 통해 복소수 신호 $x_{1}(t)$ , $x_{2}(t)$ 로 변환된다. 
2. STTD Encoding:
  - 두 심볼을 시간과 안테나에 분산시켜 전송.
  - 타임 슬롯 기준:
    + $t_{1}$ : 안테나 1에서 $x_{1}$, 안테나 2에서 $x_{2}$ 전송
    + $t_{2}$ : 안테나 1에서 $x_{1}^{*}$, 안테나 2에서 $x_{2}^{*}$ 전송
    * 수학적 구조:
    &ensp;$\begin{bmatrix} x_{1} & x_{2} \\-x_{2}^{*} & x^{*} \\ \end{bmatrix}$
3. Complex Spreading:
  - 확산코드 $c_{1}(t)$ , $c_{2}(t)$ 를 복소 형태로 사용
  - $c_{1}(t) + jc_{2}(t)$ 와 같은 형식으로 각각의 송신 신호에 곱해져 다이버시티를 극대화
4. 수신 측 (Rx):
  - 두 안테나의 채널 응답 $h_{1}(t)$ , $h_{2}(t)$ 을 이용해 채널 등화를 수행하고
  - STTD 구조에 따라 합산 복원을 수행하여 심볼 복원.

1. Transmit Diversity: 송신 신호와 수신 신호<br/>
* 송신 신호 구조
  - 두 개의 송신 안테나에서 전송되는 STTD 부호화 신호:
    + 안테나 1
    <p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-36.png" width="600"></p>

    + 안테나 2
    <p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-37.png" width="600"></p>

&ensp;-> 두 안테나는 서로 다른 시간에 conjugate, 음수 부호 등을 달리하여 보냄<br/>
* 수신 신호 구조
  - 수신기에서는 두 안테나의 채널 $h_{1}(t), h_{2}(t)$ 를 통해 도달한 $s_{1}, s_{2}$ 를 수신하고,
    + 예를 들어 첫 번째 기호 구간에서는: 
    &ensp;$r_{1}(t) = α_{1}s_{1}(t) + α_{2}s_{2}(t)$C <br/>
    &ensp;를 통해 합성 수신 신호가 생성됨<br/>

2. Transmit Diversity: Decision Variable 구성
* 수신기에서는 각 기호 구간의 결정을 위해 다음과 같은 연산 수행:
  + 첫 번째 심볼에 대한 decision variable:
  &ensp;$y_1 = \int_{t_k}^{t_k + T_s} r_1(t)\, w(t)\, dt = E_s \left[ \alpha_1 x_i1 - \alpha_2 x_i2^* \right]$ <br/>

  + 두 번째 심볼에 대한 decision variable: 
  &ensp; $y_2 = \int_{t_k}^{t_k + T_s} r_2(t)\, w(t)\, dt = E_s \left[ \alpha_2 x_i2 - \alpha_1 x_i1^* \right]$ <br/>

  + 이 두 결과를 결합해서 원하는 기호 복원:
  &ensp;$z_1 = \alpha_1^* y_1 + \alpha_2 y_2 \Rightarrow E_s \left( |\alpha_1|^2 + |\alpha_2|^2 \right) x_i1$ <br/>
&ensp;-> 채널 이득 × 원래 보낸 심볼 복원이 가능

3. Transmit Diversity: 심볼 복원 결과
* 앞으로 나온 $Z_{1}$ 와 유사하게 $z_{2}$ 는 다음과 같이 구성됨:
&ensp;$z_2 = \alpha_2^* y_2 + \alpha_1 y_1 \Rightarrow E_s \left( |\alpha_1|^2 + |\alpha_2|^2 \right) x_2$ <br/>
* 즉 두 개의 송신 경로의 channel gain을 조합한 신호 강도로 원래의 심볼이 복원됨:
  - 더 많은 diversity 경로를 확보할 수 있다.
  - ->fading에 강함 + 에러 확률이 낮아짐

&ensp;왜 diversity가 성능을 향상시키는가?<br/>
&ensp;📌 요점 요약<br/>
1. **다이버시티(Diversity)**란?
* 동일한 정보 신호를 **서로 독립적인 여러 경로(채널)**를 통해 전송하는 기술
* 대표작 예: STTD 등
2. 핵심 장점:
* 모든 채널이 동시에 페이딩(fading)되는 확률이 매우 낮음
* 따라서 최소 하나의 채널은 양호한 품질을 유지하고 있을 가능성이 높음
* 결과적으로 전체 수신 신호의 신뢰도와 성능이 향상됨

&ensp;그래프 해석: $h_{1}(t)$ , $h_{2}(t)$ 두 채널 이득 변화 <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-38.png" width="600"></p>

* x축 시간(time[sec])
  - 예: 0.03초 ~ 0.1초 구간
* y축: 채널 이득(Chaneel amplitude[dB])
  - 수신된 신호의 강도
  - 낮을수록 신호 감쇄(fading)가 심함 -> 특히 Deep fading 이 성능 저하의 핵심 원인
* 파란 선 $h_{1}(t)$ , $h_{2}(t)$ : 
  - 서로 독립적인 두 채널의 페이딩 특성
  - 두 선이 동시에 -10 dB 이하로 떨어지는 경우는 매우 드뭄
  - 보통 한 채널이 deep fading에 빠질 때 다른 채널은 양호한 상태

&ensp;Deep Fading에 대한 해석<br/>
* Deep fading: 수신 신호 강도가 매우 약해져 **비트 오류율(BER)**이 크게 증가하는 현상
* 위 그래프에서는:
  - 예: $h_{1}(t)$ , $h_{2}(t)$ 가 모두 -10dB 아래로 떨어진 경우는 아주 짧음
  - 동시에 페이딩 확률이 낮다 -> 수신 신호의 **합산 이득(combined gain)** 을 통해 복원이 가능

&ensp;✅ 결론: 다이버시티의 효과<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-39.png" width="600"></p>

&ensp;Space-Time Block Code (STBC)<br/>
* STBC는 공간(안테나) + 시간 축을 활용한 코딩 방식으로, 송신 diversity를 제공하여 수신 성능을 높이는 기술
* 가장 대표적인 STBC는 Alamouti 코드이다.

1. 송신부 구조 
* 입력
  - x(t): QAM 또는 PSK로 변조된 신호
  - S/P 변환을 통해 두 심볼로 나눔 -> $x_{1}, x_{2}$
* STBC 인코딩
&ensp;STBC 인코딩은 아래와 같이 2개 심볼을 시간과 안테나 축으로 재배열한다:
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-40.png" width="600"></p>

&ensp;즉, 한 시간에 하나의 안테나에서만 송신하는 방식이다.<br/>

2. 📡 채널과 수신부

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-42.png" width="600"></p>

&ensp;채널 계수<br/>
* $α_{1}$ : 안테나 1에서 수신기까지의 채널
* $α_{2}$ : 안테나 2에서 수신기까지의 채널

&ensp;수신신호<br/>
&ensp;두 시간 구간에서의 수신 신호는 다음과 같다<br/> 
&ensp;수신 1: <br/>
&ensp;$y_{1} = α_{1}x_{1} + α_{2}x_{2} + n_{1}$ <br/>
&ensp;수신 2: <br/>
&ensp;$y_{2} = -α_{1}x_{2}^{*} + α_{2}x_{1}^{*} + n_{2}$ <br/>

3. 수신기에서의 복원 (Decoding)
&ensp;이제 $y_{1}, y_{2}$를 바탕으로 $x_{1}, x_{2}$ 를 복원한다. <br/>
&ensp;복원 수식 정리: <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-41.png" width="600"></p>

&ensp;-> STBC 구조 덕분에 두 심볼을 독립적으로 복원할 수 있고, 채널 간섭이 상쇄된다.

&ensp;🎯 성능 향상 포인트<br/>
* Diversity Gain: 두 개의 독립적인 경로로 인해 페이딩의 영향을 극복 가능
* Channel estimation만 정확하다면 간단한 선형 연산으로 복원이 가능
* 수신기 복잡도는 낮고, 성능은 향상됨

Spatial Multiplexing
======

&ensp;Transmitter<br/>
&ensp;🧩 시스템 구조<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-44.png" width="600"></p>

* 송신 신호 흐름
1. 원본 비트열 b(t) -> QAM mapper: 심볼 x(t) 생성
2. MIMO encoder에서 송신 엔테나 수만큼 분할:
  - $x_{1}(t), x_{2}(t)$ : 서로 다른 두 심볼
3. Complex spreading:
  - 확산 코드 $c_{1}(t), c_{2}(t)$ 와 정규화된 직교 가산 $jc_{2}(t)$ 이용
  - 송신신호: 
  $ s_{1}(t) = \sqrt{\frac{E_{s}}{T_{s}}}x_{1}(t)w(t)$ , 
  $ s_{2}(t) = \sqrt{\frac{E_{s}}{T_{s}}}x_{2}(t)w(t)$
4. 각 안테나는 s1(t), s2(t)를 다른 채널 $h_{ij}(t)$ 을 통해 전송

&ensp;receiver<br/>
&ensp;🧩 수신기 구조<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-43.png" width="600"></p>

1. 수신 안테나 출력:
&ensp;$r_{1}(t), r_{2}(t) = h_{11}s_{1}(t) + h_{12}(t)s_{2}(t) , h_{21}s_{1}(t) + h_{22}s_{2}(t)$ <br/>
2. 복소 확산 코드 제거 (despreading):
  - $c_{1}(t) - jc_{2}(t)$ 를 곱하고 적분 -> $y_{11}, y_{12}$
3. MIMO Detection:
  - 공간적으로 겹친 신호를 분리 (ex. Zero-Forcing, MMSE detection 등)
  - 출력: $z_{1}, z_{2}$ -> 복조기(QAM demapper)

&ensp;🧮 수신 신호 수식<br/>
&ensp;$r_m(t) = \alpha_{m1} s_1(t) + \alpha_{m2} s_2(t) = T_s E_s \left[ \alpha_{m1} x_1(t) + \alpha_{m2} x_2(t) \right] w(t) + n_m(t)$

&ensp;🎯 핵심 요점<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-45.png" width="600"></p>

&ensp;Correlation Output (수신 신호 처리)<br/>

&ensp;💡 목적<br/>
&ensp;수신 신호에서 기저대역 심볼 $x_{1}, x_{2}$ 를 복원하기 위해 복소 확산 코드 제거 후 적분하는 과정이다.<br/>

1. 첫 번째 안테나 출력
&ensp;$y_1 = \int_{(i)T_s}^{(i+1)T_s} r_1(t)\, w^*(t)\, dt$  <br/>
* 여기서 $r_{1}(t)$ 는 첫 번째 수신 안테나의 신호이며 w(t)는 전송 신호에 공통으로 곱해졌던 확산 파형
* 복조 시 conjugate $w^*(t)$를 곱해 적분

&ensp;전개하면<br/>

<p align="center">$y_{i1} = \sqrt{E_s}\alpha _{11}x_{i1} + \sqrt{E_s}\alpha _{21}x_{i2} + n_1$ </p>

2. 두 번째 수신 안테나
&ensp;동일하게 적용하면:<br/>

<p align="center">$y_{i2} = \sqrt{E_s}\alpha _{12}x_{i1} + \sqrt{E_s}\alpha _{22}x_{i2} + n_2$  </p>

&ensp;행렬 표현<br/>
&ensp;위 두 수식을 벡터와 행렬로 표현하면: <br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-46.png" width="600"></p>

&ensp;Combined Decision Variable (MIMO Detection)<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-47.png" width="600"></p>

Multicode
======

&ensp;1️⃣ 우리 상황 상상해볼까?<br/>
* 당신은 무전기 1대로 친구한테 말을 하고 있다.
* 그런데 한 번에 한 마디씩만 말하면 시간이 오래 걸리겠죠?
* 그래서 3개의 무전기를 사용해서 친구한테 동시에 3마디를 보내는 거다!
&ensp;바로 이게 멀티코드 방식이다. <br/>

&ensp;2️⃣ 어떻게 작동할까?<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-48.png" width="600"></p>

* 입력 데이터 b(t)
  - 먼저, 보낼 메시지를 3조각으로 나눈다. 
    + 예: b1(t), b2(t), b3(t) ← 각각은 전송할 작은 메시지 조각
* S/P 블록
  - 이건 나누기 블록이다.
  - b(t)를 3개의 작은 b1, b2, b3로 나눈다.
* 각 조각을 각각 다른 "비밀 코드"로 섞는다.
  - 각각은 w1(t), w2(t), w3(t)라는 다른 코드랑 곱해진다. 
*  그리고 다 더한다!
  - 마지막에 b1*w1 + b2*w2 + b3*w3 이런 식으로 합쳐진다.
  - 즉, 하나의 신호로 보이지만, 안에 세 가지 메시지가 섞여있는 거다.
* 곱하고 보내기
  - 이 메시지는 w(t)와 다시 곱해지고, cos(2πf₀t) 신호랑 곱해서 전파를 타고 날아간다.

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-49.png" width="600"></p>

1. b1(t), b2(t), b3(t) - 우리가 보낼 세 조각 메시지
2. w₁(t), w₂(t), w₃(t) - 각각의 메시지에 곱할 비밀코드
  - 이건 1과 -1로 구성된 특별한 패턴이다.
  - 예: w₁(t) = [1, -1, -1, 1, 1]
3. 각각의 b₁(t), b₂(t), b₃(t)를 코드랑 곱한다.(2, 3, 4 번 그림이 그 과정)
4. 5번 그림은 그 세 신호를 모두 더한 것
  - 어떤 부분은 겹쳐서 커지고, 어떤 건 없어지기도 한다. 
5. 6번은 그 합쳐진 신호가 전파로 바뀐 모습이다.
  - 복잡한 모양이지만 나중에 코드 w₁, w₂, w₃를 이용하면 다시 풀 수 있다.

&ensp;Reveiver<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-50.png" width="600"></p>

&ensp;수신된 신호는 여러 메시지($w_1, w_2, w_3$ 로 인코딩된 편지)가 섞인 상태다.<br/>
&ensp;수신기는 다음 과정을 거친다: <br/>
1. LPF를 통해 고주파를 없애고 기본 신호만 남겨
2. $w_1(t)$ 로 곱해서 내가 찾는 메시지에 해당하는 부분만 꺼내
3. 그 다음 시간에 따라 평균을 계산(적분)해서 $z_1$ 을 만들어
4. z₁ > η이면 이 편지는 "1"이야, z₁ < η이면 이 편지는 "0"이야
&ensp;이걸 w₂(t), w₃(t)에 대해서도 똑같이 한다.

&ensp;Multicode in WCDMA uplink<br/>
&ensp;🔍 전체 개요<br/>
* 우리가 보내려는 데이터: DPDCH(Dedicated Physical Data CHannel)
* 추가 정보나 제어신호: DPCCH (Dedicated Physical Control CHannel)
* 멀티코드를 사용해서 데이터 속도를 높이고,
* 채널화 코드 (w₀(t)~w₅(t)) 와 스크램블 코드 (c₁(t)+jc₂(t)) 로 다중 사용자를 구별함

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-51.png" width="600"></p>

&ensp;📦 구조 해설<br/>
1. DPDCH → S/P
* 전송할 데이터 비트를 여러 개의 DPDCH로 나눔 -> 병렬 처리: 데이터 전송 속도 향상

2. 각각의 DPDCHᵢ × wᵢ(t)
* 각각의 데이터 채널은 서로 다른 채널화 코드 wᵢ(t)와 곱해짐
  - 이걸 통해 각 채널의 데이터 신호가 고유해짐
  - 서로 간섭 없이 구분 가능
&ensp;예: w₀(t), w₁(t), ..., w₅(t)는 직교해서 서로 간섭이 없음<br/>

3. 채널들을 두 그룹으로 나눔: I채널 / Q채널
* I (In-phase), Q (Quadrature) → 복소수 표현을 위한 두 축
* 6개의 DPDCH 중 일부는 I 브랜치, 나머지는 Q 브랜치로 감
* 각 브랜치에서 합(sum) 계산해서 하나의 신호로 만듦

4. Scrambling: c₁(t) + j·c₂(t)
* Scrambling code를 통해 사용자마다 **신호의 '서명'**을 부여
* 복소수 코드 c₁(t) + j·c₂(t) 와 곱해서 전송 전 마지막 사용자 식별을 보장

5. 두 브랜치 결합 및 Upconversion
* I-브랜치 × 캐리어 cos파 (𝜙₁)
* Q-브랜치 × 캐리어 sin파 (𝜙₂)
* 두 신호를 더해 s(t)라는 최종 무선 신호를 생성

&ensp;receiver<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-52.png" width="600"></p>

1. 신호 분리 준비(LPF: Low Pass Filter)
* 받은 소리를 저주파만 남도록 필터링함 (쓸데없는 고주파 잡음 제거)
* 위쪽은 I 채널 (실수 성분),
* 아래쪽은 Q 채널 (허수 성분)

2. 코드로 다시 분리하기
* 예: w₁(t), w₂(t) ... w₆(t)
* 각 코드로 곱해서 각각의 신호를 뽑아냄!

3. 적분 (신호 평균 내기)
&ensp;각 코드별로 곱한 결과를 일정 시간 동안 평균을 냄 -> 이걸 수식으로는 **∫ (적분)**이라고 함<br/>
&ensp;그럼 1이라고 말했는지 0이라고 말했는지 알 수 있다.<br/>

4. 판단하기 (비트 복원)
* 각 평균값이 기준값 η보다 크면 -> 1,
* 작으면 -> 0으로 판단해서 다시 원래 데이터로 복원함!

5. 마지막 단계
* 분리한 6개의 결과를 다시 차례대로 합쳐서 원래의 데이터 비트열 bᵢ를 만든다.(이걸 P/S 변환기가 한다. 병렬-> 직렬)

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-53.png" width="600"></p>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-54.png" width="600"></p>

Maximum Data Rate
======

&ensp;동기CDMA 전송속도<br/>
* 2G: 문자나 간단한 데이터를 느리게 보낼 수 있었음
* 3G: 사진, 동영상까지 빠르게 전송 가능

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-55.png" width="600"></p>

&ensp;2G<br/>
* IS-95 (2G 초기)
  - 속도: 9.6~14.4kbps
  - 아주 느림. 문자 보내기 딱 좋은 정도
  - BPSK (1비트를 한 번에 전송)
* IS-95B
  - 속도: 115.2kbps (x8 향상)
  - 한 번에 여러 채널을 사용해서 속도 ↑
  - 여전히 BPSK이지만 여러 개 묶어서 송신
* CDMA2000-1x (Release 0)
  - 속도: 153.6kbps
  - 채널 품질을 개선해서 속도 ↑
* CDMA2000-1x (Release A)
  - 속도: 307.2kbps (x2 향상)
  - 변조 방식이 QPSK로 바뀜 → 한 번에 2비트 전송 가능해서 속도 ↑

&ensp;3G<br/>
* EV-DO Rel. 0
  - 속도: 2.4576Mbps
  - 변조 방식: 16QAM (한 번에 4비트 전송!)
  - Coding: 2/3 → 2개의 데이터에 1개의 에러보정코드 추가
* EV-DO Rev. A
  - 속도: 3.072Mbps
  - Coding이 5/6 → 에러보정이 줄어들고 실제 데이터 양 ↑
* EV-DO Rev. B
  - 속도: 최대 14.7Mbps
  - 64QAM 사용 → 한 번에 6비트 전송!
  - 멀티캐리어 사용: 주파수를 3개나 동시에 사용 (병렬 처리 느낌!)

&ensp;✨ QAM, BPSK, QPSK<br/>
* BPSK: 1비트 전송 (ex. 0이면 왼쪽, 1이면 오른쪽)
* QPSK: 2비트 전송 (00, 01, 10, 11 네 가지 각도로 표현)
* 16QAM: 4비트 전송 (더 많은 점으로 세밀하게 표현)
* 64QAM: 6비트 전송 (복잡하지만 훨씬 많은 정보 전송 가능)

IS-95A
------

&ensp;목표: 7.2kbps 데이터를 19.2kbps로 바꾸기까지의 과정!<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-56.png" width="600"></p>

1. 원래 데이터
* 입력: 1 0 1처럼 생긴 비트열
* 전송 속도: 7.2 kbps
* 이게 우리가 처음 전송하고 싶은 진짜 데이터

2. Channel Encoder (rate 1/2)
* 1개의 비트를 -> 2개의 비트로 바뀜
* 이유: 에러가 나도 복구할 수 있게 하기 위해
* 결과: 7.2kbps -> 14.4kbps
* 예시: 1 -> 10, 0 -> 01 같은 방식으로 두 배로 만듦

3. Symbol Repetition (2회 반복)
* 비트 하나하나를 2번씩 반복
* 예시: 1 0 1 -> 1 1 0 0 1 1
* 결과: 14.4kbps → 28.8kbps
* 이유: 노이즈 때문에 깨질까봐 한 번 더 보냄

4. Puncture (삭제)
* 반복해서 길어진 데이터를 조금 잘라냄
* 예시: 6개 중 2개 제거 -> 4개만 유지
* 결과: 28.8kbps → 19.2kbps
* 똑같은 걸 2번 보냈지만 일부만 남기니까 데이터가 적당히 안전하면서도 빠르게 전송됨

5. 결과
* 최종적으로 원래 7.2kbps -> 19.2kbps로 향상
* 효율은 좋아졌고 에러 복원도 가능한 상태

&ensp;요약<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-57.png" width="600"></p>

&ensp;왜 이렇게 복잡하게 할까?<br/>
* 무선 환경은 잡음, 끊김, 간섭이 많다.
* **신호를 반복하거나 추가 정보**를 더해서 안전하게 전달하려는 거다. 

&ensp;Cannel coding<br/>
* Convolutional Encoder란?
&ensp;데이터를 더 안전하게 전송하기 위해 입력 데이터를 규칙적으로 섞고 늘리는 장치이다.<br/>
&ensp;하나의 입력 비트가 들어오면 두 개의 출력 비트가 나간다. <br/>
&ensp;그래서 **1/2 rate** 라고 부른다. (입력 1개 -> 출력 2개)<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-58.png" width="600"></p>

1. 왼쪽 블록 다이어그램
* 입력 비트: aᵢ(한 비트씩 들어옴)
* 메모리 셀: s₁(t)와 s₀(t) -> 최근 입력 비트를 기억해놓은 장치(총 2개의 기억장치)
* 모듈로 2 덧셈기(⊕): 
  - 비트 계산: 1 + 1 = 0, 0 + 1 = 1 같은 XOR 연산
  - bᵢ, cᵢ 두 개의 출력 비트를 만듦

2. 오른쪽 테이블(시물레이션 표)
* Clock Pulse: 시간 흐름(1, 2초처럼 단계)
* Input  aᵢ: 그 순간에 들어온 데이터
* State s₁, s₀: 이전에 기억하던 두 개의 값
* Output bᵢ, cᵢ: ⊕ 계산 결과로 출력된 두 개의 비트

&ensp;예시로 흐름을 따라가 보자! <br/>
&ensp;처음 상태: s₁ = 1, s₀ = 1<br/>
1. 입력 aᵢ = 0
  - s₁ = aᵢ = 0, s₀ = 이전s₁ = 1
  - 출력 bᵢ = aᵢ ⊕ s₀ = 0⊕1 = 1
  - 출력 cᵢ = aᵢ ⊕ s₁ ⊕ s₀ = 0⊕1⊕1 = 0
2. 다음 입력 aᵢ = 0
  - s₁ = 0, s₀ = 0
  - bᵢ = 0⊕0 = 0, cᵢ = 0⊕0⊕0 = 0
3. 다음 입력 aᵢ = 1
  -  s₁ = 1, s₀ = 0
  - bᵢ = 1⊕0 = 1, cᵢ = 1⊕1⊕0 = 0

&ensp;이 방식을 사용하는 이유<br/>
* 통신 중에 오류가 생기더라도 복원할 수 있게 하기 위해서
* 데이터를 늘려서 보냈기 때문에 수신기가 더 똑똑하게 복구할 수 있다.
* 이런 걸 **에러 정정 코드(Error Correctin Code, ECC)**라고 부르기도 한다. 

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-59.png" width="600"></p>

&ensp;전송 과정 설명<br/>

1. 데이터 입력
* RS1 또는 RS2에서 데이터를 받는다. 
* 예: RS2에서는 14.4 kbps, 7.2 kbps, 3.6 kbps, 1.8 kbps 이건 통화 품질에 따라 다르다.

2.  채널 부호화 (Channel encoder rate 1/2)
* 한 비트를 두 개로 늘려서 전송 오류에 강하게 만듦.
*  왜 두 배로 늘리냐면?: 잘못 전달되었을 때 복원하기 쉽게 하기 위해서이다. (convolution encoder라고 생각하면 됨)

3. 심볼 반복 (Symbol repetition)
* RS1에서는 반복 안 하고, RS2는 두 번씩 심볼을 반복해서 보냄.(예: 14.4 kbps × 2 = 28.8 kbps)

4. 펑처링 (Puncture 2 of every 6)
* 너무 많이 늘어나면 안 되니까, 일부 심볼은 버림(제거) -> 6개 중 2개 삭제 -> 데이터 압축 효과 ->  28.8 kbps × (4/6) = 19.2 kbps

5. 확산 (Spreading)
* DMA는 모든 사용자들이 같은 주파수를 사용하므로, 서로 섞이지 않게 각자만의 코드를 곱해서 보냄 (→ Walsh 코드)
* Walsh 코드
  - 각 사용자는 서로 직교하는(=서로 겹치지 않는) 코드 사용
  - 칩 속도: 1.2288 Mcps
  - 데이터 속도: 19.2 kbps
  - 확산비(Spreading Factor, SF): SF = 1.2288M / 19.2K = 64 -> 데이터 1비트마다 64개의 칩 전송

6. Scrambling (Short PN 코드)
* Walsh 코드로 확산한 후 **PN 코드(무작위 코드)**도 곱함
* 사용자들이 송신 타이밍이 다르더라도 구분되게 함
* 코드 종류
  - Short PN Code 1: I 채널(실제 데이터)
  - Short PN code 2: Q 채널(위상 90도 차이)

&ensp;무선 채널구조<br/>
* ownlink CDMA Channel (1.25 MHz) -> 여러 채널이 있음(W = 0부터 W = 63까지) -> 각 채널도 Walsh 코드로 구분됨

&ensp;요약<br/>
&ensp;IS-95A에서는 1.25 MHz 대역폭에서 부호화, 반복, 펑처링, 확산을 거쳐 데이터를 전송하고, 그 최종 속도가 19.2 kbps까지 나온다.<br/>

IS-95B
-------

&ensp;한 명의 사용자가 데이터를 더 빨리 보내기 위해 하나의 기본 채널(Fundamental Channel) + 여러 보조 채널(Supplementary Channel)을 동시에 사용한다. <br/>

&ensp;기본 전송속도 14.4kbps × 8개 채널(One fundamental CH +7 supplementary CH) = 115.2kbps<br/>

&ensp;📦 흐름도 따라가기<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-60.png" width="600"></p>

1. 데이터 입력
* 한 사용자의 데이터가 들어온다. 
* 기본 속도는 14.4kbps
* 이걸 8개 채널로 병렬 전송하면 -> 14.4 x 8 = 115.2 kbps

2. 채널 부호화(Channel Encoder rate 1/2)
* 신호를 두 배로 늘림 -> 오류 복원 용도
  - 115.2 kbps → 230.4 kbps

&ensp;📌 왜 늘림? -> 비트를 2배로 부호화하면 나중에 복구하기 쉽기 때문이다.<br/>

3. 펑처링 (Puncture 2 of every 6)
* 너무 많아진 심볼을 간소화한다. 
* 6개 중 2개는 삭제 -> 압축됨
  - 230.4 kbps x (4/6) = 153.6 kbps

4. 직렬 -> 병렬 변환(S/P)
* 데이터를 8개 채널로 분활
  - 각 채널은 153.6 / 8 = 19.2 kbps

5. 확산(Walsh 코드 곱하기)
* CDMA 방식이라서, 모든 사용자가 같은 주파수/시간을 쓰지만 코드를 다르게 곱함으로써 서로 구분 가능
* 여기선 8개의 Walsh 코드 사용: $w_{N+1}, w_{N+2},...., w_{N+7}$

6. Scrambling (PN 코드 곱하기)
* Walsh 코드 외에도, **무작위성(PN 코드)**를 곱해서 보안을 높이고 사용자 간 구분 가능하게 함
* I/Q 두 경로로 나눠서 전송

&ensp;Spread Factor (SF)<br/>
* Walsh 코드의 확산비(SF): $\mathrm{SF} = \frac{19.2\,\text{kbps}}{1.2288\,\text{Mcps}} = 64$
* -> 1비트를 64개의 칩으로 변환해 전송한다는 뜻이다.

&ensp;🧩 전체 정리 순서<br/>
1. 데이터 115.2 kbps 들어옴
2. 채널 부호화 → 230.4 kbps
3. 심볼 일부 삭제(Puncture) → 153.6 kbps
4. 8채널 분할 → 각 19.2 kbps
5. Walsh 코드 × 8로 확산
6. PN 코드로 섞기 (Scrambling)
7. 최종 무선 전송

&ensp;비유로 정리: 마치 한 편지를 여러 복사본으로 만든 뒤, 8명의 택배기사가 **각기 다른 암호(walsh 코드)**를 써서 동시에 빠르게 전송하는 느낌이에요. ✉️📬📬📬<br/>

CDMA2000-1x (rel. 0)
------

&ensp;주제 요약<br/>
* **CDMA2000-1x (rel. 0)**는 IS-95B보다 더 진보된 3G 통신 규격이다.

&ensp;기본 BPSK + Walsh 코드 + PN 코드 확산으로 최대 전송속도: 153.6kbps 도달! 🚀<br/>

&ensp;용어 정리<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-61.png" width="600"></p>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-62.png" width="600"></p>

&ensp;위쪽 구조 설명: SF = 64일 때<br/>
1. 입력 데이터: 9.6kbps
* 사용자 기본 데이터 비율

2. 채널 부호화 (rate 1/2)
* 데이터를 2배로 늘림 → 9.6 → 19.2kbps
* 이유: 오류 정정 가능하게 하기 위함 

3. Walsh 코드로 확산
* 1개의 비트를 **64개의 칩(chip)**으로 펼침
* 즉, 19.2kbps × 64 = 1.2288 Mcps

&ensp;$\mathrm{SF} = \frac{1.2288\,\text{Mcps}}{19.2\,\text{kbps}} = 64$ <br/>

4. BPSK 변조
* 이진 데이터를 아날로그 전파로 바꾸는 과정
* 위상(위 또는 아래 파형)으로 0과 1을 표현

5. Short PN 코드와 곱함
* 사용자 식별, scrambling (혼합)

&ensp;아래쪽 구조 설명: SF = 4일 때 (속도 ↑)<br/>
1. 입력 데이터: 153.6kbps
* 더 빠른 데이터 전송을 위해 높은 속도로 시작!

2. 채널 부호화 (1/2)
* 153.6 × 2 = 307.2kbps

3. Walsh 코드로 확산 (SF = 4)
* 비트 하나를 4개의 칩으로 확산
* 307.2 × 4 = 1.2288Mcps 즉, 여전히 대역폭은 같지만 데이터 속도는 훨씬 높아짐

4. BPSK 변조 + PN 코드 혼합
* 같은 방식으로 최종 송신

&ensp;수식으로 정리<br/>
&ensp;Spread Factor 계산: SF = Spread Factor = chip rate / bit rate<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-63.png" width="600"></p>

&ensp;📌 비유로 이해하기<br/>
&ensp;SF=64: 책 한 장(비트)을 64개 쪽지로 쪼개서 보냄<br/>
&ensp;SF=4: 책 한 장을 4개 쪽지로만 보냄 (더 빠름)<br/>

&ensp;🏁 결론 요약<br/>
* 기본 속도 (SF=64): 153.6kbps
* 확산 비율 SF 줄이면 속도 증가 (→ SF=4)
* **대역폭(1.2288Mcps)**는 그대로인데 정보량을 더 밀도 있게 넣는 방식

CDMA2000-1x (Rel. A)
------

&ensp;🧠 핵심 한줄 요약: QPSK + Walsh 코드 + Complex Spreading 덕분에 CDMA2000-1x에서 307.2kbps 속도 달성!<br/>

&ensp;용어 정리<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-64.png" width="600"></p>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-65.png" width="600"></p>

&ensp;🔄 전체 흐름 설명<br/>
1. 입력 데이터: 307.2 kbps
* 시작 데이터 속도

2. 채널 부호화 (rate 1/2)
* 에러 방지용으로 데이터를 2배로 늘림 -> 307.2kbps -> 614.4kbps

3. 직렬 → 병렬 (S/P 변환기)
* 이진 데이터를 두 갈래로 쪼갠다.
* 각각  I(실수) 와 Q(허수) 경로로 보개기 위한 준비
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-66.png" width="600"></p>

&ensp;→ 각 경로마다 307.2 kbps<br/>

4. Walsh 코드로 확산 (SF=4)
* 한 비트를 4칩으로 확산 (307.2kbps x 4 = 1.2288Mcps)
* 여기까지가 확산된 데이터

5. QPSK 변조
* 두 비트 (I + Q)를 한 기호(symbol)로 변환하여 전송함

&ensp;-> 속도는 그대로지만 더 많은 정보 전송 가능

6. 복소 확산 (Complex Spreading)
* 입력 데이터 x $c_1(t) + jc_2(t)$

&ensp;(I 경로 x $c_1(t)$ , Q경로 x $c_2(t)$)<br/>

&ensp;복소 확산 수식 설명<br/>
&ensp;$(I + jQ)(c_1 + jc_2) = (Ic_1 - Qc_2) + j(Ic_2 + Qc_1)$ <br/>

&ensp;최종 전송 속도 정리<br/>
* QPSK: 한 심볼에 2비트 전송 가능
* SF = 4 → 짧은 코드, 높은 데이터율
* 9.6kbps × 2(QPSK) × 16채널 = 307.2kbps

&ensp;🏁 결론 요약<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-67.png" width="600"></p>

&ensp;비동기 CDMA 전송속도<br/>

&ensp;시작점: WCDMA (Rel.99)<br/>
* 속도: 2.88Mbps
* 변조: QPSK
* SF=4
* Multicode = 1개
* Coding: 적용됨 (1/2)

&ensp;HSDPA: 다운로드 속도 향상<br/>
* WCDMA보다 5배 빠름: 2.88Mbps x 5 = 14.4Mbps
* 16QAM: 더 많은 데이터 전송 가능
* SF = 16 (덜 확산 → 더 많은 사용자 수용)
* Multicode = 15개 사용
* Coding 없음
&ensp;-> HSDPA는 다운로드를 빠르게 해주는 기술이다.<br/>

&ensp;HSPA+ (Release 7)<br/>
* HSDPA 속도 2배 증가 → 28.8Mbps
* 2x2 MIMO 도입 (안테나 2개씩 사용)

&ensp;HSPA+ (Release 11)<br/>
* 속도 폭발적으로 증가: 672Mbps
* 64QAM: 변조 효율 최고
* Multicarrier (8개): 대역폭 8개 동시에 사용
* 4x4 MIMO: 안테나 4개씩 사용

&ensp;HSUPA: 업로드 성능
* WCDMA보다 2배 빠름: 2.88Mbps × 2 = 5.76Mbps
* QPSK, SF=4, Multicode=6

&ensp;📥 Downlink (DL)<br/>
* 기지국(Base Station) → 휴대폰(단말기)
* 즉, 네트워크에서 사용자에게 데이터를 보내는 방향
* 유튜브 시청, 웹페이지 보기 등 “내가 다운로드 받는 행위”

&ensp;📥 Uplink (UL)<br/>
* 휴대폰(단말기) -> 기지국(Base Station)
* 즉 사용자에서 네트워크로 데이터를 보내는 방향
* 음성 통화, 파일 업로드, 채팅 전송 등 내가 업로드하는 행위

WCDMA (Rel.99)
------

1. 배경 정보
* WCDMA (Rel.99): 3G 기술의 초창기 버전 (Downlink: HSDPA 이전)
* BW (대역폭): 5 MHz
* 칩레이트: 3.84 Mcps (Mega chips per second)
* 변조 방식: QPSK 사용 (한 심볼이 2비트 표현 가능)
* Spreading Factor (SF): 4 (→ 3.84M / 4 = 960kbps 심볼속도)

&ensp;⚙️ 전체 흐름 요약<br/>
&ensp;1초에 최대 2개 비트를 전송할 수 있는 QPSK 변조 신호를 여러 채널 코드(w₁(t), w₂(t), …)로 병렬로 보내고 복조하여 고속 데이터 전송을 가능하게 함<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-68.png" width="600"></p>

&ensp;🛠️ 내부 처리 과정<br/>
1. 936kbps 원래 데이터
* DPDCH: 사용자 데이터
* DPCCH: 제어 데이터
* 합쳐서 936kbps

2. 채널 부호화 (1/2 Rate)
* 채널 인코더는 오류를 줄이기 위해 2배로 확장
  - -> 936kbps -> 1.92Mbps

3. 병렬 전송 (S/P 변환기)
* 1.92Mbps 신호를 2개로 나눔
  - -> 각각 960kbps

4. Walsh code를 이용한 확산
* 각 신호에 서로 다른 Walsh 코드를 곱해 줘서 다른 사용자와 구분
  - WCDMA는 Walsh 코드로 구분된 다중 접속 방식
  - 각각 960kbps × Walsh code (chip rate 3.84Mcps)

5. QPSK 변조
* 나눠진 2개의 스트림(960kbps)을 QPSK의 I 채널/Q 채널로 각각 매핑
  - I: 상하 (cos)
  - Q: 좌우 (sin)

6. Complex spreading
* 이후 다른 사용자의 신호와 섞이기 전에 복소수 형태로 spreading 처리함
  - 즉 c₁(t), c₂(t)로 다시 확산 -> 기지국에서 구분 가능하게 만듦

WCDMA (Rel.99) downlink
-------

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-69.png" width="600"></p>

1. 시작
* 2,880 kbps 데이터 생성
* 총 데이터량: 960 kbps × 3채널 = 2,880 kbps
* 이건 여러 채널(Multicode)로 데이터를 나눠서 보내기 때문이다.

2. 데이터 처리 과정
&ensp;채널 부호화 (Channel encoder rate 1/2)<br/>
* 데이터를 2배로 부풀려서 에러를 줄이기 위해 redundancy를 추가한다.(예: 1010 -> 11001100 등)
* 그래서 2,880 kbps -> 5,760 kbps가 된다.

&ensp;직렬을 병렬로 바꾸기(S/P, Serial to Parallel)<br/>
* 데이터를 6개로 나눠서 동시에 보낼 수 있게 함(960 kbps x 6 = 5,760 kbps)
* 무선 채널 하나당 처리할 수 있는 데이터 양은 제한되어 있다. (예를 들어 한 채널은 960 kbps까지만 처리 가능하다. (왜냐하면 SF = 4면 spreading rate가 3.84 Mcps니까: 3.84M / 4 = 960K))

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-70.png" width="600"></p>


4. Walsh 코드 곱하기(Walsh spreading)
* 각각의 960kbps 데이터에 서로 다른 Walsh 코드를 곱함 -> 이렇게 하면 여러 사용자/채널이 섞여도 다시 분리할 수 있다.
* 각각의 Walsh 코드는 3.84 Mcps 속도로 동작한다.

&ensp;여기서 SF = 3.84Mcps / 960kbps = 4 -> 즉, Walsh 코드 길이 = 4 <br/>

5. QPSK 변조
* 위에서 나온 신호들을 QPSK 방식으로 묶어서 전송
* QPSK는 한 심볼에 2비트를 담을 수 있으니까 효율적이다.

6. 복잡한 퍼짐(Complex spreading)
* 여기서는 실제로 전파를 타고 나가는 신호를 만들기 위해 위에서 만든 데이터와 더 복잡한 코드들을 결합함

&ensp;최대 속도 정리<br/>
* SF가 작을수록 더 많은 데이터를 보낼 수 있음
* 예: SF = 4면 최대 960 kbps 가능(1채널 기준)
* 여기선 6채널 x 960 kbps = 5.76 Mbps -> 채널 부호화 전엔 2.88 Mbps

WCDMA (Rel.99) uplink
-------

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-71.png" width="600"></p>


&ensp;핵심 흐름: 데이터를 -> 부호화 -> 병렬 분활 -> 코드 곱하기(Walsh 코드) -> 합치기 -> 퍼뜨리기 -> 전송 <br/>

1. 시작 정보
* 변조 방식: BPSK(1비트씩 보내는 간단한 방식)
* spreading factor(SF): 4 -> 1초에 960,000비트까지 전송 가능(3.84M / 4)
* Multicode = 6개 사용 -> 실제 데이터는 부호화 되기 전이니까 2,880kbps

2. DPDCH
* 사용자 데이터 채널
* 처음에는 2,880 kbps의 데이터가 있다.
* 에러 복구를 위해 채널 부호화(Channel Encoder rate 1/2) -> 데이터 양이 2배로 늘어서 5,760 kbps

3. S/P 
* 직렬 -> 병렬
* 5,760 kbps를 한 줄로 전송하면 너무 빠르기 때문에
* 6개의 병렬 채널(=Multicode)로 분활 -> 960kbps x 6개로 나눠 전송

4. Walsh Code
* spreading 과정
* 각각의 960kbps 데이터에 서로 다른 Walsh 코드를 곱함

&ensp;-> 이 과정이 확산(spreading), 코드가 다르기 때문에 채널끼리 구분 가능<br/>
* SF = 4니까 하나의 Walsh 코드 길이 = 4칩(chip은 아주 작은 비트)

5. 합치기 + Complex Spreading
* 병렬 데이터를 다시 합쳐서 전송
* 마지막으로 복소수 스프레딩(Complex Spreading)을 통해 실제 전파로 나가는 신호 형태로 변환됨

&ensp;DPDCH vs DPCCH<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-72.png" width="600"></p>


WCDMA HSDPA
-----

&ensp;HSCPA는 기존보다 더 많은 데이터를 더 빠르게 보내는 기술이다.<br/>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-73.png" width="600"></p>

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-74.png" width="600"></p>

1. 시작
* 총 데이터량 계산
* 1개 채널 -> 240 kbps
* 15개 채널 -> 240 x 15 = 3,600 kbps
* 하지만 16QAM은 1심볼당 4비트니까 -> 3,600 × 4 = 14,400 kbps (14.4 Mbps)

&ensp;즉, 기존보다 훨씬 빠르게 보냄<br/>

2. DPDCH / DPCCH
* DPDCH: 사용자 데이터(여기선 7,200kbps로 가정)
* DPCCH: 제어 채널(동기화 등)
* 채널 인코딩 안 하고 바로 보낼 수도 있음(no coding)

3. S/P
* 직렬 -> 병렬 변환
* 총 데이터 14,400 kbps를 15개 채널로 나눔
* -> 각 채널당 960kbps
* 960 kbps는 240 ksymbol x 4 bits(16QAM)에서 나옴

4. 16QAM 변조(한 심볼에 4비트)
* QPSK는 2비트/심볼인데
* 16QAM은 4비트/심볼 -> 더 많은 정보를 한 번에 전송할 수 있다.
* 그래서 240k심볼/초 x 4비트 = 960kbps가 한 채널에서 나옴

5. Walsh 코드 곱하기(Spreading)
* 각 채널에 서로 다른 Walsh 코드를 곱함
* SF = 16 -> Walsh 코드 길이 16칩
* 3.84 Mcps / 16 = 240 ksps(심볼 속도)

6. 합치기 & Complex Spreading
* 15개 채널의 결과를 합치고 실제 전파에 실어보내는 복소 스프레딩을 통해 전송
* 마지막엔 안테나로 송신

&ensp;전체 데이터 흐름 요약<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-75.png" width="600"></p>


<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-76.png" width="600"></p>

&ensp;전제 조건 정리<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-77.png" width="600"></p>

&ensp;최종 전송 속도 = 960 kbps x 6 = 5,760 kbps<br/>

&ensp;구조 분석<br/>

1. DPDCH
* 사용자가 보내는 실제 데이터가 있는 채널
* 이번에는 채널 부호화 없음(No coding)

&ensp;-> 에러 복구 대신 속도를 최우선으로 함<br/>
&ensp;-> 따라서 5,760kbps 그대로 전송<br/>

2. S/P(직렬 -> 병렬 변환)
* 5,760kbps를 6개로 나눔 -> 각 채널은 960kbps
* 하나의 채널(SF = 4)은 960kbps 이상 처리 못하니까 분산시킨 것이다. 
* 이게 바로 Multicode 방식

3. Spreading(각 채널에 Walsh 코드 곱하기)
* 각각의 데이터 스트림에 서로 다른 Walsh 코드를 곱해준다.
* 이렇게 하면 채널 간에 간섭 없이 구분할 수 있다. 
* Walsh 코드는 3.84Mcps, SF = 4 -> 각 채널 심볼 속도는 960kbps

4. QPSK 변조
* 각 채널의 데이터는 2비트씩 묶어서 하나의 심볼로 변환된다.
&ensp;-> 즉 960 kbps = 480ksymbol/sec, QPSK니까ㅏ 2비트씩 처리<br/>

5. DPDCH + DPCCH 병합
* DPCCH는 제어 채널(control)
* DPCCH 신호도 Walsh코드(w₀(t))와 곱해져서 함께 전송

6. 합치기 + Complex Spreading
* 6개 DPDCH + 1개 DPCCH 신호를 QPSK로 병합
* 마지막엔 복소 스프레딩(Complex spreading)으로 전파 신호 형태로 바꿔서 안테나로 전송

&ensp;전체 과정 요약표<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-78.png" width="600"></p>

&ensp;이렇게까지 하는 이유: <br/>
* 병렬 처리(Multicode)
* 고속 전속(QPSK)
* 확산 코드(Walsh)로 채널 분리 -> 최대 속도 & 신뢰도 확보

&ensp;No coding & Channel encoder rate 1/2 차이<br/>
<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-79.png" width="600"></p>


WCDMA HSPA+
------

<p align="center"><img src="/assets/img/Wireless Communication Systems/5장 CDMA 통신 시스템/5-80.png" width="600"></p>


&ensp;Downlink(기지국 -> 스마트폰)<br/>

* Step 1: HSDPA (Rel.5)
  - 14 Mbps
  - 16 QAM 사용
  - Multicode = 15개
  - No coding(빠르게만 전송)

* Step 2: HSPA+ (Rel.7)
  - 28Mbps
  - 기존보다 2배 빨라짐
    + 왜? -> 2x2 MIMO 사용 -> 2개의 안테나로 동시에 전송
  
* Step 3: HSPA+ (Rel.11)
  - 672 Mpbs
  - 64 QAM 사용(6비트/ 심볼)
  - 4x4 MIMO (안테나 4개)
  - 8개 Multicarrier(주파수 8개)
  
&ensp;계산 공식: <br/>
&ensp;$\frac{6}{4} \times 2 \times 8  =24$ <br/>

* 6/4 : 64 QAM(6비트) / 16QAM(4비트)
* 2: 2배 MIMO (2x2 -> 4x4)
* 8: 주파수 8개

&ensp;-> 최종: 14Mbps x 2 x 24 = 672 Mbps<br/>

&ensp;Uplink<br/>

* Step 1: HSUPA (Rel.6)
  - 5.76 Mbps
  - QPSK
  - Multicode 6개
  - No coding

* Step 2: HSPA+ (Rel.7)
  - 11.52 Mbps
  - Modulation이 16QAM으로 바뀌어서 -> 2배 전송 가능

* Step 3: HSPA+ (Rel.11)
  - 69.12 Mbps
  - 64QAM 사용
  - Dual-carrier(2개 주파수)
  - 2x2 MIMO

&ensp;계산 공식<br/>
&ensp;$\frac{6}{4} \times 2 \times 2  =6$ <br/>

* 6/4: 64QAM / 16 QAM
* 2: Dual-carrier
* 2: 2x2 MIMO

&ensp;-> 최종 11.52 Mbps × 6 = 69.12 Mbps<br/>

